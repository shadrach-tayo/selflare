#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) =>
	function __init() {
		return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])((fn = 0))), res;
	};
var __commonJS = (cb, mod) =>
	function __require() {
		return (
			mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod),
			mod.exports
		);
	};
var __export = (target, all) => {
	for (var name in all) __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
	if ((from && typeof from === "object") || typeof from === "function") {
		for (let key of __getOwnPropNames(from))
			if (!__hasOwnProp.call(to, key) && key !== except)
				__defProp(to, key, {
					get: () => from[key],
					enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,
				});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (
	(target = mod != null ? __create(__getProtoOf(mod)) : {}),
	__copyProps(
		// If the importer is in node compatibility mode or this is not an ESM
		// file that has been converted to a CommonJS file using a Babel-
		// compatible transform (i.e. "__esModule" has not been set), then set
		// "default" to the CommonJS "module.exports" for node compatibility.
		isNodeMode || !mod || !mod.__esModule
			? __defProp(target, "default", { value: mod, enumerable: true })
			: target,
		mod,
	)
);
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
	__addDisposableResource: () => __addDisposableResource,
	__assign: () => __assign,
	__asyncDelegator: () => __asyncDelegator,
	__asyncGenerator: () => __asyncGenerator,
	__asyncValues: () => __asyncValues,
	__await: () => __await,
	__awaiter: () => __awaiter,
	__classPrivateFieldGet: () => __classPrivateFieldGet,
	__classPrivateFieldIn: () => __classPrivateFieldIn,
	__classPrivateFieldSet: () => __classPrivateFieldSet,
	__createBinding: () => __createBinding,
	__decorate: () => __decorate,
	__disposeResources: () => __disposeResources,
	__esDecorate: () => __esDecorate,
	__exportStar: () => __exportStar,
	__extends: () => __extends,
	__generator: () => __generator,
	__importDefault: () => __importDefault,
	__importStar: () => __importStar,
	__makeTemplateObject: () => __makeTemplateObject,
	__metadata: () => __metadata,
	__param: () => __param,
	__propKey: () => __propKey,
	__read: () => __read,
	__rest: () => __rest,
	__rewriteRelativeImportExtension: () => __rewriteRelativeImportExtension,
	__runInitializers: () => __runInitializers,
	__setFunctionName: () => __setFunctionName,
	__spread: () => __spread,
	__spreadArray: () => __spreadArray,
	__spreadArrays: () => __spreadArrays,
	__values: () => __values,
	default: () => tslib_es6_default,
});
function __extends(d, b) {
	if (typeof b !== "function" && b !== null)
		throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
	extendStatics(d, b);
	function __() {
		this.constructor = d;
	}
	d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
}
function __rest(s, e) {
	var t = {};
	for (var p in s)
		if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
	if (s != null && typeof Object.getOwnPropertySymbols === "function")
		for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
			if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
				t[p[i]] = s[p[i]];
		}
	return t;
}
function __decorate(decorators, target, key, desc) {
	var c = arguments.length,
		r =
			c < 3
				? target
				: desc === null
					? (desc = Object.getOwnPropertyDescriptor(target, key))
					: desc,
		d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
		r = Reflect.decorate(decorators, target, key, desc);
	else
		for (var i = decorators.length - 1; i >= 0; i--)
			if ((d = decorators[i]))
				r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
	return function (target, key) {
		decorator(target, key, paramIndex);
	};
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
	function accept(f) {
		if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
		return f;
	}
	var kind = contextIn.kind,
		key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
	var target = !descriptorIn && ctor ? (contextIn["static"] ? ctor : ctor.prototype) : null;
	var descriptor =
		descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
	var _,
		done = false;
	for (var i = decorators.length - 1; i >= 0; i--) {
		var context = {};
		for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
		for (var p in contextIn.access) context.access[p] = contextIn.access[p];
		context.addInitializer = function (f) {
			if (done) throw new TypeError("Cannot add initializers after decoration has completed");
			extraInitializers.push(accept(f || null));
		};
		var result = (0, decorators[i])(
			kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key],
			context,
		);
		if (kind === "accessor") {
			if (result === void 0) continue;
			if (result === null || typeof result !== "object")
				throw new TypeError("Object expected");
			if ((_ = accept(result.get))) descriptor.get = _;
			if ((_ = accept(result.set))) descriptor.set = _;
			if ((_ = accept(result.init))) initializers.unshift(_);
		} else if ((_ = accept(result))) {
			if (kind === "field") initializers.unshift(_);
			else descriptor[key] = _;
		}
	}
	if (target) Object.defineProperty(target, contextIn.name, descriptor);
	done = true;
}
function __runInitializers(thisArg, initializers, value) {
	var useValue = arguments.length > 2;
	for (var i = 0; i < initializers.length; i++) {
		value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
	}
	return useValue ? value : void 0;
}
function __propKey(x) {
	return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
	if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
	return Object.defineProperty(f, "name", {
		configurable: true,
		value: prefix ? "".concat(prefix, " ", name) : name,
	});
}
function __metadata(metadataKey, metadataValue) {
	if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
		return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P
			? value
			: new P(function (resolve) {
					resolve(value);
				});
	}
	return new (P || (P = Promise))(function (resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e) {
				reject(e);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e) {
				reject(e);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
}
function __generator(thisArg, body) {
	var _ = {
			label: 0,
			sent: function () {
				if (t[0] & 1) throw t[1];
				return t[1];
			},
			trys: [],
			ops: [],
		},
		f,
		y,
		t,
		g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
	return (
		(g.next = verb(0)),
		(g["throw"] = verb(1)),
		(g["return"] = verb(2)),
		typeof Symbol === "function" &&
			(g[Symbol.iterator] = function () {
				return this;
			}),
		g
	);
	function verb(n) {
		return function (v) {
			return step([n, v]);
		};
	}
	function step(op) {
		if (f) throw new TypeError("Generator is already executing.");
		while ((g && ((g = 0), op[0] && (_ = 0)), _))
			try {
				if (
					((f = 1),
					y &&
						(t =
							op[0] & 2
								? y["return"]
								: op[0]
									? y["throw"] || ((t = y["return"]) && t.call(y), 0)
									: y.next) &&
						!(t = t.call(y, op[1])).done)
				)
					return t;
				if (((y = 0), t)) op = [op[0] & 2, t.value];
				switch (op[0]) {
					case 0:
					case 1:
						t = op;
						break;
					case 4:
						_.label++;
						return { value: op[1], done: false };
					case 5:
						_.label++;
						y = op[1];
						op = [0];
						continue;
					case 7:
						op = _.ops.pop();
						_.trys.pop();
						continue;
					default:
						if (
							!((t = _.trys), (t = t.length > 0 && t[t.length - 1])) &&
							(op[0] === 6 || op[0] === 2)
						) {
							_ = 0;
							continue;
						}
						if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
							_.label = op[1];
							break;
						}
						if (op[0] === 6 && _.label < t[1]) {
							_.label = t[1];
							t = op;
							break;
						}
						if (t && _.label < t[2]) {
							_.label = t[2];
							_.ops.push(op);
							break;
						}
						if (t[2]) _.ops.pop();
						_.trys.pop();
						continue;
				}
				op = body.call(thisArg, _);
			} catch (e) {
				op = [6, e];
				y = 0;
			} finally {
				f = t = 0;
			}
		if (op[0] & 5) throw op[1];
		return { value: op[0] ? op[1] : void 0, done: true };
	}
}
function __exportStar(m, o) {
	for (var p in m)
		if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
			__createBinding(o, m, p);
}
function __values(o) {
	var s = typeof Symbol === "function" && Symbol.iterator,
		m = s && o[s],
		i = 0;
	if (m) return m.call(o);
	if (o && typeof o.length === "number")
		return {
			next: function () {
				if (o && i >= o.length) o = void 0;
				return { value: o && o[i++], done: !o };
			},
		};
	throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
	var m = typeof Symbol === "function" && o[Symbol.iterator];
	if (!m) return o;
	var i = m.call(o),
		r,
		ar = [],
		e;
	try {
		while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	} catch (error) {
		e = { error };
	} finally {
		try {
			if (r && !r.done && (m = i["return"])) m.call(i);
		} finally {
			if (e) throw e.error;
		}
	}
	return ar;
}
function __spread() {
	for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
	return ar;
}
function __spreadArrays() {
	for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
	for (var r = Array(s), k = 0, i = 0; i < il; i++)
		for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
	return r;
}
function __spreadArray(to, from, pack) {
	if (pack || arguments.length === 2)
		for (var i = 0, l = from.length, ar; i < l; i++) {
			if (ar || !(i in from)) {
				if (!ar) ar = Array.prototype.slice.call(from, 0, i);
				ar[i] = from[i];
			}
		}
	return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
	return this instanceof __await ? ((this.v = v), this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
	if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	var g = generator.apply(thisArg, _arguments || []),
		i,
		q = [];
	return (
		(i = Object.create(
			(typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype,
		)),
		verb("next"),
		verb("throw"),
		verb("return", awaitReturn),
		(i[Symbol.asyncIterator] = function () {
			return this;
		}),
		i
	);
	function awaitReturn(f) {
		return function (v) {
			return Promise.resolve(v).then(f, reject);
		};
	}
	function verb(n, f) {
		if (g[n]) {
			i[n] = function (v) {
				return new Promise(function (a, b) {
					q.push([n, v, a, b]) > 1 || resume(n, v);
				});
			};
			if (f) i[n] = f(i[n]);
		}
	}
	function resume(n, v) {
		try {
			step(g[n](v));
		} catch (e) {
			settle(q[0][3], e);
		}
	}
	function step(r) {
		r.value instanceof __await
			? Promise.resolve(r.value.v).then(fulfill, reject)
			: settle(q[0][2], r);
	}
	function fulfill(value) {
		resume("next", value);
	}
	function reject(value) {
		resume("throw", value);
	}
	function settle(f, v) {
		if ((f(v), q.shift(), q.length)) resume(q[0][0], q[0][1]);
	}
}
function __asyncDelegator(o) {
	var i, p;
	return (
		(i = {}),
		verb("next"),
		verb("throw", function (e) {
			throw e;
		}),
		verb("return"),
		(i[Symbol.iterator] = function () {
			return this;
		}),
		i
	);
	function verb(n, f) {
		i[n] = o[n]
			? function (v) {
					return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
				}
			: f;
	}
}
function __asyncValues(o) {
	if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	var m = o[Symbol.asyncIterator],
		i;
	return m
		? m.call(o)
		: ((o = typeof __values === "function" ? __values(o) : o[Symbol.iterator]()),
			(i = {}),
			verb("next"),
			verb("throw"),
			verb("return"),
			(i[Symbol.asyncIterator] = function () {
				return this;
			}),
			i);
	function verb(n) {
		i[n] =
			o[n] &&
			function (v) {
				return new Promise(function (resolve, reject) {
					(v = o[n](v)), settle(resolve, reject, v.done, v.value);
				});
			};
	}
	function settle(resolve, reject, d, v) {
		Promise.resolve(v).then(function (v2) {
			resolve({ value: v2, done: d });
		}, reject);
	}
}
function __makeTemplateObject(cooked, raw) {
	if (Object.defineProperty) {
		Object.defineProperty(cooked, "raw", { value: raw });
	} else {
		cooked.raw = raw;
	}
	return cooked;
}
function __importStar(mod) {
	if (mod && mod.__esModule) return mod;
	var result = {};
	if (mod != null) {
		for (var k = ownKeys(mod), i = 0; i < k.length; i++)
			if (k[i] !== "default") __createBinding(result, mod, k[i]);
	}
	__setModuleDefault(result, mod);
	return result;
}
function __importDefault(mod) {
	return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
	if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
		throw new TypeError(
			"Cannot read private member from an object whose class did not declare it",
		);
	return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
	if (kind === "m") throw new TypeError("Private method is not writable");
	if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
		throw new TypeError(
			"Cannot write private member to an object whose class did not declare it",
		);
	return (
		kind === "a" ? f.call(receiver, value) : f ? (f.value = value) : state.set(receiver, value),
		value
	);
}
function __classPrivateFieldIn(state, receiver) {
	if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function"))
		throw new TypeError("Cannot use 'in' operator on non-object");
	return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
	if (value !== null && value !== void 0) {
		if (typeof value !== "object" && typeof value !== "function")
			throw new TypeError("Object expected.");
		var dispose, inner;
		if (async) {
			if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
			dispose = value[Symbol.asyncDispose];
		}
		if (dispose === void 0) {
			if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
			dispose = value[Symbol.dispose];
			if (async) inner = dispose;
		}
		if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
		if (inner)
			dispose = function () {
				try {
					inner.call(this);
				} catch (e) {
					return Promise.reject(e);
				}
			};
		env.stack.push({ value, dispose, async });
	} else if (async) {
		env.stack.push({ async: true });
	}
	return value;
}
function __disposeResources(env) {
	function fail(e) {
		env.error = env.hasError
			? new _SuppressedError(e, env.error, "An error was suppressed during disposal.")
			: e;
		env.hasError = true;
	}
	var r,
		s = 0;
	function next() {
		while ((r = env.stack.pop())) {
			try {
				if (!r.async && s === 1)
					return (s = 0), env.stack.push(r), Promise.resolve().then(next);
				if (r.dispose) {
					var result = r.dispose.call(r.value);
					if (r.async)
						return (
							(s |= 2),
							Promise.resolve(result).then(next, function (e) {
								fail(e);
								return next();
							})
						);
				} else s |= 1;
			} catch (e) {
				fail(e);
			}
		}
		if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
		if (env.hasError) throw env.error;
	}
	return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
	if (typeof path === "string" && /^\.\.?\//.test(path)) {
		return path.replace(
			/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i,
			function (m, tsx, d, ext, cm) {
				return tsx
					? preserveJsx
						? ".jsx"
						: ".js"
					: d && (!ext || !cm)
						? m
						: d + ext + "." + cm.toLowerCase() + "js";
			},
		);
	}
	return path;
}
var extendStatics,
	__assign,
	__createBinding,
	__setModuleDefault,
	ownKeys,
	_SuppressedError,
	tslib_es6_default;
var init_tslib_es6 = __esm({
	"node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs"() {
		"use strict";
		extendStatics = function (d, b) {
			extendStatics =
				Object.setPrototypeOf ||
				({ __proto__: [] } instanceof Array &&
					function (d2, b2) {
						d2.__proto__ = b2;
					}) ||
				function (d2, b2) {
					for (var p in b2)
						if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
				};
			return extendStatics(d, b);
		};
		__assign = function () {
			__assign =
				Object.assign ||
				function __assign2(t) {
					for (var s, i = 1, n = arguments.length; i < n; i++) {
						s = arguments[i];
						for (var p in s)
							if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
					}
					return t;
				};
			return __assign.apply(this, arguments);
		};
		__createBinding = Object.create
			? function (o, m, k, k2) {
					if (k2 === void 0) k2 = k;
					var desc = Object.getOwnPropertyDescriptor(m, k);
					if (
						!desc ||
						("get" in desc ? !m.__esModule : desc.writable || desc.configurable)
					) {
						desc = {
							enumerable: true,
							get: function () {
								return m[k];
							},
						};
					}
					Object.defineProperty(o, k2, desc);
				}
			: function (o, m, k, k2) {
					if (k2 === void 0) k2 = k;
					o[k2] = m[k];
				};
		__setModuleDefault = Object.create
			? function (o, v) {
					Object.defineProperty(o, "default", { enumerable: true, value: v });
				}
			: function (o, v) {
					o["default"] = v;
				};
		ownKeys = function (o) {
			ownKeys =
				Object.getOwnPropertyNames ||
				function (o2) {
					var ar = [];
					for (var k in o2)
						if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
					return ar;
				};
			return ownKeys(o);
		};
		_SuppressedError =
			typeof SuppressedError === "function"
				? SuppressedError
				: function (error, suppressed, message) {
						var e = new Error(message);
						return (
							(e.name = "SuppressedError"),
							(e.error = error),
							(e.suppressed = suppressed),
							e
						);
					};
		tslib_es6_default = {
			__extends,
			__assign,
			__rest,
			__decorate,
			__param,
			__esDecorate,
			__runInitializers,
			__propKey,
			__setFunctionName,
			__metadata,
			__awaiter,
			__generator,
			__createBinding,
			__exportStar,
			__values,
			__read,
			__spread,
			__spreadArrays,
			__spreadArray,
			__await,
			__asyncGenerator,
			__asyncDelegator,
			__asyncValues,
			__makeTemplateObject,
			__importStar,
			__importDefault,
			__classPrivateFieldGet,
			__classPrivateFieldSet,
			__classPrivateFieldIn,
			__addDisposableResource,
			__disposeResources,
			__rewriteRelativeImportExtension,
		};
	},
});

// node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms = __commonJS({
	"node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"(exports2, module2) {
		"use strict";
		var s = 1e3;
		var m = s * 60;
		var h = m * 60;
		var d = h * 24;
		var w = d * 7;
		var y = d * 365.25;
		module2.exports = function (val, options) {
			options = options || {};
			var type = typeof val;
			if (type === "string" && val.length > 0) {
				return parse(val);
			} else if (type === "number" && isFinite(val)) {
				return options.long ? fmtLong(val) : fmtShort(val);
			}
			throw new Error(
				"val is not a non-empty string or a valid number. val=" + JSON.stringify(val),
			);
		};
		function parse(str) {
			str = String(str);
			if (str.length > 100) {
				return;
			}
			var match =
				/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
					str,
				);
			if (!match) {
				return;
			}
			var n = parseFloat(match[1]);
			var type = (match[2] || "ms").toLowerCase();
			switch (type) {
				case "years":
				case "year":
				case "yrs":
				case "yr":
				case "y":
					return n * y;
				case "weeks":
				case "week":
				case "w":
					return n * w;
				case "days":
				case "day":
				case "d":
					return n * d;
				case "hours":
				case "hour":
				case "hrs":
				case "hr":
				case "h":
					return n * h;
				case "minutes":
				case "minute":
				case "mins":
				case "min":
				case "m":
					return n * m;
				case "seconds":
				case "second":
				case "secs":
				case "sec":
				case "s":
					return n * s;
				case "milliseconds":
				case "millisecond":
				case "msecs":
				case "msec":
				case "ms":
					return n;
				default:
					return void 0;
			}
		}
		function fmtShort(ms) {
			var msAbs = Math.abs(ms);
			if (msAbs >= d) {
				return Math.round(ms / d) + "d";
			}
			if (msAbs >= h) {
				return Math.round(ms / h) + "h";
			}
			if (msAbs >= m) {
				return Math.round(ms / m) + "m";
			}
			if (msAbs >= s) {
				return Math.round(ms / s) + "s";
			}
			return ms + "ms";
		}
		function fmtLong(ms) {
			var msAbs = Math.abs(ms);
			if (msAbs >= d) {
				return plural(ms, msAbs, d, "day");
			}
			if (msAbs >= h) {
				return plural(ms, msAbs, h, "hour");
			}
			if (msAbs >= m) {
				return plural(ms, msAbs, m, "minute");
			}
			if (msAbs >= s) {
				return plural(ms, msAbs, s, "second");
			}
			return ms + " ms";
		}
		function plural(ms, msAbs, n, name) {
			var isPlural = msAbs >= n * 1.5;
			return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
		}
	},
});

// node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/common.js
var require_common = __commonJS({
	"node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/common.js"(exports2, module2) {
		"use strict";
		function setup(env) {
			createDebug.debug = createDebug;
			createDebug.default = createDebug;
			createDebug.coerce = coerce;
			createDebug.disable = disable;
			createDebug.enable = enable;
			createDebug.enabled = enabled;
			createDebug.humanize = require_ms();
			createDebug.destroy = destroy;
			Object.keys(env).forEach((key) => {
				createDebug[key] = env[key];
			});
			createDebug.names = [];
			createDebug.skips = [];
			createDebug.formatters = {};
			function selectColor(namespace) {
				let hash = 0;
				for (let i = 0; i < namespace.length; i++) {
					hash = (hash << 5) - hash + namespace.charCodeAt(i);
					hash |= 0;
				}
				return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
			}
			createDebug.selectColor = selectColor;
			function createDebug(namespace) {
				let prevTime;
				let enableOverride = null;
				let namespacesCache;
				let enabledCache;
				function debug(...args) {
					if (!debug.enabled) {
						return;
					}
					const self2 = debug;
					const curr = Number(/* @__PURE__ */ new Date());
					const ms = curr - (prevTime || curr);
					self2.diff = ms;
					self2.prev = prevTime;
					self2.curr = curr;
					prevTime = curr;
					args[0] = createDebug.coerce(args[0]);
					if (typeof args[0] !== "string") {
						args.unshift("%O");
					}
					let index = 0;
					args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
						if (match === "%%") {
							return "%";
						}
						index++;
						const formatter = createDebug.formatters[format];
						if (typeof formatter === "function") {
							const val = args[index];
							match = formatter.call(self2, val);
							args.splice(index, 1);
							index--;
						}
						return match;
					});
					createDebug.formatArgs.call(self2, args);
					const logFn = self2.log || createDebug.log;
					logFn.apply(self2, args);
				}
				debug.namespace = namespace;
				debug.useColors = createDebug.useColors();
				debug.color = createDebug.selectColor(namespace);
				debug.extend = extend;
				debug.destroy = createDebug.destroy;
				Object.defineProperty(debug, "enabled", {
					enumerable: true,
					configurable: false,
					get: () => {
						if (enableOverride !== null) {
							return enableOverride;
						}
						if (namespacesCache !== createDebug.namespaces) {
							namespacesCache = createDebug.namespaces;
							enabledCache = createDebug.enabled(namespace);
						}
						return enabledCache;
					},
					set: (v) => {
						enableOverride = v;
					},
				});
				if (typeof createDebug.init === "function") {
					createDebug.init(debug);
				}
				return debug;
			}
			function extend(namespace, delimiter) {
				const newDebug = createDebug(
					this.namespace +
						(typeof delimiter === "undefined" ? ":" : delimiter) +
						namespace,
				);
				newDebug.log = this.log;
				return newDebug;
			}
			function enable(namespaces) {
				createDebug.save(namespaces);
				createDebug.namespaces = namespaces;
				createDebug.names = [];
				createDebug.skips = [];
				let i;
				const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
				const len = split.length;
				for (i = 0; i < len; i++) {
					if (!split[i]) {
						continue;
					}
					namespaces = split[i].replace(/\*/g, ".*?");
					if (namespaces[0] === "-") {
						createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
					} else {
						createDebug.names.push(new RegExp("^" + namespaces + "$"));
					}
				}
			}
			function disable() {
				const namespaces = [
					...createDebug.names.map(toNamespace),
					...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace),
				].join(",");
				createDebug.enable("");
				return namespaces;
			}
			function enabled(name) {
				if (name[name.length - 1] === "*") {
					return true;
				}
				let i;
				let len;
				for (i = 0, len = createDebug.skips.length; i < len; i++) {
					if (createDebug.skips[i].test(name)) {
						return false;
					}
				}
				for (i = 0, len = createDebug.names.length; i < len; i++) {
					if (createDebug.names[i].test(name)) {
						return true;
					}
				}
				return false;
			}
			function toNamespace(regexp) {
				return regexp
					.toString()
					.substring(2, regexp.toString().length - 2)
					.replace(/\.\*\?$/, "*");
			}
			function coerce(val) {
				if (val instanceof Error) {
					return val.stack || val.message;
				}
				return val;
			}
			function destroy() {
				console.warn(
					"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
				);
			}
			createDebug.enable(createDebug.load());
			return createDebug;
		}
		module2.exports = setup;
	},
});

// node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/browser.js
var require_browser = __commonJS({
	"node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/browser.js"(exports2, module2) {
		"use strict";
		exports2.formatArgs = formatArgs;
		exports2.save = save;
		exports2.load = load;
		exports2.useColors = useColors;
		exports2.storage = localstorage();
		exports2.destroy = /* @__PURE__ */ (() => {
			let warned = false;
			return () => {
				if (!warned) {
					warned = true;
					console.warn(
						"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
					);
				}
			};
		})();
		exports2.colors = [
			"#0000CC",
			"#0000FF",
			"#0033CC",
			"#0033FF",
			"#0066CC",
			"#0066FF",
			"#0099CC",
			"#0099FF",
			"#00CC00",
			"#00CC33",
			"#00CC66",
			"#00CC99",
			"#00CCCC",
			"#00CCFF",
			"#3300CC",
			"#3300FF",
			"#3333CC",
			"#3333FF",
			"#3366CC",
			"#3366FF",
			"#3399CC",
			"#3399FF",
			"#33CC00",
			"#33CC33",
			"#33CC66",
			"#33CC99",
			"#33CCCC",
			"#33CCFF",
			"#6600CC",
			"#6600FF",
			"#6633CC",
			"#6633FF",
			"#66CC00",
			"#66CC33",
			"#9900CC",
			"#9900FF",
			"#9933CC",
			"#9933FF",
			"#99CC00",
			"#99CC33",
			"#CC0000",
			"#CC0033",
			"#CC0066",
			"#CC0099",
			"#CC00CC",
			"#CC00FF",
			"#CC3300",
			"#CC3333",
			"#CC3366",
			"#CC3399",
			"#CC33CC",
			"#CC33FF",
			"#CC6600",
			"#CC6633",
			"#CC9900",
			"#CC9933",
			"#CCCC00",
			"#CCCC33",
			"#FF0000",
			"#FF0033",
			"#FF0066",
			"#FF0099",
			"#FF00CC",
			"#FF00FF",
			"#FF3300",
			"#FF3333",
			"#FF3366",
			"#FF3399",
			"#FF33CC",
			"#FF33FF",
			"#FF6600",
			"#FF6633",
			"#FF9900",
			"#FF9933",
			"#FFCC00",
			"#FFCC33",
		];
		function useColors() {
			if (
				typeof window !== "undefined" &&
				window.process &&
				(window.process.type === "renderer" || window.process.__nwjs)
			) {
				return true;
			}
			if (
				typeof navigator !== "undefined" &&
				navigator.userAgent &&
				navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
			) {
				return false;
			}
			let m;
			return (
				(typeof document !== "undefined" &&
					document.documentElement &&
					document.documentElement.style &&
					document.documentElement.style.WebkitAppearance) || // Is firebug? http://stackoverflow.com/a/398120/376773
				(typeof window !== "undefined" &&
					window.console &&
					(window.console.firebug ||
						(window.console.exception && window.console.table))) || // Is firefox >= v31?
				// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
				(typeof navigator !== "undefined" &&
					navigator.userAgent &&
					(m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) &&
					parseInt(m[1], 10) >= 31) || // Double check webkit in userAgent just in case we are in a worker
				(typeof navigator !== "undefined" &&
					navigator.userAgent &&
					navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
			);
		}
		function formatArgs(args) {
			args[0] =
				(this.useColors ? "%c" : "") +
				this.namespace +
				(this.useColors ? " %c" : " ") +
				args[0] +
				(this.useColors ? "%c " : " ") +
				"+" +
				module2.exports.humanize(this.diff);
			if (!this.useColors) {
				return;
			}
			const c = "color: " + this.color;
			args.splice(1, 0, c, "color: inherit");
			let index = 0;
			let lastC = 0;
			args[0].replace(/%[a-zA-Z%]/g, (match) => {
				if (match === "%%") {
					return;
				}
				index++;
				if (match === "%c") {
					lastC = index;
				}
			});
			args.splice(lastC, 0, c);
		}
		exports2.log = console.debug || console.log || (() => {});
		function save(namespaces) {
			try {
				if (namespaces) {
					exports2.storage.setItem("debug", namespaces);
				} else {
					exports2.storage.removeItem("debug");
				}
			} catch (error) {}
		}
		function load() {
			let r;
			try {
				r = exports2.storage.getItem("debug");
			} catch (error) {}
			if (!r && typeof process !== "undefined" && "env" in process) {
				r = process.env.DEBUG;
			}
			return r;
		}
		function localstorage() {
			try {
				return localStorage;
			} catch (error) {}
		}
		module2.exports = require_common()(exports2);
		var { formatters } = module2.exports;
		formatters.j = function (v) {
			try {
				return JSON.stringify(v);
			} catch (error) {
				return "[UnexpectedJSONParseError]: " + error.message;
			}
		};
	},
});

// node_modules/.pnpm/has-flag@3.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
	"node_modules/.pnpm/has-flag@3.0.0/node_modules/has-flag/index.js"(exports2, module2) {
		"use strict";
		module2.exports = (flag, argv) => {
			argv = argv || process.argv;
			const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
			const pos = argv.indexOf(prefix + flag);
			const terminatorPos = argv.indexOf("--");
			return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
		};
	},
});

// node_modules/.pnpm/supports-color@5.5.0/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
	"node_modules/.pnpm/supports-color@5.5.0/node_modules/supports-color/index.js"(
		exports2,
		module2,
	) {
		"use strict";
		var os = require("os");
		var hasFlag = require_has_flag();
		var env = process.env;
		var forceColor;
		if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
			forceColor = false;
		} else if (
			hasFlag("color") ||
			hasFlag("colors") ||
			hasFlag("color=true") ||
			hasFlag("color=always")
		) {
			forceColor = true;
		}
		if ("FORCE_COLOR" in env) {
			forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
		}
		function translateLevel(level) {
			if (level === 0) {
				return false;
			}
			return {
				level,
				hasBasic: true,
				has256: level >= 2,
				has16m: level >= 3,
			};
		}
		function supportsColor(stream) {
			if (forceColor === false) {
				return 0;
			}
			if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
				return 3;
			}
			if (hasFlag("color=256")) {
				return 2;
			}
			if (stream && !stream.isTTY && forceColor !== true) {
				return 0;
			}
			const min = forceColor ? 1 : 0;
			if (process.platform === "win32") {
				const osRelease = os.release().split(".");
				if (
					Number(process.versions.node.split(".")[0]) >= 8 &&
					Number(osRelease[0]) >= 10 &&
					Number(osRelease[2]) >= 10586
				) {
					return Number(osRelease[2]) >= 14931 ? 3 : 2;
				}
				return 1;
			}
			if ("CI" in env) {
				if (
					["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) ||
					env.CI_NAME === "codeship"
				) {
					return 1;
				}
				return min;
			}
			if ("TEAMCITY_VERSION" in env) {
				return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
			}
			if (env.COLORTERM === "truecolor") {
				return 3;
			}
			if ("TERM_PROGRAM" in env) {
				const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
				switch (env.TERM_PROGRAM) {
					case "iTerm.app":
						return version >= 3 ? 3 : 2;
					case "Apple_Terminal":
						return 2;
				}
			}
			if (/-256(color)?$/i.test(env.TERM)) {
				return 2;
			}
			if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
				return 1;
			}
			if ("COLORTERM" in env) {
				return 1;
			}
			if (env.TERM === "dumb") {
				return min;
			}
			return min;
		}
		function getSupportLevel(stream) {
			const level = supportsColor(stream);
			return translateLevel(level);
		}
		module2.exports = {
			supportsColor: getSupportLevel,
			stdout: getSupportLevel(process.stdout),
			stderr: getSupportLevel(process.stderr),
		};
	},
});

// node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/node.js
var require_node = __commonJS({
	"node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/node.js"(exports2, module2) {
		"use strict";
		var tty = require("tty");
		var util = require("util");
		exports2.init = init;
		exports2.log = log;
		exports2.formatArgs = formatArgs;
		exports2.save = save;
		exports2.load = load;
		exports2.useColors = useColors;
		exports2.destroy = util.deprecate(
			() => {},
			"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
		);
		exports2.colors = [6, 2, 3, 4, 5, 1];
		try {
			const supportsColor = require_supports_color();
			if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
				exports2.colors = [
					20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69,
					74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135,
					148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173,
					178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
					208, 209, 214, 215, 220, 221,
				];
			}
		} catch (error) {}
		exports2.inspectOpts = Object.keys(process.env)
			.filter((key) => {
				return /^debug_/i.test(key);
			})
			.reduce((obj, key) => {
				const prop = key
					.substring(6)
					.toLowerCase()
					.replace(/_([a-z])/g, (_, k) => {
						return k.toUpperCase();
					});
				let val = process.env[key];
				if (/^(yes|on|true|enabled)$/i.test(val)) {
					val = true;
				} else if (/^(no|off|false|disabled)$/i.test(val)) {
					val = false;
				} else if (val === "null") {
					val = null;
				} else {
					val = Number(val);
				}
				obj[prop] = val;
				return obj;
			}, {});
		function useColors() {
			return "colors" in exports2.inspectOpts
				? Boolean(exports2.inspectOpts.colors)
				: tty.isatty(process.stderr.fd);
		}
		function formatArgs(args) {
			const { namespace: name, useColors: useColors2 } = this;
			if (useColors2) {
				const c = this.color;
				const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
				const prefix = `  ${colorCode};1m${name} \x1B[0m`;
				args[0] = prefix + args[0].split("\n").join("\n" + prefix);
				args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
			} else {
				args[0] = getDate() + name + " " + args[0];
			}
		}
		function getDate() {
			if (exports2.inspectOpts.hideDate) {
				return "";
			}
			return /* @__PURE__ */ new Date().toISOString() + " ";
		}
		function log(...args) {
			return process.stderr.write(
				util.formatWithOptions(exports2.inspectOpts, ...args) + "\n",
			);
		}
		function save(namespaces) {
			if (namespaces) {
				process.env.DEBUG = namespaces;
			} else {
				delete process.env.DEBUG;
			}
		}
		function load() {
			return process.env.DEBUG;
		}
		function init(debug) {
			debug.inspectOpts = {};
			const keys = Object.keys(exports2.inspectOpts);
			for (let i = 0; i < keys.length; i++) {
				debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
			}
		}
		module2.exports = require_common()(exports2);
		var { formatters } = module2.exports;
		formatters.o = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util
				.inspect(v, this.inspectOpts)
				.split("\n")
				.map((str) => str.trim())
				.join(" ");
		};
		formatters.O = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts);
		};
	},
});

// node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js
var require_src = __commonJS({
	"node_modules/.pnpm/debug@4.3.7/node_modules/debug/src/index.js"(exports2, module2) {
		"use strict";
		if (
			typeof process === "undefined" ||
			process.type === "renderer" ||
			process.browser === true ||
			process.__nwjs
		) {
			module2.exports = require_browser();
		} else {
			module2.exports = require_node();
		}
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/constants.js
var require_constants = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/constants.js"(exports2) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.MAX_SEGMENT_LENGTH =
			exports2.MAX_DEPTH =
			exports2.VAL32 =
			exports2.POINTER_TYPE_MASK =
			exports2.POINTER_DOUBLE_FAR_MASK =
			exports2.POINTER_COPY_LIMIT =
			exports2.PACK_SPAN_THRESHOLD =
			exports2.NATIVE_LITTLE_ENDIAN =
			exports2.MIN_SINGLE_SEGMENT_GROWTH =
			exports2.MIN_SAFE_INTEGER =
			exports2.MAX_STREAM_SEGMENTS =
			exports2.MAX_SAFE_INTEGER =
			exports2.MAX_UINT32 =
			exports2.MAX_INT32 =
			exports2.MAX_BUFFER_DUMP_BYTES =
			exports2.LIST_SIZE_MASK =
			exports2.GROWTH_FACTOR =
			exports2.DEFAULT_TRAVERSE_LIMIT =
			exports2.DEFAULT_DEPTH_LIMIT =
			exports2.DEFAULT_DECODE_LIMIT =
			exports2.DEFAULT_BUFFER_SIZE =
				void 0;
		var tmpWord = new DataView(new ArrayBuffer(8));
		new Uint16Array(tmpWord.buffer)[0] = 258;
		exports2.DEFAULT_BUFFER_SIZE = 4096;
		exports2.DEFAULT_DECODE_LIMIT = 64 << 20;
		exports2.DEFAULT_DEPTH_LIMIT = 64;
		exports2.DEFAULT_TRAVERSE_LIMIT = 64 << 20;
		exports2.GROWTH_FACTOR = 1.5;
		exports2.LIST_SIZE_MASK = 7;
		exports2.MAX_BUFFER_DUMP_BYTES = 8192;
		exports2.MAX_INT32 = 2147483647;
		exports2.MAX_UINT32 = 4294967295;
		exports2.MAX_SAFE_INTEGER = 9007199254740991;
		exports2.MAX_STREAM_SEGMENTS = 512;
		exports2.MIN_SAFE_INTEGER = -9007199254740991;
		exports2.MIN_SINGLE_SEGMENT_GROWTH = 4096;
		exports2.NATIVE_LITTLE_ENDIAN = tmpWord.getUint8(0) === 2;
		exports2.PACK_SPAN_THRESHOLD = 2;
		exports2.POINTER_COPY_LIMIT = 32;
		exports2.POINTER_DOUBLE_FAR_MASK = 4;
		exports2.POINTER_TYPE_MASK = 3;
		exports2.VAL32 = 4294967296;
		exports2.MAX_DEPTH = exports2.MAX_INT32;
		exports2.MAX_SEGMENT_LENGTH = exports2.MAX_UINT32;
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/errors.js
var require_errors = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/errors.js"(exports2) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.PTR_WRITE_CONST_STRUCT =
			exports2.PTR_WRITE_CONST_LIST =
			exports2.TYPE_SET_GENERIC_LIST =
			exports2.TYPE_GET_GENERIC_LIST =
			exports2.TYPE_COMPOSITE_SIZE_UNDEFINED =
			exports2.SEG_SIZE_OVERFLOW =
			exports2.SEG_REPLACEMENT_BUFFER_TOO_SMALL =
			exports2.SEG_NOT_WORD_ALIGNED =
			exports2.SEG_ID_OUT_OF_BOUNDS =
			exports2.SEG_GET_NON_ZERO_SINGLE =
			exports2.SEG_BUFFER_NOT_ALLOCATED =
			exports2.RANGE_UINT32_OVERFLOW =
			exports2.RANGE_SIZE_OVERFLOW =
			exports2.RANGE_INVALID_UTF8 =
			exports2.RANGE_INT64_UNDERFLOW =
			exports2.RANGE_INT32_OVERFLOW =
			exports2.PTR_WRONG_STRUCT_PTR_SIZE =
			exports2.PTR_WRONG_STRUCT_DATA_SIZE =
			exports2.PTR_WRONG_COMPOSITE_PTR_SIZE =
			exports2.PTR_WRONG_COMPOSITE_DATA_SIZE =
			exports2.PTR_WRONG_POINTER_TYPE =
			exports2.PTR_WRONG_LIST_TYPE =
			exports2.PTR_TRAVERSAL_LIMIT_EXCEEDED =
			exports2.PTR_STRUCT_POINTER_OUT_OF_BOUNDS =
			exports2.PTR_STRUCT_DATA_OUT_OF_BOUNDS =
			exports2.PTR_OFFSET_OUT_OF_BOUNDS =
			exports2.PTR_INVALID_UNION_ACCESS =
			exports2.PTR_INVALID_POINTER_TYPE =
			exports2.PTR_INVALID_LIST_SIZE =
			exports2.PTR_INVALID_FAR_TARGET =
			exports2.PTR_INIT_NON_GROUP =
			exports2.PTR_INIT_COMPOSITE_STRUCT =
			exports2.PTR_DISOWN_COMPOSITE_STRUCT =
			exports2.PTR_DEPTH_LIMIT_EXCEEDED =
			exports2.PTR_COMPOSITE_SIZE_UNDEFINED =
			exports2.PTR_ALREADY_ADOPTED =
			exports2.PTR_ADOPT_WRONG_MESSAGE =
			exports2.PTR_ADOPT_COMPOSITE_STRUCT =
			exports2.NOT_IMPLEMENTED =
			exports2.MSG_SEGMENT_TOO_SMALL =
			exports2.MSG_SEGMENT_OUT_OF_BOUNDS =
			exports2.MSG_PACK_NOT_WORD_ALIGNED =
			exports2.MSG_NO_SEGMENTS_IN_ARENA =
			exports2.MSG_INVALID_FRAME_HEADER =
			exports2.assertNever =
			exports2.INVARIANT_UNREACHABLE_CODE =
				void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var constants_1 = require_constants();
		var trace = debug_1.default("capnp:errors");
		trace("load");
		exports2.INVARIANT_UNREACHABLE_CODE = "CAPNP-TS000 Unreachable code detected.";
		function assertNever(n) {
			throw new Error(exports2.INVARIANT_UNREACHABLE_CODE + ` (never block hit with: ${n})`);
		}
		exports2.assertNever = assertNever;
		exports2.MSG_INVALID_FRAME_HEADER =
			"CAPNP-TS001 Attempted to parse an invalid message frame header; are you sure this is a Cap'n Proto message?";
		exports2.MSG_NO_SEGMENTS_IN_ARENA =
			"CAPNP-TS002 Attempted to preallocate a message with no segments in the arena.";
		exports2.MSG_PACK_NOT_WORD_ALIGNED =
			"CAPNP-TS003 Attempted to pack a message that was not word-aligned.";
		exports2.MSG_SEGMENT_OUT_OF_BOUNDS =
			"CAPNP-TS004 Segment ID %X is out of bounds for message %s.";
		exports2.MSG_SEGMENT_TOO_SMALL =
			"CAPNP-TS005 First segment must have at least enough room to hold the root pointer (8 bytes).";
		exports2.NOT_IMPLEMENTED = "CAPNP-TS006 %s is not implemented.";
		exports2.PTR_ADOPT_COMPOSITE_STRUCT =
			"CAPNP-TS007 Attempted to adopt a struct into a composite list (%s).";
		exports2.PTR_ADOPT_WRONG_MESSAGE =
			"CAPNP-TS008 Attempted to adopt %s into a pointer in a different message %s.";
		exports2.PTR_ALREADY_ADOPTED = "CAPNP-TS009 Attempted to adopt %s more than once.";
		exports2.PTR_COMPOSITE_SIZE_UNDEFINED =
			"CAPNP-TS010 Attempted to set a composite list without providing a composite element size.";
		exports2.PTR_DEPTH_LIMIT_EXCEEDED = "CAPNP-TS011 Nesting depth limit exceeded for %s.";
		exports2.PTR_DISOWN_COMPOSITE_STRUCT =
			"CAPNP-TS012 Attempted to disown a struct member from a composite list (%s).";
		exports2.PTR_INIT_COMPOSITE_STRUCT =
			"CAPNP-TS013 Attempted to initialize a struct member from a composite list (%s).";
		exports2.PTR_INIT_NON_GROUP =
			"CAPNP-TS014 Attempted to initialize a group field with a non-group struct class.";
		exports2.PTR_INVALID_FAR_TARGET =
			"CAPNP-TS015 Target of a far pointer (%s) is another far pointer.";
		exports2.PTR_INVALID_LIST_SIZE = "CAPNP-TS016 Invalid list element size: %x.";
		exports2.PTR_INVALID_POINTER_TYPE = "CAPNP-TS017 Invalid pointer type: %x.";
		exports2.PTR_INVALID_UNION_ACCESS =
			"CAPNP-TS018 Attempted to access getter on %s for union field %s that is not currently set (wanted: %d, found: %d).";
		exports2.PTR_OFFSET_OUT_OF_BOUNDS =
			"CAPNP-TS019 Pointer offset %a is out of bounds for underlying buffer.";
		exports2.PTR_STRUCT_DATA_OUT_OF_BOUNDS =
			"CAPNP-TS020 Attempted to access out-of-bounds struct data (struct: %s, %d bytes at %a, data words: %d).";
		exports2.PTR_STRUCT_POINTER_OUT_OF_BOUNDS =
			"CAPNP-TS021 Attempted to access out-of-bounds struct pointer (%s, index: %d, length: %d).";
		exports2.PTR_TRAVERSAL_LIMIT_EXCEEDED =
			"CAPNP-TS022 Traversal limit exceeded! Slow down! %s";
		exports2.PTR_WRONG_LIST_TYPE = "CAPNP-TS023 Cannot convert %s to a %s list.";
		exports2.PTR_WRONG_POINTER_TYPE =
			"CAPNP-TS024 Attempted to convert pointer %s to a %s type.";
		exports2.PTR_WRONG_COMPOSITE_DATA_SIZE =
			"CAPNP-TS025 Attempted to convert %s to a composite list with the wrong data size (found: %d).";
		exports2.PTR_WRONG_COMPOSITE_PTR_SIZE =
			"CAPNP-TS026 Attempted to convert %s to a composite list with the wrong pointer size (found: %d).";
		exports2.PTR_WRONG_STRUCT_DATA_SIZE =
			"CAPNP-TS027 Attempted to convert %s to a struct with the wrong data size (found: %d).";
		exports2.PTR_WRONG_STRUCT_PTR_SIZE =
			"CAPNP-TS028 Attempted to convert %s to a struct with the wrong pointer size (found: %d).";
		exports2.RANGE_INT32_OVERFLOW = "CAPNP-TS029 32-bit signed integer overflow detected.";
		exports2.RANGE_INT64_UNDERFLOW = "CAPNP-TS030 Buffer is not large enough to hold a word.";
		exports2.RANGE_INVALID_UTF8 = "CAPNP-TS031 Invalid UTF-8 code sequence detected.";
		exports2.RANGE_SIZE_OVERFLOW = `CAPNP-TS032 Size %x exceeds maximum ${constants_1.MAX_SEGMENT_LENGTH.toString(16)}.`;
		exports2.RANGE_UINT32_OVERFLOW = "CAPNP-TS033 32-bit unsigned integer overflow detected.";
		exports2.SEG_BUFFER_NOT_ALLOCATED =
			"CAPNP-TS034 allocate() needs to be called at least once before getting a buffer.";
		exports2.SEG_GET_NON_ZERO_SINGLE =
			"CAPNP-TS035 Attempted to get a segment other than 0 (%d) from a single segment arena.";
		exports2.SEG_ID_OUT_OF_BOUNDS =
			"CAPNP-TS036 Attempted to get an out-of-bounds segment (%d).";
		exports2.SEG_NOT_WORD_ALIGNED =
			"CAPNP-TS037 Segment buffer length %d is not a multiple of 8.";
		exports2.SEG_REPLACEMENT_BUFFER_TOO_SMALL =
			"CAPNP-TS038 Attempted to replace a segment buffer with one that is smaller than the allocated space.";
		exports2.SEG_SIZE_OVERFLOW = `CAPNP-TS039 Requested size %x exceeds maximum value (${constants_1.MAX_SEGMENT_LENGTH}).`;
		exports2.TYPE_COMPOSITE_SIZE_UNDEFINED =
			"CAPNP-TS040 Must provide a composite element size for composite list pointers.";
		exports2.TYPE_GET_GENERIC_LIST = "CAPNP-TS041 Attempted to call get() on a generic list.";
		exports2.TYPE_SET_GENERIC_LIST = "CAPNP-TS042 Attempted to call set() on a generic list.";
		exports2.PTR_WRITE_CONST_LIST = "CAPNP-TS043 Attempted to write to a const list.";
		exports2.PTR_WRITE_CONST_STRUCT = "CAPNP-TS044 Attempted to write to a const struct.";
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/mask.js
var require_mask = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/mask.js"(exports2) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.getVoidMask =
			exports2.getUint64Mask =
			exports2.getInt64Mask =
			exports2.getBitMask =
			exports2.getUint8Mask =
			exports2.getUint32Mask =
			exports2.getUint16Mask =
			exports2.getInt8Mask =
			exports2.getInt32Mask =
			exports2.getInt16Mask =
			exports2.getFloat64Mask =
			exports2.getFloat32Mask =
				void 0;
		var errors_1 = require_errors();
		function _makePrimitiveMaskFn(byteLength, setter) {
			return (x) => {
				const dv = new DataView(new ArrayBuffer(byteLength));
				setter.call(dv, 0, x, true);
				return dv;
			};
		}
		exports2.getFloat32Mask = _makePrimitiveMaskFn(4, DataView.prototype.setFloat32);
		exports2.getFloat64Mask = _makePrimitiveMaskFn(8, DataView.prototype.setFloat64);
		exports2.getInt16Mask = _makePrimitiveMaskFn(2, DataView.prototype.setInt16);
		exports2.getInt32Mask = _makePrimitiveMaskFn(4, DataView.prototype.setInt32);
		exports2.getInt8Mask = _makePrimitiveMaskFn(1, DataView.prototype.setInt8);
		exports2.getUint16Mask = _makePrimitiveMaskFn(2, DataView.prototype.setUint16);
		exports2.getUint32Mask = _makePrimitiveMaskFn(4, DataView.prototype.setUint32);
		exports2.getUint8Mask = _makePrimitiveMaskFn(1, DataView.prototype.setUint8);
		function getBitMask(value, bitOffset) {
			const dv = new DataView(new ArrayBuffer(1));
			if (!value) return dv;
			dv.setUint8(0, 1 << bitOffset % 8);
			return dv;
		}
		exports2.getBitMask = getBitMask;
		function getInt64Mask(x) {
			return x.toDataView();
		}
		exports2.getInt64Mask = getInt64Mask;
		function getUint64Mask(x) {
			return x.toDataView();
		}
		exports2.getUint64Mask = getUint64Mask;
		function getVoidMask() {
			throw new Error(errors_1.INVARIANT_UNREACHABLE_CODE);
		}
		exports2.getVoidMask = getVoidMask;
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/list-element-size.js
var require_list_element_size = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/list-element-size.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.ListElementOffset = exports2.ListElementSize = void 0;
		var ListElementSize;
		(function (ListElementSize2) {
			ListElementSize2[(ListElementSize2["VOID"] = 0)] = "VOID";
			ListElementSize2[(ListElementSize2["BIT"] = 1)] = "BIT";
			ListElementSize2[(ListElementSize2["BYTE"] = 2)] = "BYTE";
			ListElementSize2[(ListElementSize2["BYTE_2"] = 3)] = "BYTE_2";
			ListElementSize2[(ListElementSize2["BYTE_4"] = 4)] = "BYTE_4";
			ListElementSize2[(ListElementSize2["BYTE_8"] = 5)] = "BYTE_8";
			ListElementSize2[(ListElementSize2["POINTER"] = 6)] = "POINTER";
			ListElementSize2[(ListElementSize2["COMPOSITE"] = 7)] = "COMPOSITE";
		})((ListElementSize = exports2.ListElementSize || (exports2.ListElementSize = {})));
		exports2.ListElementOffset = [
			0,
			0.125,
			1,
			2,
			4,
			8,
			8,
			NaN,
			// composite
		];
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/util.js
var require_util = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/util.js"(exports2) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.repeat =
			exports2.padToWord =
			exports2.pad =
			exports2.identity =
			exports2.format =
			exports2.encodeUtf8 =
			exports2.dumpBuffer =
			exports2.decodeUtf8 =
			exports2.checkUint32 =
			exports2.checkInt32 =
			exports2.bufferToHex =
				void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var constants_1 = require_constants();
		var errors_1 = require_errors();
		var trace = debug_1.default("capnp:util");
		trace("load");
		function bufferToHex(buffer) {
			const a = new Uint8Array(buffer);
			const h = [];
			for (let i = 0; i < a.byteLength; i++) h.push(pad(a[i].toString(16), 2));
			return `[${h.join(" ")}]`;
		}
		exports2.bufferToHex = bufferToHex;
		function checkInt32(value) {
			if (value > constants_1.MAX_INT32 || value < -constants_1.MAX_INT32) {
				throw new RangeError(errors_1.RANGE_INT32_OVERFLOW);
			}
			return value;
		}
		exports2.checkInt32 = checkInt32;
		function checkUint32(value) {
			if (value < 0 || value > constants_1.MAX_UINT32) {
				throw new RangeError(errors_1.RANGE_UINT32_OVERFLOW);
			}
			return value;
		}
		exports2.checkUint32 = checkUint32;
		function decodeUtf8(src) {
			const l = src.byteLength;
			let dst = "";
			let i = 0;
			let cp = 0;
			let a = 0;
			let b = 0;
			let c = 0;
			let d = 0;
			while (i < l) {
				a = src[i++];
				if ((a & 128) === 0) {
					cp = a;
				} else if ((a & 224) === 192) {
					if (i >= l) throw new RangeError(errors_1.RANGE_INVALID_UTF8);
					b = src[i++];
					cp = ((a & 31) << 6) | (b & 63);
				} else if ((a & 240) === 224) {
					if (i + 1 >= l) throw new RangeError(errors_1.RANGE_INVALID_UTF8);
					b = src[i++];
					c = src[i++];
					cp = ((a & 15) << 12) | ((b & 63) << 6) | (c & 63);
				} else if ((a & 248) === 240) {
					if (i + 2 >= l) throw new RangeError(errors_1.RANGE_INVALID_UTF8);
					b = src[i++];
					c = src[i++];
					d = src[i++];
					cp = ((a & 7) << 18) | ((b & 63) << 12) | ((c & 63) << 6) | (d & 63);
				} else {
					throw new RangeError(errors_1.RANGE_INVALID_UTF8);
				}
				if (cp <= 55295 || (cp >= 57344 && cp <= 65535)) {
					dst += String.fromCharCode(cp);
				} else {
					cp -= 65536;
					const hi = (cp >>> 10) + 55296;
					const lo = (cp & 1023) + 56320;
					if (hi < 55296 || hi > 56319) throw new RangeError(errors_1.RANGE_INVALID_UTF8);
					dst += String.fromCharCode(hi, lo);
				}
			}
			return dst;
		}
		exports2.decodeUtf8 = decodeUtf8;
		function dumpBuffer(buffer) {
			const b =
				buffer instanceof ArrayBuffer
					? new Uint8Array(buffer)
					: new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
			const byteLength = Math.min(b.byteLength, constants_1.MAX_BUFFER_DUMP_BYTES);
			let r = format("\n=== buffer[%d] ===", byteLength);
			for (let j = 0; j < byteLength; j += 16) {
				r += `
${pad(j.toString(16), 8)}: `;
				let s = "";
				let k;
				for (k = 0; k < 16 && j + k < b.byteLength; k++) {
					const v = b[j + k];
					r += `${pad(v.toString(16), 2)} `;
					s += v > 31 && v < 255 ? String.fromCharCode(v) : "\xB7";
					if (k === 7) r += " ";
				}
				r += `${repeat((17 - k) * 3, " ")}${s}`;
			}
			r += "\n";
			if (byteLength !== b.byteLength) {
				r += format("=== (truncated %d bytes) ===\n", b.byteLength - byteLength);
			}
			return r;
		}
		exports2.dumpBuffer = dumpBuffer;
		function encodeUtf8(src) {
			const l = src.length;
			const dst = new Uint8Array(new ArrayBuffer(l * 4));
			let j = 0;
			for (let i = 0; i < l; i++) {
				const c = src.charCodeAt(i);
				if (c <= 127) {
					dst[j++] = c;
				} else if (c <= 2047) {
					dst[j++] = 192 | (c >>> 6);
					dst[j++] = 128 | ((c >>> 0) & 63);
				} else if (c <= 55295 || c >= 57344) {
					dst[j++] = 224 | (c >>> 12);
					dst[j++] = 128 | ((c >>> 6) & 63);
					dst[j++] = 128 | ((c >>> 0) & 63);
				} else {
					if (i + 1 >= l) throw new RangeError(errors_1.RANGE_INVALID_UTF8);
					const hi = c - 55296;
					const lo = src.charCodeAt(++i) - 56320;
					const cp = ((hi << 10) | lo) + 65536;
					dst[j++] = 240 | (cp >>> 18);
					dst[j++] = 128 | ((cp >>> 12) & 63);
					dst[j++] = 128 | ((cp >>> 6) & 63);
					dst[j++] = 128 | ((cp >>> 0) & 63);
				}
			}
			return dst.subarray(0, j);
		}
		exports2.encodeUtf8 = encodeUtf8;
		function format(s, ...args) {
			const n = s.length;
			let arg;
			let argIndex = 0;
			let c;
			let escaped = false;
			let i = 0;
			let leadingZero = false;
			let precision;
			let result = "";
			function nextArg() {
				return args[argIndex++];
			}
			function slurpNumber() {
				let digits = "";
				while (/\d/.test(s[i])) {
					digits += s[i++];
					c = s[i];
				}
				return digits.length > 0 ? parseInt(digits, 10) : null;
			}
			for (; i < n; ++i) {
				c = s[i];
				if (escaped) {
					escaped = false;
					if (c === ".") {
						leadingZero = false;
						c = s[++i];
					} else if (c === "0" && s[i + 1] === ".") {
						leadingZero = true;
						i += 2;
						c = s[i];
					} else {
						leadingZero = true;
					}
					precision = slurpNumber();
					switch (c) {
						case "a":
							result += "0x" + pad(parseInt(String(nextArg()), 10).toString(16), 8);
							break;
						case "b":
							result += parseInt(String(nextArg()), 10).toString(2);
							break;
						case "c":
							arg = nextArg();
							if (typeof arg === "string" || arg instanceof String) {
								result += arg;
							} else {
								result += String.fromCharCode(parseInt(String(arg), 10));
							}
							break;
						case "d":
							result += parseInt(String(nextArg()), 10);
							break;
						case "f": {
							const tmp = parseFloat(String(nextArg())).toFixed(precision || 6);
							result += leadingZero ? tmp : tmp.replace(/^0/, "");
							break;
						}
						case "j":
							result += JSON.stringify(nextArg());
							break;
						case "o":
							result += "0" + parseInt(String(nextArg()), 10).toString(8);
							break;
						case "s":
							result += nextArg();
							break;
						case "x":
							result += "0x" + parseInt(String(nextArg()), 10).toString(16);
							break;
						case "X":
							result +=
								"0x" + parseInt(String(nextArg()), 10).toString(16).toUpperCase();
							break;
						default:
							result += c;
							break;
					}
				} else if (c === "%") {
					escaped = true;
				} else {
					result += c;
				}
			}
			return result;
		}
		exports2.format = format;
		function identity(x) {
			return x;
		}
		exports2.identity = identity;
		function pad(v, width, pad2 = "0") {
			return v.length >= width ? v : new Array(width - v.length + 1).join(pad2) + v;
		}
		exports2.pad = pad;
		function padToWord(size) {
			return (size + 7) & ~7;
		}
		exports2.padToWord = padToWord;
		function repeat(times, str) {
			let out = "";
			let n = times;
			let s = str;
			if (n < 1 || n > Number.MAX_VALUE) return out;
			do {
				if (n % 2) out += s;
				n = Math.floor(n / 2);
				if (n) s += s;
			} while (n);
			return out;
		}
		exports2.repeat = repeat;
		var hex = (v) => parseInt(String(v)).toString(16);
		debug_1.default.formatters["h"] = hex;
		debug_1.default.formatters["x"] = (v) => `0x${hex(v)}`;
		debug_1.default.formatters["a"] = (v) => `0x${pad(hex(v), 8)}`;
		debug_1.default.formatters["X"] = (v) => `0x${hex(v).toUpperCase()}`;
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/arena/arena-kind.js
var require_arena_kind = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/arena/arena-kind.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.ArenaKind = void 0;
		var ArenaKind;
		(function (ArenaKind2) {
			ArenaKind2[(ArenaKind2["SINGLE_SEGMENT"] = 0)] = "SINGLE_SEGMENT";
			ArenaKind2[(ArenaKind2["MULTI_SEGMENT"] = 1)] = "MULTI_SEGMENT";
		})((ArenaKind = exports2.ArenaKind || (exports2.ArenaKind = {})));
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/arena/arena-allocation-result.js
var require_arena_allocation_result = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/arena/arena-allocation-result.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.ArenaAllocationResult = void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var trace = debug_1.default("capnp:serialization:arena:arena-allocation-result");
		trace("load");
		var ArenaAllocationResult = class {
			constructor(id, buffer) {
				this.id = id;
				this.buffer = buffer;
				trace("new", this);
			}
		};
		exports2.ArenaAllocationResult = ArenaAllocationResult;
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/arena/multi-segment-arena.js
var require_multi_segment_arena = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/arena/multi-segment-arena.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.getNumSegments =
			exports2.getBuffer =
			exports2.allocate =
			exports2.MultiSegmentArena =
				void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var constants_1 = require_constants();
		var errors_1 = require_errors();
		var util_1 = require_util();
		var arena_allocation_result_1 = require_arena_allocation_result();
		var arena_kind_1 = require_arena_kind();
		var trace = debug_1.default("capnp:arena:multi");
		trace("load");
		var MultiSegmentArena = class {
			constructor(buffers = []) {
				this.kind = arena_kind_1.ArenaKind.MULTI_SEGMENT;
				this.buffers = buffers;
				trace("new %s", this);
			}
			toString() {
				return util_1.format("MultiSegmentArena_segments:%d", getNumSegments(this));
			}
		};
		exports2.MultiSegmentArena = MultiSegmentArena;
		MultiSegmentArena.allocate = allocate;
		MultiSegmentArena.getBuffer = getBuffer;
		MultiSegmentArena.getNumSegments = getNumSegments;
		function allocate(minSize, m) {
			const b = new ArrayBuffer(
				util_1.padToWord(Math.max(minSize, constants_1.DEFAULT_BUFFER_SIZE)),
			);
			m.buffers.push(b);
			return new arena_allocation_result_1.ArenaAllocationResult(m.buffers.length - 1, b);
		}
		exports2.allocate = allocate;
		function getBuffer(id, m) {
			if (id < 0 || id >= m.buffers.length) {
				throw new Error(util_1.format(errors_1.SEG_ID_OUT_OF_BOUNDS, id));
			}
			return m.buffers[id];
		}
		exports2.getBuffer = getBuffer;
		function getNumSegments(m) {
			return m.buffers.length;
		}
		exports2.getNumSegments = getNumSegments;
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/arena/single-segment-arena.js
var require_single_segment_arena = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/arena/single-segment-arena.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.getNumSegments =
			exports2.getBuffer =
			exports2.allocate =
			exports2.SingleSegmentArena =
				void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var constants_1 = require_constants();
		var errors_1 = require_errors();
		var util_1 = require_util();
		var arena_allocation_result_1 = require_arena_allocation_result();
		var arena_kind_1 = require_arena_kind();
		var trace = debug_1.default("capnp:arena:single");
		trace("load");
		var SingleSegmentArena = class {
			constructor(buffer = new ArrayBuffer(constants_1.DEFAULT_BUFFER_SIZE)) {
				this.kind = arena_kind_1.ArenaKind.SINGLE_SEGMENT;
				if ((buffer.byteLength & 7) !== 0) {
					throw new Error(
						util_1.format(errors_1.SEG_NOT_WORD_ALIGNED, buffer.byteLength),
					);
				}
				this.buffer = buffer;
				trace("new %s", this);
			}
			toString() {
				return util_1.format("SingleSegmentArena_len:%x", this.buffer.byteLength);
			}
		};
		exports2.SingleSegmentArena = SingleSegmentArena;
		SingleSegmentArena.allocate = allocate;
		SingleSegmentArena.getBuffer = getBuffer;
		SingleSegmentArena.getNumSegments = getNumSegments;
		function allocate(minSize, segments, s) {
			trace("Allocating %x bytes for segment 0 in %s.", minSize, s);
			const srcBuffer = segments.length > 0 ? segments[0].buffer : s.buffer;
			if (minSize < constants_1.MIN_SINGLE_SEGMENT_GROWTH) {
				minSize = constants_1.MIN_SINGLE_SEGMENT_GROWTH;
			} else {
				minSize = util_1.padToWord(minSize);
			}
			s.buffer = new ArrayBuffer(srcBuffer.byteLength + minSize);
			new Float64Array(s.buffer).set(new Float64Array(srcBuffer));
			return new arena_allocation_result_1.ArenaAllocationResult(0, s.buffer);
		}
		exports2.allocate = allocate;
		function getBuffer(id, s) {
			if (id !== 0) throw new Error(util_1.format(errors_1.SEG_GET_NON_ZERO_SINGLE, id));
			return s.buffer;
		}
		exports2.getBuffer = getBuffer;
		function getNumSegments() {
			return 1;
		}
		exports2.getNumSegments = getNumSegments;
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/arena/arena.js
var require_arena = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/arena/arena.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.getNumSegments = exports2.getBuffer = exports2.allocate = exports2.Arena = void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var errors_1 = require_errors();
		var arena_kind_1 = require_arena_kind();
		var multi_segment_arena_1 = require_multi_segment_arena();
		var single_segment_arena_1 = require_single_segment_arena();
		var trace = debug_1.default("capnp:arena");
		trace("load");
		var Arena = class {};
		exports2.Arena = Arena;
		Arena.allocate = allocate;
		Arena.getBuffer = getBuffer;
		Arena.getNumSegments = getNumSegments;
		function allocate(minSize, segments, a) {
			switch (a.kind) {
				case arena_kind_1.ArenaKind.MULTI_SEGMENT:
					return multi_segment_arena_1.MultiSegmentArena.allocate(minSize, a);
				case arena_kind_1.ArenaKind.SINGLE_SEGMENT:
					return single_segment_arena_1.SingleSegmentArena.allocate(minSize, segments, a);
				default:
					return errors_1.assertNever(a);
			}
		}
		exports2.allocate = allocate;
		function getBuffer(id, a) {
			switch (a.kind) {
				case arena_kind_1.ArenaKind.MULTI_SEGMENT:
					return multi_segment_arena_1.MultiSegmentArena.getBuffer(id, a);
				case arena_kind_1.ArenaKind.SINGLE_SEGMENT:
					return single_segment_arena_1.SingleSegmentArena.getBuffer(id, a);
				default:
					return errors_1.assertNever(a);
			}
		}
		exports2.getBuffer = getBuffer;
		function getNumSegments(a) {
			switch (a.kind) {
				case arena_kind_1.ArenaKind.MULTI_SEGMENT:
					return multi_segment_arena_1.MultiSegmentArena.getNumSegments(a);
				case arena_kind_1.ArenaKind.SINGLE_SEGMENT:
					return single_segment_arena_1.SingleSegmentArena.getNumSegments();
				default:
					return errors_1.assertNever(a);
			}
		}
		exports2.getNumSegments = getNumSegments;
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/arena/index.js
var require_arena2 = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/arena/index.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.SingleSegmentArena =
			exports2.MultiSegmentArena =
			exports2.ArenaKind =
			exports2.Arena =
				void 0;
		var arena_1 = require_arena();
		Object.defineProperty(exports2, "Arena", {
			enumerable: true,
			get: function () {
				return arena_1.Arena;
			},
		});
		var arena_kind_1 = require_arena_kind();
		Object.defineProperty(exports2, "ArenaKind", {
			enumerable: true,
			get: function () {
				return arena_kind_1.ArenaKind;
			},
		});
		var multi_segment_arena_1 = require_multi_segment_arena();
		Object.defineProperty(exports2, "MultiSegmentArena", {
			enumerable: true,
			get: function () {
				return multi_segment_arena_1.MultiSegmentArena;
			},
		});
		var single_segment_arena_1 = require_single_segment_arena();
		Object.defineProperty(exports2, "SingleSegmentArena", {
			enumerable: true,
			get: function () {
				return single_segment_arena_1.SingleSegmentArena;
			},
		});
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/packing.js
var require_packing = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/packing.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.unpack =
			exports2.pack =
			exports2.getZeroByteCount =
			exports2.getUnpackedByteLength =
			exports2.getTagByte =
			exports2.getHammingWeight =
				void 0;
		var constants_1 = require_constants();
		var errors_1 = require_errors();
		function getHammingWeight(x) {
			let w = x - ((x >> 1) & 1431655765);
			w = (w & 858993459) + ((w >> 2) & 858993459);
			return (((w + (w >> 4)) & 252645135) * 16843009) >> 24;
		}
		exports2.getHammingWeight = getHammingWeight;
		function getTagByte(a, b, c, d, e, f, g, h) {
			return (
				(a === 0 ? 0 : 1) |
				(b === 0 ? 0 : 2) |
				(c === 0 ? 0 : 4) |
				(d === 0 ? 0 : 8) |
				(e === 0 ? 0 : 16) |
				(f === 0 ? 0 : 32) |
				(g === 0 ? 0 : 64) |
				(h === 0 ? 0 : 128)
			);
		}
		exports2.getTagByte = getTagByte;
		function getUnpackedByteLength(packed) {
			const p = new Uint8Array(packed);
			let wordLength = 0;
			let lastTag = 119;
			for (let i = 0; i < p.byteLength; ) {
				const tag = p[i];
				if (lastTag === 0) {
					wordLength += tag;
					i++;
					lastTag = 119;
				} else if (lastTag === 255) {
					wordLength += tag;
					i += tag * 8 + 1;
					lastTag = 119;
				} else {
					wordLength++;
					i += getHammingWeight(tag) + 1;
					lastTag = tag;
				}
			}
			return wordLength * 8;
		}
		exports2.getUnpackedByteLength = getUnpackedByteLength;
		function getZeroByteCount(a, b, c, d, e, f, g, h) {
			return (
				(a === 0 ? 1 : 0) +
				(b === 0 ? 1 : 0) +
				(c === 0 ? 1 : 0) +
				(d === 0 ? 1 : 0) +
				(e === 0 ? 1 : 0) +
				(f === 0 ? 1 : 0) +
				(g === 0 ? 1 : 0) +
				(h === 0 ? 1 : 0)
			);
		}
		exports2.getZeroByteCount = getZeroByteCount;
		function pack(unpacked, byteOffset = 0, byteLength) {
			if (unpacked.byteLength % 8 !== 0) throw new Error(errors_1.MSG_PACK_NOT_WORD_ALIGNED);
			const src = new Uint8Array(unpacked, byteOffset, byteLength);
			const dst = [];
			let lastTag = 119;
			let spanTagOffset = NaN;
			let spanWordLength = 0;
			let spanThreshold = constants_1.PACK_SPAN_THRESHOLD;
			for (let srcByteOffset = 0; srcByteOffset < src.byteLength; srcByteOffset += 8) {
				const a = src[srcByteOffset];
				const b = src[srcByteOffset + 1];
				const c = src[srcByteOffset + 2];
				const d = src[srcByteOffset + 3];
				const e = src[srcByteOffset + 4];
				const f = src[srcByteOffset + 5];
				const g = src[srcByteOffset + 6];
				const h = src[srcByteOffset + 7];
				const tag = getTagByte(a, b, c, d, e, f, g, h);
				let skipWriteWord = true;
				switch (lastTag) {
					case 0:
						if (tag !== 0 || spanWordLength >= 255) {
							dst.push(spanWordLength);
							spanWordLength = 0;
							skipWriteWord = false;
						} else {
							spanWordLength++;
						}
						break;
					case 255: {
						const zeroCount = getZeroByteCount(a, b, c, d, e, f, g, h);
						spanThreshold -= zeroCount;
						if (spanThreshold <= 0 || spanWordLength >= 255) {
							dst[spanTagOffset] = spanWordLength;
							spanWordLength = 0;
							spanThreshold = constants_1.PACK_SPAN_THRESHOLD;
							skipWriteWord = false;
						} else {
							dst.push(a, b, c, d, e, f, g, h);
							spanWordLength++;
						}
						break;
					}
					default:
						skipWriteWord = false;
						break;
				}
				if (skipWriteWord) continue;
				dst.push(tag);
				lastTag = tag;
				if (a !== 0) dst.push(a);
				if (b !== 0) dst.push(b);
				if (c !== 0) dst.push(c);
				if (d !== 0) dst.push(d);
				if (e !== 0) dst.push(e);
				if (f !== 0) dst.push(f);
				if (g !== 0) dst.push(g);
				if (h !== 0) dst.push(h);
				if (tag === 255) {
					spanTagOffset = dst.length;
					dst.push(0);
				}
			}
			if (lastTag === 0) {
				dst.push(spanWordLength);
			} else if (lastTag === 255) {
				dst[spanTagOffset] = spanWordLength;
			}
			return new Uint8Array(dst).buffer;
		}
		exports2.pack = pack;
		function unpack(packed) {
			const src = new Uint8Array(packed);
			const dst = new Uint8Array(new ArrayBuffer(getUnpackedByteLength(packed)));
			let lastTag = 119;
			for (let srcByteOffset = 0, dstByteOffset = 0; srcByteOffset < src.byteLength; ) {
				const tag = src[srcByteOffset];
				if (lastTag === 0) {
					dstByteOffset += tag * 8;
					srcByteOffset++;
					lastTag = 119;
				} else if (lastTag === 255) {
					const spanByteLength = tag * 8;
					dst.set(
						src.subarray(srcByteOffset + 1, srcByteOffset + 1 + spanByteLength),
						dstByteOffset,
					);
					dstByteOffset += spanByteLength;
					srcByteOffset += 1 + spanByteLength;
					lastTag = 119;
				} else {
					srcByteOffset++;
					for (let i = 1; i <= 128; i <<= 1) {
						if ((tag & i) !== 0) dst[dstByteOffset] = src[srcByteOffset++];
						dstByteOffset++;
					}
					lastTag = tag;
				}
			}
			return dst.buffer;
		}
		exports2.unpack = unpack;
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/object-size.js
var require_object_size = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/object-size.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.padToWord =
			exports2.getWordLength =
			exports2.getDataWordLength =
			exports2.getByteLength =
			exports2.ObjectSize =
				void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var _ = tslib_1.__importStar(require_util());
		var trace = debug_1.default("capnp:object-size");
		trace("load");
		var ObjectSize = class {
			constructor(dataByteLength, pointerCount) {
				this.dataByteLength = dataByteLength;
				this.pointerLength = pointerCount;
			}
			toString() {
				return _.format(
					"ObjectSize_dw:%d,pc:%d",
					getDataWordLength(this),
					this.pointerLength,
				);
			}
		};
		exports2.ObjectSize = ObjectSize;
		function getByteLength(o) {
			return o.dataByteLength + o.pointerLength * 8;
		}
		exports2.getByteLength = getByteLength;
		function getDataWordLength(o) {
			return o.dataByteLength / 8;
		}
		exports2.getDataWordLength = getDataWordLength;
		function getWordLength(o) {
			return o.dataByteLength / 8 + o.pointerLength;
		}
		exports2.getWordLength = getWordLength;
		function padToWord(o) {
			return new ObjectSize(_.padToWord(o.dataByteLength), o.pointerLength);
		}
		exports2.padToWord = padToWord;
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/pointer-type.js
var require_pointer_type = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/pointer-type.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.PointerType = void 0;
		var PointerType;
		(function (PointerType2) {
			PointerType2[(PointerType2["STRUCT"] = 0)] = "STRUCT";
			PointerType2[(PointerType2["LIST"] = 1)] = "LIST";
			PointerType2[(PointerType2["FAR"] = 2)] = "FAR";
			PointerType2[(PointerType2["OTHER"] = 3)] = "OTHER";
		})((PointerType = exports2.PointerType || (exports2.PointerType = {})));
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/orphan.js
var require_orphan = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/orphan.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.Orphan = void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var errors_1 = require_errors();
		var util_1 = require_util();
		var list_element_size_1 = require_list_element_size();
		var object_size_1 = require_object_size();
		var pointer_1 = require_pointer();
		var pointer_type_1 = require_pointer_type();
		var trace = debug_1.default("capnp:orphan");
		trace("load");
		var Orphan = class {
			constructor(src) {
				const c = pointer_1.getContent(src);
				this.segment = c.segment;
				this.byteOffset = c.byteOffset;
				this._capnp = {};
				this._capnp.type = pointer_1.getTargetPointerType(src);
				switch (this._capnp.type) {
					case pointer_type_1.PointerType.STRUCT:
						this._capnp.size = pointer_1.getTargetStructSize(src);
						break;
					case pointer_type_1.PointerType.LIST:
						this._capnp.length = pointer_1.getTargetListLength(src);
						this._capnp.elementSize = pointer_1.getTargetListElementSize(src);
						if (
							this._capnp.elementSize ===
							list_element_size_1.ListElementSize.COMPOSITE
						) {
							this._capnp.size = pointer_1.getTargetCompositeListSize(src);
						}
						break;
					case pointer_type_1.PointerType.OTHER:
						this._capnp.capId = pointer_1.getCapabilityId(src);
						break;
					default:
						throw new Error(errors_1.PTR_INVALID_POINTER_TYPE);
				}
				pointer_1.erasePointer(src);
			}
			/**
			 * Adopt (move) this orphan into the target pointer location. This will allocate far pointers in `dst` as needed.
			 *
			 * @param {T} dst The destination pointer.
			 * @returns {void}
			 */
			_moveTo(dst) {
				if (this._capnp === void 0) {
					throw new Error(util_1.format(errors_1.PTR_ALREADY_ADOPTED, this));
				}
				if (this.segment.message !== dst.segment.message) {
					throw new Error(util_1.format(errors_1.PTR_ADOPT_WRONG_MESSAGE, this, dst));
				}
				pointer_1.erase(dst);
				const res = pointer_1.initPointer(this.segment, this.byteOffset, dst);
				switch (this._capnp.type) {
					case pointer_type_1.PointerType.STRUCT:
						pointer_1.setStructPointer(res.offsetWords, this._capnp.size, res.pointer);
						break;
					case pointer_type_1.PointerType.LIST: {
						let offsetWords = res.offsetWords;
						if (
							this._capnp.elementSize ===
							list_element_size_1.ListElementSize.COMPOSITE
						) {
							offsetWords--;
						}
						pointer_1.setListPointer(
							offsetWords,
							this._capnp.elementSize,
							this._capnp.length,
							res.pointer,
							this._capnp.size,
						);
						break;
					}
					case pointer_type_1.PointerType.OTHER:
						pointer_1.setInterfacePointer(this._capnp.capId, res.pointer);
						break;
					/* istanbul ignore next */
					default:
						throw new Error(errors_1.PTR_INVALID_POINTER_TYPE);
				}
				this._capnp = void 0;
			}
			dispose() {
				if (this._capnp === void 0) {
					trace("not disposing an already disposed orphan", this);
					return;
				}
				switch (this._capnp.type) {
					case pointer_type_1.PointerType.STRUCT:
						this.segment.fillZeroWords(
							this.byteOffset,
							object_size_1.getWordLength(this._capnp.size),
						);
						break;
					case pointer_type_1.PointerType.LIST: {
						const byteLength = pointer_1.getListByteLength(
							this._capnp.elementSize,
							this._capnp.length,
							this._capnp.size,
						);
						this.segment.fillZeroWords(this.byteOffset, byteLength);
						break;
					}
					default:
						break;
				}
				this._capnp = void 0;
			}
			toString() {
				return util_1.format(
					"Orphan_%d@%a,type:%s",
					this.segment.id,
					this.byteOffset,
					this._capnp && this._capnp.type,
				);
			}
		};
		exports2.Orphan = Orphan;
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/pointer-allocation-result.js
var require_pointer_allocation_result = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/pointer-allocation-result.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.PointerAllocationResult = void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var trace = debug_1.default("capnp:pointer-allocation-result");
		trace("load");
		var PointerAllocationResult = class {
			constructor(pointer, offsetWords) {
				this.pointer = pointer;
				this.offsetWords = offsetWords;
			}
		};
		exports2.PointerAllocationResult = PointerAllocationResult;
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/pointer.js
var require_pointer = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/pointer.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.trackPointerAllocation =
			exports2.copyFromStruct =
			exports2.copyFromList =
			exports2.validate =
			exports2.setStructPointer =
			exports2.setListPointer =
			exports2.setInterfacePointer =
			exports2.setFarPointer =
			exports2.relocateTo =
			exports2.isNull =
			exports2.isDoubleFar =
			exports2.initPointer =
			exports2.getTargetStructSize =
			exports2.getTargetPointerType =
			exports2.getTargetListLength =
			exports2.getTargetListElementSize =
			exports2.getTargetCompositeListSize =
			exports2.getTargetCompositeListTag =
			exports2.getStructSize =
			exports2.getStructPointerLength =
			exports2.getStructDataWords =
			exports2.getPointerType =
			exports2.getOffsetWords =
			exports2.getListLength =
			exports2.getListElementSize =
			exports2.getFarSegmentId =
			exports2.getContent =
			exports2.getCapabilityId =
			exports2.followFars =
			exports2.followFar =
			exports2.erasePointer =
			exports2.erase =
			exports2.copyFrom =
			exports2.add =
			exports2.getListElementByteLength =
			exports2.getListByteLength =
			exports2.dump =
			exports2.disown =
			exports2.adopt =
			exports2.Pointer =
				void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var constants_1 = require_constants();
		var util_1 = require_util();
		var list_element_size_1 = require_list_element_size();
		var object_size_1 = require_object_size();
		var orphan_1 = require_orphan();
		var pointer_allocation_result_1 = require_pointer_allocation_result();
		var pointer_type_1 = require_pointer_type();
		var errors_1 = require_errors();
		var trace = debug_1.default("capnp:pointer");
		trace("load");
		var Pointer = class {
			constructor(segment, byteOffset, depthLimit = constants_1.MAX_DEPTH) {
				this._capnp = { compositeList: false, depthLimit };
				this.segment = segment;
				this.byteOffset = byteOffset;
				if (depthLimit === 0) {
					throw new Error(util_1.format(errors_1.PTR_DEPTH_LIMIT_EXCEEDED, this));
				}
				trackPointerAllocation(segment.message, this);
				if (byteOffset < 0 || byteOffset > segment.byteLength) {
					throw new Error(util_1.format(errors_1.PTR_OFFSET_OUT_OF_BOUNDS, byteOffset));
				}
				trace("new %s", this);
			}
			toString() {
				return util_1.format(
					"Pointer_%d@%a,%s,limit:%x",
					this.segment.id,
					this.byteOffset,
					dump(this),
					this._capnp.depthLimit,
				);
			}
		};
		exports2.Pointer = Pointer;
		Pointer.adopt = adopt;
		Pointer.copyFrom = copyFrom;
		Pointer.disown = disown;
		Pointer.dump = dump;
		Pointer.isNull = isNull;
		Pointer._capnp = {
			displayName: "Pointer",
		};
		function adopt(src, p) {
			src._moveTo(p);
		}
		exports2.adopt = adopt;
		function disown(p) {
			return new orphan_1.Orphan(p);
		}
		exports2.disown = disown;
		function dump(p) {
			return util_1.bufferToHex(p.segment.buffer.slice(p.byteOffset, p.byteOffset + 8));
		}
		exports2.dump = dump;
		function getListByteLength(elementSize, length, compositeSize) {
			switch (elementSize) {
				case list_element_size_1.ListElementSize.BIT:
					return util_1.padToWord((length + 7) >>> 3);
				case list_element_size_1.ListElementSize.BYTE:
				case list_element_size_1.ListElementSize.BYTE_2:
				case list_element_size_1.ListElementSize.BYTE_4:
				case list_element_size_1.ListElementSize.BYTE_8:
				case list_element_size_1.ListElementSize.POINTER:
				case list_element_size_1.ListElementSize.VOID:
					return util_1.padToWord(getListElementByteLength(elementSize) * length);
				/* istanbul ignore next */
				case list_element_size_1.ListElementSize.COMPOSITE:
					if (compositeSize === void 0) {
						throw new Error(util_1.format(errors_1.PTR_INVALID_LIST_SIZE, NaN));
					}
					return length * util_1.padToWord(object_size_1.getByteLength(compositeSize));
				/* istanbul ignore next */
				default:
					throw new Error(errors_1.PTR_INVALID_LIST_SIZE);
			}
		}
		exports2.getListByteLength = getListByteLength;
		function getListElementByteLength(elementSize) {
			switch (elementSize) {
				/* istanbul ignore next */
				case list_element_size_1.ListElementSize.BIT:
					return NaN;
				case list_element_size_1.ListElementSize.BYTE:
					return 1;
				case list_element_size_1.ListElementSize.BYTE_2:
					return 2;
				case list_element_size_1.ListElementSize.BYTE_4:
					return 4;
				case list_element_size_1.ListElementSize.BYTE_8:
				case list_element_size_1.ListElementSize.POINTER:
					return 8;
				/* istanbul ignore next */
				case list_element_size_1.ListElementSize.COMPOSITE:
					return NaN;
				/* istanbul ignore next */
				case list_element_size_1.ListElementSize.VOID:
					return 0;
				/* istanbul ignore next */
				default:
					throw new Error(util_1.format(errors_1.PTR_INVALID_LIST_SIZE, elementSize));
			}
		}
		exports2.getListElementByteLength = getListElementByteLength;
		function add(offset, p) {
			return new Pointer(p.segment, p.byteOffset + offset, p._capnp.depthLimit);
		}
		exports2.add = add;
		function copyFrom(src, p) {
			if (p.segment === src.segment && p.byteOffset === src.byteOffset) {
				trace("ignoring copy operation from identical pointer %s", src);
				return;
			}
			erase(p);
			if (isNull(src)) return;
			switch (getTargetPointerType(src)) {
				case pointer_type_1.PointerType.STRUCT:
					copyFromStruct(src, p);
					break;
				case pointer_type_1.PointerType.LIST:
					copyFromList(src, p);
					break;
				/* istanbul ignore next */
				default:
					throw new Error(
						util_1.format(errors_1.PTR_INVALID_POINTER_TYPE, getTargetPointerType(p)),
					);
			}
		}
		exports2.copyFrom = copyFrom;
		function erase(p) {
			if (isNull(p)) return;
			let c;
			switch (getTargetPointerType(p)) {
				case pointer_type_1.PointerType.STRUCT: {
					const size = getTargetStructSize(p);
					c = getContent(p);
					c.segment.fillZeroWords(c.byteOffset, size.dataByteLength / 8);
					for (let i = 0; i < size.pointerLength; i++) {
						erase(add(i * 8, c));
					}
					break;
				}
				case pointer_type_1.PointerType.LIST: {
					const elementSize = getTargetListElementSize(p);
					const length = getTargetListLength(p);
					let contentWords = util_1.padToWord(
						length * getListElementByteLength(elementSize),
					);
					c = getContent(p);
					if (elementSize === list_element_size_1.ListElementSize.POINTER) {
						for (let i = 0; i < length; i++) {
							erase(
								new Pointer(
									c.segment,
									c.byteOffset + i * 8,
									p._capnp.depthLimit - 1,
								),
							);
						}
						break;
					} else if (elementSize === list_element_size_1.ListElementSize.COMPOSITE) {
						const tag = add(-8, c);
						const compositeSize = getStructSize(tag);
						const compositeByteLength = object_size_1.getByteLength(compositeSize);
						contentWords = getOffsetWords(tag);
						c.segment.setWordZero(c.byteOffset - 8);
						for (let i = 0; i < length; i++) {
							for (let j = 0; j < compositeSize.pointerLength; j++) {
								erase(
									new Pointer(
										c.segment,
										c.byteOffset + i * compositeByteLength + j * 8,
										p._capnp.depthLimit - 1,
									),
								);
							}
						}
					}
					c.segment.fillZeroWords(c.byteOffset, contentWords);
					break;
				}
				case pointer_type_1.PointerType.OTHER:
					break;
				default:
					throw new Error(
						util_1.format(errors_1.PTR_INVALID_POINTER_TYPE, getTargetPointerType(p)),
					);
			}
			erasePointer(p);
		}
		exports2.erase = erase;
		function erasePointer(p) {
			if (getPointerType(p) === pointer_type_1.PointerType.FAR) {
				const landingPad = followFar(p);
				if (isDoubleFar(p)) {
					landingPad.segment.setWordZero(landingPad.byteOffset + 8);
				}
				landingPad.segment.setWordZero(landingPad.byteOffset);
			}
			p.segment.setWordZero(p.byteOffset);
		}
		exports2.erasePointer = erasePointer;
		function followFar(p) {
			const targetSegment = p.segment.message.getSegment(
				p.segment.getUint32(p.byteOffset + 4),
			);
			const targetWordOffset = p.segment.getUint32(p.byteOffset) >>> 3;
			return new Pointer(targetSegment, targetWordOffset * 8, p._capnp.depthLimit - 1);
		}
		exports2.followFar = followFar;
		function followFars(p) {
			if (getPointerType(p) === pointer_type_1.PointerType.FAR) {
				const landingPad = followFar(p);
				if (isDoubleFar(p)) landingPad.byteOffset += 8;
				return landingPad;
			}
			return p;
		}
		exports2.followFars = followFars;
		function getCapabilityId(p) {
			return p.segment.getUint32(p.byteOffset + 4);
		}
		exports2.getCapabilityId = getCapabilityId;
		function isCompositeList(p) {
			return (
				getTargetPointerType(p) === pointer_type_1.PointerType.LIST &&
				getTargetListElementSize(p) === list_element_size_1.ListElementSize.COMPOSITE
			);
		}
		function getContent(p, ignoreCompositeIndex) {
			let c;
			if (isDoubleFar(p)) {
				const landingPad = followFar(p);
				c = new Pointer(
					p.segment.message.getSegment(getFarSegmentId(landingPad)),
					getOffsetWords(landingPad) * 8,
				);
			} else {
				const target = followFars(p);
				c = new Pointer(target.segment, target.byteOffset + 8 + getOffsetWords(target) * 8);
			}
			if (isCompositeList(p)) c.byteOffset += 8;
			if (!ignoreCompositeIndex && p._capnp.compositeIndex !== void 0) {
				c.byteOffset -= 8;
				c.byteOffset +=
					8 +
					p._capnp.compositeIndex *
						object_size_1.getByteLength(object_size_1.padToWord(getStructSize(c)));
			}
			return c;
		}
		exports2.getContent = getContent;
		function getFarSegmentId(p) {
			return p.segment.getUint32(p.byteOffset + 4);
		}
		exports2.getFarSegmentId = getFarSegmentId;
		function getListElementSize(p) {
			return p.segment.getUint32(p.byteOffset + 4) & constants_1.LIST_SIZE_MASK;
		}
		exports2.getListElementSize = getListElementSize;
		function getListLength(p) {
			return p.segment.getUint32(p.byteOffset + 4) >>> 3;
		}
		exports2.getListLength = getListLength;
		function getOffsetWords(p) {
			const o = p.segment.getInt32(p.byteOffset);
			return o & 2 ? o >> 3 : o >> 2;
		}
		exports2.getOffsetWords = getOffsetWords;
		function getPointerType(p) {
			return p.segment.getUint32(p.byteOffset) & constants_1.POINTER_TYPE_MASK;
		}
		exports2.getPointerType = getPointerType;
		function getStructDataWords(p) {
			return p.segment.getUint16(p.byteOffset + 4);
		}
		exports2.getStructDataWords = getStructDataWords;
		function getStructPointerLength(p) {
			return p.segment.getUint16(p.byteOffset + 6);
		}
		exports2.getStructPointerLength = getStructPointerLength;
		function getStructSize(p) {
			return new object_size_1.ObjectSize(
				getStructDataWords(p) * 8,
				getStructPointerLength(p),
			);
		}
		exports2.getStructSize = getStructSize;
		function getTargetCompositeListTag(p) {
			const c = getContent(p);
			c.byteOffset -= 8;
			return c;
		}
		exports2.getTargetCompositeListTag = getTargetCompositeListTag;
		function getTargetCompositeListSize(p) {
			return getStructSize(getTargetCompositeListTag(p));
		}
		exports2.getTargetCompositeListSize = getTargetCompositeListSize;
		function getTargetListElementSize(p) {
			return getListElementSize(followFars(p));
		}
		exports2.getTargetListElementSize = getTargetListElementSize;
		function getTargetListLength(p) {
			const t = followFars(p);
			if (getListElementSize(t) === list_element_size_1.ListElementSize.COMPOSITE) {
				return getOffsetWords(getTargetCompositeListTag(p));
			}
			return getListLength(t);
		}
		exports2.getTargetListLength = getTargetListLength;
		function getTargetPointerType(p) {
			const t = getPointerType(followFars(p));
			if (t === pointer_type_1.PointerType.FAR)
				throw new Error(util_1.format(errors_1.PTR_INVALID_FAR_TARGET, p));
			return t;
		}
		exports2.getTargetPointerType = getTargetPointerType;
		function getTargetStructSize(p) {
			return getStructSize(followFars(p));
		}
		exports2.getTargetStructSize = getTargetStructSize;
		function initPointer(contentSegment, contentOffset, p) {
			if (p.segment !== contentSegment) {
				trace("Initializing far pointer %s -> %s.", p, contentSegment);
				if (!contentSegment.hasCapacity(8)) {
					const landingPad2 = p.segment.allocate(16);
					trace(
						"GAH! Initializing double-far pointer in %s from %s -> %s.",
						p,
						contentSegment,
						landingPad2,
					);
					setFarPointer(true, landingPad2.byteOffset / 8, landingPad2.segment.id, p);
					setFarPointer(false, contentOffset / 8, contentSegment.id, landingPad2);
					landingPad2.byteOffset += 8;
					return new pointer_allocation_result_1.PointerAllocationResult(landingPad2, 0);
				}
				const landingPad = contentSegment.allocate(8);
				if (landingPad.segment.id !== contentSegment.id) {
					throw new Error(errors_1.INVARIANT_UNREACHABLE_CODE);
				}
				setFarPointer(false, landingPad.byteOffset / 8, landingPad.segment.id, p);
				return new pointer_allocation_result_1.PointerAllocationResult(
					landingPad,
					(contentOffset - landingPad.byteOffset - 8) / 8,
				);
			}
			trace("Initializing intra-segment pointer %s -> %a.", p, contentOffset);
			return new pointer_allocation_result_1.PointerAllocationResult(
				p,
				(contentOffset - p.byteOffset - 8) / 8,
			);
		}
		exports2.initPointer = initPointer;
		function isDoubleFar(p) {
			return (
				getPointerType(p) === pointer_type_1.PointerType.FAR &&
				(p.segment.getUint32(p.byteOffset) & constants_1.POINTER_DOUBLE_FAR_MASK) !== 0
			);
		}
		exports2.isDoubleFar = isDoubleFar;
		function isNull(p) {
			return p.segment.isWordZero(p.byteOffset);
		}
		exports2.isNull = isNull;
		function relocateTo(dst, src) {
			const t = followFars(src);
			const lo = t.segment.getUint8(t.byteOffset) & 3;
			const hi = t.segment.getUint32(t.byteOffset + 4);
			erase(dst);
			const res = initPointer(t.segment, t.byteOffset + 8 + getOffsetWords(t) * 8, dst);
			res.pointer.segment.setUint32(res.pointer.byteOffset, lo | (res.offsetWords << 2));
			res.pointer.segment.setUint32(res.pointer.byteOffset + 4, hi);
			erasePointer(src);
		}
		exports2.relocateTo = relocateTo;
		function setFarPointer(doubleFar, offsetWords, segmentId, p) {
			const A = pointer_type_1.PointerType.FAR;
			const B = doubleFar ? 1 : 0;
			const C = offsetWords;
			const D = segmentId;
			p.segment.setUint32(p.byteOffset, A | (B << 2) | (C << 3));
			p.segment.setUint32(p.byteOffset + 4, D);
		}
		exports2.setFarPointer = setFarPointer;
		function setInterfacePointer(capId, p) {
			p.segment.setUint32(p.byteOffset, pointer_type_1.PointerType.OTHER);
			p.segment.setUint32(p.byteOffset + 4, capId);
		}
		exports2.setInterfacePointer = setInterfacePointer;
		function setListPointer(offsetWords, size, length, p, compositeSize) {
			const A = pointer_type_1.PointerType.LIST;
			const B = offsetWords;
			const C = size;
			let D = length;
			if (size === list_element_size_1.ListElementSize.COMPOSITE) {
				if (compositeSize === void 0) {
					throw new TypeError(errors_1.TYPE_COMPOSITE_SIZE_UNDEFINED);
				}
				D *= object_size_1.getWordLength(compositeSize);
			}
			p.segment.setUint32(p.byteOffset, A | (B << 2));
			p.segment.setUint32(p.byteOffset + 4, C | (D << 3));
		}
		exports2.setListPointer = setListPointer;
		function setStructPointer(offsetWords, size, p) {
			const A = pointer_type_1.PointerType.STRUCT;
			const B = offsetWords;
			const C = object_size_1.getDataWordLength(size);
			const D = size.pointerLength;
			p.segment.setUint32(p.byteOffset, A | (B << 2));
			p.segment.setUint16(p.byteOffset + 4, C);
			p.segment.setUint16(p.byteOffset + 6, D);
		}
		exports2.setStructPointer = setStructPointer;
		function validate(pointerType, p, elementSize) {
			if (isNull(p)) return;
			const t = followFars(p);
			const A = t.segment.getUint32(t.byteOffset) & constants_1.POINTER_TYPE_MASK;
			if (A !== pointerType) {
				throw new Error(util_1.format(errors_1.PTR_WRONG_POINTER_TYPE, p, pointerType));
			}
			if (elementSize !== void 0) {
				const C = t.segment.getUint32(t.byteOffset + 4) & constants_1.LIST_SIZE_MASK;
				if (C !== elementSize) {
					throw new Error(
						util_1.format(
							errors_1.PTR_WRONG_LIST_TYPE,
							p,
							list_element_size_1.ListElementSize[elementSize],
						),
					);
				}
			}
		}
		exports2.validate = validate;
		function copyFromList(src, dst) {
			if (dst._capnp.depthLimit <= 0) throw new Error(errors_1.PTR_DEPTH_LIMIT_EXCEEDED);
			const srcContent = getContent(src);
			const srcElementSize = getTargetListElementSize(src);
			const srcLength = getTargetListLength(src);
			let srcCompositeSize;
			let srcStructByteLength;
			let dstContent;
			if (srcElementSize === list_element_size_1.ListElementSize.POINTER) {
				dstContent = dst.segment.allocate(srcLength << 3);
				for (let i = 0; i < srcLength; i++) {
					const srcPtr = new Pointer(
						srcContent.segment,
						srcContent.byteOffset + (i << 3),
						src._capnp.depthLimit - 1,
					);
					const dstPtr = new Pointer(
						dstContent.segment,
						dstContent.byteOffset + (i << 3),
						dst._capnp.depthLimit - 1,
					);
					copyFrom(srcPtr, dstPtr);
				}
			} else if (srcElementSize === list_element_size_1.ListElementSize.COMPOSITE) {
				srcCompositeSize = object_size_1.padToWord(getTargetCompositeListSize(src));
				srcStructByteLength = object_size_1.getByteLength(srcCompositeSize);
				dstContent = dst.segment.allocate(
					object_size_1.getByteLength(srcCompositeSize) * srcLength + 8,
				);
				dstContent.segment.copyWord(
					dstContent.byteOffset,
					srcContent.segment,
					srcContent.byteOffset - 8,
				);
				if (srcCompositeSize.dataByteLength > 0) {
					const wordLength = object_size_1.getWordLength(srcCompositeSize) * srcLength;
					dstContent.segment.copyWords(
						dstContent.byteOffset + 8,
						srcContent.segment,
						srcContent.byteOffset,
						wordLength,
					);
				}
				for (let i = 0; i < srcLength; i++) {
					for (let j = 0; j < srcCompositeSize.pointerLength; j++) {
						const offset =
							i * srcStructByteLength + srcCompositeSize.dataByteLength + (j << 3);
						const srcPtr = new Pointer(
							srcContent.segment,
							srcContent.byteOffset + offset,
							src._capnp.depthLimit - 1,
						);
						const dstPtr = new Pointer(
							dstContent.segment,
							dstContent.byteOffset + offset + 8,
							dst._capnp.depthLimit - 1,
						);
						copyFrom(srcPtr, dstPtr);
					}
				}
			} else {
				const byteLength = util_1.padToWord(
					srcElementSize === list_element_size_1.ListElementSize.BIT
						? (srcLength + 7) >>> 3
						: getListElementByteLength(srcElementSize) * srcLength,
				);
				const wordLength = byteLength >>> 3;
				dstContent = dst.segment.allocate(byteLength);
				dstContent.segment.copyWords(
					dstContent.byteOffset,
					srcContent.segment,
					srcContent.byteOffset,
					wordLength,
				);
			}
			const res = initPointer(dstContent.segment, dstContent.byteOffset, dst);
			setListPointer(
				res.offsetWords,
				srcElementSize,
				srcLength,
				res.pointer,
				srcCompositeSize,
			);
		}
		exports2.copyFromList = copyFromList;
		function copyFromStruct(src, dst) {
			if (dst._capnp.depthLimit <= 0) throw new Error(errors_1.PTR_DEPTH_LIMIT_EXCEEDED);
			const srcContent = getContent(src);
			const srcSize = getTargetStructSize(src);
			const srcDataWordLength = object_size_1.getDataWordLength(srcSize);
			const dstContent = dst.segment.allocate(object_size_1.getByteLength(srcSize));
			dstContent.segment.copyWords(
				dstContent.byteOffset,
				srcContent.segment,
				srcContent.byteOffset,
				srcDataWordLength,
			);
			for (let i = 0; i < srcSize.pointerLength; i++) {
				const offset = srcSize.dataByteLength + i * 8;
				const srcPtr = new Pointer(
					srcContent.segment,
					srcContent.byteOffset + offset,
					src._capnp.depthLimit - 1,
				);
				const dstPtr = new Pointer(
					dstContent.segment,
					dstContent.byteOffset + offset,
					dst._capnp.depthLimit - 1,
				);
				copyFrom(srcPtr, dstPtr);
			}
			if (dst._capnp.compositeList) return;
			const res = initPointer(dstContent.segment, dstContent.byteOffset, dst);
			setStructPointer(res.offsetWords, srcSize, res.pointer);
		}
		exports2.copyFromStruct = copyFromStruct;
		function trackPointerAllocation(message, p) {
			message._capnp.traversalLimit -= 8;
			if (message._capnp.traversalLimit <= 0) {
				throw new Error(util_1.format(errors_1.PTR_TRAVERSAL_LIMIT_EXCEEDED, p));
			}
		}
		exports2.trackPointerAllocation = trackPointerAllocation;
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/list.js
var require_list = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/list.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.set = exports2.get = exports2.initList = exports2.List = void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var errors_1 = require_errors();
		var util_1 = require_util();
		var list_element_size_1 = require_list_element_size();
		var object_size_1 = require_object_size();
		var pointer_1 = require_pointer();
		var trace = debug_1.default("capnp:list");
		trace("load");
		var List = class extends pointer_1.Pointer {
			static toString() {
				return this._capnp.displayName;
			}
			all(callbackfn) {
				const length = this.getLength();
				for (let i = 0; i < length; i++) {
					if (!callbackfn(this.get(i), i)) return false;
				}
				return true;
			}
			any(callbackfn) {
				const length = this.getLength();
				for (let i = 0; i < length; i++) {
					if (callbackfn(this.get(i), i)) return true;
				}
				return false;
			}
			ap(callbackfns) {
				const length = this.getLength();
				const res = [];
				for (let i = 0; i < length; i++) {
					res.push(...callbackfns.map((f) => f(this.get(i), i)));
				}
				return res;
			}
			concat(other) {
				const length = this.getLength();
				const otherLength = other.getLength();
				const res = new Array(length + otherLength);
				for (let i = 0; i < length; i++) res[i] = this.get(i);
				for (let i = 0; i < otherLength; i++) res[i + length] = other.get(i);
				return res;
			}
			drop(n) {
				const length = this.getLength();
				const res = new Array(length);
				for (let i = n; i < length; i++) res[i] = this.get(i);
				return res;
			}
			dropWhile(callbackfn) {
				const length = this.getLength();
				const res = [];
				let drop = true;
				for (let i = 0; i < length; i++) {
					const v = this.get(i);
					if (drop) drop = callbackfn(v, i);
					if (!drop) res.push(v);
				}
				return res;
			}
			empty() {
				return [];
			}
			every(callbackfn) {
				return this.all(callbackfn);
			}
			filter(callbackfn) {
				const length = this.getLength();
				const res = [];
				for (let i = 0; i < length; i++) {
					const value = this.get(i);
					if (callbackfn(value, i)) res.push(value);
				}
				return res;
			}
			find(callbackfn) {
				const length = this.getLength();
				for (let i = 0; i < length; i++) {
					const value = this.get(i);
					if (callbackfn(value, i)) return value;
				}
				return void 0;
			}
			findIndex(callbackfn) {
				const length = this.getLength();
				for (let i = 0; i < length; i++) {
					const value = this.get(i);
					if (callbackfn(value, i)) return i;
				}
				return -1;
			}
			forEach(callbackfn) {
				const length = this.getLength();
				for (let i = 0; i < length; i++) callbackfn(this.get(i), i);
			}
			get(_index) {
				return get(_index, this);
			}
			/**
			 * Get the length of this list.
			 *
			 * @returns {number} The number of elements in this list.
			 */
			getLength() {
				return pointer_1.getTargetListLength(this);
			}
			groupBy(callbackfn) {
				const length = this.getLength();
				const res = {};
				for (let i = 0; i < length; i++) {
					const v = this.get(i);
					res[callbackfn(v, i)] = v;
				}
				return res;
			}
			intersperse(sep) {
				const length = this.getLength();
				const res = new Array(length);
				for (let i = 0; i < length; i++) {
					if (i > 0) res.push(sep);
					res.push(this.get(i));
				}
				return res;
			}
			map(callbackfn) {
				const length = this.getLength();
				const res = new Array(length);
				for (let i = 0; i < length; i++) res[i] = callbackfn(this.get(i), i);
				return res;
			}
			reduce(callbackfn, initialValue) {
				let i = 0;
				let res;
				if (initialValue === void 0) {
					res = this.get(0);
					i++;
				} else {
					res = initialValue;
				}
				for (; i < this.getLength(); i++) res = callbackfn(res, this.get(i), i);
				return res;
			}
			set(_index, _value) {
				set(_index, _value, this);
			}
			slice(start = 0, end) {
				const length = end ? Math.min(this.getLength(), end) : this.getLength();
				const res = new Array(length - start);
				for (let i = start; i < length; i++) res[i] = this.get(i);
				return res;
			}
			some(callbackfn) {
				return this.any(callbackfn);
			}
			take(n) {
				const length = Math.min(this.getLength(), n);
				const res = new Array(length);
				for (let i = 0; i < length; i++) res[i] = this.get(i);
				return res;
			}
			takeWhile(callbackfn) {
				const length = this.getLength();
				const res = [];
				let take;
				for (let i = 0; i < length; i++) {
					const v = this.get(i);
					take = callbackfn(v, i);
					if (!take) return res;
					res.push(v);
				}
				return res;
			}
			toArray() {
				return this.map(util_1.identity);
			}
			toString() {
				return `List_${super.toString()}`;
			}
		};
		exports2.List = List;
		List._capnp = {
			displayName: "List<Generic>",
			size: list_element_size_1.ListElementSize.VOID,
		};
		List.get = get;
		List.initList = initList;
		List.set = set;
		function initList(elementSize, length, l, compositeSize) {
			let c;
			switch (elementSize) {
				case list_element_size_1.ListElementSize.BIT:
					c = l.segment.allocate(Math.ceil(length / 8));
					break;
				case list_element_size_1.ListElementSize.BYTE:
				case list_element_size_1.ListElementSize.BYTE_2:
				case list_element_size_1.ListElementSize.BYTE_4:
				case list_element_size_1.ListElementSize.BYTE_8:
				case list_element_size_1.ListElementSize.POINTER:
					c = l.segment.allocate(
						length * pointer_1.getListElementByteLength(elementSize),
					);
					break;
				case list_element_size_1.ListElementSize.COMPOSITE: {
					if (compositeSize === void 0) {
						throw new Error(util_1.format(errors_1.PTR_COMPOSITE_SIZE_UNDEFINED));
					}
					compositeSize = object_size_1.padToWord(compositeSize);
					const byteLength = object_size_1.getByteLength(compositeSize) * length;
					c = l.segment.allocate(byteLength + 8);
					pointer_1.setStructPointer(length, compositeSize, c);
					trace("Wrote composite tag word %s for %s.", c, l);
					break;
				}
				case list_element_size_1.ListElementSize.VOID:
					pointer_1.setListPointer(0, elementSize, length, l);
					return;
				default:
					throw new Error(util_1.format(errors_1.PTR_INVALID_LIST_SIZE, elementSize));
			}
			const res = pointer_1.initPointer(c.segment, c.byteOffset, l);
			pointer_1.setListPointer(
				res.offsetWords,
				elementSize,
				length,
				res.pointer,
				compositeSize,
			);
		}
		exports2.initList = initList;
		function get(_index, _l) {
			throw new TypeError();
		}
		exports2.get = get;
		function set(_index, _value, _l) {
			throw new TypeError();
		}
		exports2.set = set;
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/pointer-list.js
var require_pointer_list = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/pointer-list.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.PointerList = void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var list_element_size_1 = require_list_element_size();
		var list_1 = require_list();
		var pointer_1 = require_pointer();
		var trace = debug_1.default("capnp:list:composite");
		trace("load");
		function PointerList(PointerClass) {
			var _a;
			return (
				(_a = class extends list_1.List {
					get(index) {
						const c = pointer_1.getContent(this);
						return new PointerClass(
							c.segment,
							c.byteOffset + index * 8,
							this._capnp.depthLimit - 1,
						);
					}
					set(index, value) {
						pointer_1.copyFrom(value, this.get(index));
					}
					toString() {
						return `Pointer_${super.toString()},cls:${PointerClass.toString()}`;
					}
				}),
				(_a._capnp = {
					displayName: `List<${PointerClass._capnp.displayName}>`,
					size: list_element_size_1.ListElementSize.POINTER,
				}),
				_a
			);
		}
		exports2.PointerList = PointerList;
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/any-pointer-list.js
var require_any_pointer_list = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/any-pointer-list.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.AnyPointerList = void 0;
		var pointer_1 = require_pointer();
		var pointer_list_1 = require_pointer_list();
		exports2.AnyPointerList = pointer_list_1.PointerList(pointer_1.Pointer);
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/bool-list.js
var require_bool_list = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/bool-list.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.BoolList = void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var list_element_size_1 = require_list_element_size();
		var list_1 = require_list();
		var pointer_1 = require_pointer();
		var trace = debug_1.default("capnp:list:composite");
		trace("load");
		var BoolList = class extends list_1.List {
			get(index) {
				const bitMask = 1 << index % 8;
				const byteOffset = index >>> 3;
				const c = pointer_1.getContent(this);
				const v = c.segment.getUint8(c.byteOffset + byteOffset);
				return (v & bitMask) !== 0;
			}
			set(index, value) {
				const bitMask = 1 << index % 8;
				const c = pointer_1.getContent(this);
				const byteOffset = c.byteOffset + (index >>> 3);
				const v = c.segment.getUint8(byteOffset);
				c.segment.setUint8(byteOffset, value ? v | bitMask : v & ~bitMask);
			}
			toString() {
				return `Bool_${super.toString()}`;
			}
		};
		exports2.BoolList = BoolList;
		BoolList._capnp = {
			displayName: "List<boolean>",
			size: list_element_size_1.ListElementSize.BIT,
		};
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/composite-list.js
var require_composite_list = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/composite-list.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.CompositeList = void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var list_element_size_1 = require_list_element_size();
		var list_1 = require_list();
		var pointer_1 = require_pointer();
		var trace = debug_1.default("capnp:list:composite");
		trace("load");
		function CompositeList(CompositeClass) {
			var _a;
			return (
				(_a = class extends list_1.List {
					get(index) {
						return new CompositeClass(
							this.segment,
							this.byteOffset,
							this._capnp.depthLimit - 1,
							index,
						);
					}
					set(index, value) {
						pointer_1.copyFrom(value, this.get(index));
					}
					toString() {
						return `Composite_${super.toString()},cls:${CompositeClass.toString()}`;
					}
				}),
				(_a._capnp = {
					compositeSize: CompositeClass._capnp.size,
					displayName: `List<${CompositeClass._capnp.displayName}>`,
					size: list_element_size_1.ListElementSize.COMPOSITE,
				}),
				_a
			);
		}
		exports2.CompositeList = CompositeList;
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/data.js
var require_data = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/data.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.Data = void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var list_element_size_1 = require_list_element_size();
		var list_1 = require_list();
		var pointer_1 = require_pointer();
		var pointer_type_1 = require_pointer_type();
		var trace = debug_1.default("capnp:data");
		trace("load");
		var Data = class extends list_1.List {
			static fromPointer(pointer) {
				pointer_1.validate(
					pointer_type_1.PointerType.LIST,
					pointer,
					list_element_size_1.ListElementSize.BYTE,
				);
				return this._fromPointerUnchecked(pointer);
			}
			static _fromPointerUnchecked(pointer) {
				return new this(pointer.segment, pointer.byteOffset, pointer._capnp.depthLimit);
			}
			/**
			 * Copy the contents of `src` into this Data pointer. If `src` is smaller than the length of this pointer then the
			 * remaining bytes will be zeroed out. Extra bytes in `src` are ignored.
			 *
			 * @param {(ArrayBuffer | ArrayBufferView)} src The source buffer.
			 * @returns {void}
			 */
			// TODO: Would be nice to have a way to zero-copy a buffer by allocating a new segment into the message with that
			// buffer data.
			copyBuffer(src) {
				const c = pointer_1.getContent(this);
				const dstLength = this.getLength();
				const srcLength = src.byteLength;
				const i =
					src instanceof ArrayBuffer
						? new Uint8Array(src)
						: new Uint8Array(
								src.buffer,
								src.byteOffset,
								Math.min(dstLength, srcLength),
							);
				const o = new Uint8Array(c.segment.buffer, c.byteOffset, this.getLength());
				o.set(i);
				if (dstLength > srcLength) {
					trace(
						"Zeroing out remaining %d bytes after copy into %s.",
						dstLength - srcLength,
						this,
					);
					o.fill(0, srcLength, dstLength);
				} else if (dstLength < srcLength) {
					trace(
						"Truncated %d bytes from source buffer while copying to %s.",
						srcLength - dstLength,
						this,
					);
				}
			}
			/**
			 * Read a byte from the specified offset.
			 *
			 * @param {number} byteOffset The byte offset to read.
			 * @returns {number} The byte value.
			 */
			get(byteOffset) {
				const c = pointer_1.getContent(this);
				return c.segment.getUint8(c.byteOffset + byteOffset);
			}
			/**
			 * Write a byte at the specified offset.
			 *
			 * @param {number} byteOffset The byte offset to set.
			 * @param {number} value The byte value to set.
			 * @returns {void}
			 */
			set(byteOffset, value) {
				const c = pointer_1.getContent(this);
				c.segment.setUint8(c.byteOffset + byteOffset, value);
			}
			/**
			 * Creates a **copy** of the underlying buffer data and returns it as an ArrayBuffer.
			 *
			 * To obtain a reference to the underlying buffer instead, use `toUint8Array()` or `toDataView()`.
			 *
			 * @returns {ArrayBuffer} A copy of this data buffer.
			 */
			toArrayBuffer() {
				const c = pointer_1.getContent(this);
				return c.segment.buffer.slice(c.byteOffset, c.byteOffset + this.getLength());
			}
			/**
			 * Convert this Data pointer to a DataView representing the pointer's contents.
			 *
			 * WARNING: The DataView references memory from a message segment, so do not venture outside the bounds of the
			 * DataView or else BAD THINGS.
			 *
			 * @returns {DataView} A live reference to the underlying buffer.
			 */
			toDataView() {
				const c = pointer_1.getContent(this);
				return new DataView(c.segment.buffer, c.byteOffset, this.getLength());
			}
			toString() {
				return `Data_${super.toString()}`;
			}
			/**
			 * Convert this Data pointer to a Uint8Array representing the pointer's contents.
			 *
			 * WARNING: The Uint8Array references memory from a message segment, so do not venture outside the bounds of the
			 * Uint8Array or else BAD THINGS.
			 *
			 * @returns {DataView} A live reference to the underlying buffer.
			 */
			toUint8Array() {
				const c = pointer_1.getContent(this);
				return new Uint8Array(c.segment.buffer, c.byteOffset, this.getLength());
			}
		};
		exports2.Data = Data;
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/data-list.js
var require_data_list = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/data-list.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.DataList = void 0;
		var data_1 = require_data();
		var pointer_list_1 = require_pointer_list();
		exports2.DataList = pointer_list_1.PointerList(data_1.Data);
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/float32-list.js
var require_float32_list = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/float32-list.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.Float32List = void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var list_element_size_1 = require_list_element_size();
		var list_1 = require_list();
		var pointer_1 = require_pointer();
		var trace = debug_1.default("capnp:list:composite");
		trace("load");
		var Float32List = class extends list_1.List {
			get(index) {
				const c = pointer_1.getContent(this);
				return c.segment.getFloat32(c.byteOffset + index * 4);
			}
			set(index, value) {
				const c = pointer_1.getContent(this);
				c.segment.setFloat32(c.byteOffset + index * 4, value);
			}
			toString() {
				return `Float32_${super.toString()}`;
			}
		};
		exports2.Float32List = Float32List;
		Float32List._capnp = {
			displayName: "List<Float32>",
			size: list_element_size_1.ListElementSize.BYTE_4,
		};
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/float64-list.js
var require_float64_list = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/float64-list.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.Float64List = void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var list_element_size_1 = require_list_element_size();
		var list_1 = require_list();
		var pointer_1 = require_pointer();
		var trace = debug_1.default("capnp:list:composite");
		trace("load");
		var Float64List = class extends list_1.List {
			get(index) {
				const c = pointer_1.getContent(this);
				return c.segment.getFloat64(c.byteOffset + index * 8);
			}
			set(index, value) {
				const c = pointer_1.getContent(this);
				c.segment.setFloat64(c.byteOffset + index * 8, value);
			}
			toString() {
				return `Float64_${super.toString()}`;
			}
		};
		exports2.Float64List = Float64List;
		Float64List._capnp = {
			displayName: "List<Float64>",
			size: list_element_size_1.ListElementSize.BYTE_8,
		};
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/int8-list.js
var require_int8_list = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/int8-list.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.Int8List = void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var list_element_size_1 = require_list_element_size();
		var list_1 = require_list();
		var pointer_1 = require_pointer();
		var trace = debug_1.default("capnp:list:composite");
		trace("load");
		var Int8List = class extends list_1.List {
			get(index) {
				const c = pointer_1.getContent(this);
				return c.segment.getInt8(c.byteOffset + index);
			}
			set(index, value) {
				const c = pointer_1.getContent(this);
				c.segment.setInt8(c.byteOffset + index, value);
			}
			toString() {
				return `Int8_${super.toString()}`;
			}
		};
		exports2.Int8List = Int8List;
		Int8List._capnp = {
			displayName: "List<Int8>",
			size: list_element_size_1.ListElementSize.BYTE,
		};
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/int16-list.js
var require_int16_list = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/int16-list.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.Int16List = void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var list_element_size_1 = require_list_element_size();
		var list_1 = require_list();
		var pointer_1 = require_pointer();
		var trace = debug_1.default("capnp:list:composite");
		trace("load");
		var Int16List = class extends list_1.List {
			get(index) {
				const c = pointer_1.getContent(this);
				return c.segment.getInt16(c.byteOffset + index * 2);
			}
			set(index, value) {
				const c = pointer_1.getContent(this);
				c.segment.setInt16(c.byteOffset + index * 2, value);
			}
			toString() {
				return `Int16_${super.toString()}`;
			}
		};
		exports2.Int16List = Int16List;
		Int16List._capnp = {
			displayName: "List<Int16>",
			size: list_element_size_1.ListElementSize.BYTE_2,
		};
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/int32-list.js
var require_int32_list = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/int32-list.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.Int32List = void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var list_element_size_1 = require_list_element_size();
		var list_1 = require_list();
		var pointer_1 = require_pointer();
		var trace = debug_1.default("capnp:list:composite");
		trace("load");
		var Int32List = class extends list_1.List {
			get(index) {
				const c = pointer_1.getContent(this);
				return c.segment.getInt32(c.byteOffset + index * 4);
			}
			set(index, value) {
				const c = pointer_1.getContent(this);
				c.segment.setInt32(c.byteOffset + index * 4, value);
			}
			toString() {
				return `Int32_${super.toString()}`;
			}
		};
		exports2.Int32List = Int32List;
		Int32List._capnp = {
			displayName: "List<Int32>",
			size: list_element_size_1.ListElementSize.BYTE_4,
		};
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/int64-list.js
var require_int64_list = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/int64-list.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.Int64List = void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var list_element_size_1 = require_list_element_size();
		var list_1 = require_list();
		var pointer_1 = require_pointer();
		var trace = debug_1.default("capnp:list:composite");
		trace("load");
		var Int64List = class extends list_1.List {
			get(index) {
				const c = pointer_1.getContent(this);
				return c.segment.getInt64(c.byteOffset + index * 8);
			}
			set(index, value) {
				const c = pointer_1.getContent(this);
				c.segment.setInt64(c.byteOffset + index * 8, value);
			}
			toString() {
				return `Int64_${super.toString()}`;
			}
		};
		exports2.Int64List = Int64List;
		Int64List._capnp = {
			displayName: "List<Int64>",
			size: list_element_size_1.ListElementSize.BYTE_8,
		};
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/interface.js
var require_interface = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/interface.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.Interface = void 0;
		var constants_1 = require_constants();
		var errors_1 = require_errors();
		var util_1 = require_util();
		var pointer_1 = require_pointer();
		var Interface = class extends pointer_1.Pointer {
			constructor(segment, byteOffset, depthLimit = constants_1.MAX_DEPTH) {
				super(segment, byteOffset, depthLimit);
				throw new Error(util_1.format(errors_1.NOT_IMPLEMENTED, "new Interface"));
			}
		};
		exports2.Interface = Interface;
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/interface-list.js
var require_interface_list = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/interface-list.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.InterfaceList = void 0;
		var interface_1 = require_interface();
		var pointer_list_1 = require_pointer_list();
		exports2.InterfaceList = pointer_list_1.PointerList(interface_1.Interface);
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/types/uint64.js
var require_uint64 = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/types/uint64.js"(exports2) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.Uint64 = void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var constants_1 = require_constants();
		var errors_1 = require_errors();
		var util_1 = require_util();
		var trace = debug_1.default("capnp:uint64");
		trace("load");
		var Uint64 = class _Uint64 {
			/**
			 * Creates a new instance; this is a no-frills constructor for speed. Use the factory methods if you need to convert
			 * from other types or use a different offset into the buffer.
			 *
			 * Will throw if the buffer is not at least 8 bytes long.
			 *
			 * @constructor
			 * @param {Uint8Array} buffer The buffer to use for this 64-bit word; the bytes must be in little-endian order.
			 */
			constructor(buffer) {
				if (buffer.byteLength < 8) throw new RangeError(errors_1.RANGE_INT64_UNDERFLOW);
				this.buffer = buffer;
			}
			static fromArrayBuffer(source, offset = 0, noCopy = false) {
				if (noCopy) return new this(new Uint8Array(source, offset, 8));
				return new this(new Uint8Array(source.slice(offset, offset + 8)));
			}
			static fromDataView(source, offset = 0, noCopy = false) {
				if (noCopy) {
					return new this(new Uint8Array(source.buffer, source.byteOffset + offset, 8));
				}
				return new this(
					new Uint8Array(
						source.buffer.slice(
							source.byteOffset + offset,
							source.byteLength + offset + 8,
						),
					),
				);
			}
			/**
			 * Parse a hexadecimal string in **big endian format** as a Uint64 value.
			 *
			 * @static
			 * @param {string} source The source string.
			 * @returns {Uint64} The string parsed as a 64-bit unsigned integer.
			 */
			static fromHexString(source) {
				if (source.substr(0, 2) === "0x") source = source.substr(2);
				if (source.length < 1) return _Uint64.fromNumber(0);
				if (source[0] === "-") throw new RangeError("Source must not be negative.");
				source = util_1.pad(source, 16);
				if (source.length !== 16) {
					throw new RangeError(
						"Source string must contain at most 16 hexadecimal digits.",
					);
				}
				const bytes = source.toLowerCase().replace(/[^\da-f]/g, "");
				const buf = new Uint8Array(new ArrayBuffer(8));
				for (let i = 0; i < 8; i++) {
					buf[7 - i] = parseInt(bytes.substr(i * 2, 2), 16);
				}
				return new _Uint64(buf);
			}
			static fromNumber(source) {
				const ret = new this(new Uint8Array(8));
				ret.setValue(source);
				return ret;
			}
			static fromUint8Array(source, offset = 0, noCopy = false) {
				if (noCopy) return new this(source.subarray(offset, offset + 8));
				return new this(
					new Uint8Array(
						source.buffer.slice(
							source.byteOffset + offset,
							source.byteOffset + offset + 8,
						),
					),
				);
			}
			equals(other) {
				for (let i = 0; i < 8; i++) {
					if (this.buffer[i] !== other.buffer[i]) return false;
				}
				return true;
			}
			inspect() {
				return `[Uint64 ${this.toString(10)} 0x${this.toHexString()}]`;
			}
			/**
			 * Faster way to check for zero values without converting to a number first.
			 *
			 * @returns {boolean} `true` if the contained value is zero.
			 * @memberOf Uint64
			 */
			isZero() {
				for (let i = 0; i < 8; i++) {
					if (this.buffer[i] !== 0) return false;
				}
				return true;
			}
			setValue(loWord, hiWord) {
				let lo = loWord;
				let hi = hiWord;
				if (hi === void 0) {
					hi = lo;
					hi = Math.abs(hi);
					lo = hi % constants_1.VAL32;
					hi = hi / constants_1.VAL32;
					if (hi > constants_1.VAL32)
						throw new RangeError(`${loWord} is outside Uint64 range`);
					hi = hi >>> 0;
				}
				for (let i = 0; i < 8; i++) {
					this.buffer[i] = lo & 255;
					lo = i === 3 ? hi : lo >>> 8;
				}
			}
			/**
			 * Convert to a native javascript number.
			 *
			 * WARNING: do not expect this number to be accurate to integer precision for large (positive or negative) numbers!
			 *
			 * @param {boolean} allowImprecise If `true`, no check is performed to verify the returned value is accurate;
			 * otherwise out-of-range values are clamped to +Infinity.
			 * @returns {number} A numeric representation of this integer.
			 */
			toNumber(allowImprecise) {
				const b = this.buffer;
				let x = 0;
				let i = 0;
				let m = 1;
				while (i < 8) {
					const v = b[i];
					x += v * m;
					m *= 256;
					i++;
				}
				if (!allowImprecise && x >= constants_1.MAX_SAFE_INTEGER) {
					trace("Coercing out of range value %d to Infinity.", x);
					return Infinity;
				}
				return x;
			}
			valueOf() {
				return this.toNumber(false);
			}
			toArrayBuffer() {
				return this.buffer.buffer;
			}
			toDataView() {
				return new DataView(this.buffer.buffer);
			}
			toHexString() {
				let hex = "";
				for (let i = 7; i >= 0; i--) {
					let v = this.buffer[i].toString(16);
					if (v.length === 1) v = "0" + v;
					hex += v;
				}
				return hex;
			}
			toString(radix) {
				return this.toNumber(true).toString(radix);
			}
			toUint8Array() {
				return this.buffer;
			}
		};
		exports2.Uint64 = Uint64;
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/types/int64.js
var require_int64 = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/types/int64.js"(exports2) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.Int64 = void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var constants_1 = require_constants();
		var util_1 = require_util();
		var uint64_1 = require_uint64();
		var trace = debug_1.default("capnp:int64");
		trace("load");
		var Int64 = class _Int64 extends uint64_1.Uint64 {
			static fromArrayBuffer(source, offset = 0, noCopy = false) {
				if (noCopy) return new this(new Uint8Array(source, offset, 8));
				return new this(new Uint8Array(source.slice(offset, offset + 8)));
			}
			static fromDataView(source, offset = 0, noCopy = false) {
				if (noCopy) {
					return new this(new Uint8Array(source.buffer, source.byteOffset + offset, 8));
				}
				return new this(
					new Uint8Array(
						source.buffer.slice(
							source.byteOffset + offset,
							source.byteLength + offset + 8,
						),
					),
				);
			}
			static fromNumber(source) {
				const ret = new this(new Uint8Array(8));
				ret.setValue(source);
				return ret;
			}
			/**
			 * Parse a hexadecimal string in **big endian format** as an Int64 value.
			 *
			 * The value will be negative if the string is either preceded with a `-` sign, or already in the negative 2's
			 * complement form.
			 *
			 * @static
			 * @param {string} source The source string.
			 * @returns {Int64} The string parsed as a 64-bit signed integer.
			 */
			static fromHexString(source) {
				if (source.substr(0, 2) === "0x") source = source.substr(2);
				if (source.length < 1) return _Int64.fromNumber(0);
				const neg = source[0] === "-";
				if (neg) source = source.substr(1);
				source = util_1.pad(source, 16);
				if (source.length !== 16) {
					throw new RangeError(
						"Source string must contain at most 16 hexadecimal digits.",
					);
				}
				const bytes = source.toLowerCase().replace(/[^\da-f]/g, "");
				const buf = new Uint8Array(new ArrayBuffer(8));
				for (let i = 0; i < 8; i++) {
					buf[7 - i] = parseInt(bytes.substr(i * 2, 2), 16);
				}
				const val = new _Int64(buf);
				if (neg) val.negate();
				return val;
			}
			static fromUint8Array(source, offset = 0, noCopy = false) {
				if (noCopy) return new this(source.subarray(offset, offset + 8));
				return new this(
					new Uint8Array(
						source.buffer.slice(
							source.byteOffset + offset,
							source.byteOffset + offset + 8,
						),
					),
				);
			}
			equals(other) {
				return super.equals(other);
			}
			inspect() {
				return `[Int64 ${this.toString(10)} 0x${this.toHexString()}]`;
			}
			negate() {
				for (let b = this.buffer, carry = 1, i = 0; i < 8; i++) {
					const v = (b[i] ^ 255) + carry;
					b[i] = v & 255;
					carry = v >> 8;
				}
			}
			setValue(loWord, hiWord) {
				let negate = false;
				let lo = loWord;
				let hi = hiWord;
				if (hi === void 0) {
					hi = lo;
					negate = hi < 0;
					hi = Math.abs(hi);
					lo = hi % constants_1.VAL32;
					hi = hi / constants_1.VAL32;
					if (hi > constants_1.VAL32)
						throw new RangeError(`${loWord} is outside Int64 range`);
					hi = hi >>> 0;
				}
				for (let i = 0; i < 8; i++) {
					this.buffer[i] = lo & 255;
					lo = i === 3 ? hi : lo >>> 8;
				}
				if (negate) this.negate();
			}
			toHexString() {
				const b = this.buffer;
				const negate = b[7] & 128;
				if (negate) this.negate();
				let hex = "";
				for (let i = 7; i >= 0; i--) {
					let v = b[i].toString(16);
					if (v.length === 1) v = "0" + v;
					hex += v;
				}
				if (negate) {
					this.negate();
					hex = "-" + hex;
				}
				return hex;
			}
			/**
			 * Convert to a native javascript number.
			 *
			 * WARNING: do not expect this number to be accurate to integer precision for large (positive or negative) numbers!
			 *
			 * @param {boolean} allowImprecise If `true`, no check is performed to verify the returned value is accurate;
			 * otherwise out-of-range values are clamped to +/-Infinity.
			 * @returns {number} A numeric representation of this integer.
			 */
			toNumber(allowImprecise) {
				const b = this.buffer;
				const negate = b[7] & 128;
				let x = 0;
				let carry = 1;
				let i = 0;
				let m = 1;
				while (i < 8) {
					let v = b[i];
					if (negate) {
						v = (v ^ 255) + carry;
						carry = v >> 8;
						v = v & 255;
					}
					x += v * m;
					m *= 256;
					i++;
				}
				if (!allowImprecise && x >= constants_1.MAX_SAFE_INTEGER) {
					trace("Coercing out of range value %d to Infinity.", x);
					return negate ? -Infinity : Infinity;
				}
				return negate ? -x : x;
			}
		};
		exports2.Int64 = Int64;
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/types/index.js
var require_types = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/types/index.js"(exports2) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.Uint64 = exports2.Int64 = void 0;
		var int64_1 = require_int64();
		Object.defineProperty(exports2, "Int64", {
			enumerable: true,
			get: function () {
				return int64_1.Int64;
			},
		});
		var uint64_1 = require_uint64();
		Object.defineProperty(exports2, "Uint64", {
			enumerable: true,
			get: function () {
				return uint64_1.Uint64;
			},
		});
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/text.js
var require_text = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/text.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.Text = void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var util_1 = require_util();
		var list_element_size_1 = require_list_element_size();
		var list_1 = require_list();
		var pointer_1 = require_pointer();
		var pointer_type_1 = require_pointer_type();
		var trace = debug_1.default("capnp:text");
		trace("load");
		var Text = class extends list_1.List {
			static fromPointer(pointer) {
				pointer_1.validate(
					pointer_type_1.PointerType.LIST,
					pointer,
					list_element_size_1.ListElementSize.BYTE,
				);
				return textFromPointerUnchecked(pointer);
			}
			/**
			 * Read a utf-8 encoded string value from this pointer.
			 *
			 * @param {number} [index] The index at which to start reading; defaults to zero.
			 * @returns {string} The string value.
			 */
			get(index = 0) {
				if (index !== 0) {
					trace("Called get() on %s with a strange index (%d).", this, index);
				}
				if (pointer_1.isNull(this)) return "";
				const c = pointer_1.getContent(this);
				return util_1.decodeUtf8(
					new Uint8Array(
						c.segment.buffer,
						c.byteOffset + index,
						this.getLength() - index,
					),
				);
			}
			/**
			 * Get the number of utf-8 encoded bytes in this text. This does **not** include the NUL byte.
			 *
			 * @returns {number} The number of bytes allocated for the text.
			 */
			getLength() {
				return super.getLength() - 1;
			}
			/**
			 * Write a utf-8 encoded string value starting at the specified index.
			 *
			 * @param {number} index The index at which to start copying the string. Note that if this is not zero the bytes
			 * before `index` will be left as-is. All bytes after `index` will be overwritten.
			 * @param {string} value The string value to set.
			 * @returns {void}
			 */
			set(index, value) {
				if (index !== 0) {
					trace("Called set() on %s with a strange index (%d).", this, index);
				}
				const src = util_1.encodeUtf8(value);
				const dstLength = src.byteLength + index;
				let c;
				let original;
				if (!pointer_1.isNull(this)) {
					c = pointer_1.getContent(this);
					let originalLength = this.getLength();
					if (originalLength >= index) {
						originalLength = index;
					} else {
						trace(
							"%d byte gap exists between original text and new text in %s.",
							index - originalLength,
							this,
						);
					}
					original = new Uint8Array(
						c.segment.buffer.slice(
							c.byteOffset,
							c.byteOffset + Math.min(originalLength, index),
						),
					);
					pointer_1.erase(this);
				}
				list_1.initList(list_element_size_1.ListElementSize.BYTE, dstLength + 1, this);
				c = pointer_1.getContent(this);
				const dst = new Uint8Array(c.segment.buffer, c.byteOffset, dstLength);
				if (original) dst.set(original);
				dst.set(src, index);
			}
			toString() {
				return `Text_${super.toString()}`;
			}
		};
		exports2.Text = Text;
		function textFromPointerUnchecked(pointer) {
			return new Text(pointer.segment, pointer.byteOffset, pointer._capnp.depthLimit);
		}
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/struct.js
var require_struct = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/struct.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.checkPointerBounds =
			exports2.checkDataBounds =
			exports2.testWhich =
			exports2.setVoid =
			exports2.setUint8 =
			exports2.setUint64 =
			exports2.setUint32 =
			exports2.setUint16 =
			exports2.setText =
			exports2.setPointer =
			exports2.setInt8 =
			exports2.setInt64 =
			exports2.setInt32 =
			exports2.setInt16 =
			exports2.setFloat64 =
			exports2.setFloat32 =
			exports2.setBit =
			exports2.initList =
			exports2.initData =
			exports2.getVoid =
			exports2.getUint8 =
			exports2.getUint64 =
			exports2.getUint32 =
			exports2.getUint16 =
			exports2.getText =
			exports2.getStruct =
			exports2.getSize =
			exports2.getPointerSection =
			exports2.getPointerAs =
			exports2.getPointer =
			exports2.getList =
			exports2.getInt8 =
			exports2.getInt64 =
			exports2.getInt32 =
			exports2.getInt16 =
			exports2.getFloat64 =
			exports2.getFloat32 =
			exports2.getDataSection =
			exports2.getData =
			exports2.getBit =
			exports2.getAs =
			exports2.disown =
			exports2.adopt =
			exports2.resize =
			exports2.initStructAt =
			exports2.initStruct =
			exports2.Struct =
				void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var constants_1 = require_constants();
		var index_1 = require_types();
		var util_1 = require_util();
		var list_element_size_1 = require_list_element_size();
		var object_size_1 = require_object_size();
		var data_1 = require_data();
		var list_1 = require_list();
		var pointer_1 = require_pointer();
		var pointer_type_1 = require_pointer_type();
		var text_1 = require_text();
		var errors_1 = require_errors();
		var trace = debug_1.default("capnp:struct");
		trace("load");
		var TMP_WORD = new DataView(new ArrayBuffer(8));
		var Struct = class extends pointer_1.Pointer {
			/**
			 * Create a new pointer to a struct.
			 *
			 * @constructor {Struct}
			 * @param {Segment} segment The segment the pointer resides in.
			 * @param {number} byteOffset The offset from the beginning of the segment to the beginning of the pointer data.
			 * @param {any} [depthLimit=MAX_DEPTH] The nesting depth limit for this object.
			 * @param {number} [compositeIndex] If set, then this pointer is actually a reference to a composite list
			 * (`this._getPointerTargetType() === PointerType.LIST`), and this number is used as the index of the struct within
			 * the list. It is not valid to call `initStruct()` on a composite struct  the struct contents are initialized when
			 * the list pointer is initialized.
			 */
			constructor(segment, byteOffset, depthLimit = constants_1.MAX_DEPTH, compositeIndex) {
				super(segment, byteOffset, depthLimit);
				this._capnp.compositeIndex = compositeIndex;
				this._capnp.compositeList = compositeIndex !== void 0;
			}
			static toString() {
				return this._capnp.displayName;
			}
			toString() {
				return `Struct_${super.toString()}${this._capnp.compositeIndex === void 0 ? "" : `,ci:${this._capnp.compositeIndex}`}`;
			}
		};
		exports2.Struct = Struct;
		Struct._capnp = {
			displayName: "Struct",
		};
		Struct.getAs = getAs;
		Struct.getBit = getBit;
		Struct.getData = getData;
		Struct.getFloat32 = getFloat32;
		Struct.getFloat64 = getFloat64;
		Struct.getUint8 = getUint8;
		Struct.getUint16 = getUint16;
		Struct.getUint32 = getUint32;
		Struct.getUint64 = getUint64;
		Struct.getInt8 = getInt8;
		Struct.getInt16 = getInt16;
		Struct.getInt32 = getInt32;
		Struct.getInt64 = getInt64;
		Struct.getList = getList;
		Struct.getPointer = getPointer;
		Struct.getPointerAs = getPointerAs;
		Struct.getStruct = getStruct;
		Struct.getText = getText;
		Struct.initData = initData;
		Struct.initList = initList;
		Struct.initStruct = initStruct;
		Struct.initStructAt = initStructAt;
		Struct.setBit = setBit;
		Struct.setFloat32 = setFloat32;
		Struct.setFloat64 = setFloat64;
		Struct.setUint8 = setUint8;
		Struct.setUint16 = setUint16;
		Struct.setUint32 = setUint32;
		Struct.setUint64 = setUint64;
		Struct.setInt8 = setInt8;
		Struct.setInt16 = setInt16;
		Struct.setInt32 = setInt32;
		Struct.setInt64 = setInt64;
		Struct.setText = setText;
		Struct.testWhich = testWhich;
		function initStruct(size, s) {
			if (s._capnp.compositeIndex !== void 0) {
				throw new Error(util_1.format(errors_1.PTR_INIT_COMPOSITE_STRUCT, s));
			}
			pointer_1.erase(s);
			const c = s.segment.allocate(object_size_1.getByteLength(size));
			const res = pointer_1.initPointer(c.segment, c.byteOffset, s);
			pointer_1.setStructPointer(res.offsetWords, size, res.pointer);
		}
		exports2.initStruct = initStruct;
		function initStructAt(index, StructClass, p) {
			const s = getPointerAs(index, StructClass, p);
			initStruct(StructClass._capnp.size, s);
			return s;
		}
		exports2.initStructAt = initStructAt;
		function resize(dstSize, s) {
			const srcSize = getSize(s);
			const srcContent = pointer_1.getContent(s);
			const dstContent = s.segment.allocate(object_size_1.getByteLength(dstSize));
			dstContent.segment.copyWords(
				dstContent.byteOffset,
				srcContent.segment,
				srcContent.byteOffset,
				Math.min(
					object_size_1.getDataWordLength(srcSize),
					object_size_1.getDataWordLength(dstSize),
				),
			);
			const res = pointer_1.initPointer(dstContent.segment, dstContent.byteOffset, s);
			pointer_1.setStructPointer(res.offsetWords, dstSize, res.pointer);
			for (let i = 0; i < Math.min(srcSize.pointerLength, dstSize.pointerLength); i++) {
				const srcPtr = new pointer_1.Pointer(
					srcContent.segment,
					srcContent.byteOffset + srcSize.dataByteLength + i * 8,
				);
				if (pointer_1.isNull(srcPtr)) {
					continue;
				}
				const srcPtrTarget = pointer_1.followFars(srcPtr);
				const srcPtrContent = pointer_1.getContent(srcPtr);
				const dstPtr = new pointer_1.Pointer(
					dstContent.segment,
					dstContent.byteOffset + dstSize.dataByteLength + i * 8,
				);
				if (
					pointer_1.getTargetPointerType(srcPtr) === pointer_type_1.PointerType.LIST &&
					pointer_1.getTargetListElementSize(srcPtr) ===
						list_element_size_1.ListElementSize.COMPOSITE
				) {
					srcPtrContent.byteOffset -= 8;
				}
				const r = pointer_1.initPointer(
					srcPtrContent.segment,
					srcPtrContent.byteOffset,
					dstPtr,
				);
				const a = srcPtrTarget.segment.getUint8(srcPtrTarget.byteOffset) & 3;
				const b = srcPtrTarget.segment.getUint32(srcPtrTarget.byteOffset + 4);
				r.pointer.segment.setUint32(r.pointer.byteOffset, a | (r.offsetWords << 2));
				r.pointer.segment.setUint32(r.pointer.byteOffset + 4, b);
			}
			srcContent.segment.fillZeroWords(
				srcContent.byteOffset,
				object_size_1.getWordLength(srcSize),
			);
		}
		exports2.resize = resize;
		function adopt(src, s) {
			if (s._capnp.compositeIndex !== void 0) {
				throw new Error(util_1.format(errors_1.PTR_ADOPT_COMPOSITE_STRUCT, s));
			}
			pointer_1.Pointer.adopt(src, s);
		}
		exports2.adopt = adopt;
		function disown(s) {
			if (s._capnp.compositeIndex !== void 0) {
				throw new Error(util_1.format(errors_1.PTR_DISOWN_COMPOSITE_STRUCT, s));
			}
			return pointer_1.Pointer.disown(s);
		}
		exports2.disown = disown;
		function getAs(StructClass, s) {
			return new StructClass(
				s.segment,
				s.byteOffset,
				s._capnp.depthLimit,
				s._capnp.compositeIndex,
			);
		}
		exports2.getAs = getAs;
		function getBit(bitOffset, s, defaultMask) {
			const byteOffset = Math.floor(bitOffset / 8);
			const bitMask = 1 << bitOffset % 8;
			checkDataBounds(byteOffset, 1, s);
			const ds = getDataSection(s);
			const v = ds.segment.getUint8(ds.byteOffset + byteOffset);
			if (defaultMask === void 0) return (v & bitMask) !== 0;
			const defaultValue = defaultMask.getUint8(0);
			return ((v ^ defaultValue) & bitMask) !== 0;
		}
		exports2.getBit = getBit;
		function getData(index, s, defaultValue) {
			checkPointerBounds(index, s);
			const ps = getPointerSection(s);
			ps.byteOffset += index * 8;
			const l = new data_1.Data(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);
			if (pointer_1.isNull(l)) {
				if (defaultValue) {
					pointer_1.Pointer.copyFrom(defaultValue, l);
				} else {
					list_1.List.initList(list_element_size_1.ListElementSize.BYTE, 0, l);
				}
			}
			return l;
		}
		exports2.getData = getData;
		function getDataSection(s) {
			return pointer_1.getContent(s);
		}
		exports2.getDataSection = getDataSection;
		function getFloat32(byteOffset, s, defaultMask) {
			checkDataBounds(byteOffset, 4, s);
			const ds = getDataSection(s);
			if (defaultMask === void 0) {
				return ds.segment.getFloat32(ds.byteOffset + byteOffset);
			}
			const v =
				ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);
			TMP_WORD.setUint32(0, v, constants_1.NATIVE_LITTLE_ENDIAN);
			return TMP_WORD.getFloat32(0, constants_1.NATIVE_LITTLE_ENDIAN);
		}
		exports2.getFloat32 = getFloat32;
		function getFloat64(byteOffset, s, defaultMask) {
			checkDataBounds(byteOffset, 8, s);
			const ds = getDataSection(s);
			if (defaultMask !== void 0) {
				const lo =
					ds.segment.getUint32(ds.byteOffset + byteOffset) ^
					defaultMask.getUint32(0, true);
				const hi =
					ds.segment.getUint32(ds.byteOffset + byteOffset + 4) ^
					defaultMask.getUint32(4, true);
				TMP_WORD.setUint32(0, lo, constants_1.NATIVE_LITTLE_ENDIAN);
				TMP_WORD.setUint32(4, hi, constants_1.NATIVE_LITTLE_ENDIAN);
				return TMP_WORD.getFloat64(0, constants_1.NATIVE_LITTLE_ENDIAN);
			}
			return ds.segment.getFloat64(ds.byteOffset + byteOffset);
		}
		exports2.getFloat64 = getFloat64;
		function getInt16(byteOffset, s, defaultMask) {
			checkDataBounds(byteOffset, 2, s);
			const ds = getDataSection(s);
			if (defaultMask === void 0) {
				return ds.segment.getInt16(ds.byteOffset + byteOffset);
			}
			const v =
				ds.segment.getUint16(ds.byteOffset + byteOffset) ^ defaultMask.getUint16(0, true);
			TMP_WORD.setUint16(0, v, constants_1.NATIVE_LITTLE_ENDIAN);
			return TMP_WORD.getInt16(0, constants_1.NATIVE_LITTLE_ENDIAN);
		}
		exports2.getInt16 = getInt16;
		function getInt32(byteOffset, s, defaultMask) {
			checkDataBounds(byteOffset, 4, s);
			const ds = getDataSection(s);
			if (defaultMask === void 0) {
				return ds.segment.getInt32(ds.byteOffset + byteOffset);
			}
			const v =
				ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint16(0, true);
			TMP_WORD.setUint32(0, v, constants_1.NATIVE_LITTLE_ENDIAN);
			return TMP_WORD.getInt32(0, constants_1.NATIVE_LITTLE_ENDIAN);
		}
		exports2.getInt32 = getInt32;
		function getInt64(byteOffset, s, defaultMask) {
			checkDataBounds(byteOffset, 8, s);
			const ds = getDataSection(s);
			if (defaultMask === void 0) {
				return ds.segment.getInt64(ds.byteOffset + byteOffset);
			}
			const lo =
				ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);
			const hi =
				ds.segment.getUint32(ds.byteOffset + byteOffset + 4) ^
				defaultMask.getUint32(4, true);
			TMP_WORD.setUint32(0, lo, constants_1.NATIVE_LITTLE_ENDIAN);
			TMP_WORD.setUint32(4, hi, constants_1.NATIVE_LITTLE_ENDIAN);
			return new index_1.Int64(new Uint8Array(TMP_WORD.buffer.slice(0)));
		}
		exports2.getInt64 = getInt64;
		function getInt8(byteOffset, s, defaultMask) {
			checkDataBounds(byteOffset, 1, s);
			const ds = getDataSection(s);
			if (defaultMask === void 0) {
				return ds.segment.getInt8(ds.byteOffset + byteOffset);
			}
			const v = ds.segment.getUint8(ds.byteOffset + byteOffset) ^ defaultMask.getUint8(0);
			TMP_WORD.setUint8(0, v);
			return TMP_WORD.getInt8(0);
		}
		exports2.getInt8 = getInt8;
		function getList(index, ListClass, s, defaultValue) {
			checkPointerBounds(index, s);
			const ps = getPointerSection(s);
			ps.byteOffset += index * 8;
			const l = new ListClass(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);
			if (pointer_1.isNull(l)) {
				if (defaultValue) {
					pointer_1.Pointer.copyFrom(defaultValue, l);
				} else {
					list_1.List.initList(
						ListClass._capnp.size,
						0,
						l,
						ListClass._capnp.compositeSize,
					);
				}
			} else if (ListClass._capnp.compositeSize !== void 0) {
				const srcSize = pointer_1.getTargetCompositeListSize(l);
				const dstSize = ListClass._capnp.compositeSize;
				if (
					dstSize.dataByteLength > srcSize.dataByteLength ||
					dstSize.pointerLength > srcSize.pointerLength
				) {
					const srcContent = pointer_1.getContent(l);
					const srcLength = pointer_1.getTargetListLength(l);
					trace(
						"resizing composite list %s due to protocol upgrade, new size: %d",
						l,
						object_size_1.getByteLength(dstSize) * srcLength,
					);
					const dstContent = l.segment.allocate(
						object_size_1.getByteLength(dstSize) * srcLength + 8,
					);
					const res = pointer_1.initPointer(dstContent.segment, dstContent.byteOffset, l);
					pointer_1.setListPointer(
						res.offsetWords,
						ListClass._capnp.size,
						srcLength,
						res.pointer,
						dstSize,
					);
					pointer_1.setStructPointer(srcLength, dstSize, dstContent);
					dstContent.byteOffset += 8;
					for (let i = 0; i < srcLength; i++) {
						const srcElementOffset =
							srcContent.byteOffset + i * object_size_1.getByteLength(srcSize);
						const dstElementOffset =
							dstContent.byteOffset + i * object_size_1.getByteLength(dstSize);
						dstContent.segment.copyWords(
							dstElementOffset,
							srcContent.segment,
							srcElementOffset,
							object_size_1.getWordLength(srcSize),
						);
						for (let j = 0; j < srcSize.pointerLength; j++) {
							const srcPtr = new pointer_1.Pointer(
								srcContent.segment,
								srcElementOffset + srcSize.dataByteLength + j * 8,
							);
							const dstPtr = new pointer_1.Pointer(
								dstContent.segment,
								dstElementOffset + dstSize.dataByteLength + j * 8,
							);
							const srcPtrTarget = pointer_1.followFars(srcPtr);
							const srcPtrContent = pointer_1.getContent(srcPtr);
							if (
								pointer_1.getTargetPointerType(srcPtr) ===
									pointer_type_1.PointerType.LIST &&
								pointer_1.getTargetListElementSize(srcPtr) ===
									list_element_size_1.ListElementSize.COMPOSITE
							) {
								srcPtrContent.byteOffset -= 8;
							}
							const r = pointer_1.initPointer(
								srcPtrContent.segment,
								srcPtrContent.byteOffset,
								dstPtr,
							);
							const a = srcPtrTarget.segment.getUint8(srcPtrTarget.byteOffset) & 3;
							const b = srcPtrTarget.segment.getUint32(srcPtrTarget.byteOffset + 4);
							r.pointer.segment.setUint32(
								r.pointer.byteOffset,
								a | (r.offsetWords << 2),
							);
							r.pointer.segment.setUint32(r.pointer.byteOffset + 4, b);
						}
					}
					srcContent.segment.fillZeroWords(
						srcContent.byteOffset,
						object_size_1.getWordLength(srcSize) * srcLength,
					);
				}
			}
			return l;
		}
		exports2.getList = getList;
		function getPointer(index, s) {
			checkPointerBounds(index, s);
			const ps = getPointerSection(s);
			ps.byteOffset += index * 8;
			return new pointer_1.Pointer(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);
		}
		exports2.getPointer = getPointer;
		function getPointerAs(index, PointerClass, s) {
			checkPointerBounds(index, s);
			const ps = getPointerSection(s);
			ps.byteOffset += index * 8;
			return new PointerClass(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);
		}
		exports2.getPointerAs = getPointerAs;
		function getPointerSection(s) {
			const ps = pointer_1.getContent(s);
			ps.byteOffset += util_1.padToWord(getSize(s).dataByteLength);
			return ps;
		}
		exports2.getPointerSection = getPointerSection;
		function getSize(s) {
			if (s._capnp.compositeIndex !== void 0) {
				const c = pointer_1.getContent(s, true);
				c.byteOffset -= 8;
				return pointer_1.getStructSize(c);
			}
			return pointer_1.getTargetStructSize(s);
		}
		exports2.getSize = getSize;
		function getStruct(index, StructClass, s, defaultValue) {
			const t = getPointerAs(index, StructClass, s);
			if (pointer_1.isNull(t)) {
				if (defaultValue) {
					pointer_1.Pointer.copyFrom(defaultValue, t);
				} else {
					initStruct(StructClass._capnp.size, t);
				}
			} else {
				pointer_1.validate(pointer_type_1.PointerType.STRUCT, t);
				const ts = pointer_1.getTargetStructSize(t);
				if (
					ts.dataByteLength < StructClass._capnp.size.dataByteLength ||
					ts.pointerLength < StructClass._capnp.size.pointerLength
				) {
					trace("need to resize child struct %s", t);
					resize(StructClass._capnp.size, t);
				}
			}
			return t;
		}
		exports2.getStruct = getStruct;
		function getText(index, s, defaultValue) {
			const t = text_1.Text.fromPointer(getPointer(index, s));
			if (pointer_1.isNull(t) && defaultValue) t.set(0, defaultValue);
			return t.get(0);
		}
		exports2.getText = getText;
		function getUint16(byteOffset, s, defaultMask) {
			checkDataBounds(byteOffset, 2, s);
			const ds = getDataSection(s);
			if (defaultMask === void 0) {
				return ds.segment.getUint16(ds.byteOffset + byteOffset);
			}
			return (
				ds.segment.getUint16(ds.byteOffset + byteOffset) ^ defaultMask.getUint16(0, true)
			);
		}
		exports2.getUint16 = getUint16;
		function getUint32(byteOffset, s, defaultMask) {
			checkDataBounds(byteOffset, 4, s);
			const ds = getDataSection(s);
			if (defaultMask === void 0) {
				return ds.segment.getUint32(ds.byteOffset + byteOffset);
			}
			return (
				ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true)
			);
		}
		exports2.getUint32 = getUint32;
		function getUint64(byteOffset, s, defaultMask) {
			checkDataBounds(byteOffset, 8, s);
			const ds = getDataSection(s);
			if (defaultMask === void 0) {
				return ds.segment.getUint64(ds.byteOffset + byteOffset);
			}
			const lo =
				ds.segment.getUint32(ds.byteOffset + byteOffset) ^ defaultMask.getUint32(0, true);
			const hi =
				ds.segment.getUint32(ds.byteOffset + byteOffset + 4) ^
				defaultMask.getUint32(4, true);
			TMP_WORD.setUint32(0, lo, constants_1.NATIVE_LITTLE_ENDIAN);
			TMP_WORD.setUint32(4, hi, constants_1.NATIVE_LITTLE_ENDIAN);
			return new index_1.Uint64(new Uint8Array(TMP_WORD.buffer.slice(0)));
		}
		exports2.getUint64 = getUint64;
		function getUint8(byteOffset, s, defaultMask) {
			checkDataBounds(byteOffset, 1, s);
			const ds = getDataSection(s);
			if (defaultMask === void 0) {
				return ds.segment.getUint8(ds.byteOffset + byteOffset);
			}
			return ds.segment.getUint8(ds.byteOffset + byteOffset) ^ defaultMask.getUint8(0);
		}
		exports2.getUint8 = getUint8;
		function getVoid() {
			throw new Error(errors_1.INVARIANT_UNREACHABLE_CODE);
		}
		exports2.getVoid = getVoid;
		function initData(index, length, s) {
			checkPointerBounds(index, s);
			const ps = getPointerSection(s);
			ps.byteOffset += index * 8;
			const l = new data_1.Data(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);
			pointer_1.erase(l);
			list_1.List.initList(list_element_size_1.ListElementSize.BYTE, length, l);
			return l;
		}
		exports2.initData = initData;
		function initList(index, ListClass, length, s) {
			checkPointerBounds(index, s);
			const ps = getPointerSection(s);
			ps.byteOffset += index * 8;
			const l = new ListClass(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);
			pointer_1.erase(l);
			list_1.List.initList(ListClass._capnp.size, length, l, ListClass._capnp.compositeSize);
			return l;
		}
		exports2.initList = initList;
		function setBit(bitOffset, value, s, defaultMask) {
			const byteOffset = Math.floor(bitOffset / 8);
			const bitMask = 1 << bitOffset % 8;
			checkDataBounds(byteOffset, 1, s);
			const ds = getDataSection(s);
			const b = ds.segment.getUint8(ds.byteOffset + byteOffset);
			if (defaultMask !== void 0) {
				value = (defaultMask.getUint8(0) & bitMask) !== 0 ? !value : value;
			}
			ds.segment.setUint8(ds.byteOffset + byteOffset, value ? b | bitMask : b & ~bitMask);
		}
		exports2.setBit = setBit;
		function setFloat32(byteOffset, value, s, defaultMask) {
			checkDataBounds(byteOffset, 4, s);
			const ds = getDataSection(s);
			if (defaultMask !== void 0) {
				TMP_WORD.setFloat32(0, value, constants_1.NATIVE_LITTLE_ENDIAN);
				const v =
					TMP_WORD.getUint32(0, constants_1.NATIVE_LITTLE_ENDIAN) ^
					defaultMask.getUint32(0, true);
				ds.segment.setUint32(ds.byteOffset + byteOffset, v);
				return;
			}
			ds.segment.setFloat32(ds.byteOffset + byteOffset, value);
		}
		exports2.setFloat32 = setFloat32;
		function setFloat64(byteOffset, value, s, defaultMask) {
			checkDataBounds(byteOffset, 8, s);
			const ds = getDataSection(s);
			if (defaultMask !== void 0) {
				TMP_WORD.setFloat64(0, value, constants_1.NATIVE_LITTLE_ENDIAN);
				const lo =
					TMP_WORD.getUint32(0, constants_1.NATIVE_LITTLE_ENDIAN) ^
					defaultMask.getUint32(0, true);
				const hi =
					TMP_WORD.getUint32(4, constants_1.NATIVE_LITTLE_ENDIAN) ^
					defaultMask.getUint32(4, true);
				ds.segment.setUint32(ds.byteOffset + byteOffset, lo);
				ds.segment.setUint32(ds.byteOffset + byteOffset + 4, hi);
				return;
			}
			ds.segment.setFloat64(ds.byteOffset + byteOffset, value);
		}
		exports2.setFloat64 = setFloat64;
		function setInt16(byteOffset, value, s, defaultMask) {
			checkDataBounds(byteOffset, 2, s);
			const ds = getDataSection(s);
			if (defaultMask !== void 0) {
				TMP_WORD.setInt16(0, value, constants_1.NATIVE_LITTLE_ENDIAN);
				const v =
					TMP_WORD.getUint16(0, constants_1.NATIVE_LITTLE_ENDIAN) ^
					defaultMask.getUint16(0, true);
				ds.segment.setUint16(ds.byteOffset + byteOffset, v);
				return;
			}
			ds.segment.setInt16(ds.byteOffset + byteOffset, value);
		}
		exports2.setInt16 = setInt16;
		function setInt32(byteOffset, value, s, defaultMask) {
			checkDataBounds(byteOffset, 4, s);
			const ds = getDataSection(s);
			if (defaultMask !== void 0) {
				TMP_WORD.setInt32(0, value, constants_1.NATIVE_LITTLE_ENDIAN);
				const v =
					TMP_WORD.getUint32(0, constants_1.NATIVE_LITTLE_ENDIAN) ^
					defaultMask.getUint32(0, true);
				ds.segment.setUint32(ds.byteOffset + byteOffset, v);
				return;
			}
			ds.segment.setInt32(ds.byteOffset + byteOffset, value);
		}
		exports2.setInt32 = setInt32;
		function setInt64(byteOffset, value, s, defaultMask) {
			checkDataBounds(byteOffset, 8, s);
			const ds = getDataSection(s);
			if (defaultMask !== void 0) {
				for (let i = 0; i < 8; i++) {
					ds.segment.setUint8(
						ds.byteOffset + byteOffset + i,
						value.buffer[i] ^ defaultMask.getUint8(i),
					);
				}
				return;
			}
			ds.segment.setInt64(ds.byteOffset + byteOffset, value);
		}
		exports2.setInt64 = setInt64;
		function setInt8(byteOffset, value, s, defaultMask) {
			checkDataBounds(byteOffset, 1, s);
			const ds = getDataSection(s);
			if (defaultMask !== void 0) {
				TMP_WORD.setInt8(0, value);
				const v = TMP_WORD.getUint8(0) ^ defaultMask.getUint8(0);
				ds.segment.setUint8(ds.byteOffset + byteOffset, v);
				return;
			}
			ds.segment.setInt8(ds.byteOffset + byteOffset, value);
		}
		exports2.setInt8 = setInt8;
		function setPointer(index, value, s) {
			pointer_1.copyFrom(value, getPointer(index, s));
		}
		exports2.setPointer = setPointer;
		function setText(index, value, s) {
			text_1.Text.fromPointer(getPointer(index, s)).set(0, value);
		}
		exports2.setText = setText;
		function setUint16(byteOffset, value, s, defaultMask) {
			checkDataBounds(byteOffset, 2, s);
			const ds = getDataSection(s);
			if (defaultMask !== void 0) value ^= defaultMask.getUint16(0, true);
			ds.segment.setUint16(ds.byteOffset + byteOffset, value);
		}
		exports2.setUint16 = setUint16;
		function setUint32(byteOffset, value, s, defaultMask) {
			checkDataBounds(byteOffset, 4, s);
			const ds = getDataSection(s);
			if (defaultMask !== void 0) value ^= defaultMask.getUint32(0, true);
			ds.segment.setUint32(ds.byteOffset + byteOffset, value);
		}
		exports2.setUint32 = setUint32;
		function setUint64(byteOffset, value, s, defaultMask) {
			checkDataBounds(byteOffset, 8, s);
			const ds = getDataSection(s);
			if (defaultMask !== void 0) {
				for (let i = 0; i < 8; i++) {
					ds.segment.setUint8(
						ds.byteOffset + byteOffset + i,
						value.buffer[i] ^ defaultMask.getUint8(i),
					);
				}
				return;
			}
			ds.segment.setUint64(ds.byteOffset + byteOffset, value);
		}
		exports2.setUint64 = setUint64;
		function setUint8(byteOffset, value, s, defaultMask) {
			checkDataBounds(byteOffset, 1, s);
			const ds = getDataSection(s);
			if (defaultMask !== void 0) value ^= defaultMask.getUint8(0);
			ds.segment.setUint8(ds.byteOffset + byteOffset, value);
		}
		exports2.setUint8 = setUint8;
		function setVoid() {
			throw new Error(errors_1.INVARIANT_UNREACHABLE_CODE);
		}
		exports2.setVoid = setVoid;
		function testWhich(name, found, wanted, s) {
			if (found !== wanted) {
				throw new Error(
					util_1.format(errors_1.PTR_INVALID_UNION_ACCESS, s, name, found, wanted),
				);
			}
		}
		exports2.testWhich = testWhich;
		function checkDataBounds(byteOffset, byteLength, s) {
			const dataByteLength = getSize(s).dataByteLength;
			if (byteOffset < 0 || byteLength < 0 || byteOffset + byteLength > dataByteLength) {
				throw new Error(
					util_1.format(
						errors_1.PTR_STRUCT_DATA_OUT_OF_BOUNDS,
						s,
						byteLength,
						byteOffset,
						dataByteLength,
					),
				);
			}
		}
		exports2.checkDataBounds = checkDataBounds;
		function checkPointerBounds(index, s) {
			const pointerLength = getSize(s).pointerLength;
			if (index < 0 || index >= pointerLength) {
				throw new Error(
					util_1.format(
						errors_1.PTR_STRUCT_POINTER_OUT_OF_BOUNDS,
						s,
						index,
						pointerLength,
					),
				);
			}
		}
		exports2.checkPointerBounds = checkPointerBounds;
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/text-list.js
var require_text_list = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/text-list.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.TextList = void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var list_element_size_1 = require_list_element_size();
		var list_1 = require_list();
		var text_1 = require_text();
		var pointer_1 = require_pointer();
		var trace = debug_1.default("capnp:list:composite");
		trace("load");
		var TextList = class extends list_1.List {
			get(index) {
				const c = pointer_1.getContent(this);
				c.byteOffset += index * 8;
				return text_1.Text.fromPointer(c).get(0);
			}
			set(index, value) {
				const c = pointer_1.getContent(this);
				c.byteOffset += index * 8;
				text_1.Text.fromPointer(c).set(0, value);
			}
			toString() {
				return `Text_${super.toString()}`;
			}
		};
		exports2.TextList = TextList;
		TextList._capnp = {
			displayName: "List<Text>",
			size: list_element_size_1.ListElementSize.POINTER,
		};
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/uint8-list.js
var require_uint8_list = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/uint8-list.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.Uint8List = void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var list_element_size_1 = require_list_element_size();
		var list_1 = require_list();
		var pointer_1 = require_pointer();
		var trace = debug_1.default("capnp:list:composite");
		trace("load");
		var Uint8List = class extends list_1.List {
			get(index) {
				const c = pointer_1.getContent(this);
				return c.segment.getUint8(c.byteOffset + index);
			}
			set(index, value) {
				const c = pointer_1.getContent(this);
				c.segment.setUint8(c.byteOffset + index, value);
			}
			toString() {
				return `Uint8_${super.toString()}`;
			}
		};
		exports2.Uint8List = Uint8List;
		Uint8List._capnp = {
			displayName: "List<Uint8>",
			size: list_element_size_1.ListElementSize.BYTE,
		};
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/uint16-list.js
var require_uint16_list = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/uint16-list.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.Uint16List = void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var list_element_size_1 = require_list_element_size();
		var list_1 = require_list();
		var pointer_1 = require_pointer();
		var trace = debug_1.default("capnp:list:composite");
		trace("load");
		var Uint16List = class extends list_1.List {
			get(index) {
				const c = pointer_1.getContent(this);
				return c.segment.getUint16(c.byteOffset + index * 2);
			}
			set(index, value) {
				const c = pointer_1.getContent(this);
				c.segment.setUint16(c.byteOffset + index * 2, value);
			}
			toString() {
				return `Uint16_${super.toString()}`;
			}
		};
		exports2.Uint16List = Uint16List;
		Uint16List._capnp = {
			displayName: "List<Uint16>",
			size: list_element_size_1.ListElementSize.BYTE_2,
		};
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/uint32-list.js
var require_uint32_list = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/uint32-list.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.Uint32List = void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var list_element_size_1 = require_list_element_size();
		var list_1 = require_list();
		var pointer_1 = require_pointer();
		var trace = debug_1.default("capnp:list:composite");
		trace("load");
		var Uint32List = class extends list_1.List {
			get(index) {
				const c = pointer_1.getContent(this);
				return c.segment.getUint32(c.byteOffset + index * 4);
			}
			set(index, value) {
				const c = pointer_1.getContent(this);
				c.segment.setUint32(c.byteOffset + index * 4, value);
			}
			toString() {
				return `Uint32_${super.toString()}`;
			}
		};
		exports2.Uint32List = Uint32List;
		Uint32List._capnp = {
			displayName: "List<Uint32>",
			size: list_element_size_1.ListElementSize.BYTE_4,
		};
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/uint64-list.js
var require_uint64_list = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/uint64-list.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.Uint64List = void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var list_element_size_1 = require_list_element_size();
		var list_1 = require_list();
		var pointer_1 = require_pointer();
		var trace = debug_1.default("capnp:list:composite");
		trace("load");
		var Uint64List = class extends list_1.List {
			get(index) {
				const c = pointer_1.getContent(this);
				return c.segment.getUint64(c.byteOffset + index * 8);
			}
			set(index, value) {
				const c = pointer_1.getContent(this);
				c.segment.setUint64(c.byteOffset + index * 8, value);
			}
			toString() {
				return `Uint64_${super.toString()}`;
			}
		};
		exports2.Uint64List = Uint64List;
		Uint64List._capnp = {
			displayName: "List<Uint64>",
			size: list_element_size_1.ListElementSize.BYTE_8,
		};
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/void.js
var require_void = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/void.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.VOID = exports2.Void = void 0;
		var object_size_1 = require_object_size();
		var struct_1 = require_struct();
		var Void = class extends struct_1.Struct {};
		exports2.Void = Void;
		Void._capnp = {
			displayName: "Void",
			id: "0",
			size: new object_size_1.ObjectSize(0, 0),
		};
		exports2.VOID = void 0;
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/void-list.js
var require_void_list = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/void-list.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.VoidList = void 0;
		var pointer_list_1 = require_pointer_list();
		var void_1 = require_void();
		exports2.VoidList = pointer_list_1.PointerList(void_1.Void);
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/index.js
var require_pointers = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/pointers/index.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.VoidList =
			exports2.VOID =
			exports2.Void =
			exports2.Uint64List =
			exports2.Uint32List =
			exports2.Uint16List =
			exports2.Uint8List =
			exports2.TextList =
			exports2.Text =
			exports2.Struct =
			exports2.Pointer =
			exports2.PointerType =
			exports2.PointerList =
			exports2.Orphan =
			exports2.List =
			exports2.InterfaceList =
			exports2.Interface =
			exports2.Int64List =
			exports2.Int32List =
			exports2.Int16List =
			exports2.Int8List =
			exports2.Float64List =
			exports2.Float32List =
			exports2.DataList =
			exports2.Data =
			exports2.CompositeList =
			exports2.BoolList =
			exports2.AnyPointerList =
				void 0;
		var any_pointer_list_1 = require_any_pointer_list();
		Object.defineProperty(exports2, "AnyPointerList", {
			enumerable: true,
			get: function () {
				return any_pointer_list_1.AnyPointerList;
			},
		});
		var bool_list_1 = require_bool_list();
		Object.defineProperty(exports2, "BoolList", {
			enumerable: true,
			get: function () {
				return bool_list_1.BoolList;
			},
		});
		var composite_list_1 = require_composite_list();
		Object.defineProperty(exports2, "CompositeList", {
			enumerable: true,
			get: function () {
				return composite_list_1.CompositeList;
			},
		});
		var data_1 = require_data();
		Object.defineProperty(exports2, "Data", {
			enumerable: true,
			get: function () {
				return data_1.Data;
			},
		});
		var data_list_1 = require_data_list();
		Object.defineProperty(exports2, "DataList", {
			enumerable: true,
			get: function () {
				return data_list_1.DataList;
			},
		});
		var float32_list_1 = require_float32_list();
		Object.defineProperty(exports2, "Float32List", {
			enumerable: true,
			get: function () {
				return float32_list_1.Float32List;
			},
		});
		var float64_list_1 = require_float64_list();
		Object.defineProperty(exports2, "Float64List", {
			enumerable: true,
			get: function () {
				return float64_list_1.Float64List;
			},
		});
		var int8_list_1 = require_int8_list();
		Object.defineProperty(exports2, "Int8List", {
			enumerable: true,
			get: function () {
				return int8_list_1.Int8List;
			},
		});
		var int16_list_1 = require_int16_list();
		Object.defineProperty(exports2, "Int16List", {
			enumerable: true,
			get: function () {
				return int16_list_1.Int16List;
			},
		});
		var int32_list_1 = require_int32_list();
		Object.defineProperty(exports2, "Int32List", {
			enumerable: true,
			get: function () {
				return int32_list_1.Int32List;
			},
		});
		var int64_list_1 = require_int64_list();
		Object.defineProperty(exports2, "Int64List", {
			enumerable: true,
			get: function () {
				return int64_list_1.Int64List;
			},
		});
		var interface_1 = require_interface();
		Object.defineProperty(exports2, "Interface", {
			enumerable: true,
			get: function () {
				return interface_1.Interface;
			},
		});
		var interface_list_1 = require_interface_list();
		Object.defineProperty(exports2, "InterfaceList", {
			enumerable: true,
			get: function () {
				return interface_list_1.InterfaceList;
			},
		});
		var list_1 = require_list();
		Object.defineProperty(exports2, "List", {
			enumerable: true,
			get: function () {
				return list_1.List;
			},
		});
		var orphan_1 = require_orphan();
		Object.defineProperty(exports2, "Orphan", {
			enumerable: true,
			get: function () {
				return orphan_1.Orphan;
			},
		});
		var pointer_list_1 = require_pointer_list();
		Object.defineProperty(exports2, "PointerList", {
			enumerable: true,
			get: function () {
				return pointer_list_1.PointerList;
			},
		});
		var pointer_type_1 = require_pointer_type();
		Object.defineProperty(exports2, "PointerType", {
			enumerable: true,
			get: function () {
				return pointer_type_1.PointerType;
			},
		});
		var pointer_1 = require_pointer();
		Object.defineProperty(exports2, "Pointer", {
			enumerable: true,
			get: function () {
				return pointer_1.Pointer;
			},
		});
		var struct_1 = require_struct();
		Object.defineProperty(exports2, "Struct", {
			enumerable: true,
			get: function () {
				return struct_1.Struct;
			},
		});
		var text_1 = require_text();
		Object.defineProperty(exports2, "Text", {
			enumerable: true,
			get: function () {
				return text_1.Text;
			},
		});
		var text_list_1 = require_text_list();
		Object.defineProperty(exports2, "TextList", {
			enumerable: true,
			get: function () {
				return text_list_1.TextList;
			},
		});
		var uint8_list_1 = require_uint8_list();
		Object.defineProperty(exports2, "Uint8List", {
			enumerable: true,
			get: function () {
				return uint8_list_1.Uint8List;
			},
		});
		var uint16_list_1 = require_uint16_list();
		Object.defineProperty(exports2, "Uint16List", {
			enumerable: true,
			get: function () {
				return uint16_list_1.Uint16List;
			},
		});
		var uint32_list_1 = require_uint32_list();
		Object.defineProperty(exports2, "Uint32List", {
			enumerable: true,
			get: function () {
				return uint32_list_1.Uint32List;
			},
		});
		var uint64_list_1 = require_uint64_list();
		Object.defineProperty(exports2, "Uint64List", {
			enumerable: true,
			get: function () {
				return uint64_list_1.Uint64List;
			},
		});
		var void_1 = require_void();
		Object.defineProperty(exports2, "Void", {
			enumerable: true,
			get: function () {
				return void_1.Void;
			},
		});
		Object.defineProperty(exports2, "VOID", {
			enumerable: true,
			get: function () {
				return void_1.VOID;
			},
		});
		var void_list_1 = require_void_list();
		Object.defineProperty(exports2, "VoidList", {
			enumerable: true,
			get: function () {
				return void_list_1.VoidList;
			},
		});
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/segment.js
var require_segment = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/segment.js"(
		exports2,
	) {
		"use strict";
		var _a;
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.Segment = void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var constants_1 = require_constants();
		var errors_1 = require_errors();
		var types_1 = require_types();
		var util_1 = require_util();
		var pointers_1 = require_pointers();
		var trace = debug_1.default("capnp:segment");
		trace("load");
		var Segment = class {
			constructor(id, message, buffer, byteLength = 0) {
				this[_a] = "Segment";
				this.id = id;
				this.message = message;
				this.buffer = buffer;
				this._dv = new DataView(buffer);
				this.byteOffset = 0;
				this.byteLength = byteLength;
			}
			/**
			 * Attempt to allocate the requested number of bytes in this segment. If this segment is full this method will return
			 * a pointer to freshly allocated space in another segment from the same message.
			 *
			 * @param {number} byteLength The number of bytes to allocate, will be rounded up to the nearest word.
			 * @returns {Pointer} A pointer to the newly allocated space.
			 */
			allocate(byteLength) {
				trace("allocate(%d)", byteLength);
				let segment = this;
				byteLength = util_1.padToWord(byteLength);
				if (byteLength > constants_1.MAX_SEGMENT_LENGTH - 8) {
					throw new Error(util_1.format(errors_1.SEG_SIZE_OVERFLOW, byteLength));
				}
				if (!segment.hasCapacity(byteLength)) {
					segment = segment.message.allocateSegment(byteLength);
				}
				const byteOffset = segment.byteLength;
				segment.byteLength = segment.byteLength + byteLength;
				trace(
					"Allocated %x bytes in %s (requested segment: %s).",
					byteLength,
					this,
					segment,
				);
				return new pointers_1.Pointer(segment, byteOffset);
			}
			/**
			 * Quickly copy a word (8 bytes) from `srcSegment` into this one at the given offset.
			 *
			 * @param {number} byteOffset The offset to write the word to.
			 * @param {Segment} srcSegment The segment to copy the word from.
			 * @param {number} srcByteOffset The offset from the start of `srcSegment` to copy from.
			 * @returns {void}
			 */
			copyWord(byteOffset, srcSegment, srcByteOffset) {
				const value = srcSegment._dv.getFloat64(
					srcByteOffset,
					constants_1.NATIVE_LITTLE_ENDIAN,
				);
				this._dv.setFloat64(byteOffset, value, constants_1.NATIVE_LITTLE_ENDIAN);
			}
			/**
			 * Quickly copy words from `srcSegment` into this one.
			 *
			 * @param {number} byteOffset The offset to start copying into.
			 * @param {Segment} srcSegment The segment to copy from.
			 * @param {number} srcByteOffset The start offset to copy from.
			 * @param {number} wordLength The number of words to copy.
			 * @returns {void}
			 */
			copyWords(byteOffset, srcSegment, srcByteOffset, wordLength) {
				const dst = new Float64Array(this.buffer, byteOffset, wordLength);
				const src = new Float64Array(srcSegment.buffer, srcByteOffset, wordLength);
				dst.set(src);
			}
			/**
			 * Quickly fill a number of words in the buffer with zeroes.
			 *
			 * @param {number} byteOffset The first byte to set to zero.
			 * @param {number} wordLength The number of words (not bytes!) to zero out.
			 * @returns {void}
			 */
			fillZeroWords(byteOffset, wordLength) {
				new Float64Array(this.buffer, byteOffset, wordLength).fill(0);
			}
			/** WARNING: This function is not yet implemented. */
			getBigInt64(byteOffset, littleEndian) {
				throw new Error(util_1.format(errors_1.NOT_IMPLEMENTED, byteOffset, littleEndian));
			}
			/** WARNING: This function is not yet implemented. */
			getBigUint64(byteOffset, littleEndian) {
				throw new Error(util_1.format(errors_1.NOT_IMPLEMENTED, byteOffset, littleEndian));
			}
			/**
			 * Get the total number of bytes available in this segment (the size of its underlying buffer).
			 *
			 * @returns {number} The total number of bytes this segment can hold.
			 */
			getCapacity() {
				return this.buffer.byteLength;
			}
			/**
			 * Read a float32 value out of this segment.
			 *
			 * @param {number} byteOffset The offset in bytes to the value.
			 * @returns {number} The value.
			 */
			getFloat32(byteOffset) {
				return this._dv.getFloat32(byteOffset, true);
			}
			/**
			 * Read a float64 value out of this segment.
			 *
			 * @param {number} byteOffset The offset in bytes to the value.
			 * @returns {number} The value.
			 */
			getFloat64(byteOffset) {
				return this._dv.getFloat64(byteOffset, true);
			}
			/**
			 * Read an int16 value out of this segment.
			 *
			 * @param {number} byteOffset The offset in bytes to the value.
			 * @returns {number} The value.
			 */
			getInt16(byteOffset) {
				return this._dv.getInt16(byteOffset, true);
			}
			/**
			 * Read an int32 value out of this segment.
			 *
			 * @param {number} byteOffset The offset in bytes to the value.
			 * @returns {number} The value.
			 */
			getInt32(byteOffset) {
				return this._dv.getInt32(byteOffset, true);
			}
			/**
			 * Read an int64 value out of this segment.
			 *
			 * @param {number} byteOffset The offset in bytes to the value.
			 * @returns {number} The value.
			 */
			getInt64(byteOffset) {
				return new types_1.Int64(
					new Uint8Array(this.buffer.slice(byteOffset, byteOffset + 8)),
				);
			}
			/**
			 * Read an int8 value out of this segment.
			 *
			 * @param {number} byteOffset The offset in bytes to the value.
			 * @returns {number} The value.
			 */
			getInt8(byteOffset) {
				return this._dv.getInt8(byteOffset);
			}
			/**
			 * Read a uint16 value out of this segment.
			 *
			 * @param {number} byteOffset The offset in bytes to the value.
			 * @returns {number} The value.
			 */
			getUint16(byteOffset) {
				return this._dv.getUint16(byteOffset, true);
			}
			/**
			 * Read a uint32 value out of this segment.
			 *
			 * @param {number} byteOffset The offset in bytes to the value.
			 * @returns {number} The value.
			 */
			getUint32(byteOffset) {
				return this._dv.getUint32(byteOffset, true);
			}
			/**
			 * Read a uint8 value out of this segment.
			 * NOTE: this does not copy the memory region, so updates to the underlying buffer will affect the Uint64 value!
			 *
			 * @param {number} byteOffset The offset in bytes to the value.
			 * @returns {number} The value.
			 */
			getUint64(byteOffset) {
				return new types_1.Uint64(
					new Uint8Array(this.buffer.slice(byteOffset, byteOffset + 8)),
				);
			}
			/**
			 * Read a uint8 value out of this segment.
			 *
			 * @param {number} byteOffset The offset in bytes to the value.
			 * @returns {number} The value.
			 */
			getUint8(byteOffset) {
				return this._dv.getUint8(byteOffset);
			}
			hasCapacity(byteLength) {
				trace("hasCapacity(%d)", byteLength);
				return this.buffer.byteLength - this.byteLength >= byteLength;
			}
			/**
			 * Quickly check the word at the given offset to see if it is equal to zero.
			 *
			 * PERF_V8: Fastest way to do this is by reading the whole word as a `number` (float64) in the _native_ endian format
			 * and see if it's zero.
			 *
			 * Benchmark: http://jsben.ch/#/Pjooc
			 *
			 * @param {number} byteOffset The offset to the word.
			 * @returns {boolean} `true` if the word is zero.
			 */
			isWordZero(byteOffset) {
				return this._dv.getFloat64(byteOffset, constants_1.NATIVE_LITTLE_ENDIAN) === 0;
			}
			/**
			 * Swap out this segment's underlying buffer with a new one. It's assumed that the new buffer has the same content but
			 * more free space, otherwise all existing pointers to this segment will be hilariously broken.
			 *
			 * @param {ArrayBuffer} buffer The new buffer to use.
			 * @returns {void}
			 */
			replaceBuffer(buffer) {
				trace("replaceBuffer(%p)", buffer);
				if (this.buffer === buffer) return;
				if (buffer.byteLength < this.byteLength) {
					throw new Error(errors_1.SEG_REPLACEMENT_BUFFER_TOO_SMALL);
				}
				this._dv = new DataView(buffer);
				this.buffer = buffer;
			}
			/** WARNING: This function is not yet implemented.  */
			setBigInt64(byteOffset, value, littleEndian) {
				throw new Error(
					util_1.format(errors_1.NOT_IMPLEMENTED, byteOffset, value, littleEndian),
				);
			}
			/** WARNING: This function is not yet implemented.  */
			setBigUint64(byteOffset, value, littleEndian) {
				throw new Error(
					util_1.format(errors_1.NOT_IMPLEMENTED, byteOffset, value, littleEndian),
				);
			}
			/**
			 * Write a float32 value to the specified offset.
			 *
			 * @param {number} byteOffset The offset from the beginning of the buffer.
			 * @param {number} val The value to store.
			 * @returns {void}
			 */
			setFloat32(byteOffset, val) {
				this._dv.setFloat32(byteOffset, val, true);
			}
			/**
			 * Write an float64 value to the specified offset.
			 *
			 * @param {number} byteOffset The offset from the beginning of the buffer.
			 * @param {number} val The value to store.
			 * @returns {void}
			 */
			setFloat64(byteOffset, val) {
				this._dv.setFloat64(byteOffset, val, true);
			}
			/**
			 * Write an int16 value to the specified offset.
			 *
			 * @param {number} byteOffset The offset from the beginning of the buffer.
			 * @param {number} val The value to store.
			 * @returns {void}
			 */
			setInt16(byteOffset, val) {
				this._dv.setInt16(byteOffset, val, true);
			}
			/**
			 * Write an int32 value to the specified offset.
			 *
			 * @param {number} byteOffset The offset from the beginning of the buffer.
			 * @param {number} val The value to store.
			 * @returns {void}
			 */
			setInt32(byteOffset, val) {
				this._dv.setInt32(byteOffset, val, true);
			}
			/**
			 * Write an int8 value to the specified offset.
			 *
			 * @param {number} byteOffset The offset from the beginning of the buffer.
			 * @param {number} val The value to store.
			 * @returns {void}
			 */
			setInt8(byteOffset, val) {
				this._dv.setInt8(byteOffset, val);
			}
			/**
			 * Write an int64 value to the specified offset.
			 *
			 * @param {number} byteOffset The offset from the beginning of the buffer.
			 * @param {Int64} val The value to store.
			 * @returns {void}
			 */
			setInt64(byteOffset, val) {
				this._dv.setUint8(byteOffset, val.buffer[0]);
				this._dv.setUint8(byteOffset + 1, val.buffer[1]);
				this._dv.setUint8(byteOffset + 2, val.buffer[2]);
				this._dv.setUint8(byteOffset + 3, val.buffer[3]);
				this._dv.setUint8(byteOffset + 4, val.buffer[4]);
				this._dv.setUint8(byteOffset + 5, val.buffer[5]);
				this._dv.setUint8(byteOffset + 6, val.buffer[6]);
				this._dv.setUint8(byteOffset + 7, val.buffer[7]);
			}
			/**
			 * Write a uint16 value to the specified offset.
			 *
			 * @param {number} byteOffset The offset from the beginning of the buffer.
			 * @param {number} val The value to store.
			 * @returns {void}
			 */
			setUint16(byteOffset, val) {
				this._dv.setUint16(byteOffset, val, true);
			}
			/**
			 * Write a uint32 value to the specified offset.
			 *
			 * @param {number} byteOffset The offset from the beginning of the buffer.
			 * @param {number} val The value to store.
			 * @returns {void}
			 */
			setUint32(byteOffset, val) {
				this._dv.setUint32(byteOffset, val, true);
			}
			/**
			 * Write a uint64 value to the specified offset.
			 * TODO: benchmark other ways to perform this write operation.
			 *
			 * @param {number} byteOffset The offset from the beginning of the buffer.
			 * @param {Uint64} val The value to store.
			 * @returns {void}
			 */
			setUint64(byteOffset, val) {
				this._dv.setUint8(byteOffset + 0, val.buffer[0]);
				this._dv.setUint8(byteOffset + 1, val.buffer[1]);
				this._dv.setUint8(byteOffset + 2, val.buffer[2]);
				this._dv.setUint8(byteOffset + 3, val.buffer[3]);
				this._dv.setUint8(byteOffset + 4, val.buffer[4]);
				this._dv.setUint8(byteOffset + 5, val.buffer[5]);
				this._dv.setUint8(byteOffset + 6, val.buffer[6]);
				this._dv.setUint8(byteOffset + 7, val.buffer[7]);
			}
			/**
			 * Write a uint8 (byte) value to the specified offset.
			 *
			 * @param {number} byteOffset The offset from the beginning of the buffer.
			 * @param {number} val The value to store.
			 * @returns {void}
			 */
			setUint8(byteOffset, val) {
				this._dv.setUint8(byteOffset, val);
			}
			/**
			 * Write a zero word (8 bytes) to the specified offset. This is slightly faster than calling `setUint64` or
			 * `setFloat64` with a zero value.
			 *
			 * Benchmark: http://jsben.ch/#/dUdPI
			 *
			 * @param {number} byteOffset The offset of the word to set to zero.
			 * @returns {void}
			 */
			setWordZero(byteOffset) {
				this._dv.setFloat64(byteOffset, 0, constants_1.NATIVE_LITTLE_ENDIAN);
			}
			toString() {
				return util_1.format(
					"Segment_id:%d,off:%a,len:%a,cap:%a",
					this.id,
					this.byteLength,
					this.byteOffset,
					this.buffer.byteLength,
				);
			}
		};
		exports2.Segment = Segment;
		_a = Symbol.toStringTag;
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/message.js
var require_message = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/message.js"(
		exports2,
	) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.getStreamFrame =
			exports2.toPackedArrayBuffer =
			exports2.toArrayBuffer =
			exports2.setRoot =
			exports2.readRawPointer =
			exports2.initRoot =
			exports2.getSegment =
			exports2.getRoot =
			exports2.dump =
			exports2.allocateSegment =
			exports2.preallocateSegments =
			exports2.getFramedSegments =
			exports2.initMessage =
			exports2.Message =
				void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		var debug_1 = tslib_1.__importDefault(require_src());
		var constants_1 = require_constants();
		var errors_1 = require_errors();
		var util_1 = require_util();
		var arena_1 = require_arena2();
		var packing_1 = require_packing();
		var pointers_1 = require_pointers();
		var segment_1 = require_segment();
		var pointer_1 = require_pointer();
		var struct_1 = require_struct();
		var trace = debug_1.default("capnp:message");
		trace("load");
		var Message = class {
			/**
			 * A Cap'n Proto message.
			 *
			 * SECURITY WARNING: In nodejs do not pass a Buffer's internal array buffer into this constructor. Pass the buffer
			 * directly and everything will be fine. If not, your message will potentially be initialized with random memory
			 * contents!
			 *
			 * The constructor method creates a new Message, optionally using a provided arena for segment allocation, or a buffer
			 * to read from.
			 *
			 * @constructor {Message}
			 *
			 * @param {AnyArena|ArrayBufferView|ArrayBuffer} [src] The source for the message.
			 * A value of `undefined` will cause the message to initialize with a single segment arena only big enough for the
			 * root pointer; it will expand as you go. This is a reasonable choice for most messages.
			 *
			 * Passing an arena will cause the message to use that arena for its segment allocation. Contents will be accepted
			 * as-is.
			 *
			 * Passing an array buffer view (like `DataView`, `Uint8Array` or `Buffer`) will create a **copy** of the source
			 * buffer; beware of the potential performance cost!
			 *
			 * @param {boolean} [packed] Whether or not the message is packed. If `true` (the default), the message will be
			 * unpacked.
			 *
			 * @param {boolean} [singleSegment] If true, `src` will be treated as a message consisting of a single segment without
			 * a framing header.
			 *
			 */
			constructor(src, packed = true, singleSegment = false) {
				this._capnp = initMessage(src, packed, singleSegment);
				if (src && !isAnyArena(src)) preallocateSegments(this);
				trace("new %s", this);
			}
			allocateSegment(byteLength) {
				return allocateSegment(byteLength, this);
			}
			/**
			 * Create a pretty-printed string dump of this message; incredibly useful for debugging.
			 *
			 * WARNING: Do not call this method on large messages!
			 *
			 * @returns {string} A big steaming pile of pretty hex digits.
			 */
			dump() {
				return dump(this);
			}
			/**
			 * Get a struct pointer for the root of this message. This is primarily used when reading a message; it will not
			 * overwrite existing data.
			 *
			 * @template T
			 * @param {StructCtor<T>} RootStruct The struct type to use as the root.
			 * @returns {T} A struct representing the root of the message.
			 */
			getRoot(RootStruct) {
				return getRoot(RootStruct, this);
			}
			/**
			 * Get a segment by its id.
			 *
			 * This will lazily allocate the first segment if it doesn't already exist.
			 *
			 * @param {number} id The segment id.
			 * @returns {Segment} The requested segment.
			 */
			getSegment(id) {
				return getSegment(id, this);
			}
			/**
			 * Initialize a new message using the provided struct type as the root.
			 *
			 * @template T
			 * @param {StructCtor<T>} RootStruct The struct type to use as the root.
			 * @returns {T} An initialized struct pointing to the root of the message.
			 */
			initRoot(RootStruct) {
				return initRoot(RootStruct, this);
			}
			/**
			 * Set the root of the message to a copy of the given pointer. Used internally
			 * to make copies of pointers for default values.
			 *
			 * @param {Pointer} src The source pointer to copy.
			 * @returns {void}
			 */
			setRoot(src) {
				setRoot(src, this);
			}
			/**
			 * Combine the contents of this message's segments into a single array buffer and prepend a stream framing header
			 * containing information about the following segment data.
			 *
			 * @returns {ArrayBuffer} An ArrayBuffer with the contents of this message.
			 */
			toArrayBuffer() {
				return toArrayBuffer(this);
			}
			/**
			 * Like `toArrayBuffer()`, but also applies the packing algorithm to the output. This is typically what you want to
			 * use if you're sending the message over a network link or other slow I/O interface where size matters.
			 *
			 * @returns {ArrayBuffer} A packed message.
			 */
			toPackedArrayBuffer() {
				return toPackedArrayBuffer(this);
			}
			toString() {
				return `Message_arena:${this._capnp.arena}`;
			}
		};
		exports2.Message = Message;
		Message.allocateSegment = allocateSegment;
		Message.dump = dump;
		Message.getRoot = getRoot;
		Message.getSegment = getSegment;
		Message.initRoot = initRoot;
		Message.readRawPointer = readRawPointer;
		Message.toArrayBuffer = toArrayBuffer;
		Message.toPackedArrayBuffer = toPackedArrayBuffer;
		function initMessage(src, packed = true, singleSegment = false) {
			if (src === void 0) {
				return {
					arena: new arena_1.SingleSegmentArena(),
					segments: [],
					traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT,
				};
			}
			if (isAnyArena(src)) {
				return {
					arena: src,
					segments: [],
					traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT,
				};
			}
			let buf = src;
			if (isArrayBufferView(buf)) {
				buf = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
			}
			if (packed) buf = packing_1.unpack(buf);
			if (singleSegment) {
				return {
					arena: new arena_1.SingleSegmentArena(buf),
					segments: [],
					traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT,
				};
			}
			return {
				arena: new arena_1.MultiSegmentArena(getFramedSegments(buf)),
				segments: [],
				traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT,
			};
		}
		exports2.initMessage = initMessage;
		function getFramedSegments(message) {
			const dv = new DataView(message);
			const segmentCount = dv.getUint32(0, true) + 1;
			const segments = new Array(segmentCount);
			trace("reading %d framed segments from stream", segmentCount);
			let byteOffset = 4 + segmentCount * 4;
			byteOffset += byteOffset % 8;
			if (byteOffset + segmentCount * 4 > message.byteLength) {
				throw new Error(errors_1.MSG_INVALID_FRAME_HEADER);
			}
			for (let i = 0; i < segmentCount; i++) {
				const byteLength = dv.getUint32(4 + i * 4, true) * 8;
				if (byteOffset + byteLength > message.byteLength) {
					throw new Error(errors_1.MSG_INVALID_FRAME_HEADER);
				}
				segments[i] = message.slice(byteOffset, byteOffset + byteLength);
				byteOffset += byteLength;
			}
			return segments;
		}
		exports2.getFramedSegments = getFramedSegments;
		function preallocateSegments(m) {
			const numSegments = arena_1.Arena.getNumSegments(m._capnp.arena);
			if (numSegments < 1) throw new Error(errors_1.MSG_NO_SEGMENTS_IN_ARENA);
			m._capnp.segments = new Array(numSegments);
			for (let i = 0; i < numSegments; i++) {
				const buffer = arena_1.Arena.getBuffer(i, m._capnp.arena);
				const segment = new segment_1.Segment(i, m, buffer, buffer.byteLength);
				m._capnp.segments[i] = segment;
			}
		}
		exports2.preallocateSegments = preallocateSegments;
		function isArrayBufferView(src) {
			return src.byteOffset !== void 0;
		}
		function isAnyArena(o) {
			return o.kind !== void 0;
		}
		function allocateSegment(byteLength, m) {
			trace("allocating %x bytes for %s", byteLength, m);
			const res = arena_1.Arena.allocate(byteLength, m._capnp.segments, m._capnp.arena);
			let s;
			if (res.id === m._capnp.segments.length) {
				s = new segment_1.Segment(res.id, m, res.buffer);
				trace("adding new segment %s", s);
				m._capnp.segments.push(s);
			} else if (res.id < 0 || res.id > m._capnp.segments.length) {
				throw new Error(util_1.format(errors_1.MSG_SEGMENT_OUT_OF_BOUNDS, res.id, m));
			} else {
				s = m._capnp.segments[res.id];
				trace("replacing segment %s with buffer (len:%d)", s, res.buffer.byteLength);
				s.replaceBuffer(res.buffer);
			}
			return s;
		}
		exports2.allocateSegment = allocateSegment;
		function dump(m) {
			let r = "";
			if (m._capnp.segments.length === 0) {
				return "================\nNo Segments\n================\n";
			}
			for (let i = 0; i < m._capnp.segments.length; i++) {
				r += `================
Segment #${i}
================
`;
				const { buffer, byteLength } = m._capnp.segments[i];
				const b = new Uint8Array(buffer, 0, byteLength);
				r += util_1.dumpBuffer(b);
			}
			return r;
		}
		exports2.dump = dump;
		function getRoot(RootStruct, m) {
			const root = new RootStruct(m.getSegment(0), 0);
			pointer_1.validate(pointers_1.PointerType.STRUCT, root);
			const ts = pointer_1.getTargetStructSize(root);
			if (
				ts.dataByteLength < RootStruct._capnp.size.dataByteLength ||
				ts.pointerLength < RootStruct._capnp.size.pointerLength
			) {
				trace("need to resize root struct %s", root);
				struct_1.resize(RootStruct._capnp.size, root);
			}
			return root;
		}
		exports2.getRoot = getRoot;
		function getSegment(id, m) {
			const segmentLength = m._capnp.segments.length;
			if (id === 0 && segmentLength === 0) {
				const arenaSegments = arena_1.Arena.getNumSegments(m._capnp.arena);
				if (arenaSegments === 0) {
					allocateSegment(constants_1.DEFAULT_BUFFER_SIZE, m);
				} else {
					m._capnp.segments[0] = new segment_1.Segment(
						0,
						m,
						arena_1.Arena.getBuffer(0, m._capnp.arena),
					);
				}
				if (!m._capnp.segments[0].hasCapacity(8)) {
					throw new Error(errors_1.MSG_SEGMENT_TOO_SMALL);
				}
				m._capnp.segments[0].allocate(8);
				return m._capnp.segments[0];
			}
			if (id < 0 || id >= segmentLength) {
				throw new Error(util_1.format(errors_1.MSG_SEGMENT_OUT_OF_BOUNDS, id, m));
			}
			return m._capnp.segments[id];
		}
		exports2.getSegment = getSegment;
		function initRoot(RootStruct, m) {
			const root = new RootStruct(m.getSegment(0), 0);
			struct_1.initStruct(RootStruct._capnp.size, root);
			trace("Initialized root pointer %s for %s.", root, m);
			return root;
		}
		exports2.initRoot = initRoot;
		function readRawPointer(data) {
			return new pointers_1.Pointer(new Message(data).getSegment(0), 0);
		}
		exports2.readRawPointer = readRawPointer;
		function setRoot(src, m) {
			pointers_1.Pointer.copyFrom(src, new pointers_1.Pointer(m.getSegment(0), 0));
		}
		exports2.setRoot = setRoot;
		function toArrayBuffer(m) {
			const streamFrame = getStreamFrame(m);
			if (m._capnp.segments.length === 0) getSegment(0, m);
			const segments = m._capnp.segments;
			const totalLength =
				streamFrame.byteLength +
				segments.reduce((l, s) => l + util_1.padToWord(s.byteLength), 0);
			const out = new Uint8Array(new ArrayBuffer(totalLength));
			let o = streamFrame.byteLength;
			out.set(new Uint8Array(streamFrame));
			segments.forEach((s) => {
				const segmentLength = util_1.padToWord(s.byteLength);
				out.set(new Uint8Array(s.buffer, 0, segmentLength), o);
				o += segmentLength;
			});
			return out.buffer;
		}
		exports2.toArrayBuffer = toArrayBuffer;
		function toPackedArrayBuffer(m) {
			const streamFrame = packing_1.pack(getStreamFrame(m));
			if (m._capnp.segments.length === 0) m.getSegment(0);
			const segments = m._capnp.segments.map((s) =>
				packing_1.pack(s.buffer, 0, util_1.padToWord(s.byteLength)),
			);
			const totalLength =
				streamFrame.byteLength + segments.reduce((l, s) => l + s.byteLength, 0);
			const out = new Uint8Array(new ArrayBuffer(totalLength));
			let o = streamFrame.byteLength;
			out.set(new Uint8Array(streamFrame));
			segments.forEach((s) => {
				out.set(new Uint8Array(s), o);
				o += s.byteLength;
			});
			return out.buffer;
		}
		exports2.toPackedArrayBuffer = toPackedArrayBuffer;
		function getStreamFrame(m) {
			const length = m._capnp.segments.length;
			if (length === 0) {
				return new Float64Array(1).buffer;
			}
			const frameLength = 4 + length * 4 + (1 - (length % 2)) * 4;
			const out = new DataView(new ArrayBuffer(frameLength));
			trace("Writing message stream frame with segment count: %d.", length);
			out.setUint32(0, length - 1, true);
			m._capnp.segments.forEach((s, i) => {
				trace("Message segment %d word count: %d.", s.id, s.byteLength / 8);
				out.setUint32(i * 4 + 4, s.byteLength / 8, true);
			});
			return out.buffer;
		}
		exports2.getStreamFrame = getStreamFrame;
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/index.js
var require_serialization = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/serialization/index.js"(exports2) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.ObjectSize =
			exports2.readRawPointer =
			exports2.Message =
			exports2.ListElementSize =
				void 0;
		var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
		tslib_1.__exportStar(require_mask(), exports2);
		var list_element_size_1 = require_list_element_size();
		Object.defineProperty(exports2, "ListElementSize", {
			enumerable: true,
			get: function () {
				return list_element_size_1.ListElementSize;
			},
		});
		var message_1 = require_message();
		Object.defineProperty(exports2, "Message", {
			enumerable: true,
			get: function () {
				return message_1.Message;
			},
		});
		Object.defineProperty(exports2, "readRawPointer", {
			enumerable: true,
			get: function () {
				return message_1.readRawPointer;
			},
		});
		var object_size_1 = require_object_size();
		Object.defineProperty(exports2, "ObjectSize", {
			enumerable: true,
			get: function () {
				return object_size_1.ObjectSize;
			},
		});
		tslib_1.__exportStar(require_pointers(), exports2);
	},
});

// node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/index.js
var require_src2 = __commonJS({
	"node_modules/.pnpm/capnp-ts@0.7.0/node_modules/capnp-ts/src/index.js"(exports2) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.Uint64 =
			exports2.Int64 =
			exports2.getUint8Mask =
			exports2.getUint64Mask =
			exports2.getUint32Mask =
			exports2.getUint16Mask =
			exports2.getInt8Mask =
			exports2.getInt64Mask =
			exports2.getInt32Mask =
			exports2.getInt16Mask =
			exports2.getFloat64Mask =
			exports2.getFloat32Mask =
			exports2.getBitMask =
			exports2.Void =
			exports2.VoidList =
			exports2.Uint8List =
			exports2.Uint64List =
			exports2.Uint32List =
			exports2.Uint16List =
			exports2.TextList =
			exports2.Text =
			exports2.Struct =
			exports2.Pointer =
			exports2.PointerType =
			exports2.PointerList =
			exports2.Orphan =
			exports2.List =
			exports2.InterfaceList =
			exports2.Interface =
			exports2.Int8List =
			exports2.Int64List =
			exports2.Int32List =
			exports2.Int16List =
			exports2.Float64List =
			exports2.Float32List =
			exports2.DataList =
			exports2.Data =
			exports2.CompositeList =
			exports2.BoolList =
			exports2.AnyPointerList =
			exports2.readRawPointer =
			exports2.ObjectSize =
			exports2.Message =
			exports2.ListElementSize =
				void 0;
		var serialization_1 = require_serialization();
		Object.defineProperty(exports2, "ListElementSize", {
			enumerable: true,
			get: function () {
				return serialization_1.ListElementSize;
			},
		});
		Object.defineProperty(exports2, "Message", {
			enumerable: true,
			get: function () {
				return serialization_1.Message;
			},
		});
		Object.defineProperty(exports2, "ObjectSize", {
			enumerable: true,
			get: function () {
				return serialization_1.ObjectSize;
			},
		});
		Object.defineProperty(exports2, "readRawPointer", {
			enumerable: true,
			get: function () {
				return serialization_1.readRawPointer;
			},
		});
		Object.defineProperty(exports2, "AnyPointerList", {
			enumerable: true,
			get: function () {
				return serialization_1.AnyPointerList;
			},
		});
		Object.defineProperty(exports2, "BoolList", {
			enumerable: true,
			get: function () {
				return serialization_1.BoolList;
			},
		});
		Object.defineProperty(exports2, "CompositeList", {
			enumerable: true,
			get: function () {
				return serialization_1.CompositeList;
			},
		});
		Object.defineProperty(exports2, "Data", {
			enumerable: true,
			get: function () {
				return serialization_1.Data;
			},
		});
		Object.defineProperty(exports2, "DataList", {
			enumerable: true,
			get: function () {
				return serialization_1.DataList;
			},
		});
		Object.defineProperty(exports2, "Float32List", {
			enumerable: true,
			get: function () {
				return serialization_1.Float32List;
			},
		});
		Object.defineProperty(exports2, "Float64List", {
			enumerable: true,
			get: function () {
				return serialization_1.Float64List;
			},
		});
		Object.defineProperty(exports2, "Int16List", {
			enumerable: true,
			get: function () {
				return serialization_1.Int16List;
			},
		});
		Object.defineProperty(exports2, "Int32List", {
			enumerable: true,
			get: function () {
				return serialization_1.Int32List;
			},
		});
		Object.defineProperty(exports2, "Int64List", {
			enumerable: true,
			get: function () {
				return serialization_1.Int64List;
			},
		});
		Object.defineProperty(exports2, "Int8List", {
			enumerable: true,
			get: function () {
				return serialization_1.Int8List;
			},
		});
		Object.defineProperty(exports2, "Interface", {
			enumerable: true,
			get: function () {
				return serialization_1.Interface;
			},
		});
		Object.defineProperty(exports2, "InterfaceList", {
			enumerable: true,
			get: function () {
				return serialization_1.InterfaceList;
			},
		});
		Object.defineProperty(exports2, "List", {
			enumerable: true,
			get: function () {
				return serialization_1.List;
			},
		});
		Object.defineProperty(exports2, "Orphan", {
			enumerable: true,
			get: function () {
				return serialization_1.Orphan;
			},
		});
		Object.defineProperty(exports2, "PointerList", {
			enumerable: true,
			get: function () {
				return serialization_1.PointerList;
			},
		});
		Object.defineProperty(exports2, "PointerType", {
			enumerable: true,
			get: function () {
				return serialization_1.PointerType;
			},
		});
		Object.defineProperty(exports2, "Pointer", {
			enumerable: true,
			get: function () {
				return serialization_1.Pointer;
			},
		});
		Object.defineProperty(exports2, "Struct", {
			enumerable: true,
			get: function () {
				return serialization_1.Struct;
			},
		});
		Object.defineProperty(exports2, "Text", {
			enumerable: true,
			get: function () {
				return serialization_1.Text;
			},
		});
		Object.defineProperty(exports2, "TextList", {
			enumerable: true,
			get: function () {
				return serialization_1.TextList;
			},
		});
		Object.defineProperty(exports2, "Uint16List", {
			enumerable: true,
			get: function () {
				return serialization_1.Uint16List;
			},
		});
		Object.defineProperty(exports2, "Uint32List", {
			enumerable: true,
			get: function () {
				return serialization_1.Uint32List;
			},
		});
		Object.defineProperty(exports2, "Uint64List", {
			enumerable: true,
			get: function () {
				return serialization_1.Uint64List;
			},
		});
		Object.defineProperty(exports2, "Uint8List", {
			enumerable: true,
			get: function () {
				return serialization_1.Uint8List;
			},
		});
		Object.defineProperty(exports2, "VoidList", {
			enumerable: true,
			get: function () {
				return serialization_1.VoidList;
			},
		});
		Object.defineProperty(exports2, "Void", {
			enumerable: true,
			get: function () {
				return serialization_1.Void;
			},
		});
		Object.defineProperty(exports2, "getBitMask", {
			enumerable: true,
			get: function () {
				return serialization_1.getBitMask;
			},
		});
		Object.defineProperty(exports2, "getFloat32Mask", {
			enumerable: true,
			get: function () {
				return serialization_1.getFloat32Mask;
			},
		});
		Object.defineProperty(exports2, "getFloat64Mask", {
			enumerable: true,
			get: function () {
				return serialization_1.getFloat64Mask;
			},
		});
		Object.defineProperty(exports2, "getInt16Mask", {
			enumerable: true,
			get: function () {
				return serialization_1.getInt16Mask;
			},
		});
		Object.defineProperty(exports2, "getInt32Mask", {
			enumerable: true,
			get: function () {
				return serialization_1.getInt32Mask;
			},
		});
		Object.defineProperty(exports2, "getInt64Mask", {
			enumerable: true,
			get: function () {
				return serialization_1.getInt64Mask;
			},
		});
		Object.defineProperty(exports2, "getInt8Mask", {
			enumerable: true,
			get: function () {
				return serialization_1.getInt8Mask;
			},
		});
		Object.defineProperty(exports2, "getUint16Mask", {
			enumerable: true,
			get: function () {
				return serialization_1.getUint16Mask;
			},
		});
		Object.defineProperty(exports2, "getUint32Mask", {
			enumerable: true,
			get: function () {
				return serialization_1.getUint32Mask;
			},
		});
		Object.defineProperty(exports2, "getUint64Mask", {
			enumerable: true,
			get: function () {
				return serialization_1.getUint64Mask;
			},
		});
		Object.defineProperty(exports2, "getUint8Mask", {
			enumerable: true,
			get: function () {
				return serialization_1.getUint8Mask;
			},
		});
		var types_1 = require_types();
		Object.defineProperty(exports2, "Int64", {
			enumerable: true,
			get: function () {
				return types_1.Int64;
			},
		});
		Object.defineProperty(exports2, "Uint64", {
			enumerable: true,
			get: function () {
				return types_1.Uint64;
			},
		});
	},
});

// node_modules/.pnpm/exit-hook@2.2.1/node_modules/exit-hook/index.js
var require_exit_hook = __commonJS({
	"node_modules/.pnpm/exit-hook@2.2.1/node_modules/exit-hook/index.js"(exports2, module2) {
		"use strict";
		var callbacks = /* @__PURE__ */ new Set();
		var isCalled = false;
		var isRegistered = false;
		function exit(exit2, signal) {
			if (isCalled) {
				return;
			}
			isCalled = true;
			for (const callback of callbacks) {
				callback();
			}
			if (exit2 === true) {
				process.exit(128 + signal);
			}
		}
		module2.exports = (callback) => {
			callbacks.add(callback);
			if (!isRegistered) {
				isRegistered = true;
				process.once("exit", exit);
				process.once("SIGINT", exit.bind(null, true, 2));
				process.once("SIGTERM", exit.bind(null, true, 15));
				process.on("message", (message) => {
					if (message === "shutdown") {
						exit(true, -128);
					}
				});
			}
			return () => {
				callbacks.delete(callback);
			};
		};
	},
});

// node_modules/.pnpm/stoppable@1.1.0/node_modules/stoppable/lib/stoppable.js
var require_stoppable = __commonJS({
	"node_modules/.pnpm/stoppable@1.1.0/node_modules/stoppable/lib/stoppable.js"(
		exports2,
		module2,
	) {
		"use strict";
		var https = require("https");
		module2.exports = (server, grace) => {
			grace = typeof grace === "undefined" ? Infinity : grace;
			const reqsPerSocket = /* @__PURE__ */ new Map();
			let stopped = false;
			let gracefully = true;
			if (server instanceof https.Server) {
				server.on("secureConnection", onConnection);
			} else {
				server.on("connection", onConnection);
			}
			server.on("request", onRequest);
			server.stop = stop;
			server._pendingSockets = reqsPerSocket;
			return server;
			function onConnection(socket) {
				reqsPerSocket.set(socket, 0);
				socket.once("close", () => reqsPerSocket.delete(socket));
			}
			function onRequest(req, res) {
				reqsPerSocket.set(req.socket, reqsPerSocket.get(req.socket) + 1);
				res.once("finish", () => {
					const pending = reqsPerSocket.get(req.socket) - 1;
					reqsPerSocket.set(req.socket, pending);
					if (stopped && pending === 0) {
						req.socket.end();
					}
				});
			}
			function stop(callback) {
				setImmediate(() => {
					stopped = true;
					if (grace < Infinity) {
						setTimeout(destroyAll, grace).unref();
					}
					server.close((e) => {
						if (callback) {
							callback(e, gracefully);
						}
					});
					reqsPerSocket.forEach(endIfIdle);
				});
			}
			function endIfIdle(requests, socket) {
				if (requests === 0) socket.end();
			}
			function destroyAll() {
				gracefully = false;
				reqsPerSocket.forEach((reqs, socket) => socket.end());
				setImmediate(() => {
					reqsPerSocket.forEach((reqs, socket) => socket.destroy());
				});
			}
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/core/symbols.js"(exports2, module2) {
		"use strict";
		module2.exports = {
			kClose: Symbol("close"),
			kDestroy: Symbol("destroy"),
			kDispatch: Symbol("dispatch"),
			kUrl: Symbol("url"),
			kWriting: Symbol("writing"),
			kResuming: Symbol("resuming"),
			kQueue: Symbol("queue"),
			kConnect: Symbol("connect"),
			kConnecting: Symbol("connecting"),
			kHeadersList: Symbol("headers list"),
			kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
			kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
			kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
			kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
			kKeepAlive: Symbol("keep alive"),
			kHeadersTimeout: Symbol("headers timeout"),
			kBodyTimeout: Symbol("body timeout"),
			kServerName: Symbol("server name"),
			kLocalAddress: Symbol("local address"),
			kHost: Symbol("host"),
			kNoRef: Symbol("no ref"),
			kBodyUsed: Symbol("used"),
			kRunning: Symbol("running"),
			kBlocking: Symbol("blocking"),
			kPending: Symbol("pending"),
			kSize: Symbol("size"),
			kBusy: Symbol("busy"),
			kQueued: Symbol("queued"),
			kFree: Symbol("free"),
			kConnected: Symbol("connected"),
			kClosed: Symbol("closed"),
			kNeedDrain: Symbol("need drain"),
			kReset: Symbol("reset"),
			kDestroyed: Symbol.for("nodejs.stream.destroyed"),
			kMaxHeadersSize: Symbol("max headers size"),
			kRunningIdx: Symbol("running index"),
			kPendingIdx: Symbol("pending index"),
			kError: Symbol("error"),
			kClients: Symbol("clients"),
			kClient: Symbol("client"),
			kParser: Symbol("parser"),
			kOnDestroyed: Symbol("destroy callbacks"),
			kPipelining: Symbol("pipelining"),
			kSocket: Symbol("socket"),
			kHostHeader: Symbol("host header"),
			kConnector: Symbol("connector"),
			kStrictContentLength: Symbol("strict content length"),
			kMaxRedirections: Symbol("maxRedirections"),
			kMaxRequests: Symbol("maxRequestsPerClient"),
			kProxy: Symbol("proxy agent options"),
			kCounter: Symbol("socket request counter"),
			kInterceptors: Symbol("dispatch interceptors"),
			kMaxResponseSize: Symbol("max response size"),
			kHTTP2Session: Symbol("http2Session"),
			kHTTP2SessionState: Symbol("http2Session state"),
			kHTTP2BuildRequest: Symbol("http2 build request"),
			kHTTP1BuildRequest: Symbol("http1 build request"),
			kHTTP2CopyHeaders: Symbol("http2 copy headers"),
			kHTTPConnVersion: Symbol("http connection version"),
			kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
			kConstruct: Symbol("constructable"),
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/core/errors.js
var require_errors2 = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/core/errors.js"(exports2, module2) {
		"use strict";
		var UndiciError = class extends Error {
			constructor(message) {
				super(message);
				this.name = "UndiciError";
				this.code = "UND_ERR";
			}
		};
		var ConnectTimeoutError = class _ConnectTimeoutError extends UndiciError {
			constructor(message) {
				super(message);
				Error.captureStackTrace(this, _ConnectTimeoutError);
				this.name = "ConnectTimeoutError";
				this.message = message || "Connect Timeout Error";
				this.code = "UND_ERR_CONNECT_TIMEOUT";
			}
		};
		var HeadersTimeoutError = class _HeadersTimeoutError extends UndiciError {
			constructor(message) {
				super(message);
				Error.captureStackTrace(this, _HeadersTimeoutError);
				this.name = "HeadersTimeoutError";
				this.message = message || "Headers Timeout Error";
				this.code = "UND_ERR_HEADERS_TIMEOUT";
			}
		};
		var HeadersOverflowError = class _HeadersOverflowError extends UndiciError {
			constructor(message) {
				super(message);
				Error.captureStackTrace(this, _HeadersOverflowError);
				this.name = "HeadersOverflowError";
				this.message = message || "Headers Overflow Error";
				this.code = "UND_ERR_HEADERS_OVERFLOW";
			}
		};
		var BodyTimeoutError = class _BodyTimeoutError extends UndiciError {
			constructor(message) {
				super(message);
				Error.captureStackTrace(this, _BodyTimeoutError);
				this.name = "BodyTimeoutError";
				this.message = message || "Body Timeout Error";
				this.code = "UND_ERR_BODY_TIMEOUT";
			}
		};
		var ResponseStatusCodeError = class _ResponseStatusCodeError extends UndiciError {
			constructor(message, statusCode, headers, body) {
				super(message);
				Error.captureStackTrace(this, _ResponseStatusCodeError);
				this.name = "ResponseStatusCodeError";
				this.message = message || "Response Status Code Error";
				this.code = "UND_ERR_RESPONSE_STATUS_CODE";
				this.body = body;
				this.status = statusCode;
				this.statusCode = statusCode;
				this.headers = headers;
			}
		};
		var InvalidArgumentError = class _InvalidArgumentError extends UndiciError {
			constructor(message) {
				super(message);
				Error.captureStackTrace(this, _InvalidArgumentError);
				this.name = "InvalidArgumentError";
				this.message = message || "Invalid Argument Error";
				this.code = "UND_ERR_INVALID_ARG";
			}
		};
		var InvalidReturnValueError = class _InvalidReturnValueError extends UndiciError {
			constructor(message) {
				super(message);
				Error.captureStackTrace(this, _InvalidReturnValueError);
				this.name = "InvalidReturnValueError";
				this.message = message || "Invalid Return Value Error";
				this.code = "UND_ERR_INVALID_RETURN_VALUE";
			}
		};
		var RequestAbortedError = class _RequestAbortedError extends UndiciError {
			constructor(message) {
				super(message);
				Error.captureStackTrace(this, _RequestAbortedError);
				this.name = "AbortError";
				this.message = message || "Request aborted";
				this.code = "UND_ERR_ABORTED";
			}
		};
		var InformationalError = class _InformationalError extends UndiciError {
			constructor(message) {
				super(message);
				Error.captureStackTrace(this, _InformationalError);
				this.name = "InformationalError";
				this.message = message || "Request information";
				this.code = "UND_ERR_INFO";
			}
		};
		var RequestContentLengthMismatchError = class _RequestContentLengthMismatchError extends UndiciError {
			constructor(message) {
				super(message);
				Error.captureStackTrace(this, _RequestContentLengthMismatchError);
				this.name = "RequestContentLengthMismatchError";
				this.message =
					message || "Request body length does not match content-length header";
				this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
			}
		};
		var ResponseContentLengthMismatchError = class _ResponseContentLengthMismatchError extends UndiciError {
			constructor(message) {
				super(message);
				Error.captureStackTrace(this, _ResponseContentLengthMismatchError);
				this.name = "ResponseContentLengthMismatchError";
				this.message =
					message || "Response body length does not match content-length header";
				this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
			}
		};
		var ClientDestroyedError = class _ClientDestroyedError extends UndiciError {
			constructor(message) {
				super(message);
				Error.captureStackTrace(this, _ClientDestroyedError);
				this.name = "ClientDestroyedError";
				this.message = message || "The client is destroyed";
				this.code = "UND_ERR_DESTROYED";
			}
		};
		var ClientClosedError = class _ClientClosedError extends UndiciError {
			constructor(message) {
				super(message);
				Error.captureStackTrace(this, _ClientClosedError);
				this.name = "ClientClosedError";
				this.message = message || "The client is closed";
				this.code = "UND_ERR_CLOSED";
			}
		};
		var SocketError = class _SocketError extends UndiciError {
			constructor(message, socket) {
				super(message);
				Error.captureStackTrace(this, _SocketError);
				this.name = "SocketError";
				this.message = message || "Socket error";
				this.code = "UND_ERR_SOCKET";
				this.socket = socket;
			}
		};
		var NotSupportedError = class _NotSupportedError extends UndiciError {
			constructor(message) {
				super(message);
				Error.captureStackTrace(this, _NotSupportedError);
				this.name = "NotSupportedError";
				this.message = message || "Not supported error";
				this.code = "UND_ERR_NOT_SUPPORTED";
			}
		};
		var BalancedPoolMissingUpstreamError = class extends UndiciError {
			constructor(message) {
				super(message);
				Error.captureStackTrace(this, NotSupportedError);
				this.name = "MissingUpstreamError";
				this.message = message || "No upstream has been added to the BalancedPool";
				this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
			}
		};
		var HTTPParserError = class _HTTPParserError extends Error {
			constructor(message, code, data) {
				super(message);
				Error.captureStackTrace(this, _HTTPParserError);
				this.name = "HTTPParserError";
				this.code = code ? `HPE_${code}` : void 0;
				this.data = data ? data.toString() : void 0;
			}
		};
		var ResponseExceededMaxSizeError = class _ResponseExceededMaxSizeError extends UndiciError {
			constructor(message) {
				super(message);
				Error.captureStackTrace(this, _ResponseExceededMaxSizeError);
				this.name = "ResponseExceededMaxSizeError";
				this.message = message || "Response content exceeded max size";
				this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
			}
		};
		var RequestRetryError = class _RequestRetryError extends UndiciError {
			constructor(message, code, { headers, data }) {
				super(message);
				Error.captureStackTrace(this, _RequestRetryError);
				this.name = "RequestRetryError";
				this.message = message || "Request retry error";
				this.code = "UND_ERR_REQ_RETRY";
				this.statusCode = code;
				this.data = data;
				this.headers = headers;
			}
		};
		module2.exports = {
			HTTPParserError,
			UndiciError,
			HeadersTimeoutError,
			HeadersOverflowError,
			BodyTimeoutError,
			RequestContentLengthMismatchError,
			ConnectTimeoutError,
			ResponseStatusCodeError,
			InvalidArgumentError,
			InvalidReturnValueError,
			RequestAbortedError,
			ClientDestroyedError,
			ClientClosedError,
			InformationalError,
			SocketError,
			NotSupportedError,
			ResponseContentLengthMismatchError,
			BalancedPoolMissingUpstreamError,
			ResponseExceededMaxSizeError,
			RequestRetryError,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/core/constants.js
var require_constants2 = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/core/constants.js"(
		exports2,
		module2,
	) {
		"use strict";
		var headerNameLowerCasedRecord = {};
		var wellknownHeaderNames = [
			"Accept",
			"Accept-Encoding",
			"Accept-Language",
			"Accept-Ranges",
			"Access-Control-Allow-Credentials",
			"Access-Control-Allow-Headers",
			"Access-Control-Allow-Methods",
			"Access-Control-Allow-Origin",
			"Access-Control-Expose-Headers",
			"Access-Control-Max-Age",
			"Access-Control-Request-Headers",
			"Access-Control-Request-Method",
			"Age",
			"Allow",
			"Alt-Svc",
			"Alt-Used",
			"Authorization",
			"Cache-Control",
			"Clear-Site-Data",
			"Connection",
			"Content-Disposition",
			"Content-Encoding",
			"Content-Language",
			"Content-Length",
			"Content-Location",
			"Content-Range",
			"Content-Security-Policy",
			"Content-Security-Policy-Report-Only",
			"Content-Type",
			"Cookie",
			"Cross-Origin-Embedder-Policy",
			"Cross-Origin-Opener-Policy",
			"Cross-Origin-Resource-Policy",
			"Date",
			"Device-Memory",
			"Downlink",
			"ECT",
			"ETag",
			"Expect",
			"Expect-CT",
			"Expires",
			"Forwarded",
			"From",
			"Host",
			"If-Match",
			"If-Modified-Since",
			"If-None-Match",
			"If-Range",
			"If-Unmodified-Since",
			"Keep-Alive",
			"Last-Modified",
			"Link",
			"Location",
			"Max-Forwards",
			"Origin",
			"Permissions-Policy",
			"Pragma",
			"Proxy-Authenticate",
			"Proxy-Authorization",
			"RTT",
			"Range",
			"Referer",
			"Referrer-Policy",
			"Refresh",
			"Retry-After",
			"Sec-WebSocket-Accept",
			"Sec-WebSocket-Extensions",
			"Sec-WebSocket-Key",
			"Sec-WebSocket-Protocol",
			"Sec-WebSocket-Version",
			"Server",
			"Server-Timing",
			"Service-Worker-Allowed",
			"Service-Worker-Navigation-Preload",
			"Set-Cookie",
			"SourceMap",
			"Strict-Transport-Security",
			"Supports-Loading-Mode",
			"TE",
			"Timing-Allow-Origin",
			"Trailer",
			"Transfer-Encoding",
			"Upgrade",
			"Upgrade-Insecure-Requests",
			"User-Agent",
			"Vary",
			"Via",
			"WWW-Authenticate",
			"X-Content-Type-Options",
			"X-DNS-Prefetch-Control",
			"X-Frame-Options",
			"X-Permitted-Cross-Domain-Policies",
			"X-Powered-By",
			"X-Requested-With",
			"X-XSS-Protection",
		];
		for (let i = 0; i < wellknownHeaderNames.length; ++i) {
			const key = wellknownHeaderNames[i];
			const lowerCasedKey = key.toLowerCase();
			headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] =
				lowerCasedKey;
		}
		Object.setPrototypeOf(headerNameLowerCasedRecord, null);
		module2.exports = {
			wellknownHeaderNames,
			headerNameLowerCasedRecord,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/core/util.js
var require_util2 = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/core/util.js"(exports2, module2) {
		"use strict";
		var assert = require("assert");
		var { kDestroyed, kBodyUsed } = require_symbols();
		var { IncomingMessage } = require("http");
		var stream = require("stream");
		var net = require("net");
		var { InvalidArgumentError } = require_errors2();
		var { Blob: Blob2 } = require("buffer");
		var nodeUtil = require("util");
		var { stringify } = require("querystring");
		var { headerNameLowerCasedRecord } = require_constants2();
		var [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));
		function nop() {}
		function isStream(obj) {
			return (
				obj &&
				typeof obj === "object" &&
				typeof obj.pipe === "function" &&
				typeof obj.on === "function"
			);
		}
		function isBlobLike(object) {
			return (
				(Blob2 && object instanceof Blob2) ||
				(object &&
					typeof object === "object" &&
					(typeof object.stream === "function" ||
						typeof object.arrayBuffer === "function") &&
					/^(Blob|File)$/.test(object[Symbol.toStringTag]))
			);
		}
		function buildURL(url, queryParams) {
			if (url.includes("?") || url.includes("#")) {
				throw new Error(
					'Query params cannot be passed when url already contains "?" or "#".',
				);
			}
			const stringified = stringify(queryParams);
			if (stringified) {
				url += "?" + stringified;
			}
			return url;
		}
		function parseURL(url) {
			if (typeof url === "string") {
				url = new URL(url);
				if (!/^https?:/.test(url.origin || url.protocol)) {
					throw new InvalidArgumentError(
						"Invalid URL protocol: the URL must start with `http:` or `https:`.",
					);
				}
				return url;
			}
			if (!url || typeof url !== "object") {
				throw new InvalidArgumentError(
					"Invalid URL: The URL argument must be a non-null object.",
				);
			}
			if (!/^https?:/.test(url.origin || url.protocol)) {
				throw new InvalidArgumentError(
					"Invalid URL protocol: the URL must start with `http:` or `https:`.",
				);
			}
			if (!(url instanceof URL)) {
				if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port))) {
					throw new InvalidArgumentError(
						"Invalid URL: port must be a valid integer or a string representation of an integer.",
					);
				}
				if (url.path != null && typeof url.path !== "string") {
					throw new InvalidArgumentError(
						"Invalid URL path: the path must be a string or null/undefined.",
					);
				}
				if (url.pathname != null && typeof url.pathname !== "string") {
					throw new InvalidArgumentError(
						"Invalid URL pathname: the pathname must be a string or null/undefined.",
					);
				}
				if (url.hostname != null && typeof url.hostname !== "string") {
					throw new InvalidArgumentError(
						"Invalid URL hostname: the hostname must be a string or null/undefined.",
					);
				}
				if (url.origin != null && typeof url.origin !== "string") {
					throw new InvalidArgumentError(
						"Invalid URL origin: the origin must be a string or null/undefined.",
					);
				}
				const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
				let origin =
					url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;
				let path = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
				if (origin.endsWith("/")) {
					origin = origin.substring(0, origin.length - 1);
				}
				if (path && !path.startsWith("/")) {
					path = `/${path}`;
				}
				url = new URL(origin + path);
			}
			return url;
		}
		function parseOrigin(url) {
			url = parseURL(url);
			if (url.pathname !== "/" || url.search || url.hash) {
				throw new InvalidArgumentError("invalid url");
			}
			return url;
		}
		function getHostname(host) {
			if (host[0] === "[") {
				const idx2 = host.indexOf("]");
				assert(idx2 !== -1);
				return host.substring(1, idx2);
			}
			const idx = host.indexOf(":");
			if (idx === -1) return host;
			return host.substring(0, idx);
		}
		function getServerName(host) {
			if (!host) {
				return null;
			}
			assert.strictEqual(typeof host, "string");
			const servername = getHostname(host);
			if (net.isIP(servername)) {
				return "";
			}
			return servername;
		}
		function deepClone(obj) {
			return JSON.parse(JSON.stringify(obj));
		}
		function isAsyncIterable(obj) {
			return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
		}
		function isIterable(obj) {
			return !!(
				obj != null &&
				(typeof obj[Symbol.iterator] === "function" ||
					typeof obj[Symbol.asyncIterator] === "function")
			);
		}
		function bodyLength(body) {
			if (body == null) {
				return 0;
			} else if (isStream(body)) {
				const state = body._readableState;
				return state &&
					state.objectMode === false &&
					state.ended === true &&
					Number.isFinite(state.length)
					? state.length
					: null;
			} else if (isBlobLike(body)) {
				return body.size != null ? body.size : null;
			} else if (isBuffer(body)) {
				return body.byteLength;
			}
			return null;
		}
		function isDestroyed(stream2) {
			return !stream2 || !!(stream2.destroyed || stream2[kDestroyed]);
		}
		function isReadableAborted(stream2) {
			const state = stream2 && stream2._readableState;
			return isDestroyed(stream2) && state && !state.endEmitted;
		}
		function destroy(stream2, err) {
			if (stream2 == null || !isStream(stream2) || isDestroyed(stream2)) {
				return;
			}
			if (typeof stream2.destroy === "function") {
				if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
					stream2.socket = null;
				}
				stream2.destroy(err);
			} else if (err) {
				process.nextTick(
					(stream3, err2) => {
						stream3.emit("error", err2);
					},
					stream2,
					err,
				);
			}
			if (stream2.destroyed !== true) {
				stream2[kDestroyed] = true;
			}
		}
		var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
		function parseKeepAliveTimeout(val) {
			const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
			return m ? parseInt(m[1], 10) * 1e3 : null;
		}
		function headerNameToString(value) {
			return headerNameLowerCasedRecord[value] || value.toLowerCase();
		}
		function parseHeaders(headers, obj = {}) {
			if (!Array.isArray(headers)) return headers;
			for (let i = 0; i < headers.length; i += 2) {
				const key = headers[i].toString().toLowerCase();
				let val = obj[key];
				if (!val) {
					if (Array.isArray(headers[i + 1])) {
						obj[key] = headers[i + 1].map((x) => x.toString("utf8"));
					} else {
						obj[key] = headers[i + 1].toString("utf8");
					}
				} else {
					if (!Array.isArray(val)) {
						val = [val];
						obj[key] = val;
					}
					val.push(headers[i + 1].toString("utf8"));
				}
			}
			if ("content-length" in obj && "content-disposition" in obj) {
				obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString(
					"latin1",
				);
			}
			return obj;
		}
		function parseRawHeaders(headers) {
			const ret = [];
			let hasContentLength = false;
			let contentDispositionIdx = -1;
			for (let n = 0; n < headers.length; n += 2) {
				const key = headers[n + 0].toString();
				const val = headers[n + 1].toString("utf8");
				if (
					key.length === 14 &&
					(key === "content-length" || key.toLowerCase() === "content-length")
				) {
					ret.push(key, val);
					hasContentLength = true;
				} else if (
					key.length === 19 &&
					(key === "content-disposition" || key.toLowerCase() === "content-disposition")
				) {
					contentDispositionIdx = ret.push(key, val) - 1;
				} else {
					ret.push(key, val);
				}
			}
			if (hasContentLength && contentDispositionIdx !== -1) {
				ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString(
					"latin1",
				);
			}
			return ret;
		}
		function isBuffer(buffer) {
			return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
		}
		function validateHandler(handler, method, upgrade) {
			if (!handler || typeof handler !== "object") {
				throw new InvalidArgumentError("handler must be an object");
			}
			if (typeof handler.onConnect !== "function") {
				throw new InvalidArgumentError("invalid onConnect method");
			}
			if (typeof handler.onError !== "function") {
				throw new InvalidArgumentError("invalid onError method");
			}
			if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) {
				throw new InvalidArgumentError("invalid onBodySent method");
			}
			if (upgrade || method === "CONNECT") {
				if (typeof handler.onUpgrade !== "function") {
					throw new InvalidArgumentError("invalid onUpgrade method");
				}
			} else {
				if (typeof handler.onHeaders !== "function") {
					throw new InvalidArgumentError("invalid onHeaders method");
				}
				if (typeof handler.onData !== "function") {
					throw new InvalidArgumentError("invalid onData method");
				}
				if (typeof handler.onComplete !== "function") {
					throw new InvalidArgumentError("invalid onComplete method");
				}
			}
		}
		function isDisturbed(body) {
			return !!(
				body &&
				(stream.isDisturbed
					? stream.isDisturbed(body) || body[kBodyUsed]
					: body[kBodyUsed] ||
						body.readableDidRead ||
						(body._readableState && body._readableState.dataEmitted) ||
						isReadableAborted(body))
			);
		}
		function isErrored(body) {
			return !!(
				body &&
				(stream.isErrored
					? stream.isErrored(body)
					: /state: 'errored'/.test(nodeUtil.inspect(body)))
			);
		}
		function isReadable(body) {
			return !!(
				body &&
				(stream.isReadable
					? stream.isReadable(body)
					: /state: 'readable'/.test(nodeUtil.inspect(body)))
			);
		}
		function getSocketInfo(socket) {
			return {
				localAddress: socket.localAddress,
				localPort: socket.localPort,
				remoteAddress: socket.remoteAddress,
				remotePort: socket.remotePort,
				remoteFamily: socket.remoteFamily,
				timeout: socket.timeout,
				bytesWritten: socket.bytesWritten,
				bytesRead: socket.bytesRead,
			};
		}
		async function* convertIterableToBuffer(iterable) {
			for await (const chunk of iterable) {
				yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
			}
		}
		var ReadableStream;
		function ReadableStreamFrom(iterable) {
			if (!ReadableStream) {
				ReadableStream = require("stream/web").ReadableStream;
			}
			if (ReadableStream.from) {
				return ReadableStream.from(convertIterableToBuffer(iterable));
			}
			let iterator;
			return new ReadableStream(
				{
					async start() {
						iterator = iterable[Symbol.asyncIterator]();
					},
					async pull(controller) {
						const { done, value } = await iterator.next();
						if (done) {
							queueMicrotask(() => {
								controller.close();
							});
						} else {
							const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
							controller.enqueue(new Uint8Array(buf));
						}
						return controller.desiredSize > 0;
					},
					async cancel(reason) {
						await iterator.return();
					},
				},
				0,
			);
		}
		function isFormDataLike(object) {
			return (
				object &&
				typeof object === "object" &&
				typeof object.append === "function" &&
				typeof object.delete === "function" &&
				typeof object.get === "function" &&
				typeof object.getAll === "function" &&
				typeof object.has === "function" &&
				typeof object.set === "function" &&
				object[Symbol.toStringTag] === "FormData"
			);
		}
		function throwIfAborted(signal) {
			if (!signal) {
				return;
			}
			if (typeof signal.throwIfAborted === "function") {
				signal.throwIfAborted();
			} else {
				if (signal.aborted) {
					const err = new Error("The operation was aborted");
					err.name = "AbortError";
					throw err;
				}
			}
		}
		function addAbortListener(signal, listener) {
			if ("addEventListener" in signal) {
				signal.addEventListener("abort", listener, { once: true });
				return () => signal.removeEventListener("abort", listener);
			}
			signal.addListener("abort", listener);
			return () => signal.removeListener("abort", listener);
		}
		var hasToWellFormed = !!String.prototype.toWellFormed;
		function toUSVString(val) {
			if (hasToWellFormed) {
				return `${val}`.toWellFormed();
			} else if (nodeUtil.toUSVString) {
				return nodeUtil.toUSVString(val);
			}
			return `${val}`;
		}
		function parseRangeHeader(range) {
			if (range == null || range === "") return { start: 0, end: null, size: null };
			const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
			return m
				? {
						start: parseInt(m[1]),
						end: m[2] ? parseInt(m[2]) : null,
						size: m[3] ? parseInt(m[3]) : null,
					}
				: null;
		}
		var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
		kEnumerableProperty.enumerable = true;
		module2.exports = {
			kEnumerableProperty,
			nop,
			isDisturbed,
			isErrored,
			isReadable,
			toUSVString,
			isReadableAborted,
			isBlobLike,
			parseOrigin,
			parseURL,
			getServerName,
			isStream,
			isIterable,
			isAsyncIterable,
			isDestroyed,
			headerNameToString,
			parseRawHeaders,
			parseHeaders,
			parseKeepAliveTimeout,
			destroy,
			bodyLength,
			deepClone,
			ReadableStreamFrom,
			isBuffer,
			validateHandler,
			getSocketInfo,
			isFormDataLike,
			buildURL,
			throwIfAborted,
			addAbortListener,
			parseRangeHeader,
			nodeMajor,
			nodeMinor,
			nodeHasAutoSelectFamily: nodeMajor > 18 || (nodeMajor === 18 && nodeMinor >= 13),
			safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"],
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/timers.js
var require_timers = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/timers.js"(exports2, module2) {
		"use strict";
		var fastNow = Date.now();
		var fastNowTimeout;
		var fastTimers = [];
		function onTimeout() {
			fastNow = Date.now();
			let len = fastTimers.length;
			let idx = 0;
			while (idx < len) {
				const timer = fastTimers[idx];
				if (timer.state === 0) {
					timer.state = fastNow + timer.delay;
				} else if (timer.state > 0 && fastNow >= timer.state) {
					timer.state = -1;
					timer.callback(timer.opaque);
				}
				if (timer.state === -1) {
					timer.state = -2;
					if (idx !== len - 1) {
						fastTimers[idx] = fastTimers.pop();
					} else {
						fastTimers.pop();
					}
					len -= 1;
				} else {
					idx += 1;
				}
			}
			if (fastTimers.length > 0) {
				refreshTimeout();
			}
		}
		function refreshTimeout() {
			if (fastNowTimeout && fastNowTimeout.refresh) {
				fastNowTimeout.refresh();
			} else {
				clearTimeout(fastNowTimeout);
				fastNowTimeout = setTimeout(onTimeout, 1e3);
				if (fastNowTimeout.unref) {
					fastNowTimeout.unref();
				}
			}
		}
		var Timeout = class {
			constructor(callback, delay, opaque) {
				this.callback = callback;
				this.delay = delay;
				this.opaque = opaque;
				this.state = -2;
				this.refresh();
			}
			refresh() {
				if (this.state === -2) {
					fastTimers.push(this);
					if (!fastNowTimeout || fastTimers.length === 1) {
						refreshTimeout();
					}
				}
				this.state = 0;
			}
			clear() {
				this.state = -1;
			}
		};
		module2.exports = {
			setTimeout(callback, delay, opaque) {
				return delay < 1e3
					? setTimeout(callback, delay, opaque)
					: new Timeout(callback, delay, opaque);
			},
			clearTimeout(timeout) {
				if (timeout instanceof Timeout) {
					timeout.clear();
				} else {
					clearTimeout(timeout);
				}
			},
		};
	},
});

// node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js
var require_sbmh = __commonJS({
	"node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js"(
		exports2,
		module2,
	) {
		"use strict";
		var EventEmitter = require("events").EventEmitter;
		var inherits = require("util").inherits;
		function SBMH(needle) {
			if (typeof needle === "string") {
				needle = Buffer.from(needle);
			}
			if (!Buffer.isBuffer(needle)) {
				throw new TypeError("The needle has to be a String or a Buffer.");
			}
			const needleLength = needle.length;
			if (needleLength === 0) {
				throw new Error("The needle cannot be an empty String/Buffer.");
			}
			if (needleLength > 256) {
				throw new Error("The needle cannot have a length bigger than 256.");
			}
			this.maxMatches = Infinity;
			this.matches = 0;
			this._occ = new Array(256).fill(needleLength);
			this._lookbehind_size = 0;
			this._needle = needle;
			this._bufpos = 0;
			this._lookbehind = Buffer.alloc(needleLength);
			for (var i = 0; i < needleLength - 1; ++i) {
				this._occ[needle[i]] = needleLength - 1 - i;
			}
		}
		inherits(SBMH, EventEmitter);
		SBMH.prototype.reset = function () {
			this._lookbehind_size = 0;
			this.matches = 0;
			this._bufpos = 0;
		};
		SBMH.prototype.push = function (chunk, pos) {
			if (!Buffer.isBuffer(chunk)) {
				chunk = Buffer.from(chunk, "binary");
			}
			const chlen = chunk.length;
			this._bufpos = pos || 0;
			let r;
			while (r !== chlen && this.matches < this.maxMatches) {
				r = this._sbmh_feed(chunk);
			}
			return r;
		};
		SBMH.prototype._sbmh_feed = function (data) {
			const len = data.length;
			const needle = this._needle;
			const needleLength = needle.length;
			const lastNeedleChar = needle[needleLength - 1];
			let pos = -this._lookbehind_size;
			let ch;
			if (pos < 0) {
				while (pos < 0 && pos <= len - needleLength) {
					ch = this._sbmh_lookup_char(data, pos + needleLength - 1);
					if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {
						this._lookbehind_size = 0;
						++this.matches;
						this.emit("info", true);
						return (this._bufpos = pos + needleLength);
					}
					pos += this._occ[ch];
				}
				if (pos < 0) {
					while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {
						++pos;
					}
				}
				if (pos >= 0) {
					this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);
					this._lookbehind_size = 0;
				} else {
					const bytesToCutOff = this._lookbehind_size + pos;
					if (bytesToCutOff > 0) {
						this.emit("info", false, this._lookbehind, 0, bytesToCutOff);
					}
					this._lookbehind.copy(
						this._lookbehind,
						0,
						bytesToCutOff,
						this._lookbehind_size - bytesToCutOff,
					);
					this._lookbehind_size -= bytesToCutOff;
					data.copy(this._lookbehind, this._lookbehind_size);
					this._lookbehind_size += len;
					this._bufpos = len;
					return len;
				}
			}
			pos += (pos >= 0) * this._bufpos;
			if (data.indexOf(needle, pos) !== -1) {
				pos = data.indexOf(needle, pos);
				++this.matches;
				if (pos > 0) {
					this.emit("info", true, data, this._bufpos, pos);
				} else {
					this.emit("info", true);
				}
				return (this._bufpos = pos + needleLength);
			} else {
				pos = len - needleLength;
			}
			while (
				pos < len &&
				(data[pos] !== needle[0] ||
					Buffer.compare(
						data.subarray(pos, pos + len - pos),
						needle.subarray(0, len - pos),
					) !== 0)
			) {
				++pos;
			}
			if (pos < len) {
				data.copy(this._lookbehind, 0, pos, pos + (len - pos));
				this._lookbehind_size = len - pos;
			}
			if (pos > 0) {
				this.emit("info", false, data, this._bufpos, pos < len ? pos : len);
			}
			this._bufpos = len;
			return len;
		};
		SBMH.prototype._sbmh_lookup_char = function (data, pos) {
			return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];
		};
		SBMH.prototype._sbmh_memcmp = function (data, pos, len) {
			for (var i = 0; i < len; ++i) {
				if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) {
					return false;
				}
			}
			return true;
		};
		module2.exports = SBMH;
	},
});

// node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js
var require_PartStream = __commonJS({
	"node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js"(
		exports2,
		module2,
	) {
		"use strict";
		var inherits = require("util").inherits;
		var ReadableStream = require("stream").Readable;
		function PartStream(opts) {
			ReadableStream.call(this, opts);
		}
		inherits(PartStream, ReadableStream);
		PartStream.prototype._read = function (n) {};
		module2.exports = PartStream;
	},
});

// node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/getLimit.js
var require_getLimit = __commonJS({
	"node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/getLimit.js"(
		exports2,
		module2,
	) {
		"use strict";
		module2.exports = function getLimit(limits, name, defaultLimit) {
			if (!limits || limits[name] === void 0 || limits[name] === null) {
				return defaultLimit;
			}
			if (typeof limits[name] !== "number" || isNaN(limits[name])) {
				throw new TypeError("Limit " + name + " is not a valid number");
			}
			return limits[name];
		};
	},
});

// node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js
var require_HeaderParser = __commonJS({
	"node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js"(
		exports2,
		module2,
	) {
		"use strict";
		var EventEmitter = require("events").EventEmitter;
		var inherits = require("util").inherits;
		var getLimit = require_getLimit();
		var StreamSearch = require_sbmh();
		var B_DCRLF = Buffer.from("\r\n\r\n");
		var RE_CRLF = /\r\n/g;
		var RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
		function HeaderParser(cfg) {
			EventEmitter.call(this);
			cfg = cfg || {};
			const self2 = this;
			this.nread = 0;
			this.maxed = false;
			this.npairs = 0;
			this.maxHeaderPairs = getLimit(cfg, "maxHeaderPairs", 2e3);
			this.maxHeaderSize = getLimit(cfg, "maxHeaderSize", 80 * 1024);
			this.buffer = "";
			this.header = {};
			this.finished = false;
			this.ss = new StreamSearch(B_DCRLF);
			this.ss.on("info", function (isMatch, data, start, end) {
				if (data && !self2.maxed) {
					if (self2.nread + end - start >= self2.maxHeaderSize) {
						end = self2.maxHeaderSize - self2.nread + start;
						self2.nread = self2.maxHeaderSize;
						self2.maxed = true;
					} else {
						self2.nread += end - start;
					}
					self2.buffer += data.toString("binary", start, end);
				}
				if (isMatch) {
					self2._finish();
				}
			});
		}
		inherits(HeaderParser, EventEmitter);
		HeaderParser.prototype.push = function (data) {
			const r = this.ss.push(data);
			if (this.finished) {
				return r;
			}
		};
		HeaderParser.prototype.reset = function () {
			this.finished = false;
			this.buffer = "";
			this.header = {};
			this.ss.reset();
		};
		HeaderParser.prototype._finish = function () {
			if (this.buffer) {
				this._parseHeader();
			}
			this.ss.matches = this.ss.maxMatches;
			const header = this.header;
			this.header = {};
			this.buffer = "";
			this.finished = true;
			this.nread = this.npairs = 0;
			this.maxed = false;
			this.emit("header", header);
		};
		HeaderParser.prototype._parseHeader = function () {
			if (this.npairs === this.maxHeaderPairs) {
				return;
			}
			const lines = this.buffer.split(RE_CRLF);
			const len = lines.length;
			let m, h;
			for (var i = 0; i < len; ++i) {
				if (lines[i].length === 0) {
					continue;
				}
				if (lines[i][0] === "	" || lines[i][0] === " ") {
					if (h) {
						this.header[h][this.header[h].length - 1] += lines[i];
						continue;
					}
				}
				const posColon = lines[i].indexOf(":");
				if (posColon === -1 || posColon === 0) {
					return;
				}
				m = RE_HDR.exec(lines[i]);
				h = m[1].toLowerCase();
				this.header[h] = this.header[h] || [];
				this.header[h].push(m[2] || "");
				if (++this.npairs === this.maxHeaderPairs) {
					break;
				}
			}
		};
		module2.exports = HeaderParser;
	},
});

// node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js
var require_Dicer = __commonJS({
	"node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js"(
		exports2,
		module2,
	) {
		"use strict";
		var WritableStream = require("stream").Writable;
		var inherits = require("util").inherits;
		var StreamSearch = require_sbmh();
		var PartStream = require_PartStream();
		var HeaderParser = require_HeaderParser();
		var DASH = 45;
		var B_ONEDASH = Buffer.from("-");
		var B_CRLF = Buffer.from("\r\n");
		var EMPTY_FN = function () {};
		function Dicer(cfg) {
			if (!(this instanceof Dicer)) {
				return new Dicer(cfg);
			}
			WritableStream.call(this, cfg);
			if (!cfg || (!cfg.headerFirst && typeof cfg.boundary !== "string")) {
				throw new TypeError("Boundary required");
			}
			if (typeof cfg.boundary === "string") {
				this.setBoundary(cfg.boundary);
			} else {
				this._bparser = void 0;
			}
			this._headerFirst = cfg.headerFirst;
			this._dashes = 0;
			this._parts = 0;
			this._finished = false;
			this._realFinish = false;
			this._isPreamble = true;
			this._justMatched = false;
			this._firstWrite = true;
			this._inHeader = true;
			this._part = void 0;
			this._cb = void 0;
			this._ignoreData = false;
			this._partOpts = { highWaterMark: cfg.partHwm };
			this._pause = false;
			const self2 = this;
			this._hparser = new HeaderParser(cfg);
			this._hparser.on("header", function (header) {
				self2._inHeader = false;
				self2._part.emit("header", header);
			});
		}
		inherits(Dicer, WritableStream);
		Dicer.prototype.emit = function (ev) {
			if (ev === "finish" && !this._realFinish) {
				if (!this._finished) {
					const self2 = this;
					process.nextTick(function () {
						self2.emit("error", new Error("Unexpected end of multipart data"));
						if (self2._part && !self2._ignoreData) {
							const type = self2._isPreamble ? "Preamble" : "Part";
							self2._part.emit(
								"error",
								new Error(
									type +
										" terminated early due to unexpected end of multipart data",
								),
							);
							self2._part.push(null);
							process.nextTick(function () {
								self2._realFinish = true;
								self2.emit("finish");
								self2._realFinish = false;
							});
							return;
						}
						self2._realFinish = true;
						self2.emit("finish");
						self2._realFinish = false;
					});
				}
			} else {
				WritableStream.prototype.emit.apply(this, arguments);
			}
		};
		Dicer.prototype._write = function (data, encoding, cb) {
			if (!this._hparser && !this._bparser) {
				return cb();
			}
			if (this._headerFirst && this._isPreamble) {
				if (!this._part) {
					this._part = new PartStream(this._partOpts);
					if (this.listenerCount("preamble") !== 0) {
						this.emit("preamble", this._part);
					} else {
						this._ignore();
					}
				}
				const r = this._hparser.push(data);
				if (!this._inHeader && r !== void 0 && r < data.length) {
					data = data.slice(r);
				} else {
					return cb();
				}
			}
			if (this._firstWrite) {
				this._bparser.push(B_CRLF);
				this._firstWrite = false;
			}
			this._bparser.push(data);
			if (this._pause) {
				this._cb = cb;
			} else {
				cb();
			}
		};
		Dicer.prototype.reset = function () {
			this._part = void 0;
			this._bparser = void 0;
			this._hparser = void 0;
		};
		Dicer.prototype.setBoundary = function (boundary) {
			const self2 = this;
			this._bparser = new StreamSearch("\r\n--" + boundary);
			this._bparser.on("info", function (isMatch, data, start, end) {
				self2._oninfo(isMatch, data, start, end);
			});
		};
		Dicer.prototype._ignore = function () {
			if (this._part && !this._ignoreData) {
				this._ignoreData = true;
				this._part.on("error", EMPTY_FN);
				this._part.resume();
			}
		};
		Dicer.prototype._oninfo = function (isMatch, data, start, end) {
			let buf;
			const self2 = this;
			let i = 0;
			let r;
			let shouldWriteMore = true;
			if (!this._part && this._justMatched && data) {
				while (this._dashes < 2 && start + i < end) {
					if (data[start + i] === DASH) {
						++i;
						++this._dashes;
					} else {
						if (this._dashes) {
							buf = B_ONEDASH;
						}
						this._dashes = 0;
						break;
					}
				}
				if (this._dashes === 2) {
					if (start + i < end && this.listenerCount("trailer") !== 0) {
						this.emit("trailer", data.slice(start + i, end));
					}
					this.reset();
					this._finished = true;
					if (self2._parts === 0) {
						self2._realFinish = true;
						self2.emit("finish");
						self2._realFinish = false;
					}
				}
				if (this._dashes) {
					return;
				}
			}
			if (this._justMatched) {
				this._justMatched = false;
			}
			if (!this._part) {
				this._part = new PartStream(this._partOpts);
				this._part._read = function (n) {
					self2._unpause();
				};
				if (this._isPreamble && this.listenerCount("preamble") !== 0) {
					this.emit("preamble", this._part);
				} else if (this._isPreamble !== true && this.listenerCount("part") !== 0) {
					this.emit("part", this._part);
				} else {
					this._ignore();
				}
				if (!this._isPreamble) {
					this._inHeader = true;
				}
			}
			if (data && start < end && !this._ignoreData) {
				if (this._isPreamble || !this._inHeader) {
					if (buf) {
						shouldWriteMore = this._part.push(buf);
					}
					shouldWriteMore = this._part.push(data.slice(start, end));
					if (!shouldWriteMore) {
						this._pause = true;
					}
				} else if (!this._isPreamble && this._inHeader) {
					if (buf) {
						this._hparser.push(buf);
					}
					r = this._hparser.push(data.slice(start, end));
					if (!this._inHeader && r !== void 0 && r < end) {
						this._oninfo(false, data, start + r, end);
					}
				}
			}
			if (isMatch) {
				this._hparser.reset();
				if (this._isPreamble) {
					this._isPreamble = false;
				} else {
					if (start !== end) {
						++this._parts;
						this._part.on("end", function () {
							if (--self2._parts === 0) {
								if (self2._finished) {
									self2._realFinish = true;
									self2.emit("finish");
									self2._realFinish = false;
								} else {
									self2._unpause();
								}
							}
						});
					}
				}
				this._part.push(null);
				this._part = void 0;
				this._ignoreData = false;
				this._justMatched = true;
				this._dashes = 0;
			}
		};
		Dicer.prototype._unpause = function () {
			if (!this._pause) {
				return;
			}
			this._pause = false;
			if (this._cb) {
				const cb = this._cb;
				this._cb = void 0;
				cb();
			}
		};
		module2.exports = Dicer;
	},
});

// node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/decodeText.js
var require_decodeText = __commonJS({
	"node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/decodeText.js"(
		exports2,
		module2,
	) {
		"use strict";
		var utf8Decoder = new TextDecoder("utf-8");
		var textDecoders = /* @__PURE__ */ new Map([
			["utf-8", utf8Decoder],
			["utf8", utf8Decoder],
		]);
		function getDecoder(charset) {
			let lc;
			while (true) {
				switch (charset) {
					case "utf-8":
					case "utf8":
						return decoders.utf8;
					case "latin1":
					case "ascii":
					// TODO: Make these a separate, strict decoder?
					case "us-ascii":
					case "iso-8859-1":
					case "iso8859-1":
					case "iso88591":
					case "iso_8859-1":
					case "windows-1252":
					case "iso_8859-1:1987":
					case "cp1252":
					case "x-cp1252":
						return decoders.latin1;
					case "utf16le":
					case "utf-16le":
					case "ucs2":
					case "ucs-2":
						return decoders.utf16le;
					case "base64":
						return decoders.base64;
					default:
						if (lc === void 0) {
							lc = true;
							charset = charset.toLowerCase();
							continue;
						}
						return decoders.other.bind(charset);
				}
			}
		}
		var decoders = {
			utf8: (data, sourceEncoding) => {
				if (data.length === 0) {
					return "";
				}
				if (typeof data === "string") {
					data = Buffer.from(data, sourceEncoding);
				}
				return data.utf8Slice(0, data.length);
			},
			latin1: (data, sourceEncoding) => {
				if (data.length === 0) {
					return "";
				}
				if (typeof data === "string") {
					return data;
				}
				return data.latin1Slice(0, data.length);
			},
			utf16le: (data, sourceEncoding) => {
				if (data.length === 0) {
					return "";
				}
				if (typeof data === "string") {
					data = Buffer.from(data, sourceEncoding);
				}
				return data.ucs2Slice(0, data.length);
			},
			base64: (data, sourceEncoding) => {
				if (data.length === 0) {
					return "";
				}
				if (typeof data === "string") {
					data = Buffer.from(data, sourceEncoding);
				}
				return data.base64Slice(0, data.length);
			},
			other: (data, sourceEncoding) => {
				if (data.length === 0) {
					return "";
				}
				if (typeof data === "string") {
					data = Buffer.from(data, sourceEncoding);
				}
				if (textDecoders.has(exports2.toString())) {
					try {
						return textDecoders.get(exports2).decode(data);
					} catch {}
				}
				return typeof data === "string" ? data : data.toString();
			},
		};
		function decodeText(text, sourceEncoding, destEncoding) {
			if (text) {
				return getDecoder(destEncoding)(text, sourceEncoding);
			}
			return text;
		}
		module2.exports = decodeText;
	},
});

// node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/parseParams.js
var require_parseParams = __commonJS({
	"node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/parseParams.js"(
		exports2,
		module2,
	) {
		"use strict";
		var decodeText = require_decodeText();
		var RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;
		var EncodedLookup = {
			"%00": "\0",
			"%01": "",
			"%02": "",
			"%03": "",
			"%04": "",
			"%05": "",
			"%06": "",
			"%07": "\x07",
			"%08": "\b",
			"%09": "	",
			"%0a": "\n",
			"%0A": "\n",
			"%0b": "\v",
			"%0B": "\v",
			"%0c": "\f",
			"%0C": "\f",
			"%0d": "\r",
			"%0D": "\r",
			"%0e": "",
			"%0E": "",
			"%0f": "",
			"%0F": "",
			"%10": "",
			"%11": "",
			"%12": "",
			"%13": "",
			"%14": "",
			"%15": "",
			"%16": "",
			"%17": "",
			"%18": "",
			"%19": "",
			"%1a": "",
			"%1A": "",
			"%1b": "\x1B",
			"%1B": "\x1B",
			"%1c": "",
			"%1C": "",
			"%1d": "",
			"%1D": "",
			"%1e": "",
			"%1E": "",
			"%1f": "",
			"%1F": "",
			"%20": " ",
			"%21": "!",
			"%22": '"',
			"%23": "#",
			"%24": "$",
			"%25": "%",
			"%26": "&",
			"%27": "'",
			"%28": "(",
			"%29": ")",
			"%2a": "*",
			"%2A": "*",
			"%2b": "+",
			"%2B": "+",
			"%2c": ",",
			"%2C": ",",
			"%2d": "-",
			"%2D": "-",
			"%2e": ".",
			"%2E": ".",
			"%2f": "/",
			"%2F": "/",
			"%30": "0",
			"%31": "1",
			"%32": "2",
			"%33": "3",
			"%34": "4",
			"%35": "5",
			"%36": "6",
			"%37": "7",
			"%38": "8",
			"%39": "9",
			"%3a": ":",
			"%3A": ":",
			"%3b": ";",
			"%3B": ";",
			"%3c": "<",
			"%3C": "<",
			"%3d": "=",
			"%3D": "=",
			"%3e": ">",
			"%3E": ">",
			"%3f": "?",
			"%3F": "?",
			"%40": "@",
			"%41": "A",
			"%42": "B",
			"%43": "C",
			"%44": "D",
			"%45": "E",
			"%46": "F",
			"%47": "G",
			"%48": "H",
			"%49": "I",
			"%4a": "J",
			"%4A": "J",
			"%4b": "K",
			"%4B": "K",
			"%4c": "L",
			"%4C": "L",
			"%4d": "M",
			"%4D": "M",
			"%4e": "N",
			"%4E": "N",
			"%4f": "O",
			"%4F": "O",
			"%50": "P",
			"%51": "Q",
			"%52": "R",
			"%53": "S",
			"%54": "T",
			"%55": "U",
			"%56": "V",
			"%57": "W",
			"%58": "X",
			"%59": "Y",
			"%5a": "Z",
			"%5A": "Z",
			"%5b": "[",
			"%5B": "[",
			"%5c": "\\",
			"%5C": "\\",
			"%5d": "]",
			"%5D": "]",
			"%5e": "^",
			"%5E": "^",
			"%5f": "_",
			"%5F": "_",
			"%60": "`",
			"%61": "a",
			"%62": "b",
			"%63": "c",
			"%64": "d",
			"%65": "e",
			"%66": "f",
			"%67": "g",
			"%68": "h",
			"%69": "i",
			"%6a": "j",
			"%6A": "j",
			"%6b": "k",
			"%6B": "k",
			"%6c": "l",
			"%6C": "l",
			"%6d": "m",
			"%6D": "m",
			"%6e": "n",
			"%6E": "n",
			"%6f": "o",
			"%6F": "o",
			"%70": "p",
			"%71": "q",
			"%72": "r",
			"%73": "s",
			"%74": "t",
			"%75": "u",
			"%76": "v",
			"%77": "w",
			"%78": "x",
			"%79": "y",
			"%7a": "z",
			"%7A": "z",
			"%7b": "{",
			"%7B": "{",
			"%7c": "|",
			"%7C": "|",
			"%7d": "}",
			"%7D": "}",
			"%7e": "~",
			"%7E": "~",
			"%7f": "\x7F",
			"%7F": "\x7F",
			"%80": "\x80",
			"%81": "\x81",
			"%82": "\x82",
			"%83": "\x83",
			"%84": "\x84",
			"%85": "\x85",
			"%86": "\x86",
			"%87": "\x87",
			"%88": "\x88",
			"%89": "\x89",
			"%8a": "\x8A",
			"%8A": "\x8A",
			"%8b": "\x8B",
			"%8B": "\x8B",
			"%8c": "\x8C",
			"%8C": "\x8C",
			"%8d": "\x8D",
			"%8D": "\x8D",
			"%8e": "\x8E",
			"%8E": "\x8E",
			"%8f": "\x8F",
			"%8F": "\x8F",
			"%90": "\x90",
			"%91": "\x91",
			"%92": "\x92",
			"%93": "\x93",
			"%94": "\x94",
			"%95": "\x95",
			"%96": "\x96",
			"%97": "\x97",
			"%98": "\x98",
			"%99": "\x99",
			"%9a": "\x9A",
			"%9A": "\x9A",
			"%9b": "\x9B",
			"%9B": "\x9B",
			"%9c": "\x9C",
			"%9C": "\x9C",
			"%9d": "\x9D",
			"%9D": "\x9D",
			"%9e": "\x9E",
			"%9E": "\x9E",
			"%9f": "\x9F",
			"%9F": "\x9F",
			"%a0": "\xA0",
			"%A0": "\xA0",
			"%a1": "\xA1",
			"%A1": "\xA1",
			"%a2": "\xA2",
			"%A2": "\xA2",
			"%a3": "\xA3",
			"%A3": "\xA3",
			"%a4": "\xA4",
			"%A4": "\xA4",
			"%a5": "\xA5",
			"%A5": "\xA5",
			"%a6": "\xA6",
			"%A6": "\xA6",
			"%a7": "\xA7",
			"%A7": "\xA7",
			"%a8": "\xA8",
			"%A8": "\xA8",
			"%a9": "\xA9",
			"%A9": "\xA9",
			"%aa": "\xAA",
			"%Aa": "\xAA",
			"%aA": "\xAA",
			"%AA": "\xAA",
			"%ab": "\xAB",
			"%Ab": "\xAB",
			"%aB": "\xAB",
			"%AB": "\xAB",
			"%ac": "\xAC",
			"%Ac": "\xAC",
			"%aC": "\xAC",
			"%AC": "\xAC",
			"%ad": "\xAD",
			"%Ad": "\xAD",
			"%aD": "\xAD",
			"%AD": "\xAD",
			"%ae": "\xAE",
			"%Ae": "\xAE",
			"%aE": "\xAE",
			"%AE": "\xAE",
			"%af": "\xAF",
			"%Af": "\xAF",
			"%aF": "\xAF",
			"%AF": "\xAF",
			"%b0": "\xB0",
			"%B0": "\xB0",
			"%b1": "\xB1",
			"%B1": "\xB1",
			"%b2": "\xB2",
			"%B2": "\xB2",
			"%b3": "\xB3",
			"%B3": "\xB3",
			"%b4": "\xB4",
			"%B4": "\xB4",
			"%b5": "\xB5",
			"%B5": "\xB5",
			"%b6": "\xB6",
			"%B6": "\xB6",
			"%b7": "\xB7",
			"%B7": "\xB7",
			"%b8": "\xB8",
			"%B8": "\xB8",
			"%b9": "\xB9",
			"%B9": "\xB9",
			"%ba": "\xBA",
			"%Ba": "\xBA",
			"%bA": "\xBA",
			"%BA": "\xBA",
			"%bb": "\xBB",
			"%Bb": "\xBB",
			"%bB": "\xBB",
			"%BB": "\xBB",
			"%bc": "\xBC",
			"%Bc": "\xBC",
			"%bC": "\xBC",
			"%BC": "\xBC",
			"%bd": "\xBD",
			"%Bd": "\xBD",
			"%bD": "\xBD",
			"%BD": "\xBD",
			"%be": "\xBE",
			"%Be": "\xBE",
			"%bE": "\xBE",
			"%BE": "\xBE",
			"%bf": "\xBF",
			"%Bf": "\xBF",
			"%bF": "\xBF",
			"%BF": "\xBF",
			"%c0": "\xC0",
			"%C0": "\xC0",
			"%c1": "\xC1",
			"%C1": "\xC1",
			"%c2": "\xC2",
			"%C2": "\xC2",
			"%c3": "\xC3",
			"%C3": "\xC3",
			"%c4": "\xC4",
			"%C4": "\xC4",
			"%c5": "\xC5",
			"%C5": "\xC5",
			"%c6": "\xC6",
			"%C6": "\xC6",
			"%c7": "\xC7",
			"%C7": "\xC7",
			"%c8": "\xC8",
			"%C8": "\xC8",
			"%c9": "\xC9",
			"%C9": "\xC9",
			"%ca": "\xCA",
			"%Ca": "\xCA",
			"%cA": "\xCA",
			"%CA": "\xCA",
			"%cb": "\xCB",
			"%Cb": "\xCB",
			"%cB": "\xCB",
			"%CB": "\xCB",
			"%cc": "\xCC",
			"%Cc": "\xCC",
			"%cC": "\xCC",
			"%CC": "\xCC",
			"%cd": "\xCD",
			"%Cd": "\xCD",
			"%cD": "\xCD",
			"%CD": "\xCD",
			"%ce": "\xCE",
			"%Ce": "\xCE",
			"%cE": "\xCE",
			"%CE": "\xCE",
			"%cf": "\xCF",
			"%Cf": "\xCF",
			"%cF": "\xCF",
			"%CF": "\xCF",
			"%d0": "\xD0",
			"%D0": "\xD0",
			"%d1": "\xD1",
			"%D1": "\xD1",
			"%d2": "\xD2",
			"%D2": "\xD2",
			"%d3": "\xD3",
			"%D3": "\xD3",
			"%d4": "\xD4",
			"%D4": "\xD4",
			"%d5": "\xD5",
			"%D5": "\xD5",
			"%d6": "\xD6",
			"%D6": "\xD6",
			"%d7": "\xD7",
			"%D7": "\xD7",
			"%d8": "\xD8",
			"%D8": "\xD8",
			"%d9": "\xD9",
			"%D9": "\xD9",
			"%da": "\xDA",
			"%Da": "\xDA",
			"%dA": "\xDA",
			"%DA": "\xDA",
			"%db": "\xDB",
			"%Db": "\xDB",
			"%dB": "\xDB",
			"%DB": "\xDB",
			"%dc": "\xDC",
			"%Dc": "\xDC",
			"%dC": "\xDC",
			"%DC": "\xDC",
			"%dd": "\xDD",
			"%Dd": "\xDD",
			"%dD": "\xDD",
			"%DD": "\xDD",
			"%de": "\xDE",
			"%De": "\xDE",
			"%dE": "\xDE",
			"%DE": "\xDE",
			"%df": "\xDF",
			"%Df": "\xDF",
			"%dF": "\xDF",
			"%DF": "\xDF",
			"%e0": "\xE0",
			"%E0": "\xE0",
			"%e1": "\xE1",
			"%E1": "\xE1",
			"%e2": "\xE2",
			"%E2": "\xE2",
			"%e3": "\xE3",
			"%E3": "\xE3",
			"%e4": "\xE4",
			"%E4": "\xE4",
			"%e5": "\xE5",
			"%E5": "\xE5",
			"%e6": "\xE6",
			"%E6": "\xE6",
			"%e7": "\xE7",
			"%E7": "\xE7",
			"%e8": "\xE8",
			"%E8": "\xE8",
			"%e9": "\xE9",
			"%E9": "\xE9",
			"%ea": "\xEA",
			"%Ea": "\xEA",
			"%eA": "\xEA",
			"%EA": "\xEA",
			"%eb": "\xEB",
			"%Eb": "\xEB",
			"%eB": "\xEB",
			"%EB": "\xEB",
			"%ec": "\xEC",
			"%Ec": "\xEC",
			"%eC": "\xEC",
			"%EC": "\xEC",
			"%ed": "\xED",
			"%Ed": "\xED",
			"%eD": "\xED",
			"%ED": "\xED",
			"%ee": "\xEE",
			"%Ee": "\xEE",
			"%eE": "\xEE",
			"%EE": "\xEE",
			"%ef": "\xEF",
			"%Ef": "\xEF",
			"%eF": "\xEF",
			"%EF": "\xEF",
			"%f0": "\xF0",
			"%F0": "\xF0",
			"%f1": "\xF1",
			"%F1": "\xF1",
			"%f2": "\xF2",
			"%F2": "\xF2",
			"%f3": "\xF3",
			"%F3": "\xF3",
			"%f4": "\xF4",
			"%F4": "\xF4",
			"%f5": "\xF5",
			"%F5": "\xF5",
			"%f6": "\xF6",
			"%F6": "\xF6",
			"%f7": "\xF7",
			"%F7": "\xF7",
			"%f8": "\xF8",
			"%F8": "\xF8",
			"%f9": "\xF9",
			"%F9": "\xF9",
			"%fa": "\xFA",
			"%Fa": "\xFA",
			"%fA": "\xFA",
			"%FA": "\xFA",
			"%fb": "\xFB",
			"%Fb": "\xFB",
			"%fB": "\xFB",
			"%FB": "\xFB",
			"%fc": "\xFC",
			"%Fc": "\xFC",
			"%fC": "\xFC",
			"%FC": "\xFC",
			"%fd": "\xFD",
			"%Fd": "\xFD",
			"%fD": "\xFD",
			"%FD": "\xFD",
			"%fe": "\xFE",
			"%Fe": "\xFE",
			"%fE": "\xFE",
			"%FE": "\xFE",
			"%ff": "\xFF",
			"%Ff": "\xFF",
			"%fF": "\xFF",
			"%FF": "\xFF",
		};
		function encodedReplacer(match) {
			return EncodedLookup[match];
		}
		var STATE_KEY = 0;
		var STATE_VALUE = 1;
		var STATE_CHARSET = 2;
		var STATE_LANG = 3;
		function parseParams(str) {
			const res = [];
			let state = STATE_KEY;
			let charset = "";
			let inquote = false;
			let escaping = false;
			let p = 0;
			let tmp = "";
			const len = str.length;
			for (var i = 0; i < len; ++i) {
				const char = str[i];
				if (char === "\\" && inquote) {
					if (escaping) {
						escaping = false;
					} else {
						escaping = true;
						continue;
					}
				} else if (char === '"') {
					if (!escaping) {
						if (inquote) {
							inquote = false;
							state = STATE_KEY;
						} else {
							inquote = true;
						}
						continue;
					} else {
						escaping = false;
					}
				} else {
					if (escaping && inquote) {
						tmp += "\\";
					}
					escaping = false;
					if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
						if (state === STATE_CHARSET) {
							state = STATE_LANG;
							charset = tmp.substring(1);
						} else {
							state = STATE_VALUE;
						}
						tmp = "";
						continue;
					} else if (
						state === STATE_KEY &&
						(char === "*" || char === "=") &&
						res.length
					) {
						state = char === "*" ? STATE_CHARSET : STATE_VALUE;
						res[p] = [tmp, void 0];
						tmp = "";
						continue;
					} else if (!inquote && char === ";") {
						state = STATE_KEY;
						if (charset) {
							if (tmp.length) {
								tmp = decodeText(
									tmp.replace(RE_ENCODED, encodedReplacer),
									"binary",
									charset,
								);
							}
							charset = "";
						} else if (tmp.length) {
							tmp = decodeText(tmp, "binary", "utf8");
						}
						if (res[p] === void 0) {
							res[p] = tmp;
						} else {
							res[p][1] = tmp;
						}
						tmp = "";
						++p;
						continue;
					} else if (!inquote && (char === " " || char === "	")) {
						continue;
					}
				}
				tmp += char;
			}
			if (charset && tmp.length) {
				tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer), "binary", charset);
			} else if (tmp) {
				tmp = decodeText(tmp, "binary", "utf8");
			}
			if (res[p] === void 0) {
				if (tmp) {
					res[p] = tmp;
				}
			} else {
				res[p][1] = tmp;
			}
			return res;
		}
		module2.exports = parseParams;
	},
});

// node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/basename.js
var require_basename = __commonJS({
	"node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/basename.js"(
		exports2,
		module2,
	) {
		"use strict";
		module2.exports = function basename(path) {
			if (typeof path !== "string") {
				return "";
			}
			for (var i = path.length - 1; i >= 0; --i) {
				switch (path.charCodeAt(i)) {
					case 47:
					// '/'
					case 92:
						path = path.slice(i + 1);
						return path === ".." || path === "." ? "" : path;
				}
			}
			return path === ".." || path === "." ? "" : path;
		};
	},
});

// node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/types/multipart.js
var require_multipart = __commonJS({
	"node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/types/multipart.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { Readable } = require("stream");
		var { inherits } = require("util");
		var Dicer = require_Dicer();
		var parseParams = require_parseParams();
		var decodeText = require_decodeText();
		var basename = require_basename();
		var getLimit = require_getLimit();
		var RE_BOUNDARY = /^boundary$/i;
		var RE_FIELD = /^form-data$/i;
		var RE_CHARSET = /^charset$/i;
		var RE_FILENAME = /^filename$/i;
		var RE_NAME = /^name$/i;
		Multipart.detect = /^multipart\/form-data/i;
		function Multipart(boy, cfg) {
			let i;
			let len;
			const self2 = this;
			let boundary;
			const limits = cfg.limits;
			const isPartAFile =
				cfg.isPartAFile ||
				((fieldName, contentType, fileName) =>
					contentType === "application/octet-stream" || fileName !== void 0);
			const parsedConType = cfg.parsedConType || [];
			const defCharset = cfg.defCharset || "utf8";
			const preservePath = cfg.preservePath;
			const fileOpts = { highWaterMark: cfg.fileHwm };
			for (i = 0, len = parsedConType.length; i < len; ++i) {
				if (Array.isArray(parsedConType[i]) && RE_BOUNDARY.test(parsedConType[i][0])) {
					boundary = parsedConType[i][1];
					break;
				}
			}
			function checkFinished() {
				if (nends === 0 && finished && !boy._done) {
					finished = false;
					self2.end();
				}
			}
			if (typeof boundary !== "string") {
				throw new Error("Multipart: Boundary not found");
			}
			const fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
			const fileSizeLimit = getLimit(limits, "fileSize", Infinity);
			const filesLimit = getLimit(limits, "files", Infinity);
			const fieldsLimit = getLimit(limits, "fields", Infinity);
			const partsLimit = getLimit(limits, "parts", Infinity);
			const headerPairsLimit = getLimit(limits, "headerPairs", 2e3);
			const headerSizeLimit = getLimit(limits, "headerSize", 80 * 1024);
			let nfiles = 0;
			let nfields = 0;
			let nends = 0;
			let curFile;
			let curField;
			let finished = false;
			this._needDrain = false;
			this._pause = false;
			this._cb = void 0;
			this._nparts = 0;
			this._boy = boy;
			const parserCfg = {
				boundary,
				maxHeaderPairs: headerPairsLimit,
				maxHeaderSize: headerSizeLimit,
				partHwm: fileOpts.highWaterMark,
				highWaterMark: cfg.highWaterMark,
			};
			this.parser = new Dicer(parserCfg);
			this.parser
				.on("drain", function () {
					self2._needDrain = false;
					if (self2._cb && !self2._pause) {
						const cb = self2._cb;
						self2._cb = void 0;
						cb();
					}
				})
				.on("part", function onPart(part) {
					if (++self2._nparts > partsLimit) {
						self2.parser.removeListener("part", onPart);
						self2.parser.on("part", skipPart);
						boy.hitPartsLimit = true;
						boy.emit("partsLimit");
						return skipPart(part);
					}
					if (curField) {
						const field = curField;
						field.emit("end");
						field.removeAllListeners("end");
					}
					part.on("header", function (header) {
						let contype;
						let fieldname;
						let parsed;
						let charset;
						let encoding;
						let filename;
						let nsize = 0;
						if (header["content-type"]) {
							parsed = parseParams(header["content-type"][0]);
							if (parsed[0]) {
								contype = parsed[0].toLowerCase();
								for (i = 0, len = parsed.length; i < len; ++i) {
									if (RE_CHARSET.test(parsed[i][0])) {
										charset = parsed[i][1].toLowerCase();
										break;
									}
								}
							}
						}
						if (contype === void 0) {
							contype = "text/plain";
						}
						if (charset === void 0) {
							charset = defCharset;
						}
						if (header["content-disposition"]) {
							parsed = parseParams(header["content-disposition"][0]);
							if (!RE_FIELD.test(parsed[0])) {
								return skipPart(part);
							}
							for (i = 0, len = parsed.length; i < len; ++i) {
								if (RE_NAME.test(parsed[i][0])) {
									fieldname = parsed[i][1];
								} else if (RE_FILENAME.test(parsed[i][0])) {
									filename = parsed[i][1];
									if (!preservePath) {
										filename = basename(filename);
									}
								}
							}
						} else {
							return skipPart(part);
						}
						if (header["content-transfer-encoding"]) {
							encoding = header["content-transfer-encoding"][0].toLowerCase();
						} else {
							encoding = "7bit";
						}
						let onData, onEnd;
						if (isPartAFile(fieldname, contype, filename)) {
							if (nfiles === filesLimit) {
								if (!boy.hitFilesLimit) {
									boy.hitFilesLimit = true;
									boy.emit("filesLimit");
								}
								return skipPart(part);
							}
							++nfiles;
							if (boy.listenerCount("file") === 0) {
								self2.parser._ignore();
								return;
							}
							++nends;
							const file = new FileStream(fileOpts);
							curFile = file;
							file.on("end", function () {
								--nends;
								self2._pause = false;
								checkFinished();
								if (self2._cb && !self2._needDrain) {
									const cb = self2._cb;
									self2._cb = void 0;
									cb();
								}
							});
							file._read = function (n) {
								if (!self2._pause) {
									return;
								}
								self2._pause = false;
								if (self2._cb && !self2._needDrain) {
									const cb = self2._cb;
									self2._cb = void 0;
									cb();
								}
							};
							boy.emit("file", fieldname, file, filename, encoding, contype);
							onData = function (data) {
								if ((nsize += data.length) > fileSizeLimit) {
									const extralen = fileSizeLimit - nsize + data.length;
									if (extralen > 0) {
										file.push(data.slice(0, extralen));
									}
									file.truncated = true;
									file.bytesRead = fileSizeLimit;
									part.removeAllListeners("data");
									file.emit("limit");
									return;
								} else if (!file.push(data)) {
									self2._pause = true;
								}
								file.bytesRead = nsize;
							};
							onEnd = function () {
								curFile = void 0;
								file.push(null);
							};
						} else {
							if (nfields === fieldsLimit) {
								if (!boy.hitFieldsLimit) {
									boy.hitFieldsLimit = true;
									boy.emit("fieldsLimit");
								}
								return skipPart(part);
							}
							++nfields;
							++nends;
							let buffer = "";
							let truncated = false;
							curField = part;
							onData = function (data) {
								if ((nsize += data.length) > fieldSizeLimit) {
									const extralen = fieldSizeLimit - (nsize - data.length);
									buffer += data.toString("binary", 0, extralen);
									truncated = true;
									part.removeAllListeners("data");
								} else {
									buffer += data.toString("binary");
								}
							};
							onEnd = function () {
								curField = void 0;
								if (buffer.length) {
									buffer = decodeText(buffer, "binary", charset);
								}
								boy.emit(
									"field",
									fieldname,
									buffer,
									false,
									truncated,
									encoding,
									contype,
								);
								--nends;
								checkFinished();
							};
						}
						part._readableState.sync = false;
						part.on("data", onData);
						part.on("end", onEnd);
					}).on("error", function (err) {
						if (curFile) {
							curFile.emit("error", err);
						}
					});
				})
				.on("error", function (err) {
					boy.emit("error", err);
				})
				.on("finish", function () {
					finished = true;
					checkFinished();
				});
		}
		Multipart.prototype.write = function (chunk, cb) {
			const r = this.parser.write(chunk);
			if (r && !this._pause) {
				cb();
			} else {
				this._needDrain = !r;
				this._cb = cb;
			}
		};
		Multipart.prototype.end = function () {
			const self2 = this;
			if (self2.parser.writable) {
				self2.parser.end();
			} else if (!self2._boy._done) {
				process.nextTick(function () {
					self2._boy._done = true;
					self2._boy.emit("finish");
				});
			}
		};
		function skipPart(part) {
			part.resume();
		}
		function FileStream(opts) {
			Readable.call(this, opts);
			this.bytesRead = 0;
			this.truncated = false;
		}
		inherits(FileStream, Readable);
		FileStream.prototype._read = function (n) {};
		module2.exports = Multipart;
	},
});

// node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/Decoder.js
var require_Decoder = __commonJS({
	"node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/Decoder.js"(
		exports2,
		module2,
	) {
		"use strict";
		var RE_PLUS = /\+/g;
		var HEX = [
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		];
		function Decoder() {
			this.buffer = void 0;
		}
		Decoder.prototype.write = function (str) {
			str = str.replace(RE_PLUS, " ");
			let res = "";
			let i = 0;
			let p = 0;
			const len = str.length;
			for (; i < len; ++i) {
				if (this.buffer !== void 0) {
					if (!HEX[str.charCodeAt(i)]) {
						res += "%" + this.buffer;
						this.buffer = void 0;
						--i;
					} else {
						this.buffer += str[i];
						++p;
						if (this.buffer.length === 2) {
							res += String.fromCharCode(parseInt(this.buffer, 16));
							this.buffer = void 0;
						}
					}
				} else if (str[i] === "%") {
					if (i > p) {
						res += str.substring(p, i);
						p = i;
					}
					this.buffer = "";
					++p;
				}
			}
			if (p < len && this.buffer === void 0) {
				res += str.substring(p);
			}
			return res;
		};
		Decoder.prototype.reset = function () {
			this.buffer = void 0;
		};
		module2.exports = Decoder;
	},
});

// node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS({
	"node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/types/urlencoded.js"(
		exports2,
		module2,
	) {
		"use strict";
		var Decoder = require_Decoder();
		var decodeText = require_decodeText();
		var getLimit = require_getLimit();
		var RE_CHARSET = /^charset$/i;
		UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
		function UrlEncoded(boy, cfg) {
			const limits = cfg.limits;
			const parsedConType = cfg.parsedConType;
			this.boy = boy;
			this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
			this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100);
			this.fieldsLimit = getLimit(limits, "fields", Infinity);
			let charset;
			for (var i = 0, len = parsedConType.length; i < len; ++i) {
				if (Array.isArray(parsedConType[i]) && RE_CHARSET.test(parsedConType[i][0])) {
					charset = parsedConType[i][1].toLowerCase();
					break;
				}
			}
			if (charset === void 0) {
				charset = cfg.defCharset || "utf8";
			}
			this.decoder = new Decoder();
			this.charset = charset;
			this._fields = 0;
			this._state = "key";
			this._checkingBytes = true;
			this._bytesKey = 0;
			this._bytesVal = 0;
			this._key = "";
			this._val = "";
			this._keyTrunc = false;
			this._valTrunc = false;
			this._hitLimit = false;
		}
		UrlEncoded.prototype.write = function (data, cb) {
			if (this._fields === this.fieldsLimit) {
				if (!this.boy.hitFieldsLimit) {
					this.boy.hitFieldsLimit = true;
					this.boy.emit("fieldsLimit");
				}
				return cb();
			}
			let idxeq;
			let idxamp;
			let i;
			let p = 0;
			const len = data.length;
			while (p < len) {
				if (this._state === "key") {
					idxeq = idxamp = void 0;
					for (i = p; i < len; ++i) {
						if (!this._checkingBytes) {
							++p;
						}
						if (data[i] === 61) {
							idxeq = i;
							break;
						} else if (data[i] === 38) {
							idxamp = i;
							break;
						}
						if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
							this._hitLimit = true;
							break;
						} else if (this._checkingBytes) {
							++this._bytesKey;
						}
					}
					if (idxeq !== void 0) {
						if (idxeq > p) {
							this._key += this.decoder.write(data.toString("binary", p, idxeq));
						}
						this._state = "val";
						this._hitLimit = false;
						this._checkingBytes = true;
						this._val = "";
						this._bytesVal = 0;
						this._valTrunc = false;
						this.decoder.reset();
						p = idxeq + 1;
					} else if (idxamp !== void 0) {
						++this._fields;
						let key;
						const keyTrunc = this._keyTrunc;
						if (idxamp > p) {
							key = this._key += this.decoder.write(
								data.toString("binary", p, idxamp),
							);
						} else {
							key = this._key;
						}
						this._hitLimit = false;
						this._checkingBytes = true;
						this._key = "";
						this._bytesKey = 0;
						this._keyTrunc = false;
						this.decoder.reset();
						if (key.length) {
							this.boy.emit(
								"field",
								decodeText(key, "binary", this.charset),
								"",
								keyTrunc,
								false,
							);
						}
						p = idxamp + 1;
						if (this._fields === this.fieldsLimit) {
							return cb();
						}
					} else if (this._hitLimit) {
						if (i > p) {
							this._key += this.decoder.write(data.toString("binary", p, i));
						}
						p = i;
						if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
							this._checkingBytes = false;
							this._keyTrunc = true;
						}
					} else {
						if (p < len) {
							this._key += this.decoder.write(data.toString("binary", p));
						}
						p = len;
					}
				} else {
					idxamp = void 0;
					for (i = p; i < len; ++i) {
						if (!this._checkingBytes) {
							++p;
						}
						if (data[i] === 38) {
							idxamp = i;
							break;
						}
						if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
							this._hitLimit = true;
							break;
						} else if (this._checkingBytes) {
							++this._bytesVal;
						}
					}
					if (idxamp !== void 0) {
						++this._fields;
						if (idxamp > p) {
							this._val += this.decoder.write(data.toString("binary", p, idxamp));
						}
						this.boy.emit(
							"field",
							decodeText(this._key, "binary", this.charset),
							decodeText(this._val, "binary", this.charset),
							this._keyTrunc,
							this._valTrunc,
						);
						this._state = "key";
						this._hitLimit = false;
						this._checkingBytes = true;
						this._key = "";
						this._bytesKey = 0;
						this._keyTrunc = false;
						this.decoder.reset();
						p = idxamp + 1;
						if (this._fields === this.fieldsLimit) {
							return cb();
						}
					} else if (this._hitLimit) {
						if (i > p) {
							this._val += this.decoder.write(data.toString("binary", p, i));
						}
						p = i;
						if (
							(this._val === "" && this.fieldSizeLimit === 0) ||
							(this._bytesVal = this._val.length) === this.fieldSizeLimit
						) {
							this._checkingBytes = false;
							this._valTrunc = true;
						}
					} else {
						if (p < len) {
							this._val += this.decoder.write(data.toString("binary", p));
						}
						p = len;
					}
				}
			}
			cb();
		};
		UrlEncoded.prototype.end = function () {
			if (this.boy._done) {
				return;
			}
			if (this._state === "key" && this._key.length > 0) {
				this.boy.emit(
					"field",
					decodeText(this._key, "binary", this.charset),
					"",
					this._keyTrunc,
					false,
				);
			} else if (this._state === "val") {
				this.boy.emit(
					"field",
					decodeText(this._key, "binary", this.charset),
					decodeText(this._val, "binary", this.charset),
					this._keyTrunc,
					this._valTrunc,
				);
			}
			this.boy._done = true;
			this.boy.emit("finish");
		};
		module2.exports = UrlEncoded;
	},
});

// node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/main.js
var require_main = __commonJS({
	"node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/main.js"(
		exports2,
		module2,
	) {
		"use strict";
		var WritableStream = require("stream").Writable;
		var { inherits } = require("util");
		var Dicer = require_Dicer();
		var MultipartParser = require_multipart();
		var UrlencodedParser = require_urlencoded();
		var parseParams = require_parseParams();
		function Busboy(opts) {
			if (!(this instanceof Busboy)) {
				return new Busboy(opts);
			}
			if (typeof opts !== "object") {
				throw new TypeError("Busboy expected an options-Object.");
			}
			if (typeof opts.headers !== "object") {
				throw new TypeError("Busboy expected an options-Object with headers-attribute.");
			}
			if (typeof opts.headers["content-type"] !== "string") {
				throw new TypeError("Missing Content-Type-header.");
			}
			const { headers, ...streamOptions } = opts;
			this.opts = {
				autoDestroy: false,
				...streamOptions,
			};
			WritableStream.call(this, this.opts);
			this._done = false;
			this._parser = this.getParserByHeaders(headers);
			this._finished = false;
		}
		inherits(Busboy, WritableStream);
		Busboy.prototype.emit = function (ev) {
			if (ev === "finish") {
				if (!this._done) {
					this._parser?.end();
					return;
				} else if (this._finished) {
					return;
				}
				this._finished = true;
			}
			WritableStream.prototype.emit.apply(this, arguments);
		};
		Busboy.prototype.getParserByHeaders = function (headers) {
			const parsed = parseParams(headers["content-type"]);
			const cfg = {
				defCharset: this.opts.defCharset,
				fileHwm: this.opts.fileHwm,
				headers,
				highWaterMark: this.opts.highWaterMark,
				isPartAFile: this.opts.isPartAFile,
				limits: this.opts.limits,
				parsedConType: parsed,
				preservePath: this.opts.preservePath,
			};
			if (MultipartParser.detect.test(parsed[0])) {
				return new MultipartParser(this, cfg);
			}
			if (UrlencodedParser.detect.test(parsed[0])) {
				return new UrlencodedParser(this, cfg);
			}
			throw new Error("Unsupported Content-Type.");
		};
		Busboy.prototype._write = function (chunk, encoding, cb) {
			this._parser.write(chunk, cb);
		};
		module2.exports = Busboy;
		module2.exports.default = Busboy;
		module2.exports.Busboy = Busboy;
		module2.exports.Dicer = Dicer;
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/constants.js
var require_constants3 = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/constants.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { MessageChannel, receiveMessageOnPort } = require("worker_threads");
		var corsSafeListedMethods = ["GET", "HEAD", "POST"];
		var corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
		var nullBodyStatus = [101, 204, 205, 304];
		var redirectStatus = [301, 302, 303, 307, 308];
		var redirectStatusSet = new Set(redirectStatus);
		var badPorts = [
			"1",
			"7",
			"9",
			"11",
			"13",
			"15",
			"17",
			"19",
			"20",
			"21",
			"22",
			"23",
			"25",
			"37",
			"42",
			"43",
			"53",
			"69",
			"77",
			"79",
			"87",
			"95",
			"101",
			"102",
			"103",
			"104",
			"109",
			"110",
			"111",
			"113",
			"115",
			"117",
			"119",
			"123",
			"135",
			"137",
			"139",
			"143",
			"161",
			"179",
			"389",
			"427",
			"465",
			"512",
			"513",
			"514",
			"515",
			"526",
			"530",
			"531",
			"532",
			"540",
			"548",
			"554",
			"556",
			"563",
			"587",
			"601",
			"636",
			"989",
			"990",
			"993",
			"995",
			"1719",
			"1720",
			"1723",
			"2049",
			"3659",
			"4045",
			"5060",
			"5061",
			"6000",
			"6566",
			"6665",
			"6666",
			"6667",
			"6668",
			"6669",
			"6697",
			"10080",
		];
		var badPortsSet = new Set(badPorts);
		var referrerPolicy = [
			"",
			"no-referrer",
			"no-referrer-when-downgrade",
			"same-origin",
			"origin",
			"strict-origin",
			"origin-when-cross-origin",
			"strict-origin-when-cross-origin",
			"unsafe-url",
		];
		var referrerPolicySet = new Set(referrerPolicy);
		var requestRedirect = ["follow", "manual", "error"];
		var safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
		var safeMethodsSet = new Set(safeMethods);
		var requestMode = ["navigate", "same-origin", "no-cors", "cors"];
		var requestCredentials = ["omit", "same-origin", "include"];
		var requestCache = [
			"default",
			"no-store",
			"reload",
			"no-cache",
			"force-cache",
			"only-if-cached",
		];
		var requestBodyHeader = [
			"content-encoding",
			"content-language",
			"content-location",
			"content-type",
			// See https://github.com/nodejs/undici/issues/2021
			// 'Content-Length' is a forbidden header name, which is typically
			// removed in the Headers implementation. However, undici doesn't
			// filter out headers, so we add it here.
			"content-length",
		];
		var requestDuplex = ["half"];
		var forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
		var forbiddenMethodsSet = new Set(forbiddenMethods);
		var subresource = [
			"audio",
			"audioworklet",
			"font",
			"image",
			"manifest",
			"paintworklet",
			"script",
			"style",
			"track",
			"video",
			"xslt",
			"",
		];
		var subresourceSet = new Set(subresource);
		var DOMException2 =
			globalThis.DOMException ??
			(() => {
				try {
					atob("~");
				} catch (err) {
					return Object.getPrototypeOf(err).constructor;
				}
			})();
		var channel;
		var structuredClone =
			globalThis.structuredClone ?? // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js
			// structuredClone was added in v17.0.0, but fetch supports v16.8
			function structuredClone2(value, options = void 0) {
				if (arguments.length === 0) {
					throw new TypeError("missing argument");
				}
				if (!channel) {
					channel = new MessageChannel();
				}
				channel.port1.unref();
				channel.port2.unref();
				channel.port1.postMessage(value, options?.transfer);
				return receiveMessageOnPort(channel.port2).message;
			};
		module2.exports = {
			DOMException: DOMException2,
			structuredClone,
			subresource,
			forbiddenMethods,
			requestBodyHeader,
			referrerPolicy,
			requestRedirect,
			requestMode,
			requestCredentials,
			requestCache,
			redirectStatus,
			corsSafeListedMethods,
			nullBodyStatus,
			safeMethods,
			badPorts,
			requestDuplex,
			subresourceSet,
			badPortsSet,
			redirectStatusSet,
			corsSafeListedMethodsSet,
			safeMethodsSet,
			forbiddenMethodsSet,
			referrerPolicySet,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/global.js
var require_global = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/global.js"(exports2, module2) {
		"use strict";
		var globalOrigin = Symbol.for("undici.globalOrigin.1");
		function getGlobalOrigin() {
			return globalThis[globalOrigin];
		}
		function setGlobalOrigin(newOrigin) {
			if (newOrigin === void 0) {
				Object.defineProperty(globalThis, globalOrigin, {
					value: void 0,
					writable: true,
					enumerable: false,
					configurable: false,
				});
				return;
			}
			const parsedURL = new URL(newOrigin);
			if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
				throw new TypeError(
					`Only http & https urls are allowed, received ${parsedURL.protocol}`,
				);
			}
			Object.defineProperty(globalThis, globalOrigin, {
				value: parsedURL,
				writable: true,
				enumerable: false,
				configurable: false,
			});
		}
		module2.exports = {
			getGlobalOrigin,
			setGlobalOrigin,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/util.js
var require_util3 = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/util.js"(exports2, module2) {
		"use strict";
		var {
			redirectStatusSet,
			referrerPolicySet: referrerPolicyTokens,
			badPortsSet,
		} = require_constants3();
		var { getGlobalOrigin } = require_global();
		var { performance: performance2 } = require("perf_hooks");
		var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util2();
		var assert = require("assert");
		var { isUint8Array } = require("util/types");
		var supportedHashes = [];
		var crypto;
		try {
			crypto = require("crypto");
			const possibleRelevantHashes = ["sha256", "sha384", "sha512"];
			supportedHashes = crypto
				.getHashes()
				.filter((hash) => possibleRelevantHashes.includes(hash));
		} catch {}
		function responseURL(response) {
			const urlList = response.urlList;
			const length = urlList.length;
			return length === 0 ? null : urlList[length - 1].toString();
		}
		function responseLocationURL(response, requestFragment) {
			if (!redirectStatusSet.has(response.status)) {
				return null;
			}
			let location = response.headersList.get("location");
			if (location !== null && isValidHeaderValue(location)) {
				location = new URL(location, responseURL(response));
			}
			if (location && !location.hash) {
				location.hash = requestFragment;
			}
			return location;
		}
		function requestCurrentURL(request) {
			return request.urlList[request.urlList.length - 1];
		}
		function requestBadPort(request) {
			const url = requestCurrentURL(request);
			if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
				return "blocked";
			}
			return "allowed";
		}
		function isErrorLike(object) {
			return (
				object instanceof Error ||
				object?.constructor?.name === "Error" ||
				object?.constructor?.name === "DOMException"
			);
		}
		function isValidReasonPhrase(statusText) {
			for (let i = 0; i < statusText.length; ++i) {
				const c = statusText.charCodeAt(i);
				if (
					!(
						c === 9 || // HTAB
						(c >= 32 && c <= 126) || // SP / VCHAR
						(c >= 128 && c <= 255)
					)
				) {
					return false;
				}
			}
			return true;
		}
		function isTokenCharCode(c) {
			switch (c) {
				case 34:
				case 40:
				case 41:
				case 44:
				case 47:
				case 58:
				case 59:
				case 60:
				case 61:
				case 62:
				case 63:
				case 64:
				case 91:
				case 92:
				case 93:
				case 123:
				case 125:
					return false;
				default:
					return c >= 33 && c <= 126;
			}
		}
		function isValidHTTPToken(characters) {
			if (characters.length === 0) {
				return false;
			}
			for (let i = 0; i < characters.length; ++i) {
				if (!isTokenCharCode(characters.charCodeAt(i))) {
					return false;
				}
			}
			return true;
		}
		function isValidHeaderName(potentialValue) {
			return isValidHTTPToken(potentialValue);
		}
		function isValidHeaderValue(potentialValue) {
			if (
				potentialValue.startsWith("	") ||
				potentialValue.startsWith(" ") ||
				potentialValue.endsWith("	") ||
				potentialValue.endsWith(" ")
			) {
				return false;
			}
			if (
				potentialValue.includes("\0") ||
				potentialValue.includes("\r") ||
				potentialValue.includes("\n")
			) {
				return false;
			}
			return true;
		}
		function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
			const { headersList } = actualResponse;
			const policyHeader = (headersList.get("referrer-policy") ?? "").split(",");
			let policy = "";
			if (policyHeader.length > 0) {
				for (let i = policyHeader.length; i !== 0; i--) {
					const token = policyHeader[i - 1].trim();
					if (referrerPolicyTokens.has(token)) {
						policy = token;
						break;
					}
				}
			}
			if (policy !== "") {
				request.referrerPolicy = policy;
			}
		}
		function crossOriginResourcePolicyCheck() {
			return "allowed";
		}
		function corsCheck() {
			return "success";
		}
		function TAOCheck() {
			return "success";
		}
		function appendFetchMetadata(httpRequest) {
			let header = null;
			header = httpRequest.mode;
			httpRequest.headersList.set("sec-fetch-mode", header);
		}
		function appendRequestOriginHeader(request) {
			let serializedOrigin = request.origin;
			if (request.responseTainting === "cors" || request.mode === "websocket") {
				if (serializedOrigin) {
					request.headersList.append("origin", serializedOrigin);
				}
			} else if (request.method !== "GET" && request.method !== "HEAD") {
				switch (request.referrerPolicy) {
					case "no-referrer":
						serializedOrigin = null;
						break;
					case "no-referrer-when-downgrade":
					case "strict-origin":
					case "strict-origin-when-cross-origin":
						if (
							request.origin &&
							urlHasHttpsScheme(request.origin) &&
							!urlHasHttpsScheme(requestCurrentURL(request))
						) {
							serializedOrigin = null;
						}
						break;
					case "same-origin":
						if (!sameOrigin(request, requestCurrentURL(request))) {
							serializedOrigin = null;
						}
						break;
					default:
				}
				if (serializedOrigin) {
					request.headersList.append("origin", serializedOrigin);
				}
			}
		}
		function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
			return performance2.now();
		}
		function createOpaqueTimingInfo(timingInfo) {
			return {
				startTime: timingInfo.startTime ?? 0,
				redirectStartTime: 0,
				redirectEndTime: 0,
				postRedirectStartTime: timingInfo.startTime ?? 0,
				finalServiceWorkerStartTime: 0,
				finalNetworkResponseStartTime: 0,
				finalNetworkRequestStartTime: 0,
				endTime: 0,
				encodedBodySize: 0,
				decodedBodySize: 0,
				finalConnectionTimingInfo: null,
			};
		}
		function makePolicyContainer() {
			return {
				referrerPolicy: "strict-origin-when-cross-origin",
			};
		}
		function clonePolicyContainer(policyContainer) {
			return {
				referrerPolicy: policyContainer.referrerPolicy,
			};
		}
		function determineRequestsReferrer(request) {
			const policy = request.referrerPolicy;
			assert(policy);
			let referrerSource = null;
			if (request.referrer === "client") {
				const globalOrigin = getGlobalOrigin();
				if (!globalOrigin || globalOrigin.origin === "null") {
					return "no-referrer";
				}
				referrerSource = new URL(globalOrigin);
			} else if (request.referrer instanceof URL) {
				referrerSource = request.referrer;
			}
			let referrerURL = stripURLForReferrer(referrerSource);
			const referrerOrigin = stripURLForReferrer(referrerSource, true);
			if (referrerURL.toString().length > 4096) {
				referrerURL = referrerOrigin;
			}
			const areSameOrigin = sameOrigin(request, referrerURL);
			const isNonPotentiallyTrustWorthy =
				isURLPotentiallyTrustworthy(referrerURL) &&
				!isURLPotentiallyTrustworthy(request.url);
			switch (policy) {
				case "origin":
					return referrerOrigin != null
						? referrerOrigin
						: stripURLForReferrer(referrerSource, true);
				case "unsafe-url":
					return referrerURL;
				case "same-origin":
					return areSameOrigin ? referrerOrigin : "no-referrer";
				case "origin-when-cross-origin":
					return areSameOrigin ? referrerURL : referrerOrigin;
				case "strict-origin-when-cross-origin": {
					const currentURL = requestCurrentURL(request);
					if (sameOrigin(referrerURL, currentURL)) {
						return referrerURL;
					}
					if (
						isURLPotentiallyTrustworthy(referrerURL) &&
						!isURLPotentiallyTrustworthy(currentURL)
					) {
						return "no-referrer";
					}
					return referrerOrigin;
				}
				case "strict-origin":
				// eslint-disable-line
				/**
				 * 1. If referrerURL is a potentially trustworthy URL and
				 * requests current URL is not a potentially trustworthy URL,
				 * then return no referrer.
				 * 2. Return referrerOrigin
				 */
				case "no-referrer-when-downgrade":
				// eslint-disable-line
				/**
				 * 1. If referrerURL is a potentially trustworthy URL and
				 * requests current URL is not a potentially trustworthy URL,
				 * then return no referrer.
				 * 2. Return referrerOrigin
				 */
				default:
					return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
			}
		}
		function stripURLForReferrer(url, originOnly) {
			assert(url instanceof URL);
			if (
				url.protocol === "file:" ||
				url.protocol === "about:" ||
				url.protocol === "blank:"
			) {
				return "no-referrer";
			}
			url.username = "";
			url.password = "";
			url.hash = "";
			if (originOnly) {
				url.pathname = "";
				url.search = "";
			}
			return url;
		}
		function isURLPotentiallyTrustworthy(url) {
			if (!(url instanceof URL)) {
				return false;
			}
			if (url.href === "about:blank" || url.href === "about:srcdoc") {
				return true;
			}
			if (url.protocol === "data:") return true;
			if (url.protocol === "file:") return true;
			return isOriginPotentiallyTrustworthy(url.origin);
			function isOriginPotentiallyTrustworthy(origin) {
				if (origin == null || origin === "null") return false;
				const originAsURL = new URL(origin);
				if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {
					return true;
				}
				if (
					/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(
						originAsURL.hostname,
					) ||
					originAsURL.hostname === "localhost" ||
					originAsURL.hostname.includes("localhost.") ||
					originAsURL.hostname.endsWith(".localhost")
				) {
					return true;
				}
				return false;
			}
		}
		function bytesMatch(bytes, metadataList) {
			if (crypto === void 0) {
				return true;
			}
			const parsedMetadata = parseMetadata(metadataList);
			if (parsedMetadata === "no metadata") {
				return true;
			}
			if (parsedMetadata.length === 0) {
				return true;
			}
			const strongest = getStrongestMetadata(parsedMetadata);
			const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
			for (const item of metadata) {
				const algorithm = item.algo;
				const expectedValue = item.hash;
				let actualValue = crypto.createHash(algorithm).update(bytes).digest("base64");
				if (actualValue[actualValue.length - 1] === "=") {
					if (actualValue[actualValue.length - 2] === "=") {
						actualValue = actualValue.slice(0, -2);
					} else {
						actualValue = actualValue.slice(0, -1);
					}
				}
				if (compareBase64Mixed(actualValue, expectedValue)) {
					return true;
				}
			}
			return false;
		}
		var parseHashWithOptions =
			/(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
		function parseMetadata(metadata) {
			const result = [];
			let empty = true;
			for (const token of metadata.split(" ")) {
				empty = false;
				const parsedToken = parseHashWithOptions.exec(token);
				if (
					parsedToken === null ||
					parsedToken.groups === void 0 ||
					parsedToken.groups.algo === void 0
				) {
					continue;
				}
				const algorithm = parsedToken.groups.algo.toLowerCase();
				if (supportedHashes.includes(algorithm)) {
					result.push(parsedToken.groups);
				}
			}
			if (empty === true) {
				return "no metadata";
			}
			return result;
		}
		function getStrongestMetadata(metadataList) {
			let algorithm = metadataList[0].algo;
			if (algorithm[3] === "5") {
				return algorithm;
			}
			for (let i = 1; i < metadataList.length; ++i) {
				const metadata = metadataList[i];
				if (metadata.algo[3] === "5") {
					algorithm = "sha512";
					break;
				} else if (algorithm[3] === "3") {
					continue;
				} else if (metadata.algo[3] === "3") {
					algorithm = "sha384";
				}
			}
			return algorithm;
		}
		function filterMetadataListByAlgorithm(metadataList, algorithm) {
			if (metadataList.length === 1) {
				return metadataList;
			}
			let pos = 0;
			for (let i = 0; i < metadataList.length; ++i) {
				if (metadataList[i].algo === algorithm) {
					metadataList[pos++] = metadataList[i];
				}
			}
			metadataList.length = pos;
			return metadataList;
		}
		function compareBase64Mixed(actualValue, expectedValue) {
			if (actualValue.length !== expectedValue.length) {
				return false;
			}
			for (let i = 0; i < actualValue.length; ++i) {
				if (actualValue[i] !== expectedValue[i]) {
					if (
						(actualValue[i] === "+" && expectedValue[i] === "-") ||
						(actualValue[i] === "/" && expectedValue[i] === "_")
					) {
						continue;
					}
					return false;
				}
			}
			return true;
		}
		function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {}
		function sameOrigin(A, B) {
			if (A.origin === B.origin && A.origin === "null") {
				return true;
			}
			if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
				return true;
			}
			return false;
		}
		function createDeferredPromise() {
			let res;
			let rej;
			const promise = new Promise((resolve, reject) => {
				res = resolve;
				rej = reject;
			});
			return { promise, resolve: res, reject: rej };
		}
		function isAborted(fetchParams) {
			return fetchParams.controller.state === "aborted";
		}
		function isCancelled(fetchParams) {
			return (
				fetchParams.controller.state === "aborted" ||
				fetchParams.controller.state === "terminated"
			);
		}
		var normalizeMethodRecord = {
			delete: "DELETE",
			DELETE: "DELETE",
			get: "GET",
			GET: "GET",
			head: "HEAD",
			HEAD: "HEAD",
			options: "OPTIONS",
			OPTIONS: "OPTIONS",
			post: "POST",
			POST: "POST",
			put: "PUT",
			PUT: "PUT",
		};
		Object.setPrototypeOf(normalizeMethodRecord, null);
		function normalizeMethod(method) {
			return normalizeMethodRecord[method.toLowerCase()] ?? method;
		}
		function serializeJavascriptValueToJSONString(value) {
			const result = JSON.stringify(value);
			if (result === void 0) {
				throw new TypeError("Value is not JSON serializable");
			}
			assert(typeof result === "string");
			return result;
		}
		var esIteratorPrototype = Object.getPrototypeOf(
			Object.getPrototypeOf([][Symbol.iterator]()),
		);
		function makeIterator(iterator, name, kind) {
			const object = {
				index: 0,
				kind,
				target: iterator,
			};
			const i = {
				next() {
					if (Object.getPrototypeOf(this) !== i) {
						throw new TypeError(
							`'next' called on an object that does not implement interface ${name} Iterator.`,
						);
					}
					const { index, kind: kind2, target } = object;
					const values = target();
					const len = values.length;
					if (index >= len) {
						return { value: void 0, done: true };
					}
					const pair = values[index];
					object.index = index + 1;
					return iteratorResult(pair, kind2);
				},
				// The class string of an iterator prototype object for a given interface is the
				// result of concatenating the identifier of the interface and the string " Iterator".
				[Symbol.toStringTag]: `${name} Iterator`,
			};
			Object.setPrototypeOf(i, esIteratorPrototype);
			return Object.setPrototypeOf({}, i);
		}
		function iteratorResult(pair, kind) {
			let result;
			switch (kind) {
				case "key": {
					result = pair[0];
					break;
				}
				case "value": {
					result = pair[1];
					break;
				}
				case "key+value": {
					result = pair;
					break;
				}
			}
			return { value: result, done: false };
		}
		async function fullyReadBody(body, processBody, processBodyError) {
			const successSteps = processBody;
			const errorSteps = processBodyError;
			let reader;
			try {
				reader = body.stream.getReader();
			} catch (e) {
				errorSteps(e);
				return;
			}
			try {
				const result = await readAllBytes(reader);
				successSteps(result);
			} catch (e) {
				errorSteps(e);
			}
		}
		var ReadableStream = globalThis.ReadableStream;
		function isReadableStreamLike(stream) {
			if (!ReadableStream) {
				ReadableStream = require("stream/web").ReadableStream;
			}
			return (
				stream instanceof ReadableStream ||
				(stream[Symbol.toStringTag] === "ReadableStream" &&
					typeof stream.tee === "function")
			);
		}
		var MAXIMUM_ARGUMENT_LENGTH = 65535;
		function isomorphicDecode(input) {
			if (input.length < MAXIMUM_ARGUMENT_LENGTH) {
				return String.fromCharCode(...input);
			}
			return input.reduce((previous, current) => previous + String.fromCharCode(current), "");
		}
		function readableStreamClose(controller) {
			try {
				controller.close();
			} catch (err) {
				if (!err.message.includes("Controller is already closed")) {
					throw err;
				}
			}
		}
		function isomorphicEncode(input) {
			for (let i = 0; i < input.length; i++) {
				assert(input.charCodeAt(i) <= 255);
			}
			return input;
		}
		async function readAllBytes(reader) {
			const bytes = [];
			let byteLength = 0;
			while (true) {
				const { done, value: chunk } = await reader.read();
				if (done) {
					return Buffer.concat(bytes, byteLength);
				}
				if (!isUint8Array(chunk)) {
					throw new TypeError("Received non-Uint8Array chunk");
				}
				bytes.push(chunk);
				byteLength += chunk.length;
			}
		}
		function urlIsLocal(url) {
			assert("protocol" in url);
			const protocol = url.protocol;
			return protocol === "about:" || protocol === "blob:" || protocol === "data:";
		}
		function urlHasHttpsScheme(url) {
			if (typeof url === "string") {
				return url.startsWith("https:");
			}
			return url.protocol === "https:";
		}
		function urlIsHttpHttpsScheme(url) {
			assert("protocol" in url);
			const protocol = url.protocol;
			return protocol === "http:" || protocol === "https:";
		}
		var hasOwn =
			Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
		module2.exports = {
			isAborted,
			isCancelled,
			createDeferredPromise,
			ReadableStreamFrom,
			toUSVString,
			tryUpgradeRequestToAPotentiallyTrustworthyURL,
			coarsenedSharedCurrentTime,
			determineRequestsReferrer,
			makePolicyContainer,
			clonePolicyContainer,
			appendFetchMetadata,
			appendRequestOriginHeader,
			TAOCheck,
			corsCheck,
			crossOriginResourcePolicyCheck,
			createOpaqueTimingInfo,
			setRequestReferrerPolicyOnRedirect,
			isValidHTTPToken,
			requestBadPort,
			requestCurrentURL,
			responseURL,
			responseLocationURL,
			isBlobLike,
			isURLPotentiallyTrustworthy,
			isValidReasonPhrase,
			sameOrigin,
			normalizeMethod,
			serializeJavascriptValueToJSONString,
			makeIterator,
			isValidHeaderName,
			isValidHeaderValue,
			hasOwn,
			isErrorLike,
			fullyReadBody,
			bytesMatch,
			isReadableStreamLike,
			readableStreamClose,
			isomorphicEncode,
			isomorphicDecode,
			urlIsLocal,
			urlHasHttpsScheme,
			urlIsHttpHttpsScheme,
			readAllBytes,
			normalizeMethodRecord,
			parseMetadata,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/symbols.js
var require_symbols2 = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/symbols.js"(exports2, module2) {
		"use strict";
		module2.exports = {
			kUrl: Symbol("url"),
			kHeaders: Symbol("headers"),
			kSignal: Symbol("signal"),
			kState: Symbol("state"),
			kGuard: Symbol("guard"),
			kRealm: Symbol("realm"),
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/webidl.js
var require_webidl = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/webidl.js"(exports2, module2) {
		"use strict";
		var { types } = require("util");
		var { hasOwn, toUSVString } = require_util3();
		var webidl = {};
		webidl.converters = {};
		webidl.util = {};
		webidl.errors = {};
		webidl.errors.exception = function (message) {
			return new TypeError(`${message.header}: ${message.message}`);
		};
		webidl.errors.conversionFailed = function (context) {
			const plural = context.types.length === 1 ? "" : " one of";
			const message = `${context.argument} could not be converted to${plural}: ${context.types.join(", ")}.`;
			return webidl.errors.exception({
				header: context.prefix,
				message,
			});
		};
		webidl.errors.invalidArgument = function (context) {
			return webidl.errors.exception({
				header: context.prefix,
				message: `"${context.value}" is an invalid ${context.type}.`,
			});
		};
		webidl.brandCheck = function (V, I, opts = void 0) {
			if (opts?.strict !== false && !(V instanceof I)) {
				throw new TypeError("Illegal invocation");
			} else {
				return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];
			}
		};
		webidl.argumentLengthCheck = function ({ length }, min, ctx) {
			if (length < min) {
				throw webidl.errors.exception({
					message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
					...ctx,
				});
			}
		};
		webidl.illegalConstructor = function () {
			throw webidl.errors.exception({
				header: "TypeError",
				message: "Illegal constructor",
			});
		};
		webidl.util.Type = function (V) {
			switch (typeof V) {
				case "undefined":
					return "Undefined";
				case "boolean":
					return "Boolean";
				case "string":
					return "String";
				case "symbol":
					return "Symbol";
				case "number":
					return "Number";
				case "bigint":
					return "BigInt";
				case "function":
				case "object": {
					if (V === null) {
						return "Null";
					}
					return "Object";
				}
			}
		};
		webidl.util.ConvertToInt = function (V, bitLength, signedness, opts = {}) {
			let upperBound;
			let lowerBound;
			if (bitLength === 64) {
				upperBound = Math.pow(2, 53) - 1;
				if (signedness === "unsigned") {
					lowerBound = 0;
				} else {
					lowerBound = Math.pow(-2, 53) + 1;
				}
			} else if (signedness === "unsigned") {
				lowerBound = 0;
				upperBound = Math.pow(2, bitLength) - 1;
			} else {
				lowerBound = Math.pow(-2, bitLength) - 1;
				upperBound = Math.pow(2, bitLength - 1) - 1;
			}
			let x = Number(V);
			if (x === 0) {
				x = 0;
			}
			if (opts.enforceRange === true) {
				if (
					Number.isNaN(x) ||
					x === Number.POSITIVE_INFINITY ||
					x === Number.NEGATIVE_INFINITY
				) {
					throw webidl.errors.exception({
						header: "Integer conversion",
						message: `Could not convert ${V} to an integer.`,
					});
				}
				x = webidl.util.IntegerPart(x);
				if (x < lowerBound || x > upperBound) {
					throw webidl.errors.exception({
						header: "Integer conversion",
						message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`,
					});
				}
				return x;
			}
			if (!Number.isNaN(x) && opts.clamp === true) {
				x = Math.min(Math.max(x, lowerBound), upperBound);
				if (Math.floor(x) % 2 === 0) {
					x = Math.floor(x);
				} else {
					x = Math.ceil(x);
				}
				return x;
			}
			if (
				Number.isNaN(x) ||
				(x === 0 && Object.is(0, x)) ||
				x === Number.POSITIVE_INFINITY ||
				x === Number.NEGATIVE_INFINITY
			) {
				return 0;
			}
			x = webidl.util.IntegerPart(x);
			x = x % Math.pow(2, bitLength);
			if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
				return x - Math.pow(2, bitLength);
			}
			return x;
		};
		webidl.util.IntegerPart = function (n) {
			const r = Math.floor(Math.abs(n));
			if (n < 0) {
				return -1 * r;
			}
			return r;
		};
		webidl.sequenceConverter = function (converter) {
			return (V) => {
				if (webidl.util.Type(V) !== "Object") {
					throw webidl.errors.exception({
						header: "Sequence",
						message: `Value of type ${webidl.util.Type(V)} is not an Object.`,
					});
				}
				const method = V?.[Symbol.iterator]?.();
				const seq = [];
				if (method === void 0 || typeof method.next !== "function") {
					throw webidl.errors.exception({
						header: "Sequence",
						message: "Object is not an iterator.",
					});
				}
				while (true) {
					const { done, value } = method.next();
					if (done) {
						break;
					}
					seq.push(converter(value));
				}
				return seq;
			};
		};
		webidl.recordConverter = function (keyConverter, valueConverter) {
			return (O) => {
				if (webidl.util.Type(O) !== "Object") {
					throw webidl.errors.exception({
						header: "Record",
						message: `Value of type ${webidl.util.Type(O)} is not an Object.`,
					});
				}
				const result = {};
				if (!types.isProxy(O)) {
					const keys2 = Object.keys(O);
					for (const key of keys2) {
						const typedKey = keyConverter(key);
						const typedValue = valueConverter(O[key]);
						result[typedKey] = typedValue;
					}
					return result;
				}
				const keys = Reflect.ownKeys(O);
				for (const key of keys) {
					const desc = Reflect.getOwnPropertyDescriptor(O, key);
					if (desc?.enumerable) {
						const typedKey = keyConverter(key);
						const typedValue = valueConverter(O[key]);
						result[typedKey] = typedValue;
					}
				}
				return result;
			};
		};
		webidl.interfaceConverter = function (i) {
			return (V, opts = {}) => {
				if (opts.strict !== false && !(V instanceof i)) {
					throw webidl.errors.exception({
						header: i.name,
						message: `Expected ${V} to be an instance of ${i.name}.`,
					});
				}
				return V;
			};
		};
		webidl.dictionaryConverter = function (converters) {
			return (dictionary) => {
				const type = webidl.util.Type(dictionary);
				const dict = {};
				if (type === "Null" || type === "Undefined") {
					return dict;
				} else if (type !== "Object") {
					throw webidl.errors.exception({
						header: "Dictionary",
						message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`,
					});
				}
				for (const options of converters) {
					const { key, defaultValue, required, converter } = options;
					if (required === true) {
						if (!hasOwn(dictionary, key)) {
							throw webidl.errors.exception({
								header: "Dictionary",
								message: `Missing required key "${key}".`,
							});
						}
					}
					let value = dictionary[key];
					const hasDefault = hasOwn(options, "defaultValue");
					if (hasDefault && value !== null) {
						value = value ?? defaultValue;
					}
					if (required || hasDefault || value !== void 0) {
						value = converter(value);
						if (options.allowedValues && !options.allowedValues.includes(value)) {
							throw webidl.errors.exception({
								header: "Dictionary",
								message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`,
							});
						}
						dict[key] = value;
					}
				}
				return dict;
			};
		};
		webidl.nullableConverter = function (converter) {
			return (V) => {
				if (V === null) {
					return V;
				}
				return converter(V);
			};
		};
		webidl.converters.DOMString = function (V, opts = {}) {
			if (V === null && opts.legacyNullToEmptyString) {
				return "";
			}
			if (typeof V === "symbol") {
				throw new TypeError("Could not convert argument of type symbol to string.");
			}
			return String(V);
		};
		webidl.converters.ByteString = function (V) {
			const x = webidl.converters.DOMString(V);
			for (let index = 0; index < x.length; index++) {
				if (x.charCodeAt(index) > 255) {
					throw new TypeError(
						`Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`,
					);
				}
			}
			return x;
		};
		webidl.converters.USVString = toUSVString;
		webidl.converters.boolean = function (V) {
			const x = Boolean(V);
			return x;
		};
		webidl.converters.any = function (V) {
			return V;
		};
		webidl.converters["long long"] = function (V) {
			const x = webidl.util.ConvertToInt(V, 64, "signed");
			return x;
		};
		webidl.converters["unsigned long long"] = function (V) {
			const x = webidl.util.ConvertToInt(V, 64, "unsigned");
			return x;
		};
		webidl.converters["unsigned long"] = function (V) {
			const x = webidl.util.ConvertToInt(V, 32, "unsigned");
			return x;
		};
		webidl.converters["unsigned short"] = function (V, opts) {
			const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts);
			return x;
		};
		webidl.converters.ArrayBuffer = function (V, opts = {}) {
			if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V)) {
				throw webidl.errors.conversionFailed({
					prefix: `${V}`,
					argument: `${V}`,
					types: ["ArrayBuffer"],
				});
			}
			if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {
				throw webidl.errors.exception({
					header: "ArrayBuffer",
					message: "SharedArrayBuffer is not allowed.",
				});
			}
			return V;
		};
		webidl.converters.TypedArray = function (V, T, opts = {}) {
			if (
				webidl.util.Type(V) !== "Object" ||
				!types.isTypedArray(V) ||
				V.constructor.name !== T.name
			) {
				throw webidl.errors.conversionFailed({
					prefix: `${T.name}`,
					argument: `${V}`,
					types: [T.name],
				});
			}
			if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
				throw webidl.errors.exception({
					header: "ArrayBuffer",
					message: "SharedArrayBuffer is not allowed.",
				});
			}
			return V;
		};
		webidl.converters.DataView = function (V, opts = {}) {
			if (webidl.util.Type(V) !== "Object" || !types.isDataView(V)) {
				throw webidl.errors.exception({
					header: "DataView",
					message: "Object is not a DataView.",
				});
			}
			if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
				throw webidl.errors.exception({
					header: "ArrayBuffer",
					message: "SharedArrayBuffer is not allowed.",
				});
			}
			return V;
		};
		webidl.converters.BufferSource = function (V, opts = {}) {
			if (types.isAnyArrayBuffer(V)) {
				return webidl.converters.ArrayBuffer(V, opts);
			}
			if (types.isTypedArray(V)) {
				return webidl.converters.TypedArray(V, V.constructor);
			}
			if (types.isDataView(V)) {
				return webidl.converters.DataView(V, opts);
			}
			throw new TypeError(`Could not convert ${V} to a BufferSource.`);
		};
		webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
			webidl.converters.ByteString,
		);
		webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(
			webidl.converters["sequence<ByteString>"],
		);
		webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(
			webidl.converters.ByteString,
			webidl.converters.ByteString,
		);
		module2.exports = {
			webidl,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/dataURL.js
var require_dataURL = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/dataURL.js"(exports2, module2) {
		"use strict";
		var assert = require("assert");
		var { atob: atob2 } = require("buffer");
		var { isomorphicDecode } = require_util3();
		var encoder = new TextEncoder();
		var HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
		var HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/;
		var HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
		function dataURLProcessor(dataURL) {
			assert(dataURL.protocol === "data:");
			let input = URLSerializer(dataURL, true);
			input = input.slice(5);
			const position = { position: 0 };
			let mimeType = collectASequenceOfCodePointsFast(",", input, position);
			const mimeTypeLength = mimeType.length;
			mimeType = removeASCIIWhitespace(mimeType, true, true);
			if (position.position >= input.length) {
				return "failure";
			}
			position.position++;
			const encodedBody = input.slice(mimeTypeLength + 1);
			let body = stringPercentDecode(encodedBody);
			if (/;(\u0020){0,}base64$/i.test(mimeType)) {
				const stringBody = isomorphicDecode(body);
				body = forgivingBase64(stringBody);
				if (body === "failure") {
					return "failure";
				}
				mimeType = mimeType.slice(0, -6);
				mimeType = mimeType.replace(/(\u0020)+$/, "");
				mimeType = mimeType.slice(0, -1);
			}
			if (mimeType.startsWith(";")) {
				mimeType = "text/plain" + mimeType;
			}
			let mimeTypeRecord = parseMIMEType(mimeType);
			if (mimeTypeRecord === "failure") {
				mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
			}
			return { mimeType: mimeTypeRecord, body };
		}
		function URLSerializer(url, excludeFragment = false) {
			if (!excludeFragment) {
				return url.href;
			}
			const href = url.href;
			const hashLength = url.hash.length;
			return hashLength === 0 ? href : href.substring(0, href.length - hashLength);
		}
		function collectASequenceOfCodePoints(condition, input, position) {
			let result = "";
			while (position.position < input.length && condition(input[position.position])) {
				result += input[position.position];
				position.position++;
			}
			return result;
		}
		function collectASequenceOfCodePointsFast(char, input, position) {
			const idx = input.indexOf(char, position.position);
			const start = position.position;
			if (idx === -1) {
				position.position = input.length;
				return input.slice(start);
			}
			position.position = idx;
			return input.slice(start, position.position);
		}
		function stringPercentDecode(input) {
			const bytes = encoder.encode(input);
			return percentDecode(bytes);
		}
		function percentDecode(input) {
			const output = [];
			for (let i = 0; i < input.length; i++) {
				const byte = input[i];
				if (byte !== 37) {
					output.push(byte);
				} else if (
					byte === 37 &&
					!/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))
				) {
					output.push(37);
				} else {
					const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);
					const bytePoint = Number.parseInt(nextTwoBytes, 16);
					output.push(bytePoint);
					i += 2;
				}
			}
			return Uint8Array.from(output);
		}
		function parseMIMEType(input) {
			input = removeHTTPWhitespace(input, true, true);
			const position = { position: 0 };
			const type = collectASequenceOfCodePointsFast("/", input, position);
			if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
				return "failure";
			}
			if (position.position > input.length) {
				return "failure";
			}
			position.position++;
			let subtype = collectASequenceOfCodePointsFast(";", input, position);
			subtype = removeHTTPWhitespace(subtype, false, true);
			if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
				return "failure";
			}
			const typeLowercase = type.toLowerCase();
			const subtypeLowercase = subtype.toLowerCase();
			const mimeType = {
				type: typeLowercase,
				subtype: subtypeLowercase,
				/** @type {Map<string, string>} */
				parameters: /* @__PURE__ */ new Map(),
				// https://mimesniff.spec.whatwg.org/#mime-type-essence
				essence: `${typeLowercase}/${subtypeLowercase}`,
			};
			while (position.position < input.length) {
				position.position++;
				collectASequenceOfCodePoints(
					// https://fetch.spec.whatwg.org/#http-whitespace
					(char) => HTTP_WHITESPACE_REGEX.test(char),
					input,
					position,
				);
				let parameterName = collectASequenceOfCodePoints(
					(char) => char !== ";" && char !== "=",
					input,
					position,
				);
				parameterName = parameterName.toLowerCase();
				if (position.position < input.length) {
					if (input[position.position] === ";") {
						continue;
					}
					position.position++;
				}
				if (position.position > input.length) {
					break;
				}
				let parameterValue = null;
				if (input[position.position] === '"') {
					parameterValue = collectAnHTTPQuotedString(input, position, true);
					collectASequenceOfCodePointsFast(";", input, position);
				} else {
					parameterValue = collectASequenceOfCodePointsFast(";", input, position);
					parameterValue = removeHTTPWhitespace(parameterValue, false, true);
					if (parameterValue.length === 0) {
						continue;
					}
				}
				if (
					parameterName.length !== 0 &&
					HTTP_TOKEN_CODEPOINTS.test(parameterName) &&
					(parameterValue.length === 0 ||
						HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) &&
					!mimeType.parameters.has(parameterName)
				) {
					mimeType.parameters.set(parameterName, parameterValue);
				}
			}
			return mimeType;
		}
		function forgivingBase64(data) {
			data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
			if (data.length % 4 === 0) {
				data = data.replace(/=?=$/, "");
			}
			if (data.length % 4 === 1) {
				return "failure";
			}
			if (/[^+/0-9A-Za-z]/.test(data)) {
				return "failure";
			}
			const binary = atob2(data);
			const bytes = new Uint8Array(binary.length);
			for (let byte = 0; byte < binary.length; byte++) {
				bytes[byte] = binary.charCodeAt(byte);
			}
			return bytes;
		}
		function collectAnHTTPQuotedString(input, position, extractValue) {
			const positionStart = position.position;
			let value = "";
			assert(input[position.position] === '"');
			position.position++;
			while (true) {
				value += collectASequenceOfCodePoints(
					(char) => char !== '"' && char !== "\\",
					input,
					position,
				);
				if (position.position >= input.length) {
					break;
				}
				const quoteOrBackslash = input[position.position];
				position.position++;
				if (quoteOrBackslash === "\\") {
					if (position.position >= input.length) {
						value += "\\";
						break;
					}
					value += input[position.position];
					position.position++;
				} else {
					assert(quoteOrBackslash === '"');
					break;
				}
			}
			if (extractValue) {
				return value;
			}
			return input.slice(positionStart, position.position);
		}
		function serializeAMimeType(mimeType) {
			assert(mimeType !== "failure");
			const { parameters, essence } = mimeType;
			let serialization = essence;
			for (let [name, value] of parameters.entries()) {
				serialization += ";";
				serialization += name;
				serialization += "=";
				if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
					value = value.replace(/(\\|")/g, "\\$1");
					value = '"' + value;
					value += '"';
				}
				serialization += value;
			}
			return serialization;
		}
		function isHTTPWhiteSpace(char) {
			return char === "\r" || char === "\n" || char === "	" || char === " ";
		}
		function removeHTTPWhitespace(str, leading = true, trailing = true) {
			let lead = 0;
			let trail = str.length - 1;
			if (leading) {
				for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++);
			}
			if (trailing) {
				for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--);
			}
			return str.slice(lead, trail + 1);
		}
		function isASCIIWhitespace(char) {
			return char === "\r" || char === "\n" || char === "	" || char === "\f" || char === " ";
		}
		function removeASCIIWhitespace(str, leading = true, trailing = true) {
			let lead = 0;
			let trail = str.length - 1;
			if (leading) {
				for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++);
			}
			if (trailing) {
				for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--);
			}
			return str.slice(lead, trail + 1);
		}
		module2.exports = {
			dataURLProcessor,
			URLSerializer,
			collectASequenceOfCodePoints,
			collectASequenceOfCodePointsFast,
			stringPercentDecode,
			parseMIMEType,
			collectAnHTTPQuotedString,
			serializeAMimeType,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/file.js
var require_file = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/file.js"(exports2, module2) {
		"use strict";
		var { Blob: Blob2, File: NativeFile } = require("buffer");
		var { types } = require("util");
		var { kState } = require_symbols2();
		var { isBlobLike } = require_util3();
		var { webidl } = require_webidl();
		var { parseMIMEType, serializeAMimeType } = require_dataURL();
		var { kEnumerableProperty } = require_util2();
		var encoder = new TextEncoder();
		var File2 = class _File extends Blob2 {
			constructor(fileBits, fileName, options = {}) {
				webidl.argumentLengthCheck(arguments, 2, { header: "File constructor" });
				fileBits = webidl.converters["sequence<BlobPart>"](fileBits);
				fileName = webidl.converters.USVString(fileName);
				options = webidl.converters.FilePropertyBag(options);
				const n = fileName;
				let t = options.type;
				let d;
				substep: {
					if (t) {
						t = parseMIMEType(t);
						if (t === "failure") {
							t = "";
							break substep;
						}
						t = serializeAMimeType(t).toLowerCase();
					}
					d = options.lastModified;
				}
				super(processBlobParts(fileBits, options), { type: t });
				this[kState] = {
					name: n,
					lastModified: d,
					type: t,
				};
			}
			get name() {
				webidl.brandCheck(this, _File);
				return this[kState].name;
			}
			get lastModified() {
				webidl.brandCheck(this, _File);
				return this[kState].lastModified;
			}
			get type() {
				webidl.brandCheck(this, _File);
				return this[kState].type;
			}
		};
		var FileLike = class _FileLike {
			constructor(blobLike, fileName, options = {}) {
				const n = fileName;
				const t = options.type;
				const d = options.lastModified ?? Date.now();
				this[kState] = {
					blobLike,
					name: n,
					type: t,
					lastModified: d,
				};
			}
			stream(...args) {
				webidl.brandCheck(this, _FileLike);
				return this[kState].blobLike.stream(...args);
			}
			arrayBuffer(...args) {
				webidl.brandCheck(this, _FileLike);
				return this[kState].blobLike.arrayBuffer(...args);
			}
			slice(...args) {
				webidl.brandCheck(this, _FileLike);
				return this[kState].blobLike.slice(...args);
			}
			text(...args) {
				webidl.brandCheck(this, _FileLike);
				return this[kState].blobLike.text(...args);
			}
			get size() {
				webidl.brandCheck(this, _FileLike);
				return this[kState].blobLike.size;
			}
			get type() {
				webidl.brandCheck(this, _FileLike);
				return this[kState].blobLike.type;
			}
			get name() {
				webidl.brandCheck(this, _FileLike);
				return this[kState].name;
			}
			get lastModified() {
				webidl.brandCheck(this, _FileLike);
				return this[kState].lastModified;
			}
			get [Symbol.toStringTag]() {
				return "File";
			}
		};
		Object.defineProperties(File2.prototype, {
			[Symbol.toStringTag]: {
				value: "File",
				configurable: true,
			},
			name: kEnumerableProperty,
			lastModified: kEnumerableProperty,
		});
		webidl.converters.Blob = webidl.interfaceConverter(Blob2);
		webidl.converters.BlobPart = function (V, opts) {
			if (webidl.util.Type(V) === "Object") {
				if (isBlobLike(V)) {
					return webidl.converters.Blob(V, { strict: false });
				}
				if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
					return webidl.converters.BufferSource(V, opts);
				}
			}
			return webidl.converters.USVString(V, opts);
		};
		webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(
			webidl.converters.BlobPart,
		);
		webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
			{
				key: "lastModified",
				converter: webidl.converters["long long"],
				get defaultValue() {
					return Date.now();
				},
			},
			{
				key: "type",
				converter: webidl.converters.DOMString,
				defaultValue: "",
			},
			{
				key: "endings",
				converter: (value) => {
					value = webidl.converters.DOMString(value);
					value = value.toLowerCase();
					if (value !== "native") {
						value = "transparent";
					}
					return value;
				},
				defaultValue: "transparent",
			},
		]);
		function processBlobParts(parts, options) {
			const bytes = [];
			for (const element of parts) {
				if (typeof element === "string") {
					let s = element;
					if (options.endings === "native") {
						s = convertLineEndingsNative(s);
					}
					bytes.push(encoder.encode(s));
				} else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element)) {
					if (!element.buffer) {
						bytes.push(new Uint8Array(element));
					} else {
						bytes.push(
							new Uint8Array(element.buffer, element.byteOffset, element.byteLength),
						);
					}
				} else if (isBlobLike(element)) {
					bytes.push(element);
				}
			}
			return bytes;
		}
		function convertLineEndingsNative(s) {
			let nativeLineEnding = "\n";
			if (process.platform === "win32") {
				nativeLineEnding = "\r\n";
			}
			return s.replace(/\r?\n/g, nativeLineEnding);
		}
		function isFileLike(object) {
			return (
				(NativeFile && object instanceof NativeFile) ||
				object instanceof File2 ||
				(object &&
					(typeof object.stream === "function" ||
						typeof object.arrayBuffer === "function") &&
					object[Symbol.toStringTag] === "File")
			);
		}
		module2.exports = { File: File2, FileLike, isFileLike };
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/formdata.js
var require_formdata = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/formdata.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { isBlobLike, toUSVString, makeIterator } = require_util3();
		var { kState } = require_symbols2();
		var { File: UndiciFile, FileLike, isFileLike } = require_file();
		var { webidl } = require_webidl();
		var { Blob: Blob2, File: NativeFile } = require("buffer");
		var File2 = NativeFile ?? UndiciFile;
		var FormData2 = class _FormData {
			constructor(form) {
				if (form !== void 0) {
					throw webidl.errors.conversionFailed({
						prefix: "FormData constructor",
						argument: "Argument 1",
						types: ["undefined"],
					});
				}
				this[kState] = [];
			}
			append(name, value, filename = void 0) {
				webidl.brandCheck(this, _FormData);
				webidl.argumentLengthCheck(arguments, 2, { header: "FormData.append" });
				if (arguments.length === 3 && !isBlobLike(value)) {
					throw new TypeError(
						"Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'",
					);
				}
				name = webidl.converters.USVString(name);
				value = isBlobLike(value)
					? webidl.converters.Blob(value, { strict: false })
					: webidl.converters.USVString(value);
				filename = arguments.length === 3 ? webidl.converters.USVString(filename) : void 0;
				const entry = makeEntry(name, value, filename);
				this[kState].push(entry);
			}
			delete(name) {
				webidl.brandCheck(this, _FormData);
				webidl.argumentLengthCheck(arguments, 1, { header: "FormData.delete" });
				name = webidl.converters.USVString(name);
				this[kState] = this[kState].filter((entry) => entry.name !== name);
			}
			get(name) {
				webidl.brandCheck(this, _FormData);
				webidl.argumentLengthCheck(arguments, 1, { header: "FormData.get" });
				name = webidl.converters.USVString(name);
				const idx = this[kState].findIndex((entry) => entry.name === name);
				if (idx === -1) {
					return null;
				}
				return this[kState][idx].value;
			}
			getAll(name) {
				webidl.brandCheck(this, _FormData);
				webidl.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" });
				name = webidl.converters.USVString(name);
				return this[kState]
					.filter((entry) => entry.name === name)
					.map((entry) => entry.value);
			}
			has(name) {
				webidl.brandCheck(this, _FormData);
				webidl.argumentLengthCheck(arguments, 1, { header: "FormData.has" });
				name = webidl.converters.USVString(name);
				return this[kState].findIndex((entry) => entry.name === name) !== -1;
			}
			set(name, value, filename = void 0) {
				webidl.brandCheck(this, _FormData);
				webidl.argumentLengthCheck(arguments, 2, { header: "FormData.set" });
				if (arguments.length === 3 && !isBlobLike(value)) {
					throw new TypeError(
						"Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'",
					);
				}
				name = webidl.converters.USVString(name);
				value = isBlobLike(value)
					? webidl.converters.Blob(value, { strict: false })
					: webidl.converters.USVString(value);
				filename = arguments.length === 3 ? toUSVString(filename) : void 0;
				const entry = makeEntry(name, value, filename);
				const idx = this[kState].findIndex((entry2) => entry2.name === name);
				if (idx !== -1) {
					this[kState] = [
						...this[kState].slice(0, idx),
						entry,
						...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name),
					];
				} else {
					this[kState].push(entry);
				}
			}
			entries() {
				webidl.brandCheck(this, _FormData);
				return makeIterator(
					() => this[kState].map((pair) => [pair.name, pair.value]),
					"FormData",
					"key+value",
				);
			}
			keys() {
				webidl.brandCheck(this, _FormData);
				return makeIterator(
					() => this[kState].map((pair) => [pair.name, pair.value]),
					"FormData",
					"key",
				);
			}
			values() {
				webidl.brandCheck(this, _FormData);
				return makeIterator(
					() => this[kState].map((pair) => [pair.name, pair.value]),
					"FormData",
					"value",
				);
			}
			/**
			 * @param {(value: string, key: string, self: FormData) => void} callbackFn
			 * @param {unknown} thisArg
			 */
			forEach(callbackFn, thisArg = globalThis) {
				webidl.brandCheck(this, _FormData);
				webidl.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" });
				if (typeof callbackFn !== "function") {
					throw new TypeError(
						"Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.",
					);
				}
				for (const [key, value] of this) {
					callbackFn.apply(thisArg, [value, key, this]);
				}
			}
		};
		FormData2.prototype[Symbol.iterator] = FormData2.prototype.entries;
		Object.defineProperties(FormData2.prototype, {
			[Symbol.toStringTag]: {
				value: "FormData",
				configurable: true,
			},
		});
		function makeEntry(name, value, filename) {
			name = Buffer.from(name).toString("utf8");
			if (typeof value === "string") {
				value = Buffer.from(value).toString("utf8");
			} else {
				if (!isFileLike(value)) {
					value =
						value instanceof Blob2
							? new File2([value], "blob", { type: value.type })
							: new FileLike(value, "blob", { type: value.type });
				}
				if (filename !== void 0) {
					const options = {
						type: value.type,
						lastModified: value.lastModified,
					};
					value =
						(NativeFile && value instanceof NativeFile) || value instanceof UndiciFile
							? new File2([value], filename, options)
							: new FileLike(value, filename, options);
				}
			}
			return { name, value };
		}
		module2.exports = { FormData: FormData2 };
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/body.js
var require_body = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/body.js"(exports2, module2) {
		"use strict";
		var Busboy = require_main();
		var util = require_util2();
		var {
			ReadableStreamFrom,
			isBlobLike,
			isReadableStreamLike,
			readableStreamClose,
			createDeferredPromise,
			fullyReadBody,
		} = require_util3();
		var { FormData: FormData2 } = require_formdata();
		var { kState } = require_symbols2();
		var { webidl } = require_webidl();
		var { DOMException: DOMException2, structuredClone } = require_constants3();
		var { Blob: Blob2, File: NativeFile } = require("buffer");
		var { kBodyUsed } = require_symbols();
		var assert = require("assert");
		var { isErrored } = require_util2();
		var { isUint8Array, isArrayBuffer } = require("util/types");
		var { File: UndiciFile } = require_file();
		var { parseMIMEType, serializeAMimeType } = require_dataURL();
		var ReadableStream = globalThis.ReadableStream;
		var File2 = NativeFile ?? UndiciFile;
		var textEncoder = new TextEncoder();
		var textDecoder = new TextDecoder();
		function extractBody(object, keepalive = false) {
			if (!ReadableStream) {
				ReadableStream = require("stream/web").ReadableStream;
			}
			let stream = null;
			if (object instanceof ReadableStream) {
				stream = object;
			} else if (isBlobLike(object)) {
				stream = object.stream();
			} else {
				stream = new ReadableStream({
					async pull(controller) {
						controller.enqueue(
							typeof source === "string" ? textEncoder.encode(source) : source,
						);
						queueMicrotask(() => readableStreamClose(controller));
					},
					start() {},
					type: void 0,
				});
			}
			assert(isReadableStreamLike(stream));
			let action = null;
			let source = null;
			let length = null;
			let type = null;
			if (typeof object === "string") {
				source = object;
				type = "text/plain;charset=UTF-8";
			} else if (object instanceof URLSearchParams) {
				source = object.toString();
				type = "application/x-www-form-urlencoded;charset=UTF-8";
			} else if (isArrayBuffer(object)) {
				source = new Uint8Array(object.slice());
			} else if (ArrayBuffer.isView(object)) {
				source = new Uint8Array(
					object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength),
				);
			} else if (util.isFormDataLike(object)) {
				const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, "0")}`;
				const prefix = `--${boundary}\r
Content-Disposition: form-data`;
				const escape = (str) =>
					str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
				const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
				const blobParts = [];
				const rn = new Uint8Array([13, 10]);
				length = 0;
				let hasUnknownSizeValue = false;
				for (const [name, value] of object) {
					if (typeof value === "string") {
						const chunk2 = textEncoder.encode(
							prefix +
								`; name="${escape(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`,
						);
						blobParts.push(chunk2);
						length += chunk2.byteLength;
					} else {
						const chunk2 = textEncoder.encode(
							`${prefix}; name="${escape(normalizeLinefeeds(name))}"` +
								(value.name ? `; filename="${escape(value.name)}"` : "") +
								`\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`,
						);
						blobParts.push(chunk2, value, rn);
						if (typeof value.size === "number") {
							length += chunk2.byteLength + value.size + rn.byteLength;
						} else {
							hasUnknownSizeValue = true;
						}
					}
				}
				const chunk = textEncoder.encode(`--${boundary}--`);
				blobParts.push(chunk);
				length += chunk.byteLength;
				if (hasUnknownSizeValue) {
					length = null;
				}
				source = object;
				action = async function* () {
					for (const part of blobParts) {
						if (part.stream) {
							yield* part.stream();
						} else {
							yield part;
						}
					}
				};
				type = "multipart/form-data; boundary=" + boundary;
			} else if (isBlobLike(object)) {
				source = object;
				length = object.size;
				if (object.type) {
					type = object.type;
				}
			} else if (typeof object[Symbol.asyncIterator] === "function") {
				if (keepalive) {
					throw new TypeError("keepalive");
				}
				if (util.isDisturbed(object) || object.locked) {
					throw new TypeError("Response body object should not be disturbed or locked");
				}
				stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
			}
			if (typeof source === "string" || util.isBuffer(source)) {
				length = Buffer.byteLength(source);
			}
			if (action != null) {
				let iterator;
				stream = new ReadableStream({
					async start() {
						iterator = action(object)[Symbol.asyncIterator]();
					},
					async pull(controller) {
						const { value, done } = await iterator.next();
						if (done) {
							queueMicrotask(() => {
								controller.close();
							});
						} else {
							if (!isErrored(stream)) {
								controller.enqueue(new Uint8Array(value));
							}
						}
						return controller.desiredSize > 0;
					},
					async cancel(reason) {
						await iterator.return();
					},
					type: void 0,
				});
			}
			const body = { stream, source, length };
			return [body, type];
		}
		function safelyExtractBody(object, keepalive = false) {
			if (!ReadableStream) {
				ReadableStream = require("stream/web").ReadableStream;
			}
			if (object instanceof ReadableStream) {
				assert(!util.isDisturbed(object), "The body has already been consumed.");
				assert(!object.locked, "The stream is locked.");
			}
			return extractBody(object, keepalive);
		}
		function cloneBody(body) {
			const [out1, out2] = body.stream.tee();
			const out2Clone = structuredClone(out2, { transfer: [out2] });
			const [, finalClone] = out2Clone.tee();
			body.stream = out1;
			return {
				stream: finalClone,
				length: body.length,
				source: body.source,
			};
		}
		async function* consumeBody(body) {
			if (body) {
				if (isUint8Array(body)) {
					yield body;
				} else {
					const stream = body.stream;
					if (util.isDisturbed(stream)) {
						throw new TypeError("The body has already been consumed.");
					}
					if (stream.locked) {
						throw new TypeError("The stream is locked.");
					}
					stream[kBodyUsed] = true;
					yield* stream;
				}
			}
		}
		function throwIfAborted(state) {
			if (state.aborted) {
				throw new DOMException2("The operation was aborted.", "AbortError");
			}
		}
		function bodyMixinMethods(instance) {
			const methods = {
				blob() {
					return specConsumeBody(
						this,
						(bytes) => {
							let mimeType = bodyMimeType(this);
							if (mimeType === "failure") {
								mimeType = "";
							} else if (mimeType) {
								mimeType = serializeAMimeType(mimeType);
							}
							return new Blob2([bytes], { type: mimeType });
						},
						instance,
					);
				},
				arrayBuffer() {
					return specConsumeBody(
						this,
						(bytes) => {
							return new Uint8Array(bytes).buffer;
						},
						instance,
					);
				},
				text() {
					return specConsumeBody(this, utf8DecodeBytes, instance);
				},
				json() {
					return specConsumeBody(this, parseJSONFromBytes, instance);
				},
				async formData() {
					webidl.brandCheck(this, instance);
					throwIfAborted(this[kState]);
					const contentType = this.headers.get("Content-Type");
					if (/multipart\/form-data/.test(contentType)) {
						const headers = {};
						for (const [key, value] of this.headers) headers[key.toLowerCase()] = value;
						const responseFormData = new FormData2();
						let busboy;
						try {
							busboy = new Busboy({
								headers,
								preservePath: true,
							});
						} catch (err) {
							throw new DOMException2(`${err}`, "AbortError");
						}
						busboy.on("field", (name, value) => {
							responseFormData.append(name, value);
						});
						busboy.on("file", (name, value, filename, encoding, mimeType) => {
							const chunks = [];
							if (encoding === "base64" || encoding.toLowerCase() === "base64") {
								let base64chunk = "";
								value.on("data", (chunk) => {
									base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
									const end = base64chunk.length - (base64chunk.length % 4);
									chunks.push(Buffer.from(base64chunk.slice(0, end), "base64"));
									base64chunk = base64chunk.slice(end);
								});
								value.on("end", () => {
									chunks.push(Buffer.from(base64chunk, "base64"));
									responseFormData.append(
										name,
										new File2(chunks, filename, { type: mimeType }),
									);
								});
							} else {
								value.on("data", (chunk) => {
									chunks.push(chunk);
								});
								value.on("end", () => {
									responseFormData.append(
										name,
										new File2(chunks, filename, { type: mimeType }),
									);
								});
							}
						});
						const busboyResolve = new Promise((resolve, reject) => {
							busboy.on("finish", resolve);
							busboy.on("error", (err) => reject(new TypeError(err)));
						});
						if (this.body !== null)
							for await (const chunk of consumeBody(this[kState].body))
								busboy.write(chunk);
						busboy.end();
						await busboyResolve;
						return responseFormData;
					} else if (/application\/x-www-form-urlencoded/.test(contentType)) {
						let entries;
						try {
							let text = "";
							const streamingDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
							for await (const chunk of consumeBody(this[kState].body)) {
								if (!isUint8Array(chunk)) {
									throw new TypeError("Expected Uint8Array chunk");
								}
								text += streamingDecoder.decode(chunk, { stream: true });
							}
							text += streamingDecoder.decode();
							entries = new URLSearchParams(text);
						} catch (err) {
							throw Object.assign(new TypeError(), { cause: err });
						}
						const formData = new FormData2();
						for (const [name, value] of entries) {
							formData.append(name, value);
						}
						return formData;
					} else {
						await Promise.resolve();
						throwIfAborted(this[kState]);
						throw webidl.errors.exception({
							header: `${instance.name}.formData`,
							message: "Could not parse content as FormData.",
						});
					}
				},
			};
			return methods;
		}
		function mixinBody(prototype) {
			Object.assign(prototype.prototype, bodyMixinMethods(prototype));
		}
		async function specConsumeBody(object, convertBytesToJSValue, instance) {
			webidl.brandCheck(object, instance);
			throwIfAborted(object[kState]);
			if (bodyUnusable(object[kState].body)) {
				throw new TypeError("Body is unusable");
			}
			const promise = createDeferredPromise();
			const errorSteps = (error) => promise.reject(error);
			const successSteps = (data) => {
				try {
					promise.resolve(convertBytesToJSValue(data));
				} catch (e) {
					errorSteps(e);
				}
			};
			if (object[kState].body == null) {
				successSteps(new Uint8Array());
				return promise.promise;
			}
			await fullyReadBody(object[kState].body, successSteps, errorSteps);
			return promise.promise;
		}
		function bodyUnusable(body) {
			return body != null && (body.stream.locked || util.isDisturbed(body.stream));
		}
		function utf8DecodeBytes(buffer) {
			if (buffer.length === 0) {
				return "";
			}
			if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
				buffer = buffer.subarray(3);
			}
			const output = textDecoder.decode(buffer);
			return output;
		}
		function parseJSONFromBytes(bytes) {
			return JSON.parse(utf8DecodeBytes(bytes));
		}
		function bodyMimeType(object) {
			const { headersList } = object[kState];
			const contentType = headersList.get("content-type");
			if (contentType === null) {
				return "failure";
			}
			return parseMIMEType(contentType);
		}
		module2.exports = {
			extractBody,
			safelyExtractBody,
			cloneBody,
			mixinBody,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/core/request.js
var require_request = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/core/request.js"(exports2, module2) {
		"use strict";
		var { InvalidArgumentError, NotSupportedError } = require_errors2();
		var assert = require("assert");
		var { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require_symbols();
		var util = require_util2();
		var tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
		var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
		var invalidPathRegex = /[^\u0021-\u00ff]/;
		var kHandler = Symbol("handler");
		var channels = {};
		var extractBody;
		try {
			const diagnosticsChannel = require("diagnostics_channel");
			channels.create = diagnosticsChannel.channel("undici:request:create");
			channels.bodySent = diagnosticsChannel.channel("undici:request:bodySent");
			channels.headers = diagnosticsChannel.channel("undici:request:headers");
			channels.trailers = diagnosticsChannel.channel("undici:request:trailers");
			channels.error = diagnosticsChannel.channel("undici:request:error");
		} catch {
			channels.create = { hasSubscribers: false };
			channels.bodySent = { hasSubscribers: false };
			channels.headers = { hasSubscribers: false };
			channels.trailers = { hasSubscribers: false };
			channels.error = { hasSubscribers: false };
		}
		var Request = class _Request {
			constructor(
				origin,
				{
					path,
					method,
					body,
					headers,
					query,
					idempotent,
					blocking,
					upgrade,
					headersTimeout,
					bodyTimeout,
					reset,
					throwOnError,
					expectContinue,
				},
				handler,
			) {
				if (typeof path !== "string") {
					throw new InvalidArgumentError("path must be a string");
				} else if (
					path[0] !== "/" &&
					!(path.startsWith("http://") || path.startsWith("https://")) &&
					method !== "CONNECT"
				) {
					throw new InvalidArgumentError(
						"path must be an absolute URL or start with a slash",
					);
				} else if (invalidPathRegex.exec(path) !== null) {
					throw new InvalidArgumentError("invalid request path");
				}
				if (typeof method !== "string") {
					throw new InvalidArgumentError("method must be a string");
				} else if (tokenRegExp.exec(method) === null) {
					throw new InvalidArgumentError("invalid request method");
				}
				if (upgrade && typeof upgrade !== "string") {
					throw new InvalidArgumentError("upgrade must be a string");
				}
				if (
					headersTimeout != null &&
					(!Number.isFinite(headersTimeout) || headersTimeout < 0)
				) {
					throw new InvalidArgumentError("invalid headersTimeout");
				}
				if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
					throw new InvalidArgumentError("invalid bodyTimeout");
				}
				if (reset != null && typeof reset !== "boolean") {
					throw new InvalidArgumentError("invalid reset");
				}
				if (expectContinue != null && typeof expectContinue !== "boolean") {
					throw new InvalidArgumentError("invalid expectContinue");
				}
				this.headersTimeout = headersTimeout;
				this.bodyTimeout = bodyTimeout;
				this.throwOnError = throwOnError === true;
				this.method = method;
				this.abort = null;
				if (body == null) {
					this.body = null;
				} else if (util.isStream(body)) {
					this.body = body;
					const rState = this.body._readableState;
					if (!rState || !rState.autoDestroy) {
						this.endHandler = function autoDestroy() {
							util.destroy(this);
						};
						this.body.on("end", this.endHandler);
					}
					this.errorHandler = (err) => {
						if (this.abort) {
							this.abort(err);
						} else {
							this.error = err;
						}
					};
					this.body.on("error", this.errorHandler);
				} else if (util.isBuffer(body)) {
					this.body = body.byteLength ? body : null;
				} else if (ArrayBuffer.isView(body)) {
					this.body = body.buffer.byteLength
						? Buffer.from(body.buffer, body.byteOffset, body.byteLength)
						: null;
				} else if (body instanceof ArrayBuffer) {
					this.body = body.byteLength ? Buffer.from(body) : null;
				} else if (typeof body === "string") {
					this.body = body.length ? Buffer.from(body) : null;
				} else if (
					util.isFormDataLike(body) ||
					util.isIterable(body) ||
					util.isBlobLike(body)
				) {
					this.body = body;
				} else {
					throw new InvalidArgumentError(
						"body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable",
					);
				}
				this.completed = false;
				this.aborted = false;
				this.upgrade = upgrade || null;
				this.path = query ? util.buildURL(path, query) : path;
				this.origin = origin;
				this.idempotent =
					idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
				this.blocking = blocking == null ? false : blocking;
				this.reset = reset == null ? null : reset;
				this.host = null;
				this.contentLength = null;
				this.contentType = null;
				this.headers = "";
				this.expectContinue = expectContinue != null ? expectContinue : false;
				if (Array.isArray(headers)) {
					if (headers.length % 2 !== 0) {
						throw new InvalidArgumentError("headers array must be even");
					}
					for (let i = 0; i < headers.length; i += 2) {
						processHeader(this, headers[i], headers[i + 1]);
					}
				} else if (headers && typeof headers === "object") {
					const keys = Object.keys(headers);
					for (let i = 0; i < keys.length; i++) {
						const key = keys[i];
						processHeader(this, key, headers[key]);
					}
				} else if (headers != null) {
					throw new InvalidArgumentError("headers must be an object or an array");
				}
				if (util.isFormDataLike(this.body)) {
					if (util.nodeMajor < 16 || (util.nodeMajor === 16 && util.nodeMinor < 8)) {
						throw new InvalidArgumentError(
							"Form-Data bodies are only supported in node v16.8 and newer.",
						);
					}
					if (!extractBody) {
						extractBody = require_body().extractBody;
					}
					const [bodyStream, contentType] = extractBody(body);
					if (this.contentType == null) {
						this.contentType = contentType;
						this.headers += `content-type: ${contentType}\r
`;
					}
					this.body = bodyStream.stream;
					this.contentLength = bodyStream.length;
				} else if (util.isBlobLike(body) && this.contentType == null && body.type) {
					this.contentType = body.type;
					this.headers += `content-type: ${body.type}\r
`;
				}
				util.validateHandler(handler, method, upgrade);
				this.servername = util.getServerName(this.host);
				this[kHandler] = handler;
				if (channels.create.hasSubscribers) {
					channels.create.publish({ request: this });
				}
			}
			onBodySent(chunk) {
				if (this[kHandler].onBodySent) {
					try {
						return this[kHandler].onBodySent(chunk);
					} catch (err) {
						this.abort(err);
					}
				}
			}
			onRequestSent() {
				if (channels.bodySent.hasSubscribers) {
					channels.bodySent.publish({ request: this });
				}
				if (this[kHandler].onRequestSent) {
					try {
						return this[kHandler].onRequestSent();
					} catch (err) {
						this.abort(err);
					}
				}
			}
			onConnect(abort) {
				assert(!this.aborted);
				assert(!this.completed);
				if (this.error) {
					abort(this.error);
				} else {
					this.abort = abort;
					return this[kHandler].onConnect(abort);
				}
			}
			onHeaders(statusCode, headers, resume, statusText) {
				assert(!this.aborted);
				assert(!this.completed);
				if (channels.headers.hasSubscribers) {
					channels.headers.publish({
						request: this,
						response: { statusCode, headers, statusText },
					});
				}
				try {
					return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
				} catch (err) {
					this.abort(err);
				}
			}
			onData(chunk) {
				assert(!this.aborted);
				assert(!this.completed);
				try {
					return this[kHandler].onData(chunk);
				} catch (err) {
					this.abort(err);
					return false;
				}
			}
			onUpgrade(statusCode, headers, socket) {
				assert(!this.aborted);
				assert(!this.completed);
				return this[kHandler].onUpgrade(statusCode, headers, socket);
			}
			onComplete(trailers) {
				this.onFinally();
				assert(!this.aborted);
				this.completed = true;
				if (channels.trailers.hasSubscribers) {
					channels.trailers.publish({ request: this, trailers });
				}
				try {
					return this[kHandler].onComplete(trailers);
				} catch (err) {
					this.onError(err);
				}
			}
			onError(error) {
				this.onFinally();
				if (channels.error.hasSubscribers) {
					channels.error.publish({ request: this, error });
				}
				if (this.aborted) {
					return;
				}
				this.aborted = true;
				return this[kHandler].onError(error);
			}
			onFinally() {
				if (this.errorHandler) {
					this.body.off("error", this.errorHandler);
					this.errorHandler = null;
				}
				if (this.endHandler) {
					this.body.off("end", this.endHandler);
					this.endHandler = null;
				}
			}
			// TODO: adjust to support H2
			addHeader(key, value) {
				processHeader(this, key, value);
				return this;
			}
			static [kHTTP1BuildRequest](origin, opts, handler) {
				return new _Request(origin, opts, handler);
			}
			static [kHTTP2BuildRequest](origin, opts, handler) {
				const headers = opts.headers;
				opts = { ...opts, headers: null };
				const request = new _Request(origin, opts, handler);
				request.headers = {};
				if (Array.isArray(headers)) {
					if (headers.length % 2 !== 0) {
						throw new InvalidArgumentError("headers array must be even");
					}
					for (let i = 0; i < headers.length; i += 2) {
						processHeader(request, headers[i], headers[i + 1], true);
					}
				} else if (headers && typeof headers === "object") {
					const keys = Object.keys(headers);
					for (let i = 0; i < keys.length; i++) {
						const key = keys[i];
						processHeader(request, key, headers[key], true);
					}
				} else if (headers != null) {
					throw new InvalidArgumentError("headers must be an object or an array");
				}
				return request;
			}
			static [kHTTP2CopyHeaders](raw) {
				const rawHeaders = raw.split("\r\n");
				const headers = {};
				for (const header of rawHeaders) {
					const [key, value] = header.split(": ");
					if (value == null || value.length === 0) continue;
					if (headers[key]) headers[key] += `,${value}`;
					else headers[key] = value;
				}
				return headers;
			}
		};
		function processHeaderValue(key, val, skipAppend) {
			if (val && typeof val === "object") {
				throw new InvalidArgumentError(`invalid ${key} header`);
			}
			val = val != null ? `${val}` : "";
			if (headerCharRegex.exec(val) !== null) {
				throw new InvalidArgumentError(`invalid ${key} header`);
			}
			return skipAppend
				? val
				: `${key}: ${val}\r
`;
		}
		function processHeader(request, key, val, skipAppend = false) {
			if (val && typeof val === "object" && !Array.isArray(val)) {
				throw new InvalidArgumentError(`invalid ${key} header`);
			} else if (val === void 0) {
				return;
			}
			if (request.host === null && key.length === 4 && key.toLowerCase() === "host") {
				if (headerCharRegex.exec(val) !== null) {
					throw new InvalidArgumentError(`invalid ${key} header`);
				}
				request.host = val;
			} else if (
				request.contentLength === null &&
				key.length === 14 &&
				key.toLowerCase() === "content-length"
			) {
				request.contentLength = parseInt(val, 10);
				if (!Number.isFinite(request.contentLength)) {
					throw new InvalidArgumentError("invalid content-length header");
				}
			} else if (
				request.contentType === null &&
				key.length === 12 &&
				key.toLowerCase() === "content-type"
			) {
				request.contentType = val;
				if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);
				else request.headers += processHeaderValue(key, val);
			} else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
				throw new InvalidArgumentError("invalid transfer-encoding header");
			} else if (key.length === 10 && key.toLowerCase() === "connection") {
				const value = typeof val === "string" ? val.toLowerCase() : null;
				if (value !== "close" && value !== "keep-alive") {
					throw new InvalidArgumentError("invalid connection header");
				} else if (value === "close") {
					request.reset = true;
				}
			} else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
				throw new InvalidArgumentError("invalid keep-alive header");
			} else if (key.length === 7 && key.toLowerCase() === "upgrade") {
				throw new InvalidArgumentError("invalid upgrade header");
			} else if (key.length === 6 && key.toLowerCase() === "expect") {
				throw new NotSupportedError("expect header not supported");
			} else if (tokenRegExp.exec(key) === null) {
				throw new InvalidArgumentError("invalid header key");
			} else {
				if (Array.isArray(val)) {
					for (let i = 0; i < val.length; i++) {
						if (skipAppend) {
							if (request.headers[key])
								request.headers[key] +=
									`,${processHeaderValue(key, val[i], skipAppend)}`;
							else request.headers[key] = processHeaderValue(key, val[i], skipAppend);
						} else {
							request.headers += processHeaderValue(key, val[i]);
						}
					}
				} else {
					if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);
					else request.headers += processHeaderValue(key, val);
				}
			}
		}
		module2.exports = Request;
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/dispatcher.js
var require_dispatcher = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/dispatcher.js"(exports2, module2) {
		"use strict";
		var EventEmitter = require("events");
		var Dispatcher = class extends EventEmitter {
			dispatch() {
				throw new Error("not implemented");
			}
			close() {
				throw new Error("not implemented");
			}
			destroy() {
				throw new Error("not implemented");
			}
		};
		module2.exports = Dispatcher;
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/dispatcher-base.js"(
		exports2,
		module2,
	) {
		"use strict";
		var Dispatcher = require_dispatcher();
		var { ClientDestroyedError, ClientClosedError, InvalidArgumentError } = require_errors2();
		var { kDestroy, kClose, kDispatch, kInterceptors } = require_symbols();
		var kDestroyed = Symbol("destroyed");
		var kClosed = Symbol("closed");
		var kOnDestroyed = Symbol("onDestroyed");
		var kOnClosed = Symbol("onClosed");
		var kInterceptedDispatch = Symbol("Intercepted Dispatch");
		var DispatcherBase = class extends Dispatcher {
			constructor() {
				super();
				this[kDestroyed] = false;
				this[kOnDestroyed] = null;
				this[kClosed] = false;
				this[kOnClosed] = [];
			}
			get destroyed() {
				return this[kDestroyed];
			}
			get closed() {
				return this[kClosed];
			}
			get interceptors() {
				return this[kInterceptors];
			}
			set interceptors(newInterceptors) {
				if (newInterceptors) {
					for (let i = newInterceptors.length - 1; i >= 0; i--) {
						const interceptor = this[kInterceptors][i];
						if (typeof interceptor !== "function") {
							throw new InvalidArgumentError("interceptor must be an function");
						}
					}
				}
				this[kInterceptors] = newInterceptors;
			}
			close(callback) {
				if (callback === void 0) {
					return new Promise((resolve, reject) => {
						this.close((err, data) => {
							return err ? reject(err) : resolve(data);
						});
					});
				}
				if (typeof callback !== "function") {
					throw new InvalidArgumentError("invalid callback");
				}
				if (this[kDestroyed]) {
					queueMicrotask(() => callback(new ClientDestroyedError(), null));
					return;
				}
				if (this[kClosed]) {
					if (this[kOnClosed]) {
						this[kOnClosed].push(callback);
					} else {
						queueMicrotask(() => callback(null, null));
					}
					return;
				}
				this[kClosed] = true;
				this[kOnClosed].push(callback);
				const onClosed = () => {
					const callbacks = this[kOnClosed];
					this[kOnClosed] = null;
					for (let i = 0; i < callbacks.length; i++) {
						callbacks[i](null, null);
					}
				};
				this[kClose]()
					.then(() => this.destroy())
					.then(() => {
						queueMicrotask(onClosed);
					});
			}
			destroy(err, callback) {
				if (typeof err === "function") {
					callback = err;
					err = null;
				}
				if (callback === void 0) {
					return new Promise((resolve, reject) => {
						this.destroy(err, (err2, data) => {
							return err2
								? /* istanbul ignore next: should never error */
									reject(err2)
								: resolve(data);
						});
					});
				}
				if (typeof callback !== "function") {
					throw new InvalidArgumentError("invalid callback");
				}
				if (this[kDestroyed]) {
					if (this[kOnDestroyed]) {
						this[kOnDestroyed].push(callback);
					} else {
						queueMicrotask(() => callback(null, null));
					}
					return;
				}
				if (!err) {
					err = new ClientDestroyedError();
				}
				this[kDestroyed] = true;
				this[kOnDestroyed] = this[kOnDestroyed] || [];
				this[kOnDestroyed].push(callback);
				const onDestroyed = () => {
					const callbacks = this[kOnDestroyed];
					this[kOnDestroyed] = null;
					for (let i = 0; i < callbacks.length; i++) {
						callbacks[i](null, null);
					}
				};
				this[kDestroy](err).then(() => {
					queueMicrotask(onDestroyed);
				});
			}
			[kInterceptedDispatch](opts, handler) {
				if (!this[kInterceptors] || this[kInterceptors].length === 0) {
					this[kInterceptedDispatch] = this[kDispatch];
					return this[kDispatch](opts, handler);
				}
				let dispatch = this[kDispatch].bind(this);
				for (let i = this[kInterceptors].length - 1; i >= 0; i--) {
					dispatch = this[kInterceptors][i](dispatch);
				}
				this[kInterceptedDispatch] = dispatch;
				return dispatch(opts, handler);
			}
			dispatch(opts, handler) {
				if (!handler || typeof handler !== "object") {
					throw new InvalidArgumentError("handler must be an object");
				}
				try {
					if (!opts || typeof opts !== "object") {
						throw new InvalidArgumentError("opts must be an object.");
					}
					if (this[kDestroyed] || this[kOnDestroyed]) {
						throw new ClientDestroyedError();
					}
					if (this[kClosed]) {
						throw new ClientClosedError();
					}
					return this[kInterceptedDispatch](opts, handler);
				} catch (err) {
					if (typeof handler.onError !== "function") {
						throw new InvalidArgumentError("invalid onError method");
					}
					handler.onError(err);
					return false;
				}
			}
		};
		module2.exports = DispatcherBase;
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/core/connect.js
var require_connect = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/core/connect.js"(exports2, module2) {
		"use strict";
		var net = require("net");
		var assert = require("assert");
		var util = require_util2();
		var { InvalidArgumentError, ConnectTimeoutError } = require_errors2();
		var tls;
		var SessionCache;
		if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {
			SessionCache = class WeakSessionCache {
				constructor(maxCachedSessions) {
					this._maxCachedSessions = maxCachedSessions;
					this._sessionCache = /* @__PURE__ */ new Map();
					this._sessionRegistry = new global.FinalizationRegistry((key) => {
						if (this._sessionCache.size < this._maxCachedSessions) {
							return;
						}
						const ref = this._sessionCache.get(key);
						if (ref !== void 0 && ref.deref() === void 0) {
							this._sessionCache.delete(key);
						}
					});
				}
				get(sessionKey) {
					const ref = this._sessionCache.get(sessionKey);
					return ref ? ref.deref() : null;
				}
				set(sessionKey, session) {
					if (this._maxCachedSessions === 0) {
						return;
					}
					this._sessionCache.set(sessionKey, new WeakRef(session));
					this._sessionRegistry.register(session, sessionKey);
				}
			};
		} else {
			SessionCache = class SimpleSessionCache {
				constructor(maxCachedSessions) {
					this._maxCachedSessions = maxCachedSessions;
					this._sessionCache = /* @__PURE__ */ new Map();
				}
				get(sessionKey) {
					return this._sessionCache.get(sessionKey);
				}
				set(sessionKey, session) {
					if (this._maxCachedSessions === 0) {
						return;
					}
					if (this._sessionCache.size >= this._maxCachedSessions) {
						const { value: oldestKey } = this._sessionCache.keys().next();
						this._sessionCache.delete(oldestKey);
					}
					this._sessionCache.set(sessionKey, session);
				}
			};
		}
		function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {
			if (
				maxCachedSessions != null &&
				(!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)
			) {
				throw new InvalidArgumentError(
					"maxCachedSessions must be a positive integer or zero",
				);
			}
			const options = { path: socketPath, ...opts };
			const sessionCache = new SessionCache(
				maxCachedSessions == null ? 100 : maxCachedSessions,
			);
			timeout = timeout == null ? 1e4 : timeout;
			allowH2 = allowH2 != null ? allowH2 : false;
			return function connect(
				{ hostname, host, protocol, port, servername, localAddress, httpSocket },
				callback,
			) {
				let socket;
				if (protocol === "https:") {
					if (!tls) {
						tls = require("tls");
					}
					servername =
						servername || options.servername || util.getServerName(host) || null;
					const sessionKey = servername || hostname;
					const session = sessionCache.get(sessionKey) || null;
					assert(sessionKey);
					socket = tls.connect({
						highWaterMark: 16384,
						// TLS in node can't have bigger HWM anyway...
						...options,
						servername,
						session,
						localAddress,
						// TODO(HTTP/2): Add support for h2c
						ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
						socket: httpSocket,
						// upgrade socket connection
						port: port || 443,
						host: hostname,
					});
					socket.on("session", function (session2) {
						sessionCache.set(sessionKey, session2);
					});
				} else {
					assert(!httpSocket, "httpSocket can only be sent on TLS update");
					socket = net.connect({
						highWaterMark: 64 * 1024,
						// Same as nodejs fs streams.
						...options,
						localAddress,
						port: port || 80,
						host: hostname,
					});
				}
				if (options.keepAlive == null || options.keepAlive) {
					const keepAliveInitialDelay =
						options.keepAliveInitialDelay === void 0
							? 6e4
							: options.keepAliveInitialDelay;
					socket.setKeepAlive(true, keepAliveInitialDelay);
				}
				const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
				socket
					.setNoDelay(true)
					.once(protocol === "https:" ? "secureConnect" : "connect", function () {
						cancelTimeout();
						if (callback) {
							const cb = callback;
							callback = null;
							cb(null, this);
						}
					})
					.on("error", function (err) {
						cancelTimeout();
						if (callback) {
							const cb = callback;
							callback = null;
							cb(err);
						}
					});
				return socket;
			};
		}
		function setupTimeout(onConnectTimeout2, timeout) {
			if (!timeout) {
				return () => {};
			}
			let s1 = null;
			let s2 = null;
			const timeoutId = setTimeout(() => {
				s1 = setImmediate(() => {
					if (process.platform === "win32") {
						s2 = setImmediate(() => onConnectTimeout2());
					} else {
						onConnectTimeout2();
					}
				});
			}, timeout);
			return () => {
				clearTimeout(timeoutId);
				clearImmediate(s1);
				clearImmediate(s2);
			};
		}
		function onConnectTimeout(socket) {
			util.destroy(socket, new ConnectTimeoutError());
		}
		module2.exports = buildConnector;
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/llhttp/utils.js
var require_utils = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/llhttp/utils.js"(exports2) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.enumToMap = void 0;
		function enumToMap(obj) {
			const res = {};
			Object.keys(obj).forEach((key) => {
				const value = obj[key];
				if (typeof value === "number") {
					res[key] = value;
				}
			});
			return res;
		}
		exports2.enumToMap = enumToMap;
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/llhttp/constants.js
var require_constants4 = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/llhttp/constants.js"(exports2) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.SPECIAL_HEADERS =
			exports2.HEADER_STATE =
			exports2.MINOR =
			exports2.MAJOR =
			exports2.CONNECTION_TOKEN_CHARS =
			exports2.HEADER_CHARS =
			exports2.TOKEN =
			exports2.STRICT_TOKEN =
			exports2.HEX =
			exports2.URL_CHAR =
			exports2.STRICT_URL_CHAR =
			exports2.USERINFO_CHARS =
			exports2.MARK =
			exports2.ALPHANUM =
			exports2.NUM =
			exports2.HEX_MAP =
			exports2.NUM_MAP =
			exports2.ALPHA =
			exports2.FINISH =
			exports2.H_METHOD_MAP =
			exports2.METHOD_MAP =
			exports2.METHODS_RTSP =
			exports2.METHODS_ICE =
			exports2.METHODS_HTTP =
			exports2.METHODS =
			exports2.LENIENT_FLAGS =
			exports2.FLAGS =
			exports2.TYPE =
			exports2.ERROR =
				void 0;
		var utils_1 = require_utils();
		var ERROR;
		(function (ERROR2) {
			ERROR2[(ERROR2["OK"] = 0)] = "OK";
			ERROR2[(ERROR2["INTERNAL"] = 1)] = "INTERNAL";
			ERROR2[(ERROR2["STRICT"] = 2)] = "STRICT";
			ERROR2[(ERROR2["LF_EXPECTED"] = 3)] = "LF_EXPECTED";
			ERROR2[(ERROR2["UNEXPECTED_CONTENT_LENGTH"] = 4)] = "UNEXPECTED_CONTENT_LENGTH";
			ERROR2[(ERROR2["CLOSED_CONNECTION"] = 5)] = "CLOSED_CONNECTION";
			ERROR2[(ERROR2["INVALID_METHOD"] = 6)] = "INVALID_METHOD";
			ERROR2[(ERROR2["INVALID_URL"] = 7)] = "INVALID_URL";
			ERROR2[(ERROR2["INVALID_CONSTANT"] = 8)] = "INVALID_CONSTANT";
			ERROR2[(ERROR2["INVALID_VERSION"] = 9)] = "INVALID_VERSION";
			ERROR2[(ERROR2["INVALID_HEADER_TOKEN"] = 10)] = "INVALID_HEADER_TOKEN";
			ERROR2[(ERROR2["INVALID_CONTENT_LENGTH"] = 11)] = "INVALID_CONTENT_LENGTH";
			ERROR2[(ERROR2["INVALID_CHUNK_SIZE"] = 12)] = "INVALID_CHUNK_SIZE";
			ERROR2[(ERROR2["INVALID_STATUS"] = 13)] = "INVALID_STATUS";
			ERROR2[(ERROR2["INVALID_EOF_STATE"] = 14)] = "INVALID_EOF_STATE";
			ERROR2[(ERROR2["INVALID_TRANSFER_ENCODING"] = 15)] = "INVALID_TRANSFER_ENCODING";
			ERROR2[(ERROR2["CB_MESSAGE_BEGIN"] = 16)] = "CB_MESSAGE_BEGIN";
			ERROR2[(ERROR2["CB_HEADERS_COMPLETE"] = 17)] = "CB_HEADERS_COMPLETE";
			ERROR2[(ERROR2["CB_MESSAGE_COMPLETE"] = 18)] = "CB_MESSAGE_COMPLETE";
			ERROR2[(ERROR2["CB_CHUNK_HEADER"] = 19)] = "CB_CHUNK_HEADER";
			ERROR2[(ERROR2["CB_CHUNK_COMPLETE"] = 20)] = "CB_CHUNK_COMPLETE";
			ERROR2[(ERROR2["PAUSED"] = 21)] = "PAUSED";
			ERROR2[(ERROR2["PAUSED_UPGRADE"] = 22)] = "PAUSED_UPGRADE";
			ERROR2[(ERROR2["PAUSED_H2_UPGRADE"] = 23)] = "PAUSED_H2_UPGRADE";
			ERROR2[(ERROR2["USER"] = 24)] = "USER";
		})((ERROR = exports2.ERROR || (exports2.ERROR = {})));
		var TYPE;
		(function (TYPE2) {
			TYPE2[(TYPE2["BOTH"] = 0)] = "BOTH";
			TYPE2[(TYPE2["REQUEST"] = 1)] = "REQUEST";
			TYPE2[(TYPE2["RESPONSE"] = 2)] = "RESPONSE";
		})((TYPE = exports2.TYPE || (exports2.TYPE = {})));
		var FLAGS;
		(function (FLAGS2) {
			FLAGS2[(FLAGS2["CONNECTION_KEEP_ALIVE"] = 1)] = "CONNECTION_KEEP_ALIVE";
			FLAGS2[(FLAGS2["CONNECTION_CLOSE"] = 2)] = "CONNECTION_CLOSE";
			FLAGS2[(FLAGS2["CONNECTION_UPGRADE"] = 4)] = "CONNECTION_UPGRADE";
			FLAGS2[(FLAGS2["CHUNKED"] = 8)] = "CHUNKED";
			FLAGS2[(FLAGS2["UPGRADE"] = 16)] = "UPGRADE";
			FLAGS2[(FLAGS2["CONTENT_LENGTH"] = 32)] = "CONTENT_LENGTH";
			FLAGS2[(FLAGS2["SKIPBODY"] = 64)] = "SKIPBODY";
			FLAGS2[(FLAGS2["TRAILING"] = 128)] = "TRAILING";
			FLAGS2[(FLAGS2["TRANSFER_ENCODING"] = 512)] = "TRANSFER_ENCODING";
		})((FLAGS = exports2.FLAGS || (exports2.FLAGS = {})));
		var LENIENT_FLAGS;
		(function (LENIENT_FLAGS2) {
			LENIENT_FLAGS2[(LENIENT_FLAGS2["HEADERS"] = 1)] = "HEADERS";
			LENIENT_FLAGS2[(LENIENT_FLAGS2["CHUNKED_LENGTH"] = 2)] = "CHUNKED_LENGTH";
			LENIENT_FLAGS2[(LENIENT_FLAGS2["KEEP_ALIVE"] = 4)] = "KEEP_ALIVE";
		})((LENIENT_FLAGS = exports2.LENIENT_FLAGS || (exports2.LENIENT_FLAGS = {})));
		var METHODS;
		(function (METHODS2) {
			METHODS2[(METHODS2["DELETE"] = 0)] = "DELETE";
			METHODS2[(METHODS2["GET"] = 1)] = "GET";
			METHODS2[(METHODS2["HEAD"] = 2)] = "HEAD";
			METHODS2[(METHODS2["POST"] = 3)] = "POST";
			METHODS2[(METHODS2["PUT"] = 4)] = "PUT";
			METHODS2[(METHODS2["CONNECT"] = 5)] = "CONNECT";
			METHODS2[(METHODS2["OPTIONS"] = 6)] = "OPTIONS";
			METHODS2[(METHODS2["TRACE"] = 7)] = "TRACE";
			METHODS2[(METHODS2["COPY"] = 8)] = "COPY";
			METHODS2[(METHODS2["LOCK"] = 9)] = "LOCK";
			METHODS2[(METHODS2["MKCOL"] = 10)] = "MKCOL";
			METHODS2[(METHODS2["MOVE"] = 11)] = "MOVE";
			METHODS2[(METHODS2["PROPFIND"] = 12)] = "PROPFIND";
			METHODS2[(METHODS2["PROPPATCH"] = 13)] = "PROPPATCH";
			METHODS2[(METHODS2["SEARCH"] = 14)] = "SEARCH";
			METHODS2[(METHODS2["UNLOCK"] = 15)] = "UNLOCK";
			METHODS2[(METHODS2["BIND"] = 16)] = "BIND";
			METHODS2[(METHODS2["REBIND"] = 17)] = "REBIND";
			METHODS2[(METHODS2["UNBIND"] = 18)] = "UNBIND";
			METHODS2[(METHODS2["ACL"] = 19)] = "ACL";
			METHODS2[(METHODS2["REPORT"] = 20)] = "REPORT";
			METHODS2[(METHODS2["MKACTIVITY"] = 21)] = "MKACTIVITY";
			METHODS2[(METHODS2["CHECKOUT"] = 22)] = "CHECKOUT";
			METHODS2[(METHODS2["MERGE"] = 23)] = "MERGE";
			METHODS2[(METHODS2["M-SEARCH"] = 24)] = "M-SEARCH";
			METHODS2[(METHODS2["NOTIFY"] = 25)] = "NOTIFY";
			METHODS2[(METHODS2["SUBSCRIBE"] = 26)] = "SUBSCRIBE";
			METHODS2[(METHODS2["UNSUBSCRIBE"] = 27)] = "UNSUBSCRIBE";
			METHODS2[(METHODS2["PATCH"] = 28)] = "PATCH";
			METHODS2[(METHODS2["PURGE"] = 29)] = "PURGE";
			METHODS2[(METHODS2["MKCALENDAR"] = 30)] = "MKCALENDAR";
			METHODS2[(METHODS2["LINK"] = 31)] = "LINK";
			METHODS2[(METHODS2["UNLINK"] = 32)] = "UNLINK";
			METHODS2[(METHODS2["SOURCE"] = 33)] = "SOURCE";
			METHODS2[(METHODS2["PRI"] = 34)] = "PRI";
			METHODS2[(METHODS2["DESCRIBE"] = 35)] = "DESCRIBE";
			METHODS2[(METHODS2["ANNOUNCE"] = 36)] = "ANNOUNCE";
			METHODS2[(METHODS2["SETUP"] = 37)] = "SETUP";
			METHODS2[(METHODS2["PLAY"] = 38)] = "PLAY";
			METHODS2[(METHODS2["PAUSE"] = 39)] = "PAUSE";
			METHODS2[(METHODS2["TEARDOWN"] = 40)] = "TEARDOWN";
			METHODS2[(METHODS2["GET_PARAMETER"] = 41)] = "GET_PARAMETER";
			METHODS2[(METHODS2["SET_PARAMETER"] = 42)] = "SET_PARAMETER";
			METHODS2[(METHODS2["REDIRECT"] = 43)] = "REDIRECT";
			METHODS2[(METHODS2["RECORD"] = 44)] = "RECORD";
			METHODS2[(METHODS2["FLUSH"] = 45)] = "FLUSH";
		})((METHODS = exports2.METHODS || (exports2.METHODS = {})));
		exports2.METHODS_HTTP = [
			METHODS.DELETE,
			METHODS.GET,
			METHODS.HEAD,
			METHODS.POST,
			METHODS.PUT,
			METHODS.CONNECT,
			METHODS.OPTIONS,
			METHODS.TRACE,
			METHODS.COPY,
			METHODS.LOCK,
			METHODS.MKCOL,
			METHODS.MOVE,
			METHODS.PROPFIND,
			METHODS.PROPPATCH,
			METHODS.SEARCH,
			METHODS.UNLOCK,
			METHODS.BIND,
			METHODS.REBIND,
			METHODS.UNBIND,
			METHODS.ACL,
			METHODS.REPORT,
			METHODS.MKACTIVITY,
			METHODS.CHECKOUT,
			METHODS.MERGE,
			METHODS["M-SEARCH"],
			METHODS.NOTIFY,
			METHODS.SUBSCRIBE,
			METHODS.UNSUBSCRIBE,
			METHODS.PATCH,
			METHODS.PURGE,
			METHODS.MKCALENDAR,
			METHODS.LINK,
			METHODS.UNLINK,
			METHODS.PRI,
			// TODO(indutny): should we allow it with HTTP?
			METHODS.SOURCE,
		];
		exports2.METHODS_ICE = [METHODS.SOURCE];
		exports2.METHODS_RTSP = [
			METHODS.OPTIONS,
			METHODS.DESCRIBE,
			METHODS.ANNOUNCE,
			METHODS.SETUP,
			METHODS.PLAY,
			METHODS.PAUSE,
			METHODS.TEARDOWN,
			METHODS.GET_PARAMETER,
			METHODS.SET_PARAMETER,
			METHODS.REDIRECT,
			METHODS.RECORD,
			METHODS.FLUSH,
			// For AirPlay
			METHODS.GET,
			METHODS.POST,
		];
		exports2.METHOD_MAP = utils_1.enumToMap(METHODS);
		exports2.H_METHOD_MAP = {};
		Object.keys(exports2.METHOD_MAP).forEach((key) => {
			if (/^H/.test(key)) {
				exports2.H_METHOD_MAP[key] = exports2.METHOD_MAP[key];
			}
		});
		var FINISH;
		(function (FINISH2) {
			FINISH2[(FINISH2["SAFE"] = 0)] = "SAFE";
			FINISH2[(FINISH2["SAFE_WITH_CB"] = 1)] = "SAFE_WITH_CB";
			FINISH2[(FINISH2["UNSAFE"] = 2)] = "UNSAFE";
		})((FINISH = exports2.FINISH || (exports2.FINISH = {})));
		exports2.ALPHA = [];
		for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
			exports2.ALPHA.push(String.fromCharCode(i));
			exports2.ALPHA.push(String.fromCharCode(i + 32));
		}
		exports2.NUM_MAP = {
			0: 0,
			1: 1,
			2: 2,
			3: 3,
			4: 4,
			5: 5,
			6: 6,
			7: 7,
			8: 8,
			9: 9,
		};
		exports2.HEX_MAP = {
			0: 0,
			1: 1,
			2: 2,
			3: 3,
			4: 4,
			5: 5,
			6: 6,
			7: 7,
			8: 8,
			9: 9,
			A: 10,
			B: 11,
			C: 12,
			D: 13,
			E: 14,
			F: 15,
			a: 10,
			b: 11,
			c: 12,
			d: 13,
			e: 14,
			f: 15,
		};
		exports2.NUM = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
		exports2.ALPHANUM = exports2.ALPHA.concat(exports2.NUM);
		exports2.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
		exports2.USERINFO_CHARS = exports2.ALPHANUM.concat(exports2.MARK).concat([
			"%",
			";",
			":",
			"&",
			"=",
			"+",
			"$",
			",",
		]);
		exports2.STRICT_URL_CHAR = [
			"!",
			'"',
			"$",
			"%",
			"&",
			"'",
			"(",
			")",
			"*",
			"+",
			",",
			"-",
			".",
			"/",
			":",
			";",
			"<",
			"=",
			">",
			"@",
			"[",
			"\\",
			"]",
			"^",
			"_",
			"`",
			"{",
			"|",
			"}",
			"~",
		].concat(exports2.ALPHANUM);
		exports2.URL_CHAR = exports2.STRICT_URL_CHAR.concat(["	", "\f"]);
		for (let i = 128; i <= 255; i++) {
			exports2.URL_CHAR.push(i);
		}
		exports2.HEX = exports2.NUM.concat([
			"a",
			"b",
			"c",
			"d",
			"e",
			"f",
			"A",
			"B",
			"C",
			"D",
			"E",
			"F",
		]);
		exports2.STRICT_TOKEN = [
			"!",
			"#",
			"$",
			"%",
			"&",
			"'",
			"*",
			"+",
			"-",
			".",
			"^",
			"_",
			"`",
			"|",
			"~",
		].concat(exports2.ALPHANUM);
		exports2.TOKEN = exports2.STRICT_TOKEN.concat([" "]);
		exports2.HEADER_CHARS = ["	"];
		for (let i = 32; i <= 255; i++) {
			if (i !== 127) {
				exports2.HEADER_CHARS.push(i);
			}
		}
		exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS.filter((c) => c !== 44);
		exports2.MAJOR = exports2.NUM_MAP;
		exports2.MINOR = exports2.MAJOR;
		var HEADER_STATE;
		(function (HEADER_STATE2) {
			HEADER_STATE2[(HEADER_STATE2["GENERAL"] = 0)] = "GENERAL";
			HEADER_STATE2[(HEADER_STATE2["CONNECTION"] = 1)] = "CONNECTION";
			HEADER_STATE2[(HEADER_STATE2["CONTENT_LENGTH"] = 2)] = "CONTENT_LENGTH";
			HEADER_STATE2[(HEADER_STATE2["TRANSFER_ENCODING"] = 3)] = "TRANSFER_ENCODING";
			HEADER_STATE2[(HEADER_STATE2["UPGRADE"] = 4)] = "UPGRADE";
			HEADER_STATE2[(HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5)] = "CONNECTION_KEEP_ALIVE";
			HEADER_STATE2[(HEADER_STATE2["CONNECTION_CLOSE"] = 6)] = "CONNECTION_CLOSE";
			HEADER_STATE2[(HEADER_STATE2["CONNECTION_UPGRADE"] = 7)] = "CONNECTION_UPGRADE";
			HEADER_STATE2[(HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8)] =
				"TRANSFER_ENCODING_CHUNKED";
		})((HEADER_STATE = exports2.HEADER_STATE || (exports2.HEADER_STATE = {})));
		exports2.SPECIAL_HEADERS = {
			connection: HEADER_STATE.CONNECTION,
			"content-length": HEADER_STATE.CONTENT_LENGTH,
			"proxy-connection": HEADER_STATE.CONNECTION,
			"transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
			upgrade: HEADER_STATE.UPGRADE,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/handler/RedirectHandler.js
var require_RedirectHandler = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/handler/RedirectHandler.js"(
		exports2,
		module2,
	) {
		"use strict";
		var util = require_util2();
		var { kBodyUsed } = require_symbols();
		var assert = require("assert");
		var { InvalidArgumentError } = require_errors2();
		var EE = require("events");
		var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
		var kBody = Symbol("body");
		var BodyAsyncIterable = class {
			constructor(body) {
				this[kBody] = body;
				this[kBodyUsed] = false;
			}
			async *[Symbol.asyncIterator]() {
				assert(!this[kBodyUsed], "disturbed");
				this[kBodyUsed] = true;
				yield* this[kBody];
			}
		};
		var RedirectHandler = class {
			constructor(dispatch, maxRedirections, opts, handler) {
				if (
					maxRedirections != null &&
					(!Number.isInteger(maxRedirections) || maxRedirections < 0)
				) {
					throw new InvalidArgumentError("maxRedirections must be a positive number");
				}
				util.validateHandler(handler, opts.method, opts.upgrade);
				this.dispatch = dispatch;
				this.location = null;
				this.abort = null;
				this.opts = { ...opts, maxRedirections: 0 };
				this.maxRedirections = maxRedirections;
				this.handler = handler;
				this.history = [];
				if (util.isStream(this.opts.body)) {
					if (util.bodyLength(this.opts.body) === 0) {
						this.opts.body.on("data", function () {
							assert(false);
						});
					}
					if (typeof this.opts.body.readableDidRead !== "boolean") {
						this.opts.body[kBodyUsed] = false;
						EE.prototype.on.call(this.opts.body, "data", function () {
							this[kBodyUsed] = true;
						});
					}
				} else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
					this.opts.body = new BodyAsyncIterable(this.opts.body);
				} else if (
					this.opts.body &&
					typeof this.opts.body !== "string" &&
					!ArrayBuffer.isView(this.opts.body) &&
					util.isIterable(this.opts.body)
				) {
					this.opts.body = new BodyAsyncIterable(this.opts.body);
				}
			}
			onConnect(abort) {
				this.abort = abort;
				this.handler.onConnect(abort, { history: this.history });
			}
			onUpgrade(statusCode, headers, socket) {
				this.handler.onUpgrade(statusCode, headers, socket);
			}
			onError(error) {
				this.handler.onError(error);
			}
			onHeaders(statusCode, headers, resume, statusText) {
				this.location =
					this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body)
						? null
						: parseLocation(statusCode, headers);
				if (this.opts.origin) {
					this.history.push(new URL(this.opts.path, this.opts.origin));
				}
				if (!this.location) {
					return this.handler.onHeaders(statusCode, headers, resume, statusText);
				}
				const { origin, pathname, search } = util.parseURL(
					new URL(
						this.location,
						this.opts.origin && new URL(this.opts.path, this.opts.origin),
					),
				);
				const path = search ? `${pathname}${search}` : pathname;
				this.opts.headers = cleanRequestHeaders(
					this.opts.headers,
					statusCode === 303,
					this.opts.origin !== origin,
				);
				this.opts.path = path;
				this.opts.origin = origin;
				this.opts.maxRedirections = 0;
				this.opts.query = null;
				if (statusCode === 303 && this.opts.method !== "HEAD") {
					this.opts.method = "GET";
					this.opts.body = null;
				}
			}
			onData(chunk) {
				if (this.location) {
				} else {
					return this.handler.onData(chunk);
				}
			}
			onComplete(trailers) {
				if (this.location) {
					this.location = null;
					this.abort = null;
					this.dispatch(this.opts, this);
				} else {
					this.handler.onComplete(trailers);
				}
			}
			onBodySent(chunk) {
				if (this.handler.onBodySent) {
					this.handler.onBodySent(chunk);
				}
			}
		};
		function parseLocation(statusCode, headers) {
			if (redirectableStatusCodes.indexOf(statusCode) === -1) {
				return null;
			}
			for (let i = 0; i < headers.length; i += 2) {
				if (headers[i].toString().toLowerCase() === "location") {
					return headers[i + 1];
				}
			}
		}
		function shouldRemoveHeader(header, removeContent, unknownOrigin) {
			if (header.length === 4) {
				return util.headerNameToString(header) === "host";
			}
			if (removeContent && util.headerNameToString(header).startsWith("content-")) {
				return true;
			}
			if (
				unknownOrigin &&
				(header.length === 13 || header.length === 6 || header.length === 19)
			) {
				const name = util.headerNameToString(header);
				return (
					name === "authorization" || name === "cookie" || name === "proxy-authorization"
				);
			}
			return false;
		}
		function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
			const ret = [];
			if (Array.isArray(headers)) {
				for (let i = 0; i < headers.length; i += 2) {
					if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
						ret.push(headers[i], headers[i + 1]);
					}
				}
			} else if (headers && typeof headers === "object") {
				for (const key of Object.keys(headers)) {
					if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
						ret.push(key, headers[key]);
					}
				}
			} else {
				assert(headers == null, "headers must be an object or an array");
			}
			return ret;
		}
		module2.exports = RedirectHandler;
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/interceptor/redirectInterceptor.js
var require_redirectInterceptor = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/interceptor/redirectInterceptor.js"(
		exports2,
		module2,
	) {
		"use strict";
		var RedirectHandler = require_RedirectHandler();
		function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
			return (dispatch) => {
				return function Intercept(opts, handler) {
					const { maxRedirections = defaultMaxRedirections } = opts;
					if (!maxRedirections) {
						return dispatch(opts, handler);
					}
					const redirectHandler = new RedirectHandler(
						dispatch,
						maxRedirections,
						opts,
						handler,
					);
					opts = { ...opts, maxRedirections: 0 };
					return dispatch(opts, redirectHandler);
				};
			};
		}
		module2.exports = createRedirectInterceptor;
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/llhttp/llhttp-wasm.js"(
		exports2,
		module2,
	) {
		"use strict";
		module2.exports =
			"AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAQDscBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxweHyAhIyUoP0BBREVGR0hJSktMTU9QUVJT3gNXWVtcXWBiZWZnaGlqa2xtb3BxcnN0dXZ3eHl6e3x9foABggGFAYYBhwGJAYsBjAGNAY4BjwGQAZEBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAdUB1gHXAdgB2QHaAdsB3AHdAd4B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAZkCpAKwAv4C/gILIAEiBCACRw3zAUHdASEQDP8DCyABIhAgAkcN3QFBwwEhEAz+AwsgASIBIAJHDZABQfcAIRAM/QMLIAEiASACRw2GAUHvACEQDPwDCyABIgEgAkcNf0HqACEQDPsDCyABIgEgAkcNe0HoACEQDPoDCyABIgEgAkcNeEHmACEQDPkDCyABIgEgAkcNGkEYIRAM+AMLIAEiASACRw0UQRIhEAz3AwsgASIBIAJHDVlBxQAhEAz2AwsgASIBIAJHDUpBPyEQDPUDCyABIgEgAkcNSEE8IRAM9AMLIAEiASACRw1BQTEhEAzzAwsgAC0ALkEBRg3rAwyHAgsgACABIgEgAhDAgICAAEEBRw3mASAAQgA3AyAM5wELIAAgASIBIAIQtICAgAAiEA3nASABIQEM9QILAkAgASIBIAJHDQBBBiEQDPADCyAAIAFBAWoiASACELuAgIAAIhAN6AEgASEBDDELIABCADcDIEESIRAM1QMLIAEiECACRw0rQR0hEAztAwsCQCABIgEgAkYNACABQQFqIQFBECEQDNQDC0EHIRAM7AMLIABCACAAKQMgIhEgAiABIhBrrSISfSITIBMgEVYbNwMgIBEgElYiFEUN5QFBCCEQDOsDCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEUIRAM0gMLQQkhEAzqAwsgASEBIAApAyBQDeQBIAEhAQzyAgsCQCABIgEgAkcNAEELIRAM6QMLIAAgAUEBaiIBIAIQtoCAgAAiEA3lASABIQEM8gILIAAgASIBIAIQuICAgAAiEA3lASABIQEM8gILIAAgASIBIAIQuICAgAAiEA3mASABIQEMDQsgACABIgEgAhC6gICAACIQDecBIAEhAQzwAgsCQCABIgEgAkcNAEEPIRAM5QMLIAEtAAAiEEE7Rg0IIBBBDUcN6AEgAUEBaiEBDO8CCyAAIAEiASACELqAgIAAIhAN6AEgASEBDPICCwNAAkAgAS0AAEHwtYCAAGotAAAiEEEBRg0AIBBBAkcN6wEgACgCBCEQIABBADYCBCAAIBAgAUEBaiIBELmAgIAAIhAN6gEgASEBDPQCCyABQQFqIgEgAkcNAAtBEiEQDOIDCyAAIAEiASACELqAgIAAIhAN6QEgASEBDAoLIAEiASACRw0GQRshEAzgAwsCQCABIgEgAkcNAEEWIRAM4AMLIABBioCAgAA2AgggACABNgIEIAAgASACELiAgIAAIhAN6gEgASEBQSAhEAzGAwsCQCABIgEgAkYNAANAAkAgAS0AAEHwt4CAAGotAAAiEEECRg0AAkAgEEF/ag4E5QHsAQDrAewBCyABQQFqIQFBCCEQDMgDCyABQQFqIgEgAkcNAAtBFSEQDN8DC0EVIRAM3gMLA0ACQCABLQAAQfC5gIAAai0AACIQQQJGDQAgEEF/ag4E3gHsAeAB6wHsAQsgAUEBaiIBIAJHDQALQRghEAzdAwsCQCABIgEgAkYNACAAQYuAgIAANgIIIAAgATYCBCABIQFBByEQDMQDC0EZIRAM3AMLIAFBAWohAQwCCwJAIAEiFCACRw0AQRohEAzbAwsgFCEBAkAgFC0AAEFzag4U3QLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gIA7gILQQAhECAAQQA2AhwgAEGvi4CAADYCECAAQQI2AgwgACAUQQFqNgIUDNoDCwJAIAEtAAAiEEE7Rg0AIBBBDUcN6AEgAUEBaiEBDOUCCyABQQFqIQELQSIhEAy/AwsCQCABIhAgAkcNAEEcIRAM2AMLQgAhESAQIQEgEC0AAEFQag435wHmAQECAwQFBgcIAAAAAAAAAAkKCwwNDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADxAREhMUAAtBHiEQDL0DC0ICIREM5QELQgMhEQzkAQtCBCERDOMBC0IFIREM4gELQgYhEQzhAQtCByERDOABC0IIIREM3wELQgkhEQzeAQtCCiERDN0BC0ILIREM3AELQgwhEQzbAQtCDSERDNoBC0IOIREM2QELQg8hEQzYAQtCCiERDNcBC0ILIREM1gELQgwhEQzVAQtCDSERDNQBC0IOIREM0wELQg8hEQzSAQtCACERAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAQLQAAQVBqDjflAeQBAAECAwQFBgfmAeYB5gHmAeYB5gHmAQgJCgsMDeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gEODxAREhPmAQtCAiERDOQBC0IDIREM4wELQgQhEQziAQtCBSERDOEBC0IGIREM4AELQgchEQzfAQtCCCERDN4BC0IJIREM3QELQgohEQzcAQtCCyERDNsBC0IMIREM2gELQg0hEQzZAQtCDiERDNgBC0IPIREM1wELQgohEQzWAQtCCyERDNUBC0IMIREM1AELQg0hEQzTAQtCDiERDNIBC0IPIREM0QELIABCACAAKQMgIhEgAiABIhBrrSISfSITIBMgEVYbNwMgIBEgElYiFEUN0gFBHyEQDMADCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEkIRAMpwMLQSAhEAy/AwsgACABIhAgAhC+gICAAEF/ag4FtgEAxQIB0QHSAQtBESEQDKQDCyAAQQE6AC8gECEBDLsDCyABIgEgAkcN0gFBJCEQDLsDCyABIg0gAkcNHkHGACEQDLoDCyAAIAEiASACELKAgIAAIhAN1AEgASEBDLUBCyABIhAgAkcNJkHQACEQDLgDCwJAIAEiASACRw0AQSghEAy4AwsgAEEANgIEIABBjICAgAA2AgggACABIAEQsYCAgAAiEA3TASABIQEM2AELAkAgASIQIAJHDQBBKSEQDLcDCyAQLQAAIgFBIEYNFCABQQlHDdMBIBBBAWohAQwVCwJAIAEiASACRg0AIAFBAWohAQwXC0EqIRAMtQMLAkAgASIQIAJHDQBBKyEQDLUDCwJAIBAtAAAiAUEJRg0AIAFBIEcN1QELIAAtACxBCEYN0wEgECEBDJEDCwJAIAEiASACRw0AQSwhEAy0AwsgAS0AAEEKRw3VASABQQFqIQEMyQILIAEiDiACRw3VAUEvIRAMsgMLA0ACQCABLQAAIhBBIEYNAAJAIBBBdmoOBADcAdwBANoBCyABIQEM4AELIAFBAWoiASACRw0AC0ExIRAMsQMLQTIhECABIhQgAkYNsAMgAiAUayAAKAIAIgFqIRUgFCABa0EDaiEWAkADQCAULQAAIhdBIHIgFyAXQb9/akH/AXFBGkkbQf8BcSABQfC7gIAAai0AAEcNAQJAIAFBA0cNAEEGIQEMlgMLIAFBAWohASAUQQFqIhQgAkcNAAsgACAVNgIADLEDCyAAQQA2AgAgFCEBDNkBC0EzIRAgASIUIAJGDa8DIAIgFGsgACgCACIBaiEVIBQgAWtBCGohFgJAA0AgFC0AACIXQSByIBcgF0G/f2pB/wFxQRpJG0H/AXEgAUH0u4CAAGotAABHDQECQCABQQhHDQBBBSEBDJUDCyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFTYCAAywAwsgAEEANgIAIBQhAQzYAQtBNCEQIAEiFCACRg2uAyACIBRrIAAoAgAiAWohFSAUIAFrQQVqIRYCQANAIBQtAAAiF0EgciAXIBdBv39qQf8BcUEaSRtB/wFxIAFB0MKAgABqLQAARw0BAkAgAUEFRw0AQQchAQyUAwsgAUEBaiEBIBRBAWoiFCACRw0ACyAAIBU2AgAMrwMLIABBADYCACAUIQEM1wELAkAgASIBIAJGDQADQAJAIAEtAABBgL6AgABqLQAAIhBBAUYNACAQQQJGDQogASEBDN0BCyABQQFqIgEgAkcNAAtBMCEQDK4DC0EwIRAMrQMLAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgRg0AIBBBdmoOBNkB2gHaAdkB2gELIAFBAWoiASACRw0AC0E4IRAMrQMLQTghEAysAwsDQAJAIAEtAAAiEEEgRg0AIBBBCUcNAwsgAUEBaiIBIAJHDQALQTwhEAyrAwsDQAJAIAEtAAAiEEEgRg0AAkACQCAQQXZqDgTaAQEB2gEACyAQQSxGDdsBCyABIQEMBAsgAUEBaiIBIAJHDQALQT8hEAyqAwsgASEBDNsBC0HAACEQIAEiFCACRg2oAyACIBRrIAAoAgAiAWohFiAUIAFrQQZqIRcCQANAIBQtAABBIHIgAUGAwICAAGotAABHDQEgAUEGRg2OAyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFjYCAAypAwsgAEEANgIAIBQhAQtBNiEQDI4DCwJAIAEiDyACRw0AQcEAIRAMpwMLIABBjICAgAA2AgggACAPNgIEIA8hASAALQAsQX9qDgTNAdUB1wHZAYcDCyABQQFqIQEMzAELAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgciAQIBBBv39qQf8BcUEaSRtB/wFxIhBBCUYNACAQQSBGDQACQAJAAkACQCAQQZ1/ag4TAAMDAwMDAwMBAwMDAwMDAwMDAgMLIAFBAWohAUExIRAMkQMLIAFBAWohAUEyIRAMkAMLIAFBAWohAUEzIRAMjwMLIAEhAQzQAQsgAUEBaiIBIAJHDQALQTUhEAylAwtBNSEQDKQDCwJAIAEiASACRg0AA0ACQCABLQAAQYC8gIAAai0AAEEBRg0AIAEhAQzTAQsgAUEBaiIBIAJHDQALQT0hEAykAwtBPSEQDKMDCyAAIAEiASACELCAgIAAIhAN1gEgASEBDAELIBBBAWohAQtBPCEQDIcDCwJAIAEiASACRw0AQcIAIRAMoAMLAkADQAJAIAEtAABBd2oOGAAC/gL+AoQD/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4CAP4CCyABQQFqIgEgAkcNAAtBwgAhEAygAwsgAUEBaiEBIAAtAC1BAXFFDb0BIAEhAQtBLCEQDIUDCyABIgEgAkcN0wFBxAAhEAydAwsDQAJAIAEtAABBkMCAgABqLQAAQQFGDQAgASEBDLcCCyABQQFqIgEgAkcNAAtBxQAhEAycAwsgDS0AACIQQSBGDbMBIBBBOkcNgQMgACgCBCEBIABBADYCBCAAIAEgDRCvgICAACIBDdABIA1BAWohAQyzAgtBxwAhECABIg0gAkYNmgMgAiANayAAKAIAIgFqIRYgDSABa0EFaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGQwoCAAGotAABHDYADIAFBBUYN9AIgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMmgMLQcgAIRAgASINIAJGDZkDIAIgDWsgACgCACIBaiEWIA0gAWtBCWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBlsKAgABqLQAARw3/AgJAIAFBCUcNAEECIQEM9QILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJkDCwJAIAEiDSACRw0AQckAIRAMmQMLAkACQCANLQAAIgFBIHIgASABQb9/akH/AXFBGkkbQf8BcUGSf2oOBwCAA4ADgAOAA4ADAYADCyANQQFqIQFBPiEQDIADCyANQQFqIQFBPyEQDP8CC0HKACEQIAEiDSACRg2XAyACIA1rIAAoAgAiAWohFiANIAFrQQFqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQaDCgIAAai0AAEcN/QIgAUEBRg3wAiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyXAwtBywAhECABIg0gAkYNlgMgAiANayAAKAIAIgFqIRYgDSABa0EOaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGiwoCAAGotAABHDfwCIAFBDkYN8AIgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMlgMLQcwAIRAgASINIAJGDZUDIAIgDWsgACgCACIBaiEWIA0gAWtBD2ohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBwMKAgABqLQAARw37AgJAIAFBD0cNAEEDIQEM8QILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJUDC0HNACEQIAEiDSACRg2UAyACIA1rIAAoAgAiAWohFiANIAFrQQVqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQdDCgIAAai0AAEcN+gICQCABQQVHDQBBBCEBDPACCyABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyUAwsCQCABIg0gAkcNAEHOACEQDJQDCwJAAkACQAJAIA0tAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZ1/ag4TAP0C/QL9Av0C/QL9Av0C/QL9Av0C/QL9AgH9Av0C/QICA/0CCyANQQFqIQFBwQAhEAz9AgsgDUEBaiEBQcIAIRAM/AILIA1BAWohAUHDACEQDPsCCyANQQFqIQFBxAAhEAz6AgsCQCABIgEgAkYNACAAQY2AgIAANgIIIAAgATYCBCABIQFBxQAhEAz6AgtBzwAhEAySAwsgECEBAkACQCAQLQAAQXZqDgQBqAKoAgCoAgsgEEEBaiEBC0EnIRAM+AILAkAgASIBIAJHDQBB0QAhEAyRAwsCQCABLQAAQSBGDQAgASEBDI0BCyABQQFqIQEgAC0ALUEBcUUNxwEgASEBDIwBCyABIhcgAkcNyAFB0gAhEAyPAwtB0wAhECABIhQgAkYNjgMgAiAUayAAKAIAIgFqIRYgFCABa0EBaiEXA0AgFC0AACABQdbCgIAAai0AAEcNzAEgAUEBRg3HASABQQFqIQEgFEEBaiIUIAJHDQALIAAgFjYCAAyOAwsCQCABIgEgAkcNAEHVACEQDI4DCyABLQAAQQpHDcwBIAFBAWohAQzHAQsCQCABIgEgAkcNAEHWACEQDI0DCwJAAkAgAS0AAEF2ag4EAM0BzQEBzQELIAFBAWohAQzHAQsgAUEBaiEBQcoAIRAM8wILIAAgASIBIAIQroCAgAAiEA3LASABIQFBzQAhEAzyAgsgAC0AKUEiRg2FAwymAgsCQCABIgEgAkcNAEHbACEQDIoDC0EAIRRBASEXQQEhFkEAIRACQAJAAkACQAJAAkACQAJAAkAgAS0AAEFQag4K1AHTAQABAgMEBQYI1QELQQIhEAwGC0EDIRAMBQtBBCEQDAQLQQUhEAwDC0EGIRAMAgtBByEQDAELQQghEAtBACEXQQAhFkEAIRQMzAELQQkhEEEBIRRBACEXQQAhFgzLAQsCQCABIgEgAkcNAEHdACEQDIkDCyABLQAAQS5HDcwBIAFBAWohAQymAgsgASIBIAJHDcwBQd8AIRAMhwMLAkAgASIBIAJGDQAgAEGOgICAADYCCCAAIAE2AgQgASEBQdAAIRAM7gILQeAAIRAMhgMLQeEAIRAgASIBIAJGDYUDIAIgAWsgACgCACIUaiEWIAEgFGtBA2ohFwNAIAEtAAAgFEHiwoCAAGotAABHDc0BIBRBA0YNzAEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMhQMLQeIAIRAgASIBIAJGDYQDIAIgAWsgACgCACIUaiEWIAEgFGtBAmohFwNAIAEtAAAgFEHmwoCAAGotAABHDcwBIBRBAkYNzgEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMhAMLQeMAIRAgASIBIAJGDYMDIAIgAWsgACgCACIUaiEWIAEgFGtBA2ohFwNAIAEtAAAgFEHpwoCAAGotAABHDcsBIBRBA0YNzgEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMgwMLAkAgASIBIAJHDQBB5QAhEAyDAwsgACABQQFqIgEgAhCogICAACIQDc0BIAEhAUHWACEQDOkCCwJAIAEiASACRg0AA0ACQCABLQAAIhBBIEYNAAJAAkACQCAQQbh/ag4LAAHPAc8BzwHPAc8BzwHPAc8BAs8BCyABQQFqIQFB0gAhEAztAgsgAUEBaiEBQdMAIRAM7AILIAFBAWohAUHUACEQDOsCCyABQQFqIgEgAkcNAAtB5AAhEAyCAwtB5AAhEAyBAwsDQAJAIAEtAABB8MKAgABqLQAAIhBBAUYNACAQQX5qDgPPAdAB0QHSAQsgAUEBaiIBIAJHDQALQeYAIRAMgAMLAkAgASIBIAJGDQAgAUEBaiEBDAMLQecAIRAM/wILA0ACQCABLQAAQfDEgIAAai0AACIQQQFGDQACQCAQQX5qDgTSAdMB1AEA1QELIAEhAUHXACEQDOcCCyABQQFqIgEgAkcNAAtB6AAhEAz+AgsCQCABIgEgAkcNAEHpACEQDP4CCwJAIAEtAAAiEEF2ag4augHVAdUBvAHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHKAdUB1QEA0wELIAFBAWohAQtBBiEQDOMCCwNAAkAgAS0AAEHwxoCAAGotAABBAUYNACABIQEMngILIAFBAWoiASACRw0AC0HqACEQDPsCCwJAIAEiASACRg0AIAFBAWohAQwDC0HrACEQDPoCCwJAIAEiASACRw0AQewAIRAM+gILIAFBAWohAQwBCwJAIAEiASACRw0AQe0AIRAM+QILIAFBAWohAQtBBCEQDN4CCwJAIAEiFCACRw0AQe4AIRAM9wILIBQhAQJAAkACQCAULQAAQfDIgIAAai0AAEF/ag4H1AHVAdYBAJwCAQLXAQsgFEEBaiEBDAoLIBRBAWohAQzNAQtBACEQIABBADYCHCAAQZuSgIAANgIQIABBBzYCDCAAIBRBAWo2AhQM9gILAkADQAJAIAEtAABB8MiAgABqLQAAIhBBBEYNAAJAAkAgEEF/ag4H0gHTAdQB2QEABAHZAQsgASEBQdoAIRAM4AILIAFBAWohAUHcACEQDN8CCyABQQFqIgEgAkcNAAtB7wAhEAz2AgsgAUEBaiEBDMsBCwJAIAEiFCACRw0AQfAAIRAM9QILIBQtAABBL0cN1AEgFEEBaiEBDAYLAkAgASIUIAJHDQBB8QAhEAz0AgsCQCAULQAAIgFBL0cNACAUQQFqIQFB3QAhEAzbAgsgAUF2aiIEQRZLDdMBQQEgBHRBiYCAAnFFDdMBDMoCCwJAIAEiASACRg0AIAFBAWohAUHeACEQDNoCC0HyACEQDPICCwJAIAEiFCACRw0AQfQAIRAM8gILIBQhAQJAIBQtAABB8MyAgABqLQAAQX9qDgPJApQCANQBC0HhACEQDNgCCwJAIAEiFCACRg0AA0ACQCAULQAAQfDKgIAAai0AACIBQQNGDQACQCABQX9qDgLLAgDVAQsgFCEBQd8AIRAM2gILIBRBAWoiFCACRw0AC0HzACEQDPECC0HzACEQDPACCwJAIAEiASACRg0AIABBj4CAgAA2AgggACABNgIEIAEhAUHgACEQDNcCC0H1ACEQDO8CCwJAIAEiASACRw0AQfYAIRAM7wILIABBj4CAgAA2AgggACABNgIEIAEhAQtBAyEQDNQCCwNAIAEtAABBIEcNwwIgAUEBaiIBIAJHDQALQfcAIRAM7AILAkAgASIBIAJHDQBB+AAhEAzsAgsgAS0AAEEgRw3OASABQQFqIQEM7wELIAAgASIBIAIQrICAgAAiEA3OASABIQEMjgILAkAgASIEIAJHDQBB+gAhEAzqAgsgBC0AAEHMAEcN0QEgBEEBaiEBQRMhEAzPAQsCQCABIgQgAkcNAEH7ACEQDOkCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRADQCAELQAAIAFB8M6AgABqLQAARw3QASABQQVGDc4BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQfsAIRAM6AILAkAgASIEIAJHDQBB/AAhEAzoAgsCQAJAIAQtAABBvX9qDgwA0QHRAdEB0QHRAdEB0QHRAdEB0QEB0QELIARBAWohAUHmACEQDM8CCyAEQQFqIQFB5wAhEAzOAgsCQCABIgQgAkcNAEH9ACEQDOcCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDc8BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH9ACEQDOcCCyAAQQA2AgAgEEEBaiEBQRAhEAzMAQsCQCABIgQgAkcNAEH+ACEQDOYCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUH2zoCAAGotAABHDc4BIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH+ACEQDOYCCyAAQQA2AgAgEEEBaiEBQRYhEAzLAQsCQCABIgQgAkcNAEH/ACEQDOUCCyACIARrIAAoAgAiAWohFCAEIAFrQQNqIRACQANAIAQtAAAgAUH8zoCAAGotAABHDc0BIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH/ACEQDOUCCyAAQQA2AgAgEEEBaiEBQQUhEAzKAQsCQCABIgQgAkcNAEGAASEQDOQCCyAELQAAQdkARw3LASAEQQFqIQFBCCEQDMkBCwJAIAEiBCACRw0AQYEBIRAM4wILAkACQCAELQAAQbJ/ag4DAMwBAcwBCyAEQQFqIQFB6wAhEAzKAgsgBEEBaiEBQewAIRAMyQILAkAgASIEIAJHDQBBggEhEAziAgsCQAJAIAQtAABBuH9qDggAywHLAcsBywHLAcsBAcsBCyAEQQFqIQFB6gAhEAzJAgsgBEEBaiEBQe0AIRAMyAILAkAgASIEIAJHDQBBgwEhEAzhAgsgAiAEayAAKAIAIgFqIRAgBCABa0ECaiEUAkADQCAELQAAIAFBgM+AgABqLQAARw3JASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBA2AgBBgwEhEAzhAgtBACEQIABBADYCACAUQQFqIQEMxgELAkAgASIEIAJHDQBBhAEhEAzgAgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBg8+AgABqLQAARw3IASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBhAEhEAzgAgsgAEEANgIAIBBBAWohAUEjIRAMxQELAkAgASIEIAJHDQBBhQEhEAzfAgsCQAJAIAQtAABBtH9qDggAyAHIAcgByAHIAcgBAcgBCyAEQQFqIQFB7wAhEAzGAgsgBEEBaiEBQfAAIRAMxQILAkAgASIEIAJHDQBBhgEhEAzeAgsgBC0AAEHFAEcNxQEgBEEBaiEBDIMCCwJAIAEiBCACRw0AQYcBIRAM3QILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQYjPgIAAai0AAEcNxQEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYcBIRAM3QILIABBADYCACAQQQFqIQFBLSEQDMIBCwJAIAEiBCACRw0AQYgBIRAM3AILIAIgBGsgACgCACIBaiEUIAQgAWtBCGohEAJAA0AgBC0AACABQdDPgIAAai0AAEcNxAEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYgBIRAM3AILIABBADYCACAQQQFqIQFBKSEQDMEBCwJAIAEiASACRw0AQYkBIRAM2wILQQEhECABLQAAQd8ARw3AASABQQFqIQEMgQILAkAgASIEIAJHDQBBigEhEAzaAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQA0AgBC0AACABQYzPgIAAai0AAEcNwQEgAUEBRg2vAiABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGKASEQDNkCCwJAIAEiBCACRw0AQYsBIRAM2QILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQY7PgIAAai0AAEcNwQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYsBIRAM2QILIABBADYCACAQQQFqIQFBAiEQDL4BCwJAIAEiBCACRw0AQYwBIRAM2AILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfDPgIAAai0AAEcNwAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYwBIRAM2AILIABBADYCACAQQQFqIQFBHyEQDL0BCwJAIAEiBCACRw0AQY0BIRAM1wILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfLPgIAAai0AAEcNvwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQY0BIRAM1wILIABBADYCACAQQQFqIQFBCSEQDLwBCwJAIAEiBCACRw0AQY4BIRAM1gILAkACQCAELQAAQbd/ag4HAL8BvwG/Ab8BvwEBvwELIARBAWohAUH4ACEQDL0CCyAEQQFqIQFB+QAhEAy8AgsCQCABIgQgAkcNAEGPASEQDNUCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGRz4CAAGotAABHDb0BIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGPASEQDNUCCyAAQQA2AgAgEEEBaiEBQRghEAy6AQsCQCABIgQgAkcNAEGQASEQDNQCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUGXz4CAAGotAABHDbwBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGQASEQDNQCCyAAQQA2AgAgEEEBaiEBQRchEAy5AQsCQCABIgQgAkcNAEGRASEQDNMCCyACIARrIAAoAgAiAWohFCAEIAFrQQZqIRACQANAIAQtAAAgAUGaz4CAAGotAABHDbsBIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGRASEQDNMCCyAAQQA2AgAgEEEBaiEBQRUhEAy4AQsCQCABIgQgAkcNAEGSASEQDNICCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGhz4CAAGotAABHDboBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGSASEQDNICCyAAQQA2AgAgEEEBaiEBQR4hEAy3AQsCQCABIgQgAkcNAEGTASEQDNECCyAELQAAQcwARw24ASAEQQFqIQFBCiEQDLYBCwJAIAQgAkcNAEGUASEQDNACCwJAAkAgBC0AAEG/f2oODwC5AbkBuQG5AbkBuQG5AbkBuQG5AbkBuQG5AQG5AQsgBEEBaiEBQf4AIRAMtwILIARBAWohAUH/ACEQDLYCCwJAIAQgAkcNAEGVASEQDM8CCwJAAkAgBC0AAEG/f2oOAwC4AQG4AQsgBEEBaiEBQf0AIRAMtgILIARBAWohBEGAASEQDLUCCwJAIAQgAkcNAEGWASEQDM4CCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUGnz4CAAGotAABHDbYBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGWASEQDM4CCyAAQQA2AgAgEEEBaiEBQQshEAyzAQsCQCAEIAJHDQBBlwEhEAzNAgsCQAJAAkACQCAELQAAQVNqDiMAuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AQG4AbgBuAG4AbgBArgBuAG4AQO4AQsgBEEBaiEBQfsAIRAMtgILIARBAWohAUH8ACEQDLUCCyAEQQFqIQRBgQEhEAy0AgsgBEEBaiEEQYIBIRAMswILAkAgBCACRw0AQZgBIRAMzAILIAIgBGsgACgCACIBaiEUIAQgAWtBBGohEAJAA0AgBC0AACABQanPgIAAai0AAEcNtAEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZgBIRAMzAILIABBADYCACAQQQFqIQFBGSEQDLEBCwJAIAQgAkcNAEGZASEQDMsCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGuz4CAAGotAABHDbMBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGZASEQDMsCCyAAQQA2AgAgEEEBaiEBQQYhEAywAQsCQCAEIAJHDQBBmgEhEAzKAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBtM+AgABqLQAARw2yASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmgEhEAzKAgsgAEEANgIAIBBBAWohAUEcIRAMrwELAkAgBCACRw0AQZsBIRAMyQILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQbbPgIAAai0AAEcNsQEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZsBIRAMyQILIABBADYCACAQQQFqIQFBJyEQDK4BCwJAIAQgAkcNAEGcASEQDMgCCwJAAkAgBC0AAEGsf2oOAgABsQELIARBAWohBEGGASEQDK8CCyAEQQFqIQRBhwEhEAyuAgsCQCAEIAJHDQBBnQEhEAzHAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBuM+AgABqLQAARw2vASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBnQEhEAzHAgsgAEEANgIAIBBBAWohAUEmIRAMrAELAkAgBCACRw0AQZ4BIRAMxgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQbrPgIAAai0AAEcNrgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZ4BIRAMxgILIABBADYCACAQQQFqIQFBAyEQDKsBCwJAIAQgAkcNAEGfASEQDMUCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDa0BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGfASEQDMUCCyAAQQA2AgAgEEEBaiEBQQwhEAyqAQsCQCAEIAJHDQBBoAEhEAzEAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFBvM+AgABqLQAARw2sASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBoAEhEAzEAgsgAEEANgIAIBBBAWohAUENIRAMqQELAkAgBCACRw0AQaEBIRAMwwILAkACQCAELQAAQbp/ag4LAKwBrAGsAawBrAGsAawBrAGsAQGsAQsgBEEBaiEEQYsBIRAMqgILIARBAWohBEGMASEQDKkCCwJAIAQgAkcNAEGiASEQDMICCyAELQAAQdAARw2pASAEQQFqIQQM6QELAkAgBCACRw0AQaMBIRAMwQILAkACQCAELQAAQbd/ag4HAaoBqgGqAaoBqgEAqgELIARBAWohBEGOASEQDKgCCyAEQQFqIQFBIiEQDKYBCwJAIAQgAkcNAEGkASEQDMACCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUHAz4CAAGotAABHDagBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGkASEQDMACCyAAQQA2AgAgEEEBaiEBQR0hEAylAQsCQCAEIAJHDQBBpQEhEAy/AgsCQAJAIAQtAABBrn9qDgMAqAEBqAELIARBAWohBEGQASEQDKYCCyAEQQFqIQFBBCEQDKQBCwJAIAQgAkcNAEGmASEQDL4CCwJAAkACQAJAAkAgBC0AAEG/f2oOFQCqAaoBqgGqAaoBqgGqAaoBqgGqAQGqAaoBAqoBqgEDqgGqAQSqAQsgBEEBaiEEQYgBIRAMqAILIARBAWohBEGJASEQDKcCCyAEQQFqIQRBigEhEAymAgsgBEEBaiEEQY8BIRAMpQILIARBAWohBEGRASEQDKQCCwJAIAQgAkcNAEGnASEQDL0CCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDaUBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGnASEQDL0CCyAAQQA2AgAgEEEBaiEBQREhEAyiAQsCQCAEIAJHDQBBqAEhEAy8AgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBws+AgABqLQAARw2kASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBqAEhEAy8AgsgAEEANgIAIBBBAWohAUEsIRAMoQELAkAgBCACRw0AQakBIRAMuwILIAIgBGsgACgCACIBaiEUIAQgAWtBBGohEAJAA0AgBC0AACABQcXPgIAAai0AAEcNowEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQakBIRAMuwILIABBADYCACAQQQFqIQFBKyEQDKABCwJAIAQgAkcNAEGqASEQDLoCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHKz4CAAGotAABHDaIBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGqASEQDLoCCyAAQQA2AgAgEEEBaiEBQRQhEAyfAQsCQCAEIAJHDQBBqwEhEAy5AgsCQAJAAkACQCAELQAAQb5/ag4PAAECpAGkAaQBpAGkAaQBpAGkAaQBpAGkAQOkAQsgBEEBaiEEQZMBIRAMogILIARBAWohBEGUASEQDKECCyAEQQFqIQRBlQEhEAygAgsgBEEBaiEEQZYBIRAMnwILAkAgBCACRw0AQawBIRAMuAILIAQtAABBxQBHDZ8BIARBAWohBAzgAQsCQCAEIAJHDQBBrQEhEAy3AgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBzc+AgABqLQAARw2fASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBrQEhEAy3AgsgAEEANgIAIBBBAWohAUEOIRAMnAELAkAgBCACRw0AQa4BIRAMtgILIAQtAABB0ABHDZ0BIARBAWohAUElIRAMmwELAkAgBCACRw0AQa8BIRAMtQILIAIgBGsgACgCACIBaiEUIAQgAWtBCGohEAJAA0AgBC0AACABQdDPgIAAai0AAEcNnQEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQa8BIRAMtQILIABBADYCACAQQQFqIQFBKiEQDJoBCwJAIAQgAkcNAEGwASEQDLQCCwJAAkAgBC0AAEGrf2oOCwCdAZ0BnQGdAZ0BnQGdAZ0BnQEBnQELIARBAWohBEGaASEQDJsCCyAEQQFqIQRBmwEhEAyaAgsCQCAEIAJHDQBBsQEhEAyzAgsCQAJAIAQtAABBv39qDhQAnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBAZwBCyAEQQFqIQRBmQEhEAyaAgsgBEEBaiEEQZwBIRAMmQILAkAgBCACRw0AQbIBIRAMsgILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQdnPgIAAai0AAEcNmgEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbIBIRAMsgILIABBADYCACAQQQFqIQFBISEQDJcBCwJAIAQgAkcNAEGzASEQDLECCyACIARrIAAoAgAiAWohFCAEIAFrQQZqIRACQANAIAQtAAAgAUHdz4CAAGotAABHDZkBIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGzASEQDLECCyAAQQA2AgAgEEEBaiEBQRohEAyWAQsCQCAEIAJHDQBBtAEhEAywAgsCQAJAAkAgBC0AAEG7f2oOEQCaAZoBmgGaAZoBmgGaAZoBmgEBmgGaAZoBmgGaAQKaAQsgBEEBaiEEQZ0BIRAMmAILIARBAWohBEGeASEQDJcCCyAEQQFqIQRBnwEhEAyWAgsCQCAEIAJHDQBBtQEhEAyvAgsgAiAEayAAKAIAIgFqIRQgBCABa0EFaiEQAkADQCAELQAAIAFB5M+AgABqLQAARw2XASABQQVGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBtQEhEAyvAgsgAEEANgIAIBBBAWohAUEoIRAMlAELAkAgBCACRw0AQbYBIRAMrgILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQerPgIAAai0AAEcNlgEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbYBIRAMrgILIABBADYCACAQQQFqIQFBByEQDJMBCwJAIAQgAkcNAEG3ASEQDK0CCwJAAkAgBC0AAEG7f2oODgCWAZYBlgGWAZYBlgGWAZYBlgGWAZYBlgEBlgELIARBAWohBEGhASEQDJQCCyAEQQFqIQRBogEhEAyTAgsCQCAEIAJHDQBBuAEhEAysAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFB7c+AgABqLQAARw2UASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBuAEhEAysAgsgAEEANgIAIBBBAWohAUESIRAMkQELAkAgBCACRw0AQbkBIRAMqwILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfDPgIAAai0AAEcNkwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbkBIRAMqwILIABBADYCACAQQQFqIQFBICEQDJABCwJAIAQgAkcNAEG6ASEQDKoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUHyz4CAAGotAABHDZIBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG6ASEQDKoCCyAAQQA2AgAgEEEBaiEBQQ8hEAyPAQsCQCAEIAJHDQBBuwEhEAypAgsCQAJAIAQtAABBt39qDgcAkgGSAZIBkgGSAQGSAQsgBEEBaiEEQaUBIRAMkAILIARBAWohBEGmASEQDI8CCwJAIAQgAkcNAEG8ASEQDKgCCyACIARrIAAoAgAiAWohFCAEIAFrQQdqIRACQANAIAQtAAAgAUH0z4CAAGotAABHDZABIAFBB0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG8ASEQDKgCCyAAQQA2AgAgEEEBaiEBQRshEAyNAQsCQCAEIAJHDQBBvQEhEAynAgsCQAJAAkAgBC0AAEG+f2oOEgCRAZEBkQGRAZEBkQGRAZEBkQEBkQGRAZEBkQGRAZEBApEBCyAEQQFqIQRBpAEhEAyPAgsgBEEBaiEEQacBIRAMjgILIARBAWohBEGoASEQDI0CCwJAIAQgAkcNAEG+ASEQDKYCCyAELQAAQc4ARw2NASAEQQFqIQQMzwELAkAgBCACRw0AQb8BIRAMpQILAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBC0AAEG/f2oOFQABAgOcAQQFBpwBnAGcAQcICQoLnAEMDQ4PnAELIARBAWohAUHoACEQDJoCCyAEQQFqIQFB6QAhEAyZAgsgBEEBaiEBQe4AIRAMmAILIARBAWohAUHyACEQDJcCCyAEQQFqIQFB8wAhEAyWAgsgBEEBaiEBQfYAIRAMlQILIARBAWohAUH3ACEQDJQCCyAEQQFqIQFB+gAhEAyTAgsgBEEBaiEEQYMBIRAMkgILIARBAWohBEGEASEQDJECCyAEQQFqIQRBhQEhEAyQAgsgBEEBaiEEQZIBIRAMjwILIARBAWohBEGYASEQDI4CCyAEQQFqIQRBoAEhEAyNAgsgBEEBaiEEQaMBIRAMjAILIARBAWohBEGqASEQDIsCCwJAIAQgAkYNACAAQZCAgIAANgIIIAAgBDYCBEGrASEQDIsCC0HAASEQDKMCCyAAIAUgAhCqgICAACIBDYsBIAUhAQxcCwJAIAYgAkYNACAGQQFqIQUMjQELQcIBIRAMoQILA0ACQCAQLQAAQXZqDgSMAQAAjwEACyAQQQFqIhAgAkcNAAtBwwEhEAygAgsCQCAHIAJGDQAgAEGRgICAADYCCCAAIAc2AgQgByEBQQEhEAyHAgtBxAEhEAyfAgsCQCAHIAJHDQBBxQEhEAyfAgsCQAJAIActAABBdmoOBAHOAc4BAM4BCyAHQQFqIQYMjQELIAdBAWohBQyJAQsCQCAHIAJHDQBBxgEhEAyeAgsCQAJAIActAABBdmoOFwGPAY8BAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAQCPAQsgB0EBaiEHC0GwASEQDIQCCwJAIAggAkcNAEHIASEQDJ0CCyAILQAAQSBHDY0BIABBADsBMiAIQQFqIQFBswEhEAyDAgsgASEXAkADQCAXIgcgAkYNASAHLQAAQVBqQf8BcSIQQQpPDcwBAkAgAC8BMiIUQZkzSw0AIAAgFEEKbCIUOwEyIBBB//8DcyAUQf7/A3FJDQAgB0EBaiEXIAAgFCAQaiIQOwEyIBBB//8DcUHoB0kNAQsLQQAhECAAQQA2AhwgAEHBiYCAADYCECAAQQ02AgwgACAHQQFqNgIUDJwCC0HHASEQDJsCCyAAIAggAhCugICAACIQRQ3KASAQQRVHDYwBIABByAE2AhwgACAINgIUIABByZeAgAA2AhAgAEEVNgIMQQAhEAyaAgsCQCAJIAJHDQBBzAEhEAyaAgtBACEUQQEhF0EBIRZBACEQAkACQAJAAkACQAJAAkACQAJAIAktAABBUGoOCpYBlQEAAQIDBAUGCJcBC0ECIRAMBgtBAyEQDAULQQQhEAwEC0EFIRAMAwtBBiEQDAILQQchEAwBC0EIIRALQQAhF0EAIRZBACEUDI4BC0EJIRBBASEUQQAhF0EAIRYMjQELAkAgCiACRw0AQc4BIRAMmQILIAotAABBLkcNjgEgCkEBaiEJDMoBCyALIAJHDY4BQdABIRAMlwILAkAgCyACRg0AIABBjoCAgAA2AgggACALNgIEQbcBIRAM/gELQdEBIRAMlgILAkAgBCACRw0AQdIBIRAMlgILIAIgBGsgACgCACIQaiEUIAQgEGtBBGohCwNAIAQtAAAgEEH8z4CAAGotAABHDY4BIBBBBEYN6QEgEEEBaiEQIARBAWoiBCACRw0ACyAAIBQ2AgBB0gEhEAyVAgsgACAMIAIQrICAgAAiAQ2NASAMIQEMuAELAkAgBCACRw0AQdQBIRAMlAILIAIgBGsgACgCACIQaiEUIAQgEGtBAWohDANAIAQtAAAgEEGB0ICAAGotAABHDY8BIBBBAUYNjgEgEEEBaiEQIARBAWoiBCACRw0ACyAAIBQ2AgBB1AEhEAyTAgsCQCAEIAJHDQBB1gEhEAyTAgsgAiAEayAAKAIAIhBqIRQgBCAQa0ECaiELA0AgBC0AACAQQYPQgIAAai0AAEcNjgEgEEECRg2QASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHWASEQDJICCwJAIAQgAkcNAEHXASEQDJICCwJAAkAgBC0AAEG7f2oOEACPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BAY8BCyAEQQFqIQRBuwEhEAz5AQsgBEEBaiEEQbwBIRAM+AELAkAgBCACRw0AQdgBIRAMkQILIAQtAABByABHDYwBIARBAWohBAzEAQsCQCAEIAJGDQAgAEGQgICAADYCCCAAIAQ2AgRBvgEhEAz3AQtB2QEhEAyPAgsCQCAEIAJHDQBB2gEhEAyPAgsgBC0AAEHIAEYNwwEgAEEBOgAoDLkBCyAAQQI6AC8gACAEIAIQpoCAgAAiEA2NAUHCASEQDPQBCyAALQAoQX9qDgK3AbkBuAELA0ACQCAELQAAQXZqDgQAjgGOAQCOAQsgBEEBaiIEIAJHDQALQd0BIRAMiwILIABBADoALyAALQAtQQRxRQ2EAgsgAEEAOgAvIABBAToANCABIQEMjAELIBBBFUYN2gEgAEEANgIcIAAgATYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAMiAILAkAgACAQIAIQtICAgAAiBA0AIBAhAQyBAgsCQCAEQRVHDQAgAEEDNgIcIAAgEDYCFCAAQbCYgIAANgIQIABBFTYCDEEAIRAMiAILIABBADYCHCAAIBA2AhQgAEGnjoCAADYCECAAQRI2AgxBACEQDIcCCyAQQRVGDdYBIABBADYCHCAAIAE2AhQgAEHajYCAADYCECAAQRQ2AgxBACEQDIYCCyAAKAIEIRcgAEEANgIEIBAgEadqIhYhASAAIBcgECAWIBQbIhAQtYCAgAAiFEUNjQEgAEEHNgIcIAAgEDYCFCAAIBQ2AgxBACEQDIUCCyAAIAAvATBBgAFyOwEwIAEhAQtBKiEQDOoBCyAQQRVGDdEBIABBADYCHCAAIAE2AhQgAEGDjICAADYCECAAQRM2AgxBACEQDIICCyAQQRVGDc8BIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDIECCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyNAQsgAEEMNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDIACCyAQQRVGDcwBIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDP8BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyMAQsgAEENNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDP4BCyAQQRVGDckBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDP0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQuYCAgAAiEA0AIAFBAWohAQyLAQsgAEEONgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPwBCyAAQQA2AhwgACABNgIUIABBwJWAgAA2AhAgAEECNgIMQQAhEAz7AQsgEEEVRg3FASAAQQA2AhwgACABNgIUIABBxoyAgAA2AhAgAEEjNgIMQQAhEAz6AQsgAEEQNgIcIAAgATYCFCAAIBA2AgxBACEQDPkBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQuYCAgAAiBA0AIAFBAWohAQzxAQsgAEERNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPgBCyAQQRVGDcEBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDPcBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQuYCAgAAiEA0AIAFBAWohAQyIAQsgAEETNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPYBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQuYCAgAAiBA0AIAFBAWohAQztAQsgAEEUNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPUBCyAQQRVGDb0BIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDPQBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyGAQsgAEEWNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPMBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQt4CAgAAiBA0AIAFBAWohAQzpAQsgAEEXNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPIBCyAAQQA2AhwgACABNgIUIABBzZOAgAA2AhAgAEEMNgIMQQAhEAzxAQtCASERCyAQQQFqIQECQCAAKQMgIhJC//////////8PVg0AIAAgEkIEhiARhDcDICABIQEMhAELIABBADYCHCAAIAE2AhQgAEGtiYCAADYCECAAQQw2AgxBACEQDO8BCyAAQQA2AhwgACAQNgIUIABBzZOAgAA2AhAgAEEMNgIMQQAhEAzuAQsgACgCBCEXIABBADYCBCAQIBGnaiIWIQEgACAXIBAgFiAUGyIQELWAgIAAIhRFDXMgAEEFNgIcIAAgEDYCFCAAIBQ2AgxBACEQDO0BCyAAQQA2AhwgACAQNgIUIABBqpyAgAA2AhAgAEEPNgIMQQAhEAzsAQsgACAQIAIQtICAgAAiAQ0BIBAhAQtBDiEQDNEBCwJAIAFBFUcNACAAQQI2AhwgACAQNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAzqAQsgAEEANgIcIAAgEDYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAM6QELIAFBAWohEAJAIAAvATAiAUGAAXFFDQACQCAAIBAgAhC7gICAACIBDQAgECEBDHALIAFBFUcNugEgAEEFNgIcIAAgEDYCFCAAQfmXgIAANgIQIABBFTYCDEEAIRAM6QELAkAgAUGgBHFBoARHDQAgAC0ALUECcQ0AIABBADYCHCAAIBA2AhQgAEGWk4CAADYCECAAQQQ2AgxBACEQDOkBCyAAIBAgAhC9gICAABogECEBAkACQAJAAkACQCAAIBAgAhCzgICAAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIABBAToALgsgACAALwEwQcAAcjsBMCAQIQELQSYhEAzRAQsgAEEjNgIcIAAgEDYCFCAAQaWWgIAANgIQIABBFTYCDEEAIRAM6QELIABBADYCHCAAIBA2AhQgAEHVi4CAADYCECAAQRE2AgxBACEQDOgBCyAALQAtQQFxRQ0BQcMBIRAMzgELAkAgDSACRg0AA0ACQCANLQAAQSBGDQAgDSEBDMQBCyANQQFqIg0gAkcNAAtBJSEQDOcBC0ElIRAM5gELIAAoAgQhBCAAQQA2AgQgACAEIA0Qr4CAgAAiBEUNrQEgAEEmNgIcIAAgBDYCDCAAIA1BAWo2AhRBACEQDOUBCyAQQRVGDasBIABBADYCHCAAIAE2AhQgAEH9jYCAADYCECAAQR02AgxBACEQDOQBCyAAQSc2AhwgACABNgIUIAAgEDYCDEEAIRAM4wELIBAhAUEBIRQCQAJAAkACQAJAAkACQCAALQAsQX5qDgcGBQUDAQIABQsgACAALwEwQQhyOwEwDAMLQQIhFAwBC0EEIRQLIABBAToALCAAIAAvATAgFHI7ATALIBAhAQtBKyEQDMoBCyAAQQA2AhwgACAQNgIUIABBq5KAgAA2AhAgAEELNgIMQQAhEAziAQsgAEEANgIcIAAgATYCFCAAQeGPgIAANgIQIABBCjYCDEEAIRAM4QELIABBADoALCAQIQEMvQELIBAhAUEBIRQCQAJAAkACQAJAIAAtACxBe2oOBAMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEUDAELQQQhFAsgAEEBOgAsIAAgAC8BMCAUcjsBMAsgECEBC0EpIRAMxQELIABBADYCHCAAIAE2AhQgAEHwlICAADYCECAAQQM2AgxBACEQDN0BCwJAIA4tAABBDUcNACAAKAIEIQEgAEEANgIEAkAgACABIA4QsYCAgAAiAQ0AIA5BAWohAQx1CyAAQSw2AhwgACABNgIMIAAgDkEBajYCFEEAIRAM3QELIAAtAC1BAXFFDQFBxAEhEAzDAQsCQCAOIAJHDQBBLSEQDNwBCwJAAkADQAJAIA4tAABBdmoOBAIAAAMACyAOQQFqIg4gAkcNAAtBLSEQDN0BCyAAKAIEIQEgAEEANgIEAkAgACABIA4QsYCAgAAiAQ0AIA4hAQx0CyAAQSw2AhwgACAONgIUIAAgATYCDEEAIRAM3AELIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDkEBaiEBDHMLIABBLDYCHCAAIAE2AgwgACAOQQFqNgIUQQAhEAzbAQsgACgCBCEEIABBADYCBCAAIAQgDhCxgICAACIEDaABIA4hAQzOAQsgEEEsRw0BIAFBAWohEEEBIQECQAJAAkACQAJAIAAtACxBe2oOBAMBAgQACyAQIQEMBAtBAiEBDAELQQQhAQsgAEEBOgAsIAAgAC8BMCABcjsBMCAQIQEMAQsgACAALwEwQQhyOwEwIBAhAQtBOSEQDL8BCyAAQQA6ACwgASEBC0E0IRAMvQELIAAgAC8BMEEgcjsBMCABIQEMAgsgACgCBCEEIABBADYCBAJAIAAgBCABELGAgIAAIgQNACABIQEMxwELIABBNzYCHCAAIAE2AhQgACAENgIMQQAhEAzUAQsgAEEIOgAsIAEhAQtBMCEQDLkBCwJAIAAtAChBAUYNACABIQEMBAsgAC0ALUEIcUUNkwEgASEBDAMLIAAtADBBIHENlAFBxQEhEAy3AQsCQCAPIAJGDQACQANAAkAgDy0AAEFQaiIBQf8BcUEKSQ0AIA8hAUE1IRAMugELIAApAyAiEUKZs+bMmbPmzBlWDQEgACARQgp+IhE3AyAgESABrUL/AYMiEkJ/hVYNASAAIBEgEnw3AyAgD0EBaiIPIAJHDQALQTkhEAzRAQsgACgCBCECIABBADYCBCAAIAIgD0EBaiIEELGAgIAAIgINlQEgBCEBDMMBC0E5IRAMzwELAkAgAC8BMCIBQQhxRQ0AIAAtAChBAUcNACAALQAtQQhxRQ2QAQsgACABQff7A3FBgARyOwEwIA8hAQtBNyEQDLQBCyAAIAAvATBBEHI7ATAMqwELIBBBFUYNiwEgAEEANgIcIAAgATYCFCAAQfCOgIAANgIQIABBHDYCDEEAIRAMywELIABBwwA2AhwgACABNgIMIAAgDUEBajYCFEEAIRAMygELAkAgAS0AAEE6Rw0AIAAoAgQhECAAQQA2AgQCQCAAIBAgARCvgICAACIQDQAgAUEBaiEBDGMLIABBwwA2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAMygELIABBADYCHCAAIAE2AhQgAEGxkYCAADYCECAAQQo2AgxBACEQDMkBCyAAQQA2AhwgACABNgIUIABBoJmAgAA2AhAgAEEeNgIMQQAhEAzIAQsgAEEANgIACyAAQYASOwEqIAAgF0EBaiIBIAIQqICAgAAiEA0BIAEhAQtBxwAhEAysAQsgEEEVRw2DASAAQdEANgIcIAAgATYCFCAAQeOXgIAANgIQIABBFTYCDEEAIRAMxAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDF4LIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMwwELIABBADYCHCAAIBQ2AhQgAEHBqICAADYCECAAQQc2AgwgAEEANgIAQQAhEAzCAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMXQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAzBAQtBACEQIABBADYCHCAAIAE2AhQgAEGAkYCAADYCECAAQQk2AgwMwAELIBBBFUYNfSAAQQA2AhwgACABNgIUIABBlI2AgAA2AhAgAEEhNgIMQQAhEAy/AQtBASEWQQAhF0EAIRRBASEQCyAAIBA6ACsgAUEBaiEBAkACQCAALQAtQRBxDQACQAJAAkAgAC0AKg4DAQACBAsgFkUNAwwCCyAUDQEMAgsgF0UNAQsgACgCBCEQIABBADYCBAJAIAAgECABEK2AgIAAIhANACABIQEMXAsgAEHYADYCHCAAIAE2AhQgACAQNgIMQQAhEAy+AQsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMrQELIABB2QA2AhwgACABNgIUIAAgBDYCDEEAIRAMvQELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKsBCyAAQdoANgIcIAAgATYCFCAAIAQ2AgxBACEQDLwBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQypAQsgAEHcADYCHCAAIAE2AhQgACAENgIMQQAhEAy7AQsCQCABLQAAQVBqIhBB/wFxQQpPDQAgACAQOgAqIAFBAWohAUHPACEQDKIBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQynAQsgAEHeADYCHCAAIAE2AhQgACAENgIMQQAhEAy6AQsgAEEANgIAIBdBAWohAQJAIAAtAClBI08NACABIQEMWQsgAEEANgIcIAAgATYCFCAAQdOJgIAANgIQIABBCDYCDEEAIRAMuQELIABBADYCAAtBACEQIABBADYCHCAAIAE2AhQgAEGQs4CAADYCECAAQQg2AgwMtwELIABBADYCACAXQQFqIQECQCAALQApQSFHDQAgASEBDFYLIABBADYCHCAAIAE2AhQgAEGbioCAADYCECAAQQg2AgxBACEQDLYBCyAAQQA2AgAgF0EBaiEBAkAgAC0AKSIQQV1qQQtPDQAgASEBDFULAkAgEEEGSw0AQQEgEHRBygBxRQ0AIAEhAQxVC0EAIRAgAEEANgIcIAAgATYCFCAAQfeJgIAANgIQIABBCDYCDAy1AQsgEEEVRg1xIABBADYCHCAAIAE2AhQgAEG5jYCAADYCECAAQRo2AgxBACEQDLQBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxUCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLMBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdIANgIcIAAgATYCFCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js"(
		exports2,
		module2,
	) {
		"use strict";
		module2.exports =
			"AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCrLgAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQyoCAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDKgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMqAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMqAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL/gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARB//8DcSIDQQhxDQACQCADQYAEcUUNAAJAIAAtAChBAUcNACAALQAtQQpxDQBBBQ8LQQQPCwJAIANBIHENAAJAIAAtAChBAUYNACAALwEyQf//A3EiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQShxRQ0CIANBiARxQYAERg0CC0EADwtBAEEDIAApAyBQGyEFCyAFC2IBAn9BACEBAkAgAC0AKEEBRg0AIAAvATJB//8DcSICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6cBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMkH//wNxIgVBnH9qQeQASQ0AIAVBzAFGDQAgBUGwAkYNACAEQcAAcQ0AQQAhAyAEQYgEcUGABEYNACAEQShxQQBHIQMLIABBADsBMCAAQQA6AC8gAwuZAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEBIAAvATAiAkECcUUNAQwCC0EAIQEgAC8BMCICQQFxRQ0BC0EBIQEgAC0AKEEBRg0AIAAvATJB//8DcSIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC0kBAXsgAEEQav0MAAAAAAAAAAAAAAAAAAAAACIB/QsDACAAIAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AcsBygG4AckBuQHIAboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBANwBC0EAIRAMxgELQQ4hEAzFAQtBDSEQDMQBC0EPIRAMwwELQRAhEAzCAQtBEyEQDMEBC0EUIRAMwAELQRUhEAy/AQtBFiEQDL4BC0EXIRAMvQELQRghEAy8AQtBGSEQDLsBC0EaIRAMugELQRshEAy5AQtBHCEQDLgBC0EIIRAMtwELQR0hEAy2AQtBICEQDLUBC0EfIRAMtAELQQchEAyzAQtBISEQDLIBC0EiIRAMsQELQR4hEAywAQtBIyEQDK8BC0ESIRAMrgELQREhEAytAQtBJCEQDKwBC0ElIRAMqwELQSYhEAyqAQtBJyEQDKkBC0HDASEQDKgBC0EpIRAMpwELQSshEAymAQtBLCEQDKUBC0EtIRAMpAELQS4hEAyjAQtBLyEQDKIBC0HEASEQDKEBC0EwIRAMoAELQTQhEAyfAQtBDCEQDJ4BC0ExIRAMnQELQTIhEAycAQtBMyEQDJsBC0E5IRAMmgELQTUhEAyZAQtBxQEhEAyYAQtBCyEQDJcBC0E6IRAMlgELQTYhEAyVAQtBCiEQDJQBC0E3IRAMkwELQTghEAySAQtBPCEQDJEBC0E7IRAMkAELQT0hEAyPAQtBCSEQDI4BC0EoIRAMjQELQT4hEAyMAQtBPyEQDIsBC0HAACEQDIoBC0HBACEQDIkBC0HCACEQDIgBC0HDACEQDIcBC0HEACEQDIYBC0HFACEQDIUBC0HGACEQDIQBC0EqIRAMgwELQccAIRAMggELQcgAIRAMgQELQckAIRAMgAELQcoAIRAMfwtBywAhEAx+C0HNACEQDH0LQcwAIRAMfAtBzgAhEAx7C0HPACEQDHoLQdAAIRAMeQtB0QAhEAx4C0HSACEQDHcLQdMAIRAMdgtB1AAhEAx1C0HWACEQDHQLQdUAIRAMcwtBBiEQDHILQdcAIRAMcQtBBSEQDHALQdgAIRAMbwtBBCEQDG4LQdkAIRAMbQtB2gAhEAxsC0HbACEQDGsLQdwAIRAMagtBAyEQDGkLQd0AIRAMaAtB3gAhEAxnC0HfACEQDGYLQeEAIRAMZQtB4AAhEAxkC0HiACEQDGMLQeMAIRAMYgtBAiEQDGELQeQAIRAMYAtB5QAhEAxfC0HmACEQDF4LQecAIRAMXQtB6AAhEAxcC0HpACEQDFsLQeoAIRAMWgtB6wAhEAxZC0HsACEQDFgLQe0AIRAMVwtB7gAhEAxWC0HvACEQDFULQfAAIRAMVAtB8QAhEAxTC0HyACEQDFILQfMAIRAMUQtB9AAhEAxQC0H1ACEQDE8LQfYAIRAMTgtB9wAhEAxNC0H4ACEQDEwLQfkAIRAMSwtB+gAhEAxKC0H7ACEQDEkLQfwAIRAMSAtB/QAhEAxHC0H+ACEQDEYLQf8AIRAMRQtBgAEhEAxEC0GBASEQDEMLQYIBIRAMQgtBgwEhEAxBC0GEASEQDEALQYUBIRAMPwtBhgEhEAw+C0GHASEQDD0LQYgBIRAMPAtBiQEhEAw7C0GKASEQDDoLQYsBIRAMOQtBjAEhEAw4C0GNASEQDDcLQY4BIRAMNgtBjwEhEAw1C0GQASEQDDQLQZEBIRAMMwtBkgEhEAwyC0GTASEQDDELQZQBIRAMMAtBlQEhEAwvC0GWASEQDC4LQZcBIRAMLQtBmAEhEAwsC0GZASEQDCsLQZoBIRAMKgtBmwEhEAwpC0GcASEQDCgLQZ0BIRAMJwtBngEhEAwmC0GfASEQDCULQaABIRAMJAtBoQEhEAwjC0GiASEQDCILQaMBIRAMIQtBpAEhEAwgC0GlASEQDB8LQaYBIRAMHgtBpwEhEAwdC0GoASEQDBwLQakBIRAMGwtBqgEhEAwaC0GrASEQDBkLQawBIRAMGAtBrQEhEAwXC0GuASEQDBYLQQEhEAwVC0GvASEQDBQLQbABIRAMEwtBsQEhEAwSC0GzASEQDBELQbIBIRAMEAtBtAEhEAwPC0G1ASEQDA4LQbYBIRAMDQtBtwEhEAwMC0G4ASEQDAsLQbkBIRAMCgtBugEhEAwJC0G7ASEQDAgLQcYBIRAMBwtBvAEhEAwGC0G9ASEQDAULQb4BIRAMBAtBvwEhEAwDC0HAASEQDAILQcIBIRAMAQtBwQEhEAsDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/client.js
var require_client = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/client.js"(exports2, module2) {
		"use strict";
		var assert = require("assert");
		var net = require("net");
		var http = require("http");
		var { pipeline } = require("stream");
		var util = require_util2();
		var timers = require_timers();
		var Request = require_request();
		var DispatcherBase = require_dispatcher_base();
		var {
			RequestContentLengthMismatchError,
			ResponseContentLengthMismatchError,
			InvalidArgumentError,
			RequestAbortedError,
			HeadersTimeoutError,
			HeadersOverflowError,
			SocketError,
			InformationalError,
			BodyTimeoutError,
			HTTPParserError,
			ResponseExceededMaxSizeError,
			ClientDestroyedError,
		} = require_errors2();
		var buildConnector = require_connect();
		var {
			kUrl,
			kReset,
			kServerName,
			kClient,
			kBusy,
			kParser,
			kConnect,
			kBlocking,
			kResuming,
			kRunning,
			kPending,
			kSize,
			kWriting,
			kQueue,
			kConnected,
			kConnecting,
			kNeedDrain,
			kNoRef,
			kKeepAliveDefaultTimeout,
			kHostHeader,
			kPendingIdx,
			kRunningIdx,
			kError,
			kPipelining,
			kSocket,
			kKeepAliveTimeoutValue,
			kMaxHeadersSize,
			kKeepAliveMaxTimeout,
			kKeepAliveTimeoutThreshold,
			kHeadersTimeout,
			kBodyTimeout,
			kStrictContentLength,
			kConnector,
			kMaxRedirections,
			kMaxRequests,
			kCounter,
			kClose,
			kDestroy,
			kDispatch,
			kInterceptors,
			kLocalAddress,
			kMaxResponseSize,
			kHTTPConnVersion,
			// HTTP2
			kHost,
			kHTTP2Session,
			kHTTP2SessionState,
			kHTTP2BuildRequest,
			kHTTP2CopyHeaders,
			kHTTP1BuildRequest,
		} = require_symbols();
		var http2;
		try {
			http2 = require("http2");
		} catch {
			http2 = { constants: {} };
		}
		var {
			constants: {
				HTTP2_HEADER_AUTHORITY,
				HTTP2_HEADER_METHOD,
				HTTP2_HEADER_PATH,
				HTTP2_HEADER_SCHEME,
				HTTP2_HEADER_CONTENT_LENGTH,
				HTTP2_HEADER_EXPECT,
				HTTP2_HEADER_STATUS,
			},
		} = http2;
		var h2ExperimentalWarned = false;
		var FastBuffer = Buffer[Symbol.species];
		var kClosedResolve = Symbol("kClosedResolve");
		var channels = {};
		try {
			const diagnosticsChannel = require("diagnostics_channel");
			channels.sendHeaders = diagnosticsChannel.channel("undici:client:sendHeaders");
			channels.beforeConnect = diagnosticsChannel.channel("undici:client:beforeConnect");
			channels.connectError = diagnosticsChannel.channel("undici:client:connectError");
			channels.connected = diagnosticsChannel.channel("undici:client:connected");
		} catch {
			channels.sendHeaders = { hasSubscribers: false };
			channels.beforeConnect = { hasSubscribers: false };
			channels.connectError = { hasSubscribers: false };
			channels.connected = { hasSubscribers: false };
		}
		var Client = class extends DispatcherBase {
			/**
			 *
			 * @param {string|URL} url
			 * @param {import('../types/client').Client.Options} options
			 */
			constructor(
				url,
				{
					interceptors,
					maxHeaderSize,
					headersTimeout,
					socketTimeout,
					requestTimeout,
					connectTimeout,
					bodyTimeout,
					idleTimeout,
					keepAlive,
					keepAliveTimeout,
					maxKeepAliveTimeout,
					keepAliveMaxTimeout,
					keepAliveTimeoutThreshold,
					socketPath,
					pipelining,
					tls,
					strictContentLength,
					maxCachedSessions,
					maxRedirections,
					connect: connect2,
					maxRequestsPerClient,
					localAddress,
					maxResponseSize,
					autoSelectFamily,
					autoSelectFamilyAttemptTimeout,
					// h2
					allowH2,
					maxConcurrentStreams,
				} = {},
			) {
				super();
				if (keepAlive !== void 0) {
					throw new InvalidArgumentError(
						"unsupported keepAlive, use pipelining=0 instead",
					);
				}
				if (socketTimeout !== void 0) {
					throw new InvalidArgumentError(
						"unsupported socketTimeout, use headersTimeout & bodyTimeout instead",
					);
				}
				if (requestTimeout !== void 0) {
					throw new InvalidArgumentError(
						"unsupported requestTimeout, use headersTimeout & bodyTimeout instead",
					);
				}
				if (idleTimeout !== void 0) {
					throw new InvalidArgumentError(
						"unsupported idleTimeout, use keepAliveTimeout instead",
					);
				}
				if (maxKeepAliveTimeout !== void 0) {
					throw new InvalidArgumentError(
						"unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead",
					);
				}
				if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
					throw new InvalidArgumentError("invalid maxHeaderSize");
				}
				if (socketPath != null && typeof socketPath !== "string") {
					throw new InvalidArgumentError("invalid socketPath");
				}
				if (
					connectTimeout != null &&
					(!Number.isFinite(connectTimeout) || connectTimeout < 0)
				) {
					throw new InvalidArgumentError("invalid connectTimeout");
				}
				if (
					keepAliveTimeout != null &&
					(!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)
				) {
					throw new InvalidArgumentError("invalid keepAliveTimeout");
				}
				if (
					keepAliveMaxTimeout != null &&
					(!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)
				) {
					throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
				}
				if (
					keepAliveTimeoutThreshold != null &&
					!Number.isFinite(keepAliveTimeoutThreshold)
				) {
					throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
				}
				if (
					headersTimeout != null &&
					(!Number.isInteger(headersTimeout) || headersTimeout < 0)
				) {
					throw new InvalidArgumentError(
						"headersTimeout must be a positive integer or zero",
					);
				}
				if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
					throw new InvalidArgumentError(
						"bodyTimeout must be a positive integer or zero",
					);
				}
				if (
					connect2 != null &&
					typeof connect2 !== "function" &&
					typeof connect2 !== "object"
				) {
					throw new InvalidArgumentError("connect must be a function or an object");
				}
				if (
					maxRedirections != null &&
					(!Number.isInteger(maxRedirections) || maxRedirections < 0)
				) {
					throw new InvalidArgumentError("maxRedirections must be a positive number");
				}
				if (
					maxRequestsPerClient != null &&
					(!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)
				) {
					throw new InvalidArgumentError(
						"maxRequestsPerClient must be a positive number",
					);
				}
				if (
					localAddress != null &&
					(typeof localAddress !== "string" || net.isIP(localAddress) === 0)
				) {
					throw new InvalidArgumentError("localAddress must be valid string IP address");
				}
				if (
					maxResponseSize != null &&
					(!Number.isInteger(maxResponseSize) || maxResponseSize < -1)
				) {
					throw new InvalidArgumentError("maxResponseSize must be a positive number");
				}
				if (
					autoSelectFamilyAttemptTimeout != null &&
					(!Number.isInteger(autoSelectFamilyAttemptTimeout) ||
						autoSelectFamilyAttemptTimeout < -1)
				) {
					throw new InvalidArgumentError(
						"autoSelectFamilyAttemptTimeout must be a positive number",
					);
				}
				if (allowH2 != null && typeof allowH2 !== "boolean") {
					throw new InvalidArgumentError("allowH2 must be a valid boolean value");
				}
				if (
					maxConcurrentStreams != null &&
					(typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)
				) {
					throw new InvalidArgumentError(
						"maxConcurrentStreams must be a possitive integer, greater than 0",
					);
				}
				if (typeof connect2 !== "function") {
					connect2 = buildConnector({
						...tls,
						maxCachedSessions,
						allowH2,
						socketPath,
						timeout: connectTimeout,
						...(util.nodeHasAutoSelectFamily && autoSelectFamily
							? { autoSelectFamily, autoSelectFamilyAttemptTimeout }
							: void 0),
						...connect2,
					});
				}
				this[kInterceptors] =
					interceptors && interceptors.Client && Array.isArray(interceptors.Client)
						? interceptors.Client
						: [createRedirectInterceptor({ maxRedirections })];
				this[kUrl] = util.parseOrigin(url);
				this[kConnector] = connect2;
				this[kSocket] = null;
				this[kPipelining] = pipelining != null ? pipelining : 1;
				this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
				this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
				this[kKeepAliveMaxTimeout] =
					keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
				this[kKeepAliveTimeoutThreshold] =
					keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
				this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
				this[kServerName] = null;
				this[kLocalAddress] = localAddress != null ? localAddress : null;
				this[kResuming] = 0;
				this[kNeedDrain] = 0;
				this[kHostHeader] =
					`host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
				this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
				this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
				this[kStrictContentLength] =
					strictContentLength == null ? true : strictContentLength;
				this[kMaxRedirections] = maxRedirections;
				this[kMaxRequests] = maxRequestsPerClient;
				this[kClosedResolve] = null;
				this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
				this[kHTTPConnVersion] = "h1";
				this[kHTTP2Session] = null;
				this[kHTTP2SessionState] = !allowH2
					? null
					: {
							// streams: null, // Fixed queue of streams - For future support of `push`
							openStreams: 0,
							// Keep track of them to decide wether or not unref the session
							maxConcurrentStreams:
								maxConcurrentStreams != null ? maxConcurrentStreams : 100,
							// Max peerConcurrentStreams for a Node h2 server
						};
				this[kHost] =
					`${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}`;
				this[kQueue] = [];
				this[kRunningIdx] = 0;
				this[kPendingIdx] = 0;
			}
			get pipelining() {
				return this[kPipelining];
			}
			set pipelining(value) {
				this[kPipelining] = value;
				resume(this, true);
			}
			get [kPending]() {
				return this[kQueue].length - this[kPendingIdx];
			}
			get [kRunning]() {
				return this[kPendingIdx] - this[kRunningIdx];
			}
			get [kSize]() {
				return this[kQueue].length - this[kRunningIdx];
			}
			get [kConnected]() {
				return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
			}
			get [kBusy]() {
				const socket = this[kSocket];
				return (
					(socket && (socket[kReset] || socket[kWriting] || socket[kBlocking])) ||
					this[kSize] >= (this[kPipelining] || 1) ||
					this[kPending] > 0
				);
			}
			/* istanbul ignore: only used for test */
			[kConnect](cb) {
				connect(this);
				this.once("connect", cb);
			}
			[kDispatch](opts, handler) {
				const origin = opts.origin || this[kUrl].origin;
				const request =
					this[kHTTPConnVersion] === "h2"
						? Request[kHTTP2BuildRequest](origin, opts, handler)
						: Request[kHTTP1BuildRequest](origin, opts, handler);
				this[kQueue].push(request);
				if (this[kResuming]) {
				} else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
					this[kResuming] = 1;
					process.nextTick(resume, this);
				} else {
					resume(this, true);
				}
				if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
					this[kNeedDrain] = 2;
				}
				return this[kNeedDrain] < 2;
			}
			async [kClose]() {
				return new Promise((resolve) => {
					if (!this[kSize]) {
						resolve(null);
					} else {
						this[kClosedResolve] = resolve;
					}
				});
			}
			async [kDestroy](err) {
				return new Promise((resolve) => {
					const requests = this[kQueue].splice(this[kPendingIdx]);
					for (let i = 0; i < requests.length; i++) {
						const request = requests[i];
						errorRequest(this, request, err);
					}
					const callback = () => {
						if (this[kClosedResolve]) {
							this[kClosedResolve]();
							this[kClosedResolve] = null;
						}
						resolve();
					};
					if (this[kHTTP2Session] != null) {
						util.destroy(this[kHTTP2Session], err);
						this[kHTTP2Session] = null;
						this[kHTTP2SessionState] = null;
					}
					if (!this[kSocket]) {
						queueMicrotask(callback);
					} else {
						util.destroy(this[kSocket].on("close", callback), err);
					}
					resume(this);
				});
			}
		};
		function onHttp2SessionError(err) {
			assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
			this[kSocket][kError] = err;
			onError(this[kClient], err);
		}
		function onHttp2FrameError(type, code, id) {
			const err = new InformationalError(
				`HTTP/2: "frameError" received - type ${type}, code ${code}`,
			);
			if (id === 0) {
				this[kSocket][kError] = err;
				onError(this[kClient], err);
			}
		}
		function onHttp2SessionEnd() {
			util.destroy(this, new SocketError("other side closed"));
			util.destroy(this[kSocket], new SocketError("other side closed"));
		}
		function onHTTP2GoAway(code) {
			const client = this[kClient];
			const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
			client[kSocket] = null;
			client[kHTTP2Session] = null;
			if (client.destroyed) {
				assert(this[kPending] === 0);
				const requests = client[kQueue].splice(client[kRunningIdx]);
				for (let i = 0; i < requests.length; i++) {
					const request = requests[i];
					errorRequest(this, request, err);
				}
			} else if (client[kRunning] > 0) {
				const request = client[kQueue][client[kRunningIdx]];
				client[kQueue][client[kRunningIdx]++] = null;
				errorRequest(client, request, err);
			}
			client[kPendingIdx] = client[kRunningIdx];
			assert(client[kRunning] === 0);
			client.emit("disconnect", client[kUrl], [client], err);
			resume(client);
		}
		var constants = require_constants4();
		var createRedirectInterceptor = require_redirectInterceptor();
		var EMPTY_BUF = Buffer.alloc(0);
		async function lazyllhttp() {
			const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
			let mod;
			try {
				mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
			} catch (e) {
				mod = await WebAssembly.compile(
					Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"),
				);
			}
			return await WebAssembly.instantiate(mod, {
				env: {
					/* eslint-disable camelcase */
					wasm_on_url: (p, at, len) => {
						return 0;
					},
					wasm_on_status: (p, at, len) => {
						assert.strictEqual(currentParser.ptr, p);
						const start = at - currentBufferPtr + currentBufferRef.byteOffset;
						return (
							currentParser.onStatus(
								new FastBuffer(currentBufferRef.buffer, start, len),
							) || 0
						);
					},
					wasm_on_message_begin: (p) => {
						assert.strictEqual(currentParser.ptr, p);
						return currentParser.onMessageBegin() || 0;
					},
					wasm_on_header_field: (p, at, len) => {
						assert.strictEqual(currentParser.ptr, p);
						const start = at - currentBufferPtr + currentBufferRef.byteOffset;
						return (
							currentParser.onHeaderField(
								new FastBuffer(currentBufferRef.buffer, start, len),
							) || 0
						);
					},
					wasm_on_header_value: (p, at, len) => {
						assert.strictEqual(currentParser.ptr, p);
						const start = at - currentBufferPtr + currentBufferRef.byteOffset;
						return (
							currentParser.onHeaderValue(
								new FastBuffer(currentBufferRef.buffer, start, len),
							) || 0
						);
					},
					wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
						assert.strictEqual(currentParser.ptr, p);
						return (
							currentParser.onHeadersComplete(
								statusCode,
								Boolean(upgrade),
								Boolean(shouldKeepAlive),
							) || 0
						);
					},
					wasm_on_body: (p, at, len) => {
						assert.strictEqual(currentParser.ptr, p);
						const start = at - currentBufferPtr + currentBufferRef.byteOffset;
						return (
							currentParser.onBody(
								new FastBuffer(currentBufferRef.buffer, start, len),
							) || 0
						);
					},
					wasm_on_message_complete: (p) => {
						assert.strictEqual(currentParser.ptr, p);
						return currentParser.onMessageComplete() || 0;
					},
					/* eslint-enable camelcase */
				},
			});
		}
		var llhttpInstance = null;
		var llhttpPromise = lazyllhttp();
		llhttpPromise.catch();
		var currentParser = null;
		var currentBufferRef = null;
		var currentBufferSize = 0;
		var currentBufferPtr = null;
		var TIMEOUT_HEADERS = 1;
		var TIMEOUT_BODY = 2;
		var TIMEOUT_IDLE = 3;
		var Parser = class {
			constructor(client, socket, { exports: exports3 }) {
				assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
				this.llhttp = exports3;
				this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
				this.client = client;
				this.socket = socket;
				this.timeout = null;
				this.timeoutValue = null;
				this.timeoutType = null;
				this.statusCode = null;
				this.statusText = "";
				this.upgrade = false;
				this.headers = [];
				this.headersSize = 0;
				this.headersMaxSize = client[kMaxHeadersSize];
				this.shouldKeepAlive = false;
				this.paused = false;
				this.resume = this.resume.bind(this);
				this.bytesRead = 0;
				this.keepAlive = "";
				this.contentLength = "";
				this.connection = "";
				this.maxResponseSize = client[kMaxResponseSize];
			}
			setTimeout(value, type) {
				this.timeoutType = type;
				if (value !== this.timeoutValue) {
					timers.clearTimeout(this.timeout);
					if (value) {
						this.timeout = timers.setTimeout(onParserTimeout, value, this);
						if (this.timeout.unref) {
							this.timeout.unref();
						}
					} else {
						this.timeout = null;
					}
					this.timeoutValue = value;
				} else if (this.timeout) {
					if (this.timeout.refresh) {
						this.timeout.refresh();
					}
				}
			}
			resume() {
				if (this.socket.destroyed || !this.paused) {
					return;
				}
				assert(this.ptr != null);
				assert(currentParser == null);
				this.llhttp.llhttp_resume(this.ptr);
				assert(this.timeoutType === TIMEOUT_BODY);
				if (this.timeout) {
					if (this.timeout.refresh) {
						this.timeout.refresh();
					}
				}
				this.paused = false;
				this.execute(this.socket.read() || EMPTY_BUF);
				this.readMore();
			}
			readMore() {
				while (!this.paused && this.ptr) {
					const chunk = this.socket.read();
					if (chunk === null) {
						break;
					}
					this.execute(chunk);
				}
			}
			execute(data) {
				assert(this.ptr != null);
				assert(currentParser == null);
				assert(!this.paused);
				const { socket, llhttp } = this;
				if (data.length > currentBufferSize) {
					if (currentBufferPtr) {
						llhttp.free(currentBufferPtr);
					}
					currentBufferSize = Math.ceil(data.length / 4096) * 4096;
					currentBufferPtr = llhttp.malloc(currentBufferSize);
				}
				new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
				try {
					let ret;
					try {
						currentBufferRef = data;
						currentParser = this;
						ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
					} catch (err) {
						throw err;
					} finally {
						currentParser = null;
						currentBufferRef = null;
					}
					const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
					if (ret === constants.ERROR.PAUSED_UPGRADE) {
						this.onUpgrade(data.slice(offset));
					} else if (ret === constants.ERROR.PAUSED) {
						this.paused = true;
						socket.unshift(data.slice(offset));
					} else if (ret !== constants.ERROR.OK) {
						const ptr = llhttp.llhttp_get_error_reason(this.ptr);
						let message = "";
						if (ptr) {
							const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
							message =
								"Response does not match the HTTP/1.1 protocol (" +
								Buffer.from(llhttp.memory.buffer, ptr, len).toString() +
								")";
						}
						throw new HTTPParserError(
							message,
							constants.ERROR[ret],
							data.slice(offset),
						);
					}
				} catch (err) {
					util.destroy(socket, err);
				}
			}
			destroy() {
				assert(this.ptr != null);
				assert(currentParser == null);
				this.llhttp.llhttp_free(this.ptr);
				this.ptr = null;
				timers.clearTimeout(this.timeout);
				this.timeout = null;
				this.timeoutValue = null;
				this.timeoutType = null;
				this.paused = false;
			}
			onStatus(buf) {
				this.statusText = buf.toString();
			}
			onMessageBegin() {
				const { socket, client } = this;
				if (socket.destroyed) {
					return -1;
				}
				const request = client[kQueue][client[kRunningIdx]];
				if (!request) {
					return -1;
				}
			}
			onHeaderField(buf) {
				const len = this.headers.length;
				if ((len & 1) === 0) {
					this.headers.push(buf);
				} else {
					this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
				}
				this.trackHeader(buf.length);
			}
			onHeaderValue(buf) {
				let len = this.headers.length;
				if ((len & 1) === 1) {
					this.headers.push(buf);
					len += 1;
				} else {
					this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
				}
				const key = this.headers[len - 2];
				if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") {
					this.keepAlive += buf.toString();
				} else if (key.length === 10 && key.toString().toLowerCase() === "connection") {
					this.connection += buf.toString();
				} else if (key.length === 14 && key.toString().toLowerCase() === "content-length") {
					this.contentLength += buf.toString();
				}
				this.trackHeader(buf.length);
			}
			trackHeader(len) {
				this.headersSize += len;
				if (this.headersSize >= this.headersMaxSize) {
					util.destroy(this.socket, new HeadersOverflowError());
				}
			}
			onUpgrade(head) {
				const { upgrade, client, socket, headers, statusCode } = this;
				assert(upgrade);
				const request = client[kQueue][client[kRunningIdx]];
				assert(request);
				assert(!socket.destroyed);
				assert(socket === client[kSocket]);
				assert(!this.paused);
				assert(request.upgrade || request.method === "CONNECT");
				this.statusCode = null;
				this.statusText = "";
				this.shouldKeepAlive = null;
				assert(this.headers.length % 2 === 0);
				this.headers = [];
				this.headersSize = 0;
				socket.unshift(head);
				socket[kParser].destroy();
				socket[kParser] = null;
				socket[kClient] = null;
				socket[kError] = null;
				socket
					.removeListener("error", onSocketError)
					.removeListener("readable", onSocketReadable)
					.removeListener("end", onSocketEnd)
					.removeListener("close", onSocketClose);
				client[kSocket] = null;
				client[kQueue][client[kRunningIdx]++] = null;
				client.emit(
					"disconnect",
					client[kUrl],
					[client],
					new InformationalError("upgrade"),
				);
				try {
					request.onUpgrade(statusCode, headers, socket);
				} catch (err) {
					util.destroy(socket, err);
				}
				resume(client);
			}
			onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
				const { client, socket, headers, statusText } = this;
				if (socket.destroyed) {
					return -1;
				}
				const request = client[kQueue][client[kRunningIdx]];
				if (!request) {
					return -1;
				}
				assert(!this.upgrade);
				assert(this.statusCode < 200);
				if (statusCode === 100) {
					util.destroy(
						socket,
						new SocketError("bad response", util.getSocketInfo(socket)),
					);
					return -1;
				}
				if (upgrade && !request.upgrade) {
					util.destroy(
						socket,
						new SocketError("bad upgrade", util.getSocketInfo(socket)),
					);
					return -1;
				}
				assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
				this.statusCode = statusCode;
				this.shouldKeepAlive =
					shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.
					(request.method === "HEAD" &&
						!socket[kReset] &&
						this.connection.toLowerCase() === "keep-alive");
				if (this.statusCode >= 200) {
					const bodyTimeout =
						request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
					this.setTimeout(bodyTimeout, TIMEOUT_BODY);
				} else if (this.timeout) {
					if (this.timeout.refresh) {
						this.timeout.refresh();
					}
				}
				if (request.method === "CONNECT") {
					assert(client[kRunning] === 1);
					this.upgrade = true;
					return 2;
				}
				if (upgrade) {
					assert(client[kRunning] === 1);
					this.upgrade = true;
					return 2;
				}
				assert(this.headers.length % 2 === 0);
				this.headers = [];
				this.headersSize = 0;
				if (this.shouldKeepAlive && client[kPipelining]) {
					const keepAliveTimeout = this.keepAlive
						? util.parseKeepAliveTimeout(this.keepAlive)
						: null;
					if (keepAliveTimeout != null) {
						const timeout = Math.min(
							keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
							client[kKeepAliveMaxTimeout],
						);
						if (timeout <= 0) {
							socket[kReset] = true;
						} else {
							client[kKeepAliveTimeoutValue] = timeout;
						}
					} else {
						client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
					}
				} else {
					socket[kReset] = true;
				}
				const pause =
					request.onHeaders(statusCode, headers, this.resume, statusText) === false;
				if (request.aborted) {
					return -1;
				}
				if (request.method === "HEAD") {
					return 1;
				}
				if (statusCode < 200) {
					return 1;
				}
				if (socket[kBlocking]) {
					socket[kBlocking] = false;
					resume(client);
				}
				return pause ? constants.ERROR.PAUSED : 0;
			}
			onBody(buf) {
				const { client, socket, statusCode, maxResponseSize } = this;
				if (socket.destroyed) {
					return -1;
				}
				const request = client[kQueue][client[kRunningIdx]];
				assert(request);
				assert.strictEqual(this.timeoutType, TIMEOUT_BODY);
				if (this.timeout) {
					if (this.timeout.refresh) {
						this.timeout.refresh();
					}
				}
				assert(statusCode >= 200);
				if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
					util.destroy(socket, new ResponseExceededMaxSizeError());
					return -1;
				}
				this.bytesRead += buf.length;
				if (request.onData(buf) === false) {
					return constants.ERROR.PAUSED;
				}
			}
			onMessageComplete() {
				const {
					client,
					socket,
					statusCode,
					upgrade,
					headers,
					contentLength,
					bytesRead,
					shouldKeepAlive,
				} = this;
				if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
					return -1;
				}
				if (upgrade) {
					return;
				}
				const request = client[kQueue][client[kRunningIdx]];
				assert(request);
				assert(statusCode >= 100);
				this.statusCode = null;
				this.statusText = "";
				this.bytesRead = 0;
				this.contentLength = "";
				this.keepAlive = "";
				this.connection = "";
				assert(this.headers.length % 2 === 0);
				this.headers = [];
				this.headersSize = 0;
				if (statusCode < 200) {
					return;
				}
				if (
					request.method !== "HEAD" &&
					contentLength &&
					bytesRead !== parseInt(contentLength, 10)
				) {
					util.destroy(socket, new ResponseContentLengthMismatchError());
					return -1;
				}
				request.onComplete(headers);
				client[kQueue][client[kRunningIdx]++] = null;
				if (socket[kWriting]) {
					assert.strictEqual(client[kRunning], 0);
					util.destroy(socket, new InformationalError("reset"));
					return constants.ERROR.PAUSED;
				} else if (!shouldKeepAlive) {
					util.destroy(socket, new InformationalError("reset"));
					return constants.ERROR.PAUSED;
				} else if (socket[kReset] && client[kRunning] === 0) {
					util.destroy(socket, new InformationalError("reset"));
					return constants.ERROR.PAUSED;
				} else if (client[kPipelining] === 1) {
					setImmediate(resume, client);
				} else {
					resume(client);
				}
			}
		};
		function onParserTimeout(parser) {
			const { socket, timeoutType, client } = parser;
			if (timeoutType === TIMEOUT_HEADERS) {
				if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
					assert(!parser.paused, "cannot be paused while waiting for headers");
					util.destroy(socket, new HeadersTimeoutError());
				}
			} else if (timeoutType === TIMEOUT_BODY) {
				if (!parser.paused) {
					util.destroy(socket, new BodyTimeoutError());
				}
			} else if (timeoutType === TIMEOUT_IDLE) {
				assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
				util.destroy(socket, new InformationalError("socket idle timeout"));
			}
		}
		function onSocketReadable() {
			const { [kParser]: parser } = this;
			if (parser) {
				parser.readMore();
			}
		}
		function onSocketError(err) {
			const { [kClient]: client, [kParser]: parser } = this;
			assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
			if (client[kHTTPConnVersion] !== "h2") {
				if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
					parser.onMessageComplete();
					return;
				}
			}
			this[kError] = err;
			onError(this[kClient], err);
		}
		function onError(client, err) {
			if (
				client[kRunning] === 0 &&
				err.code !== "UND_ERR_INFO" &&
				err.code !== "UND_ERR_SOCKET"
			) {
				assert(client[kPendingIdx] === client[kRunningIdx]);
				const requests = client[kQueue].splice(client[kRunningIdx]);
				for (let i = 0; i < requests.length; i++) {
					const request = requests[i];
					errorRequest(client, request, err);
				}
				assert(client[kSize] === 0);
			}
		}
		function onSocketEnd() {
			const { [kParser]: parser, [kClient]: client } = this;
			if (client[kHTTPConnVersion] !== "h2") {
				if (parser.statusCode && !parser.shouldKeepAlive) {
					parser.onMessageComplete();
					return;
				}
			}
			util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
		}
		function onSocketClose() {
			const { [kClient]: client, [kParser]: parser } = this;
			if (client[kHTTPConnVersion] === "h1" && parser) {
				if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
					parser.onMessageComplete();
				}
				this[kParser].destroy();
				this[kParser] = null;
			}
			const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
			client[kSocket] = null;
			if (client.destroyed) {
				assert(client[kPending] === 0);
				const requests = client[kQueue].splice(client[kRunningIdx]);
				for (let i = 0; i < requests.length; i++) {
					const request = requests[i];
					errorRequest(client, request, err);
				}
			} else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
				const request = client[kQueue][client[kRunningIdx]];
				client[kQueue][client[kRunningIdx]++] = null;
				errorRequest(client, request, err);
			}
			client[kPendingIdx] = client[kRunningIdx];
			assert(client[kRunning] === 0);
			client.emit("disconnect", client[kUrl], [client], err);
			resume(client);
		}
		async function connect(client) {
			assert(!client[kConnecting]);
			assert(!client[kSocket]);
			let { host, hostname, protocol, port } = client[kUrl];
			if (hostname[0] === "[") {
				const idx = hostname.indexOf("]");
				assert(idx !== -1);
				const ip = hostname.substring(1, idx);
				assert(net.isIP(ip));
				hostname = ip;
			}
			client[kConnecting] = true;
			if (channels.beforeConnect.hasSubscribers) {
				channels.beforeConnect.publish({
					connectParams: {
						host,
						hostname,
						protocol,
						port,
						servername: client[kServerName],
						localAddress: client[kLocalAddress],
					},
					connector: client[kConnector],
				});
			}
			try {
				const socket = await new Promise((resolve, reject) => {
					client[kConnector](
						{
							host,
							hostname,
							protocol,
							port,
							servername: client[kServerName],
							localAddress: client[kLocalAddress],
						},
						(err, socket2) => {
							if (err) {
								reject(err);
							} else {
								resolve(socket2);
							}
						},
					);
				});
				if (client.destroyed) {
					util.destroy(
						socket.on("error", () => {}),
						new ClientDestroyedError(),
					);
					return;
				}
				client[kConnecting] = false;
				assert(socket);
				const isH2 = socket.alpnProtocol === "h2";
				if (isH2) {
					if (!h2ExperimentalWarned) {
						h2ExperimentalWarned = true;
						process.emitWarning(
							"H2 support is experimental, expect them to change at any time.",
							{
								code: "UNDICI-H2",
							},
						);
					}
					const session = http2.connect(client[kUrl], {
						createConnection: () => socket,
						peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams,
					});
					client[kHTTPConnVersion] = "h2";
					session[kClient] = client;
					session[kSocket] = socket;
					session.on("error", onHttp2SessionError);
					session.on("frameError", onHttp2FrameError);
					session.on("end", onHttp2SessionEnd);
					session.on("goaway", onHTTP2GoAway);
					session.on("close", onSocketClose);
					session.unref();
					client[kHTTP2Session] = session;
					socket[kHTTP2Session] = session;
				} else {
					if (!llhttpInstance) {
						llhttpInstance = await llhttpPromise;
						llhttpPromise = null;
					}
					socket[kNoRef] = false;
					socket[kWriting] = false;
					socket[kReset] = false;
					socket[kBlocking] = false;
					socket[kParser] = new Parser(client, socket, llhttpInstance);
				}
				socket[kCounter] = 0;
				socket[kMaxRequests] = client[kMaxRequests];
				socket[kClient] = client;
				socket[kError] = null;
				socket
					.on("error", onSocketError)
					.on("readable", onSocketReadable)
					.on("end", onSocketEnd)
					.on("close", onSocketClose);
				client[kSocket] = socket;
				if (channels.connected.hasSubscribers) {
					channels.connected.publish({
						connectParams: {
							host,
							hostname,
							protocol,
							port,
							servername: client[kServerName],
							localAddress: client[kLocalAddress],
						},
						connector: client[kConnector],
						socket,
					});
				}
				client.emit("connect", client[kUrl], [client]);
			} catch (err) {
				if (client.destroyed) {
					return;
				}
				client[kConnecting] = false;
				if (channels.connectError.hasSubscribers) {
					channels.connectError.publish({
						connectParams: {
							host,
							hostname,
							protocol,
							port,
							servername: client[kServerName],
							localAddress: client[kLocalAddress],
						},
						connector: client[kConnector],
						error: err,
					});
				}
				if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
					assert(client[kRunning] === 0);
					while (
						client[kPending] > 0 &&
						client[kQueue][client[kPendingIdx]].servername === client[kServerName]
					) {
						const request = client[kQueue][client[kPendingIdx]++];
						errorRequest(client, request, err);
					}
				} else {
					onError(client, err);
				}
				client.emit("connectionError", client[kUrl], [client], err);
			}
			resume(client);
		}
		function emitDrain(client) {
			client[kNeedDrain] = 0;
			client.emit("drain", client[kUrl], [client]);
		}
		function resume(client, sync) {
			if (client[kResuming] === 2) {
				return;
			}
			client[kResuming] = 2;
			_resume(client, sync);
			client[kResuming] = 0;
			if (client[kRunningIdx] > 256) {
				client[kQueue].splice(0, client[kRunningIdx]);
				client[kPendingIdx] -= client[kRunningIdx];
				client[kRunningIdx] = 0;
			}
		}
		function _resume(client, sync) {
			while (true) {
				if (client.destroyed) {
					assert(client[kPending] === 0);
					return;
				}
				if (client[kClosedResolve] && !client[kSize]) {
					client[kClosedResolve]();
					client[kClosedResolve] = null;
					return;
				}
				const socket = client[kSocket];
				if (socket && !socket.destroyed && socket.alpnProtocol !== "h2") {
					if (client[kSize] === 0) {
						if (!socket[kNoRef] && socket.unref) {
							socket.unref();
							socket[kNoRef] = true;
						}
					} else if (socket[kNoRef] && socket.ref) {
						socket.ref();
						socket[kNoRef] = false;
					}
					if (client[kSize] === 0) {
						if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
							socket[kParser].setTimeout(
								client[kKeepAliveTimeoutValue],
								TIMEOUT_IDLE,
							);
						}
					} else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
						if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
							const request2 = client[kQueue][client[kRunningIdx]];
							const headersTimeout =
								request2.headersTimeout != null
									? request2.headersTimeout
									: client[kHeadersTimeout];
							socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
						}
					}
				}
				if (client[kBusy]) {
					client[kNeedDrain] = 2;
				} else if (client[kNeedDrain] === 2) {
					if (sync) {
						client[kNeedDrain] = 1;
						process.nextTick(emitDrain, client);
					} else {
						emitDrain(client);
					}
					continue;
				}
				if (client[kPending] === 0) {
					return;
				}
				if (client[kRunning] >= (client[kPipelining] || 1)) {
					return;
				}
				const request = client[kQueue][client[kPendingIdx]];
				if (
					client[kUrl].protocol === "https:" &&
					client[kServerName] !== request.servername
				) {
					if (client[kRunning] > 0) {
						return;
					}
					client[kServerName] = request.servername;
					if (socket && socket.servername !== request.servername) {
						util.destroy(socket, new InformationalError("servername changed"));
						return;
					}
				}
				if (client[kConnecting]) {
					return;
				}
				if (!socket && !client[kHTTP2Session]) {
					connect(client);
					return;
				}
				if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
					return;
				}
				if (client[kRunning] > 0 && !request.idempotent) {
					return;
				}
				if (client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT")) {
					return;
				}
				if (
					client[kRunning] > 0 &&
					util.bodyLength(request.body) !== 0 &&
					(util.isStream(request.body) || util.isAsyncIterable(request.body))
				) {
					return;
				}
				if (!request.aborted && write(client, request)) {
					client[kPendingIdx]++;
				} else {
					client[kQueue].splice(client[kPendingIdx], 1);
				}
			}
		}
		function shouldSendContentLength(method) {
			return (
				method !== "GET" &&
				method !== "HEAD" &&
				method !== "OPTIONS" &&
				method !== "TRACE" &&
				method !== "CONNECT"
			);
		}
		function write(client, request) {
			if (client[kHTTPConnVersion] === "h2") {
				writeH2(client, client[kHTTP2Session], request);
				return;
			}
			const { body, method, path, host, upgrade, headers, blocking, reset } = request;
			const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
			if (body && typeof body.read === "function") {
				body.read(0);
			}
			const bodyLength = util.bodyLength(body);
			let contentLength = bodyLength;
			if (contentLength === null) {
				contentLength = request.contentLength;
			}
			if (contentLength === 0 && !expectsPayload) {
				contentLength = null;
			}
			if (
				shouldSendContentLength(method) &&
				contentLength > 0 &&
				request.contentLength !== null &&
				request.contentLength !== contentLength
			) {
				if (client[kStrictContentLength]) {
					errorRequest(client, request, new RequestContentLengthMismatchError());
					return false;
				}
				process.emitWarning(new RequestContentLengthMismatchError());
			}
			const socket = client[kSocket];
			try {
				request.onConnect((err) => {
					if (request.aborted || request.completed) {
						return;
					}
					errorRequest(client, request, err || new RequestAbortedError());
					util.destroy(socket, new InformationalError("aborted"));
				});
			} catch (err) {
				errorRequest(client, request, err);
			}
			if (request.aborted) {
				return false;
			}
			if (method === "HEAD") {
				socket[kReset] = true;
			}
			if (upgrade || method === "CONNECT") {
				socket[kReset] = true;
			}
			if (reset != null) {
				socket[kReset] = reset;
			}
			if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
				socket[kReset] = true;
			}
			if (blocking) {
				socket[kBlocking] = true;
			}
			let header = `${method} ${path} HTTP/1.1\r
`;
			if (typeof host === "string") {
				header += `host: ${host}\r
`;
			} else {
				header += client[kHostHeader];
			}
			if (upgrade) {
				header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
			} else if (client[kPipelining] && !socket[kReset]) {
				header += "connection: keep-alive\r\n";
			} else {
				header += "connection: close\r\n";
			}
			if (headers) {
				header += headers;
			}
			if (channels.sendHeaders.hasSubscribers) {
				channels.sendHeaders.publish({ request, headers: header, socket });
			}
			if (!body || bodyLength === 0) {
				if (contentLength === 0) {
					socket.write(
						`${header}content-length: 0\r
\r
`,
						"latin1",
					);
				} else {
					assert(contentLength === null, "no body must not have content length");
					socket.write(
						`${header}\r
`,
						"latin1",
					);
				}
				request.onRequestSent();
			} else if (util.isBuffer(body)) {
				assert(contentLength === body.byteLength, "buffer body must have content length");
				socket.cork();
				socket.write(
					`${header}content-length: ${contentLength}\r
\r
`,
					"latin1",
				);
				socket.write(body);
				socket.uncork();
				request.onBodySent(body);
				request.onRequestSent();
				if (!expectsPayload) {
					socket[kReset] = true;
				}
			} else if (util.isBlobLike(body)) {
				if (typeof body.stream === "function") {
					writeIterable({
						body: body.stream(),
						client,
						request,
						socket,
						contentLength,
						header,
						expectsPayload,
					});
				} else {
					writeBlob({
						body,
						client,
						request,
						socket,
						contentLength,
						header,
						expectsPayload,
					});
				}
			} else if (util.isStream(body)) {
				writeStream({
					body,
					client,
					request,
					socket,
					contentLength,
					header,
					expectsPayload,
				});
			} else if (util.isIterable(body)) {
				writeIterable({
					body,
					client,
					request,
					socket,
					contentLength,
					header,
					expectsPayload,
				});
			} else {
				assert(false);
			}
			return true;
		}
		function writeH2(client, session, request) {
			const {
				body,
				method,
				path,
				host,
				upgrade,
				expectContinue,
				signal,
				headers: reqHeaders,
			} = request;
			let headers;
			if (typeof reqHeaders === "string")
				headers = Request[kHTTP2CopyHeaders](reqHeaders.trim());
			else headers = reqHeaders;
			if (upgrade) {
				errorRequest(client, request, new Error("Upgrade not supported for H2"));
				return false;
			}
			try {
				request.onConnect((err) => {
					if (request.aborted || request.completed) {
						return;
					}
					errorRequest(client, request, err || new RequestAbortedError());
				});
			} catch (err) {
				errorRequest(client, request, err);
			}
			if (request.aborted) {
				return false;
			}
			let stream;
			const h2State = client[kHTTP2SessionState];
			headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];
			headers[HTTP2_HEADER_METHOD] = method;
			if (method === "CONNECT") {
				session.ref();
				stream = session.request(headers, { endStream: false, signal });
				if (stream.id && !stream.pending) {
					request.onUpgrade(null, null, stream);
					++h2State.openStreams;
				} else {
					stream.once("ready", () => {
						request.onUpgrade(null, null, stream);
						++h2State.openStreams;
					});
				}
				stream.once("close", () => {
					h2State.openStreams -= 1;
					if (h2State.openStreams === 0) session.unref();
				});
				return true;
			}
			headers[HTTP2_HEADER_PATH] = path;
			headers[HTTP2_HEADER_SCHEME] = "https";
			const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
			if (body && typeof body.read === "function") {
				body.read(0);
			}
			let contentLength = util.bodyLength(body);
			if (contentLength == null) {
				contentLength = request.contentLength;
			}
			if (contentLength === 0 || !expectsPayload) {
				contentLength = null;
			}
			if (
				shouldSendContentLength(method) &&
				contentLength > 0 &&
				request.contentLength != null &&
				request.contentLength !== contentLength
			) {
				if (client[kStrictContentLength]) {
					errorRequest(client, request, new RequestContentLengthMismatchError());
					return false;
				}
				process.emitWarning(new RequestContentLengthMismatchError());
			}
			if (contentLength != null) {
				assert(body, "no body must not have content length");
				headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
			}
			session.ref();
			const shouldEndStream = method === "GET" || method === "HEAD";
			if (expectContinue) {
				headers[HTTP2_HEADER_EXPECT] = "100-continue";
				stream = session.request(headers, { endStream: shouldEndStream, signal });
				stream.once("continue", writeBodyH2);
			} else {
				stream = session.request(headers, {
					endStream: shouldEndStream,
					signal,
				});
				writeBodyH2();
			}
			++h2State.openStreams;
			stream.once("response", (headers2) => {
				const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers2;
				if (
					request.onHeaders(
						Number(statusCode),
						realHeaders,
						stream.resume.bind(stream),
						"",
					) === false
				) {
					stream.pause();
				}
			});
			stream.once("end", () => {
				request.onComplete([]);
			});
			stream.on("data", (chunk) => {
				if (request.onData(chunk) === false) {
					stream.pause();
				}
			});
			stream.once("close", () => {
				h2State.openStreams -= 1;
				if (h2State.openStreams === 0) {
					session.unref();
				}
			});
			stream.once("error", function (err) {
				if (
					client[kHTTP2Session] &&
					!client[kHTTP2Session].destroyed &&
					!this.closed &&
					!this.destroyed
				) {
					h2State.streams -= 1;
					util.destroy(stream, err);
				}
			});
			stream.once("frameError", (type, code) => {
				const err = new InformationalError(
					`HTTP/2: "frameError" received - type ${type}, code ${code}`,
				);
				errorRequest(client, request, err);
				if (
					client[kHTTP2Session] &&
					!client[kHTTP2Session].destroyed &&
					!this.closed &&
					!this.destroyed
				) {
					h2State.streams -= 1;
					util.destroy(stream, err);
				}
			});
			return true;
			function writeBodyH2() {
				if (!body) {
					request.onRequestSent();
				} else if (util.isBuffer(body)) {
					assert(
						contentLength === body.byteLength,
						"buffer body must have content length",
					);
					stream.cork();
					stream.write(body);
					stream.uncork();
					stream.end();
					request.onBodySent(body);
					request.onRequestSent();
				} else if (util.isBlobLike(body)) {
					if (typeof body.stream === "function") {
						writeIterable({
							client,
							request,
							contentLength,
							h2stream: stream,
							expectsPayload,
							body: body.stream(),
							socket: client[kSocket],
							header: "",
						});
					} else {
						writeBlob({
							body,
							client,
							request,
							contentLength,
							expectsPayload,
							h2stream: stream,
							header: "",
							socket: client[kSocket],
						});
					}
				} else if (util.isStream(body)) {
					writeStream({
						body,
						client,
						request,
						contentLength,
						expectsPayload,
						socket: client[kSocket],
						h2stream: stream,
						header: "",
					});
				} else if (util.isIterable(body)) {
					writeIterable({
						body,
						client,
						request,
						contentLength,
						expectsPayload,
						header: "",
						h2stream: stream,
						socket: client[kSocket],
					});
				} else {
					assert(false);
				}
			}
		}
		function writeStream({
			h2stream,
			body,
			client,
			request,
			socket,
			contentLength,
			header,
			expectsPayload,
		}) {
			assert(
				contentLength !== 0 || client[kRunning] === 0,
				"stream body cannot be pipelined",
			);
			if (client[kHTTPConnVersion] === "h2") {
				let onPipeData = function (chunk) {
					request.onBodySent(chunk);
				};
				const pipe = pipeline(body, h2stream, (err) => {
					if (err) {
						util.destroy(body, err);
						util.destroy(h2stream, err);
					} else {
						request.onRequestSent();
					}
				});
				pipe.on("data", onPipeData);
				pipe.once("end", () => {
					pipe.removeListener("data", onPipeData);
					util.destroy(pipe);
				});
				return;
			}
			let finished = false;
			const writer = new AsyncWriter({
				socket,
				request,
				contentLength,
				client,
				expectsPayload,
				header,
			});
			const onData = function (chunk) {
				if (finished) {
					return;
				}
				try {
					if (!writer.write(chunk) && this.pause) {
						this.pause();
					}
				} catch (err) {
					util.destroy(this, err);
				}
			};
			const onDrain = function () {
				if (finished) {
					return;
				}
				if (body.resume) {
					body.resume();
				}
			};
			const onAbort = function () {
				if (finished) {
					return;
				}
				const err = new RequestAbortedError();
				queueMicrotask(() => onFinished(err));
			};
			const onFinished = function (err) {
				if (finished) {
					return;
				}
				finished = true;
				assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1));
				socket.off("drain", onDrain).off("error", onFinished);
				body.removeListener("data", onData)
					.removeListener("end", onFinished)
					.removeListener("error", onFinished)
					.removeListener("close", onAbort);
				if (!err) {
					try {
						writer.end();
					} catch (er) {
						err = er;
					}
				}
				writer.destroy(err);
				if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
					util.destroy(body, err);
				} else {
					util.destroy(body);
				}
			};
			body.on("data", onData)
				.on("end", onFinished)
				.on("error", onFinished)
				.on("close", onAbort);
			if (body.resume) {
				body.resume();
			}
			socket.on("drain", onDrain).on("error", onFinished);
		}
		async function writeBlob({
			h2stream,
			body,
			client,
			request,
			socket,
			contentLength,
			header,
			expectsPayload,
		}) {
			assert(contentLength === body.size, "blob body must have content length");
			const isH2 = client[kHTTPConnVersion] === "h2";
			try {
				if (contentLength != null && contentLength !== body.size) {
					throw new RequestContentLengthMismatchError();
				}
				const buffer = Buffer.from(await body.arrayBuffer());
				if (isH2) {
					h2stream.cork();
					h2stream.write(buffer);
					h2stream.uncork();
				} else {
					socket.cork();
					socket.write(
						`${header}content-length: ${contentLength}\r
\r
`,
						"latin1",
					);
					socket.write(buffer);
					socket.uncork();
				}
				request.onBodySent(buffer);
				request.onRequestSent();
				if (!expectsPayload) {
					socket[kReset] = true;
				}
				resume(client);
			} catch (err) {
				util.destroy(isH2 ? h2stream : socket, err);
			}
		}
		async function writeIterable({
			h2stream,
			body,
			client,
			request,
			socket,
			contentLength,
			header,
			expectsPayload,
		}) {
			assert(
				contentLength !== 0 || client[kRunning] === 0,
				"iterator body cannot be pipelined",
			);
			let callback = null;
			function onDrain() {
				if (callback) {
					const cb = callback;
					callback = null;
					cb();
				}
			}
			const waitForDrain = () =>
				new Promise((resolve, reject) => {
					assert(callback === null);
					if (socket[kError]) {
						reject(socket[kError]);
					} else {
						callback = resolve;
					}
				});
			if (client[kHTTPConnVersion] === "h2") {
				h2stream.on("close", onDrain).on("drain", onDrain);
				try {
					for await (const chunk of body) {
						if (socket[kError]) {
							throw socket[kError];
						}
						const res = h2stream.write(chunk);
						request.onBodySent(chunk);
						if (!res) {
							await waitForDrain();
						}
					}
				} catch (err) {
					h2stream.destroy(err);
				} finally {
					request.onRequestSent();
					h2stream.end();
					h2stream.off("close", onDrain).off("drain", onDrain);
				}
				return;
			}
			socket.on("close", onDrain).on("drain", onDrain);
			const writer = new AsyncWriter({
				socket,
				request,
				contentLength,
				client,
				expectsPayload,
				header,
			});
			try {
				for await (const chunk of body) {
					if (socket[kError]) {
						throw socket[kError];
					}
					if (!writer.write(chunk)) {
						await waitForDrain();
					}
				}
				writer.end();
			} catch (err) {
				writer.destroy(err);
			} finally {
				socket.off("close", onDrain).off("drain", onDrain);
			}
		}
		var AsyncWriter = class {
			constructor({ socket, request, contentLength, client, expectsPayload, header }) {
				this.socket = socket;
				this.request = request;
				this.contentLength = contentLength;
				this.client = client;
				this.bytesWritten = 0;
				this.expectsPayload = expectsPayload;
				this.header = header;
				socket[kWriting] = true;
			}
			write(chunk) {
				const {
					socket,
					request,
					contentLength,
					client,
					bytesWritten,
					expectsPayload,
					header,
				} = this;
				if (socket[kError]) {
					throw socket[kError];
				}
				if (socket.destroyed) {
					return false;
				}
				const len = Buffer.byteLength(chunk);
				if (!len) {
					return true;
				}
				if (contentLength !== null && bytesWritten + len > contentLength) {
					if (client[kStrictContentLength]) {
						throw new RequestContentLengthMismatchError();
					}
					process.emitWarning(new RequestContentLengthMismatchError());
				}
				socket.cork();
				if (bytesWritten === 0) {
					if (!expectsPayload) {
						socket[kReset] = true;
					}
					if (contentLength === null) {
						socket.write(
							`${header}transfer-encoding: chunked\r
`,
							"latin1",
						);
					} else {
						socket.write(
							`${header}content-length: ${contentLength}\r
\r
`,
							"latin1",
						);
					}
				}
				if (contentLength === null) {
					socket.write(
						`\r
${len.toString(16)}\r
`,
						"latin1",
					);
				}
				this.bytesWritten += len;
				const ret = socket.write(chunk);
				socket.uncork();
				request.onBodySent(chunk);
				if (!ret) {
					if (
						socket[kParser].timeout &&
						socket[kParser].timeoutType === TIMEOUT_HEADERS
					) {
						if (socket[kParser].timeout.refresh) {
							socket[kParser].timeout.refresh();
						}
					}
				}
				return ret;
			}
			end() {
				const {
					socket,
					contentLength,
					client,
					bytesWritten,
					expectsPayload,
					header,
					request,
				} = this;
				request.onRequestSent();
				socket[kWriting] = false;
				if (socket[kError]) {
					throw socket[kError];
				}
				if (socket.destroyed) {
					return;
				}
				if (bytesWritten === 0) {
					if (expectsPayload) {
						socket.write(
							`${header}content-length: 0\r
\r
`,
							"latin1",
						);
					} else {
						socket.write(
							`${header}\r
`,
							"latin1",
						);
					}
				} else if (contentLength === null) {
					socket.write("\r\n0\r\n\r\n", "latin1");
				}
				if (contentLength !== null && bytesWritten !== contentLength) {
					if (client[kStrictContentLength]) {
						throw new RequestContentLengthMismatchError();
					} else {
						process.emitWarning(new RequestContentLengthMismatchError());
					}
				}
				if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
					if (socket[kParser].timeout.refresh) {
						socket[kParser].timeout.refresh();
					}
				}
				resume(client);
			}
			destroy(err) {
				const { socket, client } = this;
				socket[kWriting] = false;
				if (err) {
					assert(client[kRunning] <= 1, "pipeline should only contain this request");
					util.destroy(socket, err);
				}
			}
		};
		function errorRequest(client, request, err) {
			try {
				request.onError(err);
				assert(request.aborted);
			} catch (err2) {
				client.emit("error", err2);
			}
		}
		module2.exports = Client;
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/node/fixed-queue.js"(
		exports2,
		module2,
	) {
		"use strict";
		var kSize = 2048;
		var kMask = kSize - 1;
		var FixedCircularBuffer = class {
			constructor() {
				this.bottom = 0;
				this.top = 0;
				this.list = new Array(kSize);
				this.next = null;
			}
			isEmpty() {
				return this.top === this.bottom;
			}
			isFull() {
				return ((this.top + 1) & kMask) === this.bottom;
			}
			push(data) {
				this.list[this.top] = data;
				this.top = (this.top + 1) & kMask;
			}
			shift() {
				const nextItem = this.list[this.bottom];
				if (nextItem === void 0) return null;
				this.list[this.bottom] = void 0;
				this.bottom = (this.bottom + 1) & kMask;
				return nextItem;
			}
		};
		module2.exports = class FixedQueue {
			constructor() {
				this.head = this.tail = new FixedCircularBuffer();
			}
			isEmpty() {
				return this.head.isEmpty();
			}
			push(data) {
				if (this.head.isFull()) {
					this.head = this.head.next = new FixedCircularBuffer();
				}
				this.head.push(data);
			}
			shift() {
				const tail = this.tail;
				const next = tail.shift();
				if (tail.isEmpty() && tail.next !== null) {
					this.tail = tail.next;
				}
				return next;
			}
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/pool-stats.js
var require_pool_stats = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/pool-stats.js"(exports2, module2) {
		"use strict";
		var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();
		var kPool = Symbol("pool");
		var PoolStats = class {
			constructor(pool) {
				this[kPool] = pool;
			}
			get connected() {
				return this[kPool][kConnected];
			}
			get free() {
				return this[kPool][kFree];
			}
			get pending() {
				return this[kPool][kPending];
			}
			get queued() {
				return this[kPool][kQueued];
			}
			get running() {
				return this[kPool][kRunning];
			}
			get size() {
				return this[kPool][kSize];
			}
		};
		module2.exports = PoolStats;
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/pool-base.js
var require_pool_base = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/pool-base.js"(exports2, module2) {
		"use strict";
		var DispatcherBase = require_dispatcher_base();
		var FixedQueue = require_fixed_queue();
		var {
			kConnected,
			kSize,
			kRunning,
			kPending,
			kQueued,
			kBusy,
			kFree,
			kUrl,
			kClose,
			kDestroy,
			kDispatch,
		} = require_symbols();
		var PoolStats = require_pool_stats();
		var kClients = Symbol("clients");
		var kNeedDrain = Symbol("needDrain");
		var kQueue = Symbol("queue");
		var kClosedResolve = Symbol("closed resolve");
		var kOnDrain = Symbol("onDrain");
		var kOnConnect = Symbol("onConnect");
		var kOnDisconnect = Symbol("onDisconnect");
		var kOnConnectionError = Symbol("onConnectionError");
		var kGetDispatcher = Symbol("get dispatcher");
		var kAddClient = Symbol("add client");
		var kRemoveClient = Symbol("remove client");
		var kStats = Symbol("stats");
		var PoolBase = class extends DispatcherBase {
			constructor() {
				super();
				this[kQueue] = new FixedQueue();
				this[kClients] = [];
				this[kQueued] = 0;
				const pool = this;
				this[kOnDrain] = function onDrain(origin, targets) {
					const queue = pool[kQueue];
					let needDrain = false;
					while (!needDrain) {
						const item = queue.shift();
						if (!item) {
							break;
						}
						pool[kQueued]--;
						needDrain = !this.dispatch(item.opts, item.handler);
					}
					this[kNeedDrain] = needDrain;
					if (!this[kNeedDrain] && pool[kNeedDrain]) {
						pool[kNeedDrain] = false;
						pool.emit("drain", origin, [pool, ...targets]);
					}
					if (pool[kClosedResolve] && queue.isEmpty()) {
						Promise.all(pool[kClients].map((c) => c.close())).then(
							pool[kClosedResolve],
						);
					}
				};
				this[kOnConnect] = (origin, targets) => {
					pool.emit("connect", origin, [pool, ...targets]);
				};
				this[kOnDisconnect] = (origin, targets, err) => {
					pool.emit("disconnect", origin, [pool, ...targets], err);
				};
				this[kOnConnectionError] = (origin, targets, err) => {
					pool.emit("connectionError", origin, [pool, ...targets], err);
				};
				this[kStats] = new PoolStats(this);
			}
			get [kBusy]() {
				return this[kNeedDrain];
			}
			get [kConnected]() {
				return this[kClients].filter((client) => client[kConnected]).length;
			}
			get [kFree]() {
				return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain])
					.length;
			}
			get [kPending]() {
				let ret = this[kQueued];
				for (const { [kPending]: pending } of this[kClients]) {
					ret += pending;
				}
				return ret;
			}
			get [kRunning]() {
				let ret = 0;
				for (const { [kRunning]: running } of this[kClients]) {
					ret += running;
				}
				return ret;
			}
			get [kSize]() {
				let ret = this[kQueued];
				for (const { [kSize]: size } of this[kClients]) {
					ret += size;
				}
				return ret;
			}
			get stats() {
				return this[kStats];
			}
			async [kClose]() {
				if (this[kQueue].isEmpty()) {
					return Promise.all(this[kClients].map((c) => c.close()));
				} else {
					return new Promise((resolve) => {
						this[kClosedResolve] = resolve;
					});
				}
			}
			async [kDestroy](err) {
				while (true) {
					const item = this[kQueue].shift();
					if (!item) {
						break;
					}
					item.handler.onError(err);
				}
				return Promise.all(this[kClients].map((c) => c.destroy(err)));
			}
			[kDispatch](opts, handler) {
				const dispatcher = this[kGetDispatcher]();
				if (!dispatcher) {
					this[kNeedDrain] = true;
					this[kQueue].push({ opts, handler });
					this[kQueued]++;
				} else if (!dispatcher.dispatch(opts, handler)) {
					dispatcher[kNeedDrain] = true;
					this[kNeedDrain] = !this[kGetDispatcher]();
				}
				return !this[kNeedDrain];
			}
			[kAddClient](client) {
				client
					.on("drain", this[kOnDrain])
					.on("connect", this[kOnConnect])
					.on("disconnect", this[kOnDisconnect])
					.on("connectionError", this[kOnConnectionError]);
				this[kClients].push(client);
				if (this[kNeedDrain]) {
					process.nextTick(() => {
						if (this[kNeedDrain]) {
							this[kOnDrain](client[kUrl], [this, client]);
						}
					});
				}
				return this;
			}
			[kRemoveClient](client) {
				client.close(() => {
					const idx = this[kClients].indexOf(client);
					if (idx !== -1) {
						this[kClients].splice(idx, 1);
					}
				});
				this[kNeedDrain] = this[kClients].some(
					(dispatcher) =>
						!dispatcher[kNeedDrain] &&
						dispatcher.closed !== true &&
						dispatcher.destroyed !== true,
				);
			}
		};
		module2.exports = {
			PoolBase,
			kClients,
			kNeedDrain,
			kAddClient,
			kRemoveClient,
			kGetDispatcher,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/pool.js
var require_pool = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/pool.js"(exports2, module2) {
		"use strict";
		var { PoolBase, kClients, kNeedDrain, kAddClient, kGetDispatcher } = require_pool_base();
		var Client = require_client();
		var { InvalidArgumentError } = require_errors2();
		var util = require_util2();
		var { kUrl, kInterceptors } = require_symbols();
		var buildConnector = require_connect();
		var kOptions = Symbol("options");
		var kConnections = Symbol("connections");
		var kFactory = Symbol("factory");
		function defaultFactory(origin, opts) {
			return new Client(origin, opts);
		}
		var Pool = class extends PoolBase {
			constructor(
				origin,
				{
					connections,
					factory = defaultFactory,
					connect,
					connectTimeout,
					tls,
					maxCachedSessions,
					socketPath,
					autoSelectFamily,
					autoSelectFamilyAttemptTimeout,
					allowH2,
					...options
				} = {},
			) {
				super();
				if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
					throw new InvalidArgumentError("invalid connections");
				}
				if (typeof factory !== "function") {
					throw new InvalidArgumentError("factory must be a function.");
				}
				if (
					connect != null &&
					typeof connect !== "function" &&
					typeof connect !== "object"
				) {
					throw new InvalidArgumentError("connect must be a function or an object");
				}
				if (typeof connect !== "function") {
					connect = buildConnector({
						...tls,
						maxCachedSessions,
						allowH2,
						socketPath,
						timeout: connectTimeout,
						...(util.nodeHasAutoSelectFamily && autoSelectFamily
							? { autoSelectFamily, autoSelectFamilyAttemptTimeout }
							: void 0),
						...connect,
					});
				}
				this[kInterceptors] =
					options.interceptors &&
					options.interceptors.Pool &&
					Array.isArray(options.interceptors.Pool)
						? options.interceptors.Pool
						: [];
				this[kConnections] = connections || null;
				this[kUrl] = util.parseOrigin(origin);
				this[kOptions] = { ...util.deepClone(options), connect, allowH2 };
				this[kOptions].interceptors = options.interceptors
					? { ...options.interceptors }
					: void 0;
				this[kFactory] = factory;
			}
			[kGetDispatcher]() {
				let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);
				if (dispatcher) {
					return dispatcher;
				}
				if (!this[kConnections] || this[kClients].length < this[kConnections]) {
					dispatcher = this[kFactory](this[kUrl], this[kOptions]);
					this[kAddClient](dispatcher);
				}
				return dispatcher;
			}
		};
		module2.exports = Pool;
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/balanced-pool.js
var require_balanced_pool = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/balanced-pool.js"(exports2, module2) {
		"use strict";
		var { BalancedPoolMissingUpstreamError, InvalidArgumentError } = require_errors2();
		var { PoolBase, kClients, kNeedDrain, kAddClient, kRemoveClient, kGetDispatcher } =
			require_pool_base();
		var Pool = require_pool();
		var { kUrl, kInterceptors } = require_symbols();
		var { parseOrigin } = require_util2();
		var kFactory = Symbol("factory");
		var kOptions = Symbol("options");
		var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
		var kCurrentWeight = Symbol("kCurrentWeight");
		var kIndex = Symbol("kIndex");
		var kWeight = Symbol("kWeight");
		var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
		var kErrorPenalty = Symbol("kErrorPenalty");
		function getGreatestCommonDivisor(a, b) {
			if (b === 0) return a;
			return getGreatestCommonDivisor(b, a % b);
		}
		function defaultFactory(origin, opts) {
			return new Pool(origin, opts);
		}
		var BalancedPool = class extends PoolBase {
			constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
				super();
				this[kOptions] = opts;
				this[kIndex] = -1;
				this[kCurrentWeight] = 0;
				this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
				this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
				if (!Array.isArray(upstreams)) {
					upstreams = [upstreams];
				}
				if (typeof factory !== "function") {
					throw new InvalidArgumentError("factory must be a function.");
				}
				this[kInterceptors] =
					opts.interceptors &&
					opts.interceptors.BalancedPool &&
					Array.isArray(opts.interceptors.BalancedPool)
						? opts.interceptors.BalancedPool
						: [];
				this[kFactory] = factory;
				for (const upstream of upstreams) {
					this.addUpstream(upstream);
				}
				this._updateBalancedPoolStats();
			}
			addUpstream(upstream) {
				const upstreamOrigin = parseOrigin(upstream).origin;
				if (
					this[kClients].find(
						(pool2) =>
							pool2[kUrl].origin === upstreamOrigin &&
							pool2.closed !== true &&
							pool2.destroyed !== true,
					)
				) {
					return this;
				}
				const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
				this[kAddClient](pool);
				pool.on("connect", () => {
					pool[kWeight] = Math.min(
						this[kMaxWeightPerServer],
						pool[kWeight] + this[kErrorPenalty],
					);
				});
				pool.on("connectionError", () => {
					pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
					this._updateBalancedPoolStats();
				});
				pool.on("disconnect", (...args) => {
					const err = args[2];
					if (err && err.code === "UND_ERR_SOCKET") {
						pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
						this._updateBalancedPoolStats();
					}
				});
				for (const client of this[kClients]) {
					client[kWeight] = this[kMaxWeightPerServer];
				}
				this._updateBalancedPoolStats();
				return this;
			}
			_updateBalancedPoolStats() {
				this[kGreatestCommonDivisor] = this[kClients]
					.map((p) => p[kWeight])
					.reduce(getGreatestCommonDivisor, 0);
			}
			removeUpstream(upstream) {
				const upstreamOrigin = parseOrigin(upstream).origin;
				const pool = this[kClients].find(
					(pool2) =>
						pool2[kUrl].origin === upstreamOrigin &&
						pool2.closed !== true &&
						pool2.destroyed !== true,
				);
				if (pool) {
					this[kRemoveClient](pool);
				}
				return this;
			}
			get upstreams() {
				return this[kClients]
					.filter(
						(dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true,
					)
					.map((p) => p[kUrl].origin);
			}
			[kGetDispatcher]() {
				if (this[kClients].length === 0) {
					throw new BalancedPoolMissingUpstreamError();
				}
				const dispatcher = this[kClients].find(
					(dispatcher2) =>
						!dispatcher2[kNeedDrain] &&
						dispatcher2.closed !== true &&
						dispatcher2.destroyed !== true,
				);
				if (!dispatcher) {
					return;
				}
				const allClientsBusy = this[kClients]
					.map((pool) => pool[kNeedDrain])
					.reduce((a, b) => a && b, true);
				if (allClientsBusy) {
					return;
				}
				let counter = 0;
				let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
				while (counter++ < this[kClients].length) {
					this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
					const pool = this[kClients][this[kIndex]];
					if (
						pool[kWeight] > this[kClients][maxWeightIndex][kWeight] &&
						!pool[kNeedDrain]
					) {
						maxWeightIndex = this[kIndex];
					}
					if (this[kIndex] === 0) {
						this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
						if (this[kCurrentWeight] <= 0) {
							this[kCurrentWeight] = this[kMaxWeightPerServer];
						}
					}
					if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
						return pool;
					}
				}
				this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
				this[kIndex] = maxWeightIndex;
				return this[kClients][maxWeightIndex];
			}
		};
		module2.exports = BalancedPool;
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/compat/dispatcher-weakref.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { kConnected, kSize } = require_symbols();
		var CompatWeakRef = class {
			constructor(value) {
				this.value = value;
			}
			deref() {
				return this.value[kConnected] === 0 && this.value[kSize] === 0
					? void 0
					: this.value;
			}
		};
		var CompatFinalizer = class {
			constructor(finalizer) {
				this.finalizer = finalizer;
			}
			register(dispatcher, key) {
				if (dispatcher.on) {
					dispatcher.on("disconnect", () => {
						if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
							this.finalizer(key);
						}
					});
				}
			}
		};
		module2.exports = function () {
			if (process.env.NODE_V8_COVERAGE) {
				return {
					WeakRef: CompatWeakRef,
					FinalizationRegistry: CompatFinalizer,
				};
			}
			return {
				WeakRef: global.WeakRef || CompatWeakRef,
				FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer,
			};
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/agent.js
var require_agent = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/agent.js"(exports2, module2) {
		"use strict";
		var { InvalidArgumentError } = require_errors2();
		var { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols();
		var DispatcherBase = require_dispatcher_base();
		var Pool = require_pool();
		var Client = require_client();
		var util = require_util2();
		var createRedirectInterceptor = require_redirectInterceptor();
		var { WeakRef: WeakRef2, FinalizationRegistry: FinalizationRegistry2 } =
			require_dispatcher_weakref()();
		var kOnConnect = Symbol("onConnect");
		var kOnDisconnect = Symbol("onDisconnect");
		var kOnConnectionError = Symbol("onConnectionError");
		var kMaxRedirections = Symbol("maxRedirections");
		var kOnDrain = Symbol("onDrain");
		var kFactory = Symbol("factory");
		var kFinalizer = Symbol("finalizer");
		var kOptions = Symbol("options");
		function defaultFactory(origin, opts) {
			return opts && opts.connections === 1
				? new Client(origin, opts)
				: new Pool(origin, opts);
		}
		var Agent = class extends DispatcherBase {
			constructor({
				factory = defaultFactory,
				maxRedirections = 0,
				connect,
				...options
			} = {}) {
				super();
				if (typeof factory !== "function") {
					throw new InvalidArgumentError("factory must be a function.");
				}
				if (
					connect != null &&
					typeof connect !== "function" &&
					typeof connect !== "object"
				) {
					throw new InvalidArgumentError("connect must be a function or an object");
				}
				if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
					throw new InvalidArgumentError("maxRedirections must be a positive number");
				}
				if (connect && typeof connect !== "function") {
					connect = { ...connect };
				}
				this[kInterceptors] =
					options.interceptors &&
					options.interceptors.Agent &&
					Array.isArray(options.interceptors.Agent)
						? options.interceptors.Agent
						: [createRedirectInterceptor({ maxRedirections })];
				this[kOptions] = { ...util.deepClone(options), connect };
				this[kOptions].interceptors = options.interceptors
					? { ...options.interceptors }
					: void 0;
				this[kMaxRedirections] = maxRedirections;
				this[kFactory] = factory;
				this[kClients] = /* @__PURE__ */ new Map();
				this[kFinalizer] = new FinalizationRegistry2(
					/* istanbul ignore next: gc is undeterministic */
					(key) => {
						const ref = this[kClients].get(key);
						if (ref !== void 0 && ref.deref() === void 0) {
							this[kClients].delete(key);
						}
					},
				);
				const agent = this;
				this[kOnDrain] = (origin, targets) => {
					agent.emit("drain", origin, [agent, ...targets]);
				};
				this[kOnConnect] = (origin, targets) => {
					agent.emit("connect", origin, [agent, ...targets]);
				};
				this[kOnDisconnect] = (origin, targets, err) => {
					agent.emit("disconnect", origin, [agent, ...targets], err);
				};
				this[kOnConnectionError] = (origin, targets, err) => {
					agent.emit("connectionError", origin, [agent, ...targets], err);
				};
			}
			get [kRunning]() {
				let ret = 0;
				for (const ref of this[kClients].values()) {
					const client = ref.deref();
					if (client) {
						ret += client[kRunning];
					}
				}
				return ret;
			}
			[kDispatch](opts, handler) {
				let key;
				if (
					opts.origin &&
					(typeof opts.origin === "string" || opts.origin instanceof URL)
				) {
					key = String(opts.origin);
				} else {
					throw new InvalidArgumentError(
						"opts.origin must be a non-empty string or URL.",
					);
				}
				const ref = this[kClients].get(key);
				let dispatcher = ref ? ref.deref() : null;
				if (!dispatcher) {
					dispatcher = this[kFactory](opts.origin, this[kOptions])
						.on("drain", this[kOnDrain])
						.on("connect", this[kOnConnect])
						.on("disconnect", this[kOnDisconnect])
						.on("connectionError", this[kOnConnectionError]);
					this[kClients].set(key, new WeakRef2(dispatcher));
					this[kFinalizer].register(dispatcher, key);
				}
				return dispatcher.dispatch(opts, handler);
			}
			async [kClose]() {
				const closePromises = [];
				for (const ref of this[kClients].values()) {
					const client = ref.deref();
					if (client) {
						closePromises.push(client.close());
					}
				}
				await Promise.all(closePromises);
			}
			async [kDestroy](err) {
				const destroyPromises = [];
				for (const ref of this[kClients].values()) {
					const client = ref.deref();
					if (client) {
						destroyPromises.push(client.destroy(err));
					}
				}
				await Promise.all(destroyPromises);
			}
		};
		module2.exports = Agent;
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/api/readable.js
var require_readable = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/api/readable.js"(exports2, module2) {
		"use strict";
		var assert = require("assert");
		var { Readable } = require("stream");
		var { RequestAbortedError, NotSupportedError, InvalidArgumentError } = require_errors2();
		var util = require_util2();
		var { ReadableStreamFrom, toUSVString } = require_util2();
		var Blob2;
		var kConsume = Symbol("kConsume");
		var kReading = Symbol("kReading");
		var kBody = Symbol("kBody");
		var kAbort = Symbol("abort");
		var kContentType = Symbol("kContentType");
		var noop = () => {};
		module2.exports = class BodyReadable extends Readable {
			constructor({
				resume,
				abort,
				contentType = "",
				highWaterMark = 64 * 1024,
				// Same as nodejs fs streams.
			}) {
				super({
					autoDestroy: true,
					read: resume,
					highWaterMark,
				});
				this._readableState.dataEmitted = false;
				this[kAbort] = abort;
				this[kConsume] = null;
				this[kBody] = null;
				this[kContentType] = contentType;
				this[kReading] = false;
			}
			destroy(err) {
				if (this.destroyed) {
					return this;
				}
				if (!err && !this._readableState.endEmitted) {
					err = new RequestAbortedError();
				}
				if (err) {
					this[kAbort]();
				}
				return super.destroy(err);
			}
			emit(ev, ...args) {
				if (ev === "data") {
					this._readableState.dataEmitted = true;
				} else if (ev === "error") {
					this._readableState.errorEmitted = true;
				}
				return super.emit(ev, ...args);
			}
			on(ev, ...args) {
				if (ev === "data" || ev === "readable") {
					this[kReading] = true;
				}
				return super.on(ev, ...args);
			}
			addListener(ev, ...args) {
				return this.on(ev, ...args);
			}
			off(ev, ...args) {
				const ret = super.off(ev, ...args);
				if (ev === "data" || ev === "readable") {
					this[kReading] =
						this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
				}
				return ret;
			}
			removeListener(ev, ...args) {
				return this.off(ev, ...args);
			}
			push(chunk) {
				if (this[kConsume] && chunk !== null && this.readableLength === 0) {
					consumePush(this[kConsume], chunk);
					return this[kReading] ? super.push(chunk) : true;
				}
				return super.push(chunk);
			}
			// https://fetch.spec.whatwg.org/#dom-body-text
			async text() {
				return consume(this, "text");
			}
			// https://fetch.spec.whatwg.org/#dom-body-json
			async json() {
				return consume(this, "json");
			}
			// https://fetch.spec.whatwg.org/#dom-body-blob
			async blob() {
				return consume(this, "blob");
			}
			// https://fetch.spec.whatwg.org/#dom-body-arraybuffer
			async arrayBuffer() {
				return consume(this, "arrayBuffer");
			}
			// https://fetch.spec.whatwg.org/#dom-body-formdata
			async formData() {
				throw new NotSupportedError();
			}
			// https://fetch.spec.whatwg.org/#dom-body-bodyused
			get bodyUsed() {
				return util.isDisturbed(this);
			}
			// https://fetch.spec.whatwg.org/#dom-body-body
			get body() {
				if (!this[kBody]) {
					this[kBody] = ReadableStreamFrom(this);
					if (this[kConsume]) {
						this[kBody].getReader();
						assert(this[kBody].locked);
					}
				}
				return this[kBody];
			}
			dump(opts) {
				let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
				const signal = opts && opts.signal;
				if (signal) {
					try {
						if (typeof signal !== "object" || !("aborted" in signal)) {
							throw new InvalidArgumentError("signal must be an AbortSignal");
						}
						util.throwIfAborted(signal);
					} catch (err) {
						return Promise.reject(err);
					}
				}
				if (this.closed) {
					return Promise.resolve(null);
				}
				return new Promise((resolve, reject) => {
					const signalListenerCleanup = signal
						? util.addAbortListener(signal, () => {
								this.destroy();
							})
						: noop;
					this.on("close", function () {
						signalListenerCleanup();
						if (signal && signal.aborted) {
							reject(
								signal.reason ||
									Object.assign(new Error("The operation was aborted"), {
										name: "AbortError",
									}),
							);
						} else {
							resolve(null);
						}
					})
						.on("error", noop)
						.on("data", function (chunk) {
							limit -= chunk.length;
							if (limit <= 0) {
								this.destroy();
							}
						})
						.resume();
				});
			}
		};
		function isLocked(self2) {
			return (self2[kBody] && self2[kBody].locked === true) || self2[kConsume];
		}
		function isUnusable(self2) {
			return util.isDisturbed(self2) || isLocked(self2);
		}
		async function consume(stream, type) {
			if (isUnusable(stream)) {
				throw new TypeError("unusable");
			}
			assert(!stream[kConsume]);
			return new Promise((resolve, reject) => {
				stream[kConsume] = {
					type,
					stream,
					resolve,
					reject,
					length: 0,
					body: [],
				};
				stream
					.on("error", function (err) {
						consumeFinish(this[kConsume], err);
					})
					.on("close", function () {
						if (this[kConsume].body !== null) {
							consumeFinish(this[kConsume], new RequestAbortedError());
						}
					});
				process.nextTick(consumeStart, stream[kConsume]);
			});
		}
		function consumeStart(consume2) {
			if (consume2.body === null) {
				return;
			}
			const { _readableState: state } = consume2.stream;
			for (const chunk of state.buffer) {
				consumePush(consume2, chunk);
			}
			if (state.endEmitted) {
				consumeEnd(this[kConsume]);
			} else {
				consume2.stream.on("end", function () {
					consumeEnd(this[kConsume]);
				});
			}
			consume2.stream.resume();
			while (consume2.stream.read() != null) {}
		}
		function consumeEnd(consume2) {
			const { type, body, resolve, stream, length } = consume2;
			try {
				if (type === "text") {
					resolve(toUSVString(Buffer.concat(body)));
				} else if (type === "json") {
					resolve(JSON.parse(Buffer.concat(body)));
				} else if (type === "arrayBuffer") {
					const dst = new Uint8Array(length);
					let pos = 0;
					for (const buf of body) {
						dst.set(buf, pos);
						pos += buf.byteLength;
					}
					resolve(dst.buffer);
				} else if (type === "blob") {
					if (!Blob2) {
						Blob2 = require("buffer").Blob;
					}
					resolve(new Blob2(body, { type: stream[kContentType] }));
				}
				consumeFinish(consume2);
			} catch (err) {
				stream.destroy(err);
			}
		}
		function consumePush(consume2, chunk) {
			consume2.length += chunk.length;
			consume2.body.push(chunk);
		}
		function consumeFinish(consume2, err) {
			if (consume2.body === null) {
				return;
			}
			if (err) {
				consume2.reject(err);
			} else {
				consume2.resolve();
			}
			consume2.type = null;
			consume2.stream = null;
			consume2.resolve = null;
			consume2.reject = null;
			consume2.length = 0;
			consume2.body = null;
		}
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/api/util.js
var require_util4 = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/api/util.js"(exports2, module2) {
		"use strict";
		var assert = require("assert");
		var { ResponseStatusCodeError } = require_errors2();
		var { toUSVString } = require_util2();
		async function getResolveErrorBodyCallback({
			callback,
			body,
			contentType,
			statusCode,
			statusMessage,
			headers,
		}) {
			assert(body);
			let chunks = [];
			let limit = 0;
			for await (const chunk of body) {
				chunks.push(chunk);
				limit += chunk.length;
				if (limit > 128 * 1024) {
					chunks = null;
					break;
				}
			}
			if (statusCode === 204 || !contentType || !chunks) {
				process.nextTick(
					callback,
					new ResponseStatusCodeError(
						`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`,
						statusCode,
						headers,
					),
				);
				return;
			}
			try {
				if (contentType.startsWith("application/json")) {
					const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
					process.nextTick(
						callback,
						new ResponseStatusCodeError(
							`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`,
							statusCode,
							headers,
							payload,
						),
					);
					return;
				}
				if (contentType.startsWith("text/")) {
					const payload = toUSVString(Buffer.concat(chunks));
					process.nextTick(
						callback,
						new ResponseStatusCodeError(
							`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`,
							statusCode,
							headers,
							payload,
						),
					);
					return;
				}
			} catch (err) {}
			process.nextTick(
				callback,
				new ResponseStatusCodeError(
					`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`,
					statusCode,
					headers,
				),
			);
		}
		module2.exports = { getResolveErrorBodyCallback };
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/api/abort-signal.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { addAbortListener } = require_util2();
		var { RequestAbortedError } = require_errors2();
		var kListener = Symbol("kListener");
		var kSignal = Symbol("kSignal");
		function abort(self2) {
			if (self2.abort) {
				self2.abort();
			} else {
				self2.onError(new RequestAbortedError());
			}
		}
		function addSignal(self2, signal) {
			self2[kSignal] = null;
			self2[kListener] = null;
			if (!signal) {
				return;
			}
			if (signal.aborted) {
				abort(self2);
				return;
			}
			self2[kSignal] = signal;
			self2[kListener] = () => {
				abort(self2);
			};
			addAbortListener(self2[kSignal], self2[kListener]);
		}
		function removeSignal(self2) {
			if (!self2[kSignal]) {
				return;
			}
			if ("removeEventListener" in self2[kSignal]) {
				self2[kSignal].removeEventListener("abort", self2[kListener]);
			} else {
				self2[kSignal].removeListener("abort", self2[kListener]);
			}
			self2[kSignal] = null;
			self2[kListener] = null;
		}
		module2.exports = {
			addSignal,
			removeSignal,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/api/api-request.js"(
		exports2,
		module2,
	) {
		"use strict";
		var Readable = require_readable();
		var { InvalidArgumentError, RequestAbortedError } = require_errors2();
		var util = require_util2();
		var { getResolveErrorBodyCallback } = require_util4();
		var { AsyncResource } = require("async_hooks");
		var { addSignal, removeSignal } = require_abort_signal();
		var RequestHandler = class extends AsyncResource {
			constructor(opts, callback) {
				if (!opts || typeof opts !== "object") {
					throw new InvalidArgumentError("invalid opts");
				}
				const {
					signal,
					method,
					opaque,
					body,
					onInfo,
					responseHeaders,
					throwOnError,
					highWaterMark,
				} = opts;
				try {
					if (typeof callback !== "function") {
						throw new InvalidArgumentError("invalid callback");
					}
					if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
						throw new InvalidArgumentError("invalid highWaterMark");
					}
					if (
						signal &&
						typeof signal.on !== "function" &&
						typeof signal.addEventListener !== "function"
					) {
						throw new InvalidArgumentError(
							"signal must be an EventEmitter or EventTarget",
						);
					}
					if (method === "CONNECT") {
						throw new InvalidArgumentError("invalid method");
					}
					if (onInfo && typeof onInfo !== "function") {
						throw new InvalidArgumentError("invalid onInfo callback");
					}
					super("UNDICI_REQUEST");
				} catch (err) {
					if (util.isStream(body)) {
						util.destroy(body.on("error", util.nop), err);
					}
					throw err;
				}
				this.responseHeaders = responseHeaders || null;
				this.opaque = opaque || null;
				this.callback = callback;
				this.res = null;
				this.abort = null;
				this.body = body;
				this.trailers = {};
				this.context = null;
				this.onInfo = onInfo || null;
				this.throwOnError = throwOnError;
				this.highWaterMark = highWaterMark;
				if (util.isStream(body)) {
					body.on("error", (err) => {
						this.onError(err);
					});
				}
				addSignal(this, signal);
			}
			onConnect(abort, context) {
				if (!this.callback) {
					throw new RequestAbortedError();
				}
				this.abort = abort;
				this.context = context;
			}
			onHeaders(statusCode, rawHeaders, resume, statusMessage) {
				const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;
				const headers =
					responseHeaders === "raw"
						? util.parseRawHeaders(rawHeaders)
						: util.parseHeaders(rawHeaders);
				if (statusCode < 200) {
					if (this.onInfo) {
						this.onInfo({ statusCode, headers });
					}
					return;
				}
				const parsedHeaders =
					responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
				const contentType = parsedHeaders["content-type"];
				const body = new Readable({ resume, abort, contentType, highWaterMark });
				this.callback = null;
				this.res = body;
				if (callback !== null) {
					if (this.throwOnError && statusCode >= 400) {
						this.runInAsyncScope(getResolveErrorBodyCallback, null, {
							callback,
							body,
							contentType,
							statusCode,
							statusMessage,
							headers,
						});
					} else {
						this.runInAsyncScope(callback, null, null, {
							statusCode,
							headers,
							trailers: this.trailers,
							opaque,
							body,
							context,
						});
					}
				}
			}
			onData(chunk) {
				const { res } = this;
				return res.push(chunk);
			}
			onComplete(trailers) {
				const { res } = this;
				removeSignal(this);
				util.parseHeaders(trailers, this.trailers);
				res.push(null);
			}
			onError(err) {
				const { res, callback, body, opaque } = this;
				removeSignal(this);
				if (callback) {
					this.callback = null;
					queueMicrotask(() => {
						this.runInAsyncScope(callback, null, err, { opaque });
					});
				}
				if (res) {
					this.res = null;
					queueMicrotask(() => {
						util.destroy(res, err);
					});
				}
				if (body) {
					this.body = null;
					util.destroy(body, err);
				}
			}
		};
		function request(opts, callback) {
			if (callback === void 0) {
				return new Promise((resolve, reject) => {
					request.call(this, opts, (err, data) => {
						return err ? reject(err) : resolve(data);
					});
				});
			}
			try {
				this.dispatch(opts, new RequestHandler(opts, callback));
			} catch (err) {
				if (typeof callback !== "function") {
					throw err;
				}
				const opaque = opts && opts.opaque;
				queueMicrotask(() => callback(err, { opaque }));
			}
		}
		module2.exports = request;
		module2.exports.RequestHandler = RequestHandler;
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/api/api-stream.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { finished, PassThrough } = require("stream");
		var { InvalidArgumentError, InvalidReturnValueError, RequestAbortedError } =
			require_errors2();
		var util = require_util2();
		var { getResolveErrorBodyCallback } = require_util4();
		var { AsyncResource } = require("async_hooks");
		var { addSignal, removeSignal } = require_abort_signal();
		var StreamHandler = class extends AsyncResource {
			constructor(opts, factory, callback) {
				if (!opts || typeof opts !== "object") {
					throw new InvalidArgumentError("invalid opts");
				}
				const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } =
					opts;
				try {
					if (typeof callback !== "function") {
						throw new InvalidArgumentError("invalid callback");
					}
					if (typeof factory !== "function") {
						throw new InvalidArgumentError("invalid factory");
					}
					if (
						signal &&
						typeof signal.on !== "function" &&
						typeof signal.addEventListener !== "function"
					) {
						throw new InvalidArgumentError(
							"signal must be an EventEmitter or EventTarget",
						);
					}
					if (method === "CONNECT") {
						throw new InvalidArgumentError("invalid method");
					}
					if (onInfo && typeof onInfo !== "function") {
						throw new InvalidArgumentError("invalid onInfo callback");
					}
					super("UNDICI_STREAM");
				} catch (err) {
					if (util.isStream(body)) {
						util.destroy(body.on("error", util.nop), err);
					}
					throw err;
				}
				this.responseHeaders = responseHeaders || null;
				this.opaque = opaque || null;
				this.factory = factory;
				this.callback = callback;
				this.res = null;
				this.abort = null;
				this.context = null;
				this.trailers = null;
				this.body = body;
				this.onInfo = onInfo || null;
				this.throwOnError = throwOnError || false;
				if (util.isStream(body)) {
					body.on("error", (err) => {
						this.onError(err);
					});
				}
				addSignal(this, signal);
			}
			onConnect(abort, context) {
				if (!this.callback) {
					throw new RequestAbortedError();
				}
				this.abort = abort;
				this.context = context;
			}
			onHeaders(statusCode, rawHeaders, resume, statusMessage) {
				const { factory, opaque, context, callback, responseHeaders } = this;
				const headers =
					responseHeaders === "raw"
						? util.parseRawHeaders(rawHeaders)
						: util.parseHeaders(rawHeaders);
				if (statusCode < 200) {
					if (this.onInfo) {
						this.onInfo({ statusCode, headers });
					}
					return;
				}
				this.factory = null;
				let res;
				if (this.throwOnError && statusCode >= 400) {
					const parsedHeaders =
						responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
					const contentType = parsedHeaders["content-type"];
					res = new PassThrough();
					this.callback = null;
					this.runInAsyncScope(getResolveErrorBodyCallback, null, {
						callback,
						body: res,
						contentType,
						statusCode,
						statusMessage,
						headers,
					});
				} else {
					if (factory === null) {
						return;
					}
					res = this.runInAsyncScope(factory, null, {
						statusCode,
						headers,
						opaque,
						context,
					});
					if (
						!res ||
						typeof res.write !== "function" ||
						typeof res.end !== "function" ||
						typeof res.on !== "function"
					) {
						throw new InvalidReturnValueError("expected Writable");
					}
					finished(res, { readable: false }, (err) => {
						const {
							callback: callback2,
							res: res2,
							opaque: opaque2,
							trailers,
							abort,
						} = this;
						this.res = null;
						if (err || !res2.readable) {
							util.destroy(res2, err);
						}
						this.callback = null;
						this.runInAsyncScope(callback2, null, err || null, {
							opaque: opaque2,
							trailers,
						});
						if (err) {
							abort();
						}
					});
				}
				res.on("drain", resume);
				this.res = res;
				const needDrain =
					res.writableNeedDrain !== void 0
						? res.writableNeedDrain
						: res._writableState && res._writableState.needDrain;
				return needDrain !== true;
			}
			onData(chunk) {
				const { res } = this;
				return res ? res.write(chunk) : true;
			}
			onComplete(trailers) {
				const { res } = this;
				removeSignal(this);
				if (!res) {
					return;
				}
				this.trailers = util.parseHeaders(trailers);
				res.end();
			}
			onError(err) {
				const { res, callback, opaque, body } = this;
				removeSignal(this);
				this.factory = null;
				if (res) {
					this.res = null;
					util.destroy(res, err);
				} else if (callback) {
					this.callback = null;
					queueMicrotask(() => {
						this.runInAsyncScope(callback, null, err, { opaque });
					});
				}
				if (body) {
					this.body = null;
					util.destroy(body, err);
				}
			}
		};
		function stream(opts, factory, callback) {
			if (callback === void 0) {
				return new Promise((resolve, reject) => {
					stream.call(this, opts, factory, (err, data) => {
						return err ? reject(err) : resolve(data);
					});
				});
			}
			try {
				this.dispatch(opts, new StreamHandler(opts, factory, callback));
			} catch (err) {
				if (typeof callback !== "function") {
					throw err;
				}
				const opaque = opts && opts.opaque;
				queueMicrotask(() => callback(err, { opaque }));
			}
		}
		module2.exports = stream;
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/api/api-pipeline.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { Readable, Duplex, PassThrough } = require("stream");
		var { InvalidArgumentError, InvalidReturnValueError, RequestAbortedError } =
			require_errors2();
		var util = require_util2();
		var { AsyncResource } = require("async_hooks");
		var { addSignal, removeSignal } = require_abort_signal();
		var assert = require("assert");
		var kResume = Symbol("resume");
		var PipelineRequest = class extends Readable {
			constructor() {
				super({ autoDestroy: true });
				this[kResume] = null;
			}
			_read() {
				const { [kResume]: resume } = this;
				if (resume) {
					this[kResume] = null;
					resume();
				}
			}
			_destroy(err, callback) {
				this._read();
				callback(err);
			}
		};
		var PipelineResponse = class extends Readable {
			constructor(resume) {
				super({ autoDestroy: true });
				this[kResume] = resume;
			}
			_read() {
				this[kResume]();
			}
			_destroy(err, callback) {
				if (!err && !this._readableState.endEmitted) {
					err = new RequestAbortedError();
				}
				callback(err);
			}
		};
		var PipelineHandler = class extends AsyncResource {
			constructor(opts, handler) {
				if (!opts || typeof opts !== "object") {
					throw new InvalidArgumentError("invalid opts");
				}
				if (typeof handler !== "function") {
					throw new InvalidArgumentError("invalid handler");
				}
				const { signal, method, opaque, onInfo, responseHeaders } = opts;
				if (
					signal &&
					typeof signal.on !== "function" &&
					typeof signal.addEventListener !== "function"
				) {
					throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
				}
				if (method === "CONNECT") {
					throw new InvalidArgumentError("invalid method");
				}
				if (onInfo && typeof onInfo !== "function") {
					throw new InvalidArgumentError("invalid onInfo callback");
				}
				super("UNDICI_PIPELINE");
				this.opaque = opaque || null;
				this.responseHeaders = responseHeaders || null;
				this.handler = handler;
				this.abort = null;
				this.context = null;
				this.onInfo = onInfo || null;
				this.req = new PipelineRequest().on("error", util.nop);
				this.ret = new Duplex({
					readableObjectMode: opts.objectMode,
					autoDestroy: true,
					read: () => {
						const { body } = this;
						if (body && body.resume) {
							body.resume();
						}
					},
					write: (chunk, encoding, callback) => {
						const { req } = this;
						if (req.push(chunk, encoding) || req._readableState.destroyed) {
							callback();
						} else {
							req[kResume] = callback;
						}
					},
					destroy: (err, callback) => {
						const { body, req, res, ret, abort } = this;
						if (!err && !ret._readableState.endEmitted) {
							err = new RequestAbortedError();
						}
						if (abort && err) {
							abort();
						}
						util.destroy(body, err);
						util.destroy(req, err);
						util.destroy(res, err);
						removeSignal(this);
						callback(err);
					},
				}).on("prefinish", () => {
					const { req } = this;
					req.push(null);
				});
				this.res = null;
				addSignal(this, signal);
			}
			onConnect(abort, context) {
				const { ret, res } = this;
				assert(!res, "pipeline cannot be retried");
				if (ret.destroyed) {
					throw new RequestAbortedError();
				}
				this.abort = abort;
				this.context = context;
			}
			onHeaders(statusCode, rawHeaders, resume) {
				const { opaque, handler, context } = this;
				if (statusCode < 200) {
					if (this.onInfo) {
						const headers =
							this.responseHeaders === "raw"
								? util.parseRawHeaders(rawHeaders)
								: util.parseHeaders(rawHeaders);
						this.onInfo({ statusCode, headers });
					}
					return;
				}
				this.res = new PipelineResponse(resume);
				let body;
				try {
					this.handler = null;
					const headers =
						this.responseHeaders === "raw"
							? util.parseRawHeaders(rawHeaders)
							: util.parseHeaders(rawHeaders);
					body = this.runInAsyncScope(handler, null, {
						statusCode,
						headers,
						opaque,
						body: this.res,
						context,
					});
				} catch (err) {
					this.res.on("error", util.nop);
					throw err;
				}
				if (!body || typeof body.on !== "function") {
					throw new InvalidReturnValueError("expected Readable");
				}
				body.on("data", (chunk) => {
					const { ret, body: body2 } = this;
					if (!ret.push(chunk) && body2.pause) {
						body2.pause();
					}
				})
					.on("error", (err) => {
						const { ret } = this;
						util.destroy(ret, err);
					})
					.on("end", () => {
						const { ret } = this;
						ret.push(null);
					})
					.on("close", () => {
						const { ret } = this;
						if (!ret._readableState.ended) {
							util.destroy(ret, new RequestAbortedError());
						}
					});
				this.body = body;
			}
			onData(chunk) {
				const { res } = this;
				return res.push(chunk);
			}
			onComplete(trailers) {
				const { res } = this;
				res.push(null);
			}
			onError(err) {
				const { ret } = this;
				this.handler = null;
				util.destroy(ret, err);
			}
		};
		function pipeline(opts, handler) {
			try {
				const pipelineHandler = new PipelineHandler(opts, handler);
				this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
				return pipelineHandler.ret;
			} catch (err) {
				return new PassThrough().destroy(err);
			}
		}
		module2.exports = pipeline;
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/api/api-upgrade.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors2();
		var { AsyncResource } = require("async_hooks");
		var util = require_util2();
		var { addSignal, removeSignal } = require_abort_signal();
		var assert = require("assert");
		var UpgradeHandler = class extends AsyncResource {
			constructor(opts, callback) {
				if (!opts || typeof opts !== "object") {
					throw new InvalidArgumentError("invalid opts");
				}
				if (typeof callback !== "function") {
					throw new InvalidArgumentError("invalid callback");
				}
				const { signal, opaque, responseHeaders } = opts;
				if (
					signal &&
					typeof signal.on !== "function" &&
					typeof signal.addEventListener !== "function"
				) {
					throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
				}
				super("UNDICI_UPGRADE");
				this.responseHeaders = responseHeaders || null;
				this.opaque = opaque || null;
				this.callback = callback;
				this.abort = null;
				this.context = null;
				addSignal(this, signal);
			}
			onConnect(abort, context) {
				if (!this.callback) {
					throw new RequestAbortedError();
				}
				this.abort = abort;
				this.context = null;
			}
			onHeaders() {
				throw new SocketError("bad upgrade", null);
			}
			onUpgrade(statusCode, rawHeaders, socket) {
				const { callback, opaque, context } = this;
				assert.strictEqual(statusCode, 101);
				removeSignal(this);
				this.callback = null;
				const headers =
					this.responseHeaders === "raw"
						? util.parseRawHeaders(rawHeaders)
						: util.parseHeaders(rawHeaders);
				this.runInAsyncScope(callback, null, null, {
					headers,
					socket,
					opaque,
					context,
				});
			}
			onError(err) {
				const { callback, opaque } = this;
				removeSignal(this);
				if (callback) {
					this.callback = null;
					queueMicrotask(() => {
						this.runInAsyncScope(callback, null, err, { opaque });
					});
				}
			}
		};
		function upgrade(opts, callback) {
			if (callback === void 0) {
				return new Promise((resolve, reject) => {
					upgrade.call(this, opts, (err, data) => {
						return err ? reject(err) : resolve(data);
					});
				});
			}
			try {
				const upgradeHandler = new UpgradeHandler(opts, callback);
				this.dispatch(
					{
						...opts,
						method: opts.method || "GET",
						upgrade: opts.protocol || "Websocket",
					},
					upgradeHandler,
				);
			} catch (err) {
				if (typeof callback !== "function") {
					throw err;
				}
				const opaque = opts && opts.opaque;
				queueMicrotask(() => callback(err, { opaque }));
			}
		}
		module2.exports = upgrade;
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/api/api-connect.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { AsyncResource } = require("async_hooks");
		var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors2();
		var util = require_util2();
		var { addSignal, removeSignal } = require_abort_signal();
		var ConnectHandler = class extends AsyncResource {
			constructor(opts, callback) {
				if (!opts || typeof opts !== "object") {
					throw new InvalidArgumentError("invalid opts");
				}
				if (typeof callback !== "function") {
					throw new InvalidArgumentError("invalid callback");
				}
				const { signal, opaque, responseHeaders } = opts;
				if (
					signal &&
					typeof signal.on !== "function" &&
					typeof signal.addEventListener !== "function"
				) {
					throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
				}
				super("UNDICI_CONNECT");
				this.opaque = opaque || null;
				this.responseHeaders = responseHeaders || null;
				this.callback = callback;
				this.abort = null;
				addSignal(this, signal);
			}
			onConnect(abort, context) {
				if (!this.callback) {
					throw new RequestAbortedError();
				}
				this.abort = abort;
				this.context = context;
			}
			onHeaders() {
				throw new SocketError("bad connect", null);
			}
			onUpgrade(statusCode, rawHeaders, socket) {
				const { callback, opaque, context } = this;
				removeSignal(this);
				this.callback = null;
				let headers = rawHeaders;
				if (headers != null) {
					headers =
						this.responseHeaders === "raw"
							? util.parseRawHeaders(rawHeaders)
							: util.parseHeaders(rawHeaders);
				}
				this.runInAsyncScope(callback, null, null, {
					statusCode,
					headers,
					socket,
					opaque,
					context,
				});
			}
			onError(err) {
				const { callback, opaque } = this;
				removeSignal(this);
				if (callback) {
					this.callback = null;
					queueMicrotask(() => {
						this.runInAsyncScope(callback, null, err, { opaque });
					});
				}
			}
		};
		function connect(opts, callback) {
			if (callback === void 0) {
				return new Promise((resolve, reject) => {
					connect.call(this, opts, (err, data) => {
						return err ? reject(err) : resolve(data);
					});
				});
			}
			try {
				const connectHandler = new ConnectHandler(opts, callback);
				this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
			} catch (err) {
				if (typeof callback !== "function") {
					throw err;
				}
				const opaque = opts && opts.opaque;
				queueMicrotask(() => callback(err, { opaque }));
			}
		}
		module2.exports = connect;
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/api/index.js
var require_api = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/api/index.js"(exports2, module2) {
		"use strict";
		module2.exports.request = require_api_request();
		module2.exports.stream = require_api_stream();
		module2.exports.pipeline = require_api_pipeline();
		module2.exports.upgrade = require_api_upgrade();
		module2.exports.connect = require_api_connect();
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/mock/mock-errors.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { UndiciError } = require_errors2();
		var MockNotMatchedError = class _MockNotMatchedError extends UndiciError {
			constructor(message) {
				super(message);
				Error.captureStackTrace(this, _MockNotMatchedError);
				this.name = "MockNotMatchedError";
				this.message =
					message || "The request does not match any registered mock dispatches";
				this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
			}
		};
		module2.exports = {
			MockNotMatchedError,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/mock/mock-symbols.js"(
		exports2,
		module2,
	) {
		"use strict";
		module2.exports = {
			kAgent: Symbol("agent"),
			kOptions: Symbol("options"),
			kFactory: Symbol("factory"),
			kDispatches: Symbol("dispatches"),
			kDispatchKey: Symbol("dispatch key"),
			kDefaultHeaders: Symbol("default headers"),
			kDefaultTrailers: Symbol("default trailers"),
			kContentLength: Symbol("content length"),
			kMockAgent: Symbol("mock agent"),
			kMockAgentSet: Symbol("mock agent set"),
			kMockAgentGet: Symbol("mock agent get"),
			kMockDispatch: Symbol("mock dispatch"),
			kClose: Symbol("close"),
			kOriginalClose: Symbol("original agent close"),
			kOrigin: Symbol("origin"),
			kIsMockActive: Symbol("is mock active"),
			kNetConnect: Symbol("net connect"),
			kGetNetConnect: Symbol("get net connect"),
			kConnected: Symbol("connected"),
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/mock/mock-utils.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { MockNotMatchedError } = require_mock_errors();
		var { kDispatches, kMockAgent, kOriginalDispatch, kOrigin, kGetNetConnect } =
			require_mock_symbols();
		var { buildURL, nop } = require_util2();
		var { STATUS_CODES } = require("http");
		var {
			types: { isPromise },
		} = require("util");
		function matchValue(match, value) {
			if (typeof match === "string") {
				return match === value;
			}
			if (match instanceof RegExp) {
				return match.test(value);
			}
			if (typeof match === "function") {
				return match(value) === true;
			}
			return false;
		}
		function lowerCaseEntries(headers) {
			return Object.fromEntries(
				Object.entries(headers).map(([headerName, headerValue]) => {
					return [headerName.toLocaleLowerCase(), headerValue];
				}),
			);
		}
		function getHeaderByName(headers, key) {
			if (Array.isArray(headers)) {
				for (let i = 0; i < headers.length; i += 2) {
					if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
						return headers[i + 1];
					}
				}
				return void 0;
			} else if (typeof headers.get === "function") {
				return headers.get(key);
			} else {
				return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
			}
		}
		function buildHeadersFromArray(headers) {
			const clone = headers.slice();
			const entries = [];
			for (let index = 0; index < clone.length; index += 2) {
				entries.push([clone[index], clone[index + 1]]);
			}
			return Object.fromEntries(entries);
		}
		function matchHeaders(mockDispatch2, headers) {
			if (typeof mockDispatch2.headers === "function") {
				if (Array.isArray(headers)) {
					headers = buildHeadersFromArray(headers);
				}
				return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
			}
			if (typeof mockDispatch2.headers === "undefined") {
				return true;
			}
			if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
				return false;
			}
			for (const [matchHeaderName, matchHeaderValue] of Object.entries(
				mockDispatch2.headers,
			)) {
				const headerValue = getHeaderByName(headers, matchHeaderName);
				if (!matchValue(matchHeaderValue, headerValue)) {
					return false;
				}
			}
			return true;
		}
		function safeUrl(path) {
			if (typeof path !== "string") {
				return path;
			}
			const pathSegments = path.split("?");
			if (pathSegments.length !== 2) {
				return path;
			}
			const qp = new URLSearchParams(pathSegments.pop());
			qp.sort();
			return [...pathSegments, qp.toString()].join("?");
		}
		function matchKey(mockDispatch2, { path, method, body, headers }) {
			const pathMatch = matchValue(mockDispatch2.path, path);
			const methodMatch = matchValue(mockDispatch2.method, method);
			const bodyMatch =
				typeof mockDispatch2.body !== "undefined"
					? matchValue(mockDispatch2.body, body)
					: true;
			const headersMatch = matchHeaders(mockDispatch2, headers);
			return pathMatch && methodMatch && bodyMatch && headersMatch;
		}
		function getResponseData(data) {
			if (Buffer.isBuffer(data)) {
				return data;
			} else if (typeof data === "object") {
				return JSON.stringify(data);
			} else {
				return data.toString();
			}
		}
		function getMockDispatch(mockDispatches, key) {
			const basePath = key.query ? buildURL(key.path, key.query) : key.path;
			const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
			let matchedMockDispatches = mockDispatches
				.filter(({ consumed }) => !consumed)
				.filter(({ path }) => matchValue(safeUrl(path), resolvedPath));
			if (matchedMockDispatches.length === 0) {
				throw new MockNotMatchedError(
					`Mock dispatch not matched for path '${resolvedPath}'`,
				);
			}
			matchedMockDispatches = matchedMockDispatches.filter(({ method }) =>
				matchValue(method, key.method),
			);
			if (matchedMockDispatches.length === 0) {
				throw new MockNotMatchedError(
					`Mock dispatch not matched for method '${key.method}'`,
				);
			}
			matchedMockDispatches = matchedMockDispatches.filter(({ body }) =>
				typeof body !== "undefined" ? matchValue(body, key.body) : true,
			);
			if (matchedMockDispatches.length === 0) {
				throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
			}
			matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) =>
				matchHeaders(mockDispatch2, key.headers),
			);
			if (matchedMockDispatches.length === 0) {
				throw new MockNotMatchedError(
					`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`,
				);
			}
			return matchedMockDispatches[0];
		}
		function addMockDispatch(mockDispatches, key, data) {
			const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
			const replyData = typeof data === "function" ? { callback: data } : { ...data };
			const newMockDispatch = {
				...baseData,
				...key,
				pending: true,
				data: { error: null, ...replyData },
			};
			mockDispatches.push(newMockDispatch);
			return newMockDispatch;
		}
		function deleteMockDispatch(mockDispatches, key) {
			const index = mockDispatches.findIndex((dispatch) => {
				if (!dispatch.consumed) {
					return false;
				}
				return matchKey(dispatch, key);
			});
			if (index !== -1) {
				mockDispatches.splice(index, 1);
			}
		}
		function buildKey(opts) {
			const { path, method, body, headers, query } = opts;
			return {
				path,
				method,
				body,
				headers,
				query,
			};
		}
		function generateKeyValues(data) {
			return Object.entries(data).reduce(
				(keyValuePairs, [key, value]) => [
					...keyValuePairs,
					Buffer.from(`${key}`),
					Array.isArray(value)
						? value.map((x) => Buffer.from(`${x}`))
						: Buffer.from(`${value}`),
				],
				[],
			);
		}
		function getStatusText(statusCode) {
			return STATUS_CODES[statusCode] || "unknown";
		}
		async function getResponse(body) {
			const buffers = [];
			for await (const data of body) {
				buffers.push(data);
			}
			return Buffer.concat(buffers).toString("utf8");
		}
		function mockDispatch(opts, handler) {
			const key = buildKey(opts);
			const mockDispatch2 = getMockDispatch(this[kDispatches], key);
			mockDispatch2.timesInvoked++;
			if (mockDispatch2.data.callback) {
				mockDispatch2.data = {
					...mockDispatch2.data,
					...mockDispatch2.data.callback(opts),
				};
			}
			const {
				data: { statusCode, data, headers, trailers, error },
				delay,
				persist,
			} = mockDispatch2;
			const { timesInvoked, times } = mockDispatch2;
			mockDispatch2.consumed = !persist && timesInvoked >= times;
			mockDispatch2.pending = timesInvoked < times;
			if (error !== null) {
				deleteMockDispatch(this[kDispatches], key);
				handler.onError(error);
				return true;
			}
			if (typeof delay === "number" && delay > 0) {
				setTimeout(() => {
					handleReply(this[kDispatches]);
				}, delay);
			} else {
				handleReply(this[kDispatches]);
			}
			function handleReply(mockDispatches, _data = data) {
				const optsHeaders = Array.isArray(opts.headers)
					? buildHeadersFromArray(opts.headers)
					: opts.headers;
				const body =
					typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
				if (isPromise(body)) {
					body.then((newData) => handleReply(mockDispatches, newData));
					return;
				}
				const responseData = getResponseData(body);
				const responseHeaders = generateKeyValues(headers);
				const responseTrailers = generateKeyValues(trailers);
				handler.abort = nop;
				handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));
				handler.onData(Buffer.from(responseData));
				handler.onComplete(responseTrailers);
				deleteMockDispatch(mockDispatches, key);
			}
			function resume() {}
			return true;
		}
		function buildMockDispatch() {
			const agent = this[kMockAgent];
			const origin = this[kOrigin];
			const originalDispatch = this[kOriginalDispatch];
			return function dispatch(opts, handler) {
				if (agent.isMockActive) {
					try {
						mockDispatch.call(this, opts, handler);
					} catch (error) {
						if (error instanceof MockNotMatchedError) {
							const netConnect = agent[kGetNetConnect]();
							if (netConnect === false) {
								throw new MockNotMatchedError(
									`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`,
								);
							}
							if (checkNetConnect(netConnect, origin)) {
								originalDispatch.call(this, opts, handler);
							} else {
								throw new MockNotMatchedError(
									`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`,
								);
							}
						} else {
							throw error;
						}
					}
				} else {
					originalDispatch.call(this, opts, handler);
				}
			};
		}
		function checkNetConnect(netConnect, origin) {
			const url = new URL(origin);
			if (netConnect === true) {
				return true;
			} else if (
				Array.isArray(netConnect) &&
				netConnect.some((matcher) => matchValue(matcher, url.host))
			) {
				return true;
			}
			return false;
		}
		function buildMockOptions(opts) {
			if (opts) {
				const { agent, ...mockOptions } = opts;
				return mockOptions;
			}
		}
		module2.exports = {
			getResponseData,
			getMockDispatch,
			addMockDispatch,
			deleteMockDispatch,
			buildKey,
			generateKeyValues,
			matchValue,
			getResponse,
			getStatusText,
			mockDispatch,
			buildMockDispatch,
			checkNetConnect,
			buildMockOptions,
			getHeaderByName,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/mock/mock-interceptor.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
		var {
			kDispatches,
			kDispatchKey,
			kDefaultHeaders,
			kDefaultTrailers,
			kContentLength,
			kMockDispatch,
		} = require_mock_symbols();
		var { InvalidArgumentError } = require_errors2();
		var { buildURL } = require_util2();
		var MockScope = class {
			constructor(mockDispatch) {
				this[kMockDispatch] = mockDispatch;
			}
			/**
			 * Delay a reply by a set amount in ms.
			 */
			delay(waitInMs) {
				if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
					throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
				}
				this[kMockDispatch].delay = waitInMs;
				return this;
			}
			/**
			 * For a defined reply, never mark as consumed.
			 */
			persist() {
				this[kMockDispatch].persist = true;
				return this;
			}
			/**
			 * Allow one to define a reply for a set amount of matching requests.
			 */
			times(repeatTimes) {
				if (
					typeof repeatTimes !== "number" ||
					!Number.isInteger(repeatTimes) ||
					repeatTimes <= 0
				) {
					throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
				}
				this[kMockDispatch].times = repeatTimes;
				return this;
			}
		};
		var MockInterceptor = class {
			constructor(opts, mockDispatches) {
				if (typeof opts !== "object") {
					throw new InvalidArgumentError("opts must be an object");
				}
				if (typeof opts.path === "undefined") {
					throw new InvalidArgumentError("opts.path must be defined");
				}
				if (typeof opts.method === "undefined") {
					opts.method = "GET";
				}
				if (typeof opts.path === "string") {
					if (opts.query) {
						opts.path = buildURL(opts.path, opts.query);
					} else {
						const parsedURL = new URL(opts.path, "data://");
						opts.path = parsedURL.pathname + parsedURL.search;
					}
				}
				if (typeof opts.method === "string") {
					opts.method = opts.method.toUpperCase();
				}
				this[kDispatchKey] = buildKey(opts);
				this[kDispatches] = mockDispatches;
				this[kDefaultHeaders] = {};
				this[kDefaultTrailers] = {};
				this[kContentLength] = false;
			}
			createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
				const responseData = getResponseData(data);
				const contentLength = this[kContentLength]
					? { "content-length": responseData.length }
					: {};
				const headers = {
					...this[kDefaultHeaders],
					...contentLength,
					...responseOptions.headers,
				};
				const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
				return { statusCode, data, headers, trailers };
			}
			validateReplyParameters(statusCode, data, responseOptions) {
				if (typeof statusCode === "undefined") {
					throw new InvalidArgumentError("statusCode must be defined");
				}
				if (typeof data === "undefined") {
					throw new InvalidArgumentError("data must be defined");
				}
				if (typeof responseOptions !== "object") {
					throw new InvalidArgumentError("responseOptions must be an object");
				}
			}
			/**
			 * Mock an undici request with a defined reply.
			 */
			reply(replyData) {
				if (typeof replyData === "function") {
					const wrappedDefaultsCallback = (opts) => {
						const resolvedData = replyData(opts);
						if (typeof resolvedData !== "object") {
							throw new InvalidArgumentError(
								"reply options callback must return an object",
							);
						}
						const {
							statusCode: statusCode2,
							data: data2 = "",
							responseOptions: responseOptions2 = {},
						} = resolvedData;
						this.validateReplyParameters(statusCode2, data2, responseOptions2);
						return {
							...this.createMockScopeDispatchData(
								statusCode2,
								data2,
								responseOptions2,
							),
						};
					};
					const newMockDispatch2 = addMockDispatch(
						this[kDispatches],
						this[kDispatchKey],
						wrappedDefaultsCallback,
					);
					return new MockScope(newMockDispatch2);
				}
				const [statusCode, data = "", responseOptions = {}] = [...arguments];
				this.validateReplyParameters(statusCode, data, responseOptions);
				const dispatchData = this.createMockScopeDispatchData(
					statusCode,
					data,
					responseOptions,
				);
				const newMockDispatch = addMockDispatch(
					this[kDispatches],
					this[kDispatchKey],
					dispatchData,
				);
				return new MockScope(newMockDispatch);
			}
			/**
			 * Mock an undici request with a defined error.
			 */
			replyWithError(error) {
				if (typeof error === "undefined") {
					throw new InvalidArgumentError("error must be defined");
				}
				const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], {
					error,
				});
				return new MockScope(newMockDispatch);
			}
			/**
			 * Set default reply headers on the interceptor for subsequent replies
			 */
			defaultReplyHeaders(headers) {
				if (typeof headers === "undefined") {
					throw new InvalidArgumentError("headers must be defined");
				}
				this[kDefaultHeaders] = headers;
				return this;
			}
			/**
			 * Set default reply trailers on the interceptor for subsequent replies
			 */
			defaultReplyTrailers(trailers) {
				if (typeof trailers === "undefined") {
					throw new InvalidArgumentError("trailers must be defined");
				}
				this[kDefaultTrailers] = trailers;
				return this;
			}
			/**
			 * Set reply content length header for replies on the interceptor
			 */
			replyContentLength() {
				this[kContentLength] = true;
				return this;
			}
		};
		module2.exports.MockInterceptor = MockInterceptor;
		module2.exports.MockScope = MockScope;
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/mock/mock-client.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { promisify } = require("util");
		var Client = require_client();
		var { buildMockDispatch } = require_mock_utils();
		var {
			kDispatches,
			kMockAgent,
			kClose,
			kOriginalClose,
			kOrigin,
			kOriginalDispatch,
			kConnected,
		} = require_mock_symbols();
		var { MockInterceptor } = require_mock_interceptor();
		var Symbols = require_symbols();
		var { InvalidArgumentError } = require_errors2();
		var MockClient = class extends Client {
			constructor(origin, opts) {
				super(origin, opts);
				if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
					throw new InvalidArgumentError("Argument opts.agent must implement Agent");
				}
				this[kMockAgent] = opts.agent;
				this[kOrigin] = origin;
				this[kDispatches] = [];
				this[kConnected] = 1;
				this[kOriginalDispatch] = this.dispatch;
				this[kOriginalClose] = this.close.bind(this);
				this.dispatch = buildMockDispatch.call(this);
				this.close = this[kClose];
			}
			get [Symbols.kConnected]() {
				return this[kConnected];
			}
			/**
			 * Sets up the base interceptor for mocking replies from undici.
			 */
			intercept(opts) {
				return new MockInterceptor(opts, this[kDispatches]);
			}
			async [kClose]() {
				await promisify(this[kOriginalClose])();
				this[kConnected] = 0;
				this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
			}
		};
		module2.exports = MockClient;
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/mock/mock-pool.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { promisify } = require("util");
		var Pool = require_pool();
		var { buildMockDispatch } = require_mock_utils();
		var {
			kDispatches,
			kMockAgent,
			kClose,
			kOriginalClose,
			kOrigin,
			kOriginalDispatch,
			kConnected,
		} = require_mock_symbols();
		var { MockInterceptor } = require_mock_interceptor();
		var Symbols = require_symbols();
		var { InvalidArgumentError } = require_errors2();
		var MockPool = class extends Pool {
			constructor(origin, opts) {
				super(origin, opts);
				if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
					throw new InvalidArgumentError("Argument opts.agent must implement Agent");
				}
				this[kMockAgent] = opts.agent;
				this[kOrigin] = origin;
				this[kDispatches] = [];
				this[kConnected] = 1;
				this[kOriginalDispatch] = this.dispatch;
				this[kOriginalClose] = this.close.bind(this);
				this.dispatch = buildMockDispatch.call(this);
				this.close = this[kClose];
			}
			get [Symbols.kConnected]() {
				return this[kConnected];
			}
			/**
			 * Sets up the base interceptor for mocking replies from undici.
			 */
			intercept(opts) {
				return new MockInterceptor(opts, this[kDispatches]);
			}
			async [kClose]() {
				await promisify(this[kOriginalClose])();
				this[kConnected] = 0;
				this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
			}
		};
		module2.exports = MockPool;
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/mock/pluralizer.js"(
		exports2,
		module2,
	) {
		"use strict";
		var singulars = {
			pronoun: "it",
			is: "is",
			was: "was",
			this: "this",
		};
		var plurals = {
			pronoun: "they",
			is: "are",
			was: "were",
			this: "these",
		};
		module2.exports = class Pluralizer {
			constructor(singular, plural) {
				this.singular = singular;
				this.plural = plural;
			}
			pluralize(count) {
				const one = count === 1;
				const keys = one ? singulars : plurals;
				const noun = one ? this.singular : this.plural;
				return { ...keys, count, noun };
			}
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/mock/pending-interceptors-formatter.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { Transform } = require("stream");
		var { Console } = require("console");
		module2.exports = class PendingInterceptorsFormatter {
			constructor({ disableColors } = {}) {
				this.transform = new Transform({
					transform(chunk, _enc, cb) {
						cb(null, chunk);
					},
				});
				this.logger = new Console({
					stdout: this.transform,
					inspectOptions: {
						colors: !disableColors && !process.env.CI,
					},
				});
			}
			format(pendingInterceptors) {
				const withPrettyHeaders = pendingInterceptors.map(
					({
						method,
						path,
						data: { statusCode },
						persist,
						times,
						timesInvoked,
						origin,
					}) => ({
						Method: method,
						Origin: origin,
						Path: path,
						"Status code": statusCode,
						Persistent: persist ? "\u2705" : "\u274C",
						Invocations: timesInvoked,
						Remaining: persist ? Infinity : times - timesInvoked,
					}),
				);
				this.logger.table(withPrettyHeaders);
				return this.transform.read().toString();
			}
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/mock/mock-agent.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { kClients } = require_symbols();
		var Agent = require_agent();
		var {
			kAgent,
			kMockAgentSet,
			kMockAgentGet,
			kDispatches,
			kIsMockActive,
			kNetConnect,
			kGetNetConnect,
			kOptions,
			kFactory,
		} = require_mock_symbols();
		var MockClient = require_mock_client();
		var MockPool = require_mock_pool();
		var { matchValue, buildMockOptions } = require_mock_utils();
		var { InvalidArgumentError, UndiciError } = require_errors2();
		var Dispatcher = require_dispatcher();
		var Pluralizer = require_pluralizer();
		var PendingInterceptorsFormatter = require_pending_interceptors_formatter();
		var FakeWeakRef = class {
			constructor(value) {
				this.value = value;
			}
			deref() {
				return this.value;
			}
		};
		var MockAgent = class extends Dispatcher {
			constructor(opts) {
				super(opts);
				this[kNetConnect] = true;
				this[kIsMockActive] = true;
				if (opts && opts.agent && typeof opts.agent.dispatch !== "function") {
					throw new InvalidArgumentError("Argument opts.agent must implement Agent");
				}
				const agent = opts && opts.agent ? opts.agent : new Agent(opts);
				this[kAgent] = agent;
				this[kClients] = agent[kClients];
				this[kOptions] = buildMockOptions(opts);
			}
			get(origin) {
				let dispatcher = this[kMockAgentGet](origin);
				if (!dispatcher) {
					dispatcher = this[kFactory](origin);
					this[kMockAgentSet](origin, dispatcher);
				}
				return dispatcher;
			}
			dispatch(opts, handler) {
				this.get(opts.origin);
				return this[kAgent].dispatch(opts, handler);
			}
			async close() {
				await this[kAgent].close();
				this[kClients].clear();
			}
			deactivate() {
				this[kIsMockActive] = false;
			}
			activate() {
				this[kIsMockActive] = true;
			}
			enableNetConnect(matcher) {
				if (
					typeof matcher === "string" ||
					typeof matcher === "function" ||
					matcher instanceof RegExp
				) {
					if (Array.isArray(this[kNetConnect])) {
						this[kNetConnect].push(matcher);
					} else {
						this[kNetConnect] = [matcher];
					}
				} else if (typeof matcher === "undefined") {
					this[kNetConnect] = true;
				} else {
					throw new InvalidArgumentError(
						"Unsupported matcher. Must be one of String|Function|RegExp.",
					);
				}
			}
			disableNetConnect() {
				this[kNetConnect] = false;
			}
			// This is required to bypass issues caused by using global symbols - see:
			// https://github.com/nodejs/undici/issues/1447
			get isMockActive() {
				return this[kIsMockActive];
			}
			[kMockAgentSet](origin, dispatcher) {
				this[kClients].set(origin, new FakeWeakRef(dispatcher));
			}
			[kFactory](origin) {
				const mockOptions = Object.assign({ agent: this }, this[kOptions]);
				return this[kOptions] && this[kOptions].connections === 1
					? new MockClient(origin, mockOptions)
					: new MockPool(origin, mockOptions);
			}
			[kMockAgentGet](origin) {
				const ref = this[kClients].get(origin);
				if (ref) {
					return ref.deref();
				}
				if (typeof origin !== "string") {
					const dispatcher = this[kFactory]("http://localhost:9999");
					this[kMockAgentSet](origin, dispatcher);
					return dispatcher;
				}
				for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
					const nonExplicitDispatcher = nonExplicitRef.deref();
					if (
						nonExplicitDispatcher &&
						typeof keyMatcher !== "string" &&
						matchValue(keyMatcher, origin)
					) {
						const dispatcher = this[kFactory](origin);
						this[kMockAgentSet](origin, dispatcher);
						dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
						return dispatcher;
					}
				}
			}
			[kGetNetConnect]() {
				return this[kNetConnect];
			}
			pendingInterceptors() {
				const mockAgentClients = this[kClients];
				return Array.from(mockAgentClients.entries())
					.flatMap(([origin, scope]) =>
						scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin })),
					)
					.filter(({ pending }) => pending);
			}
			assertNoPendingInterceptors({
				pendingInterceptorsFormatter = new PendingInterceptorsFormatter(),
			} = {}) {
				const pending = this.pendingInterceptors();
				if (pending.length === 0) {
					return;
				}
				const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(
					pending.length,
				);
				throw new UndiciError(
					`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim(),
				);
			}
		};
		module2.exports = MockAgent;
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/proxy-agent.js
var require_proxy_agent = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/proxy-agent.js"(exports2, module2) {
		"use strict";
		var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols();
		var { URL: URL2 } = require("url");
		var Agent = require_agent();
		var Pool = require_pool();
		var DispatcherBase = require_dispatcher_base();
		var { InvalidArgumentError, RequestAbortedError } = require_errors2();
		var buildConnector = require_connect();
		var kAgent = Symbol("proxy agent");
		var kClient = Symbol("proxy client");
		var kProxyHeaders = Symbol("proxy headers");
		var kRequestTls = Symbol("request tls settings");
		var kProxyTls = Symbol("proxy tls settings");
		var kConnectEndpoint = Symbol("connect endpoint function");
		function defaultProtocolPort(protocol) {
			return protocol === "https:" ? 443 : 80;
		}
		function buildProxyOptions(opts) {
			if (typeof opts === "string") {
				opts = { uri: opts };
			}
			if (!opts || !opts.uri) {
				throw new InvalidArgumentError("Proxy opts.uri is mandatory");
			}
			return {
				uri: opts.uri,
				protocol: opts.protocol || "https",
			};
		}
		function defaultFactory(origin, opts) {
			return new Pool(origin, opts);
		}
		var ProxyAgent = class extends DispatcherBase {
			constructor(opts) {
				super(opts);
				this[kProxy] = buildProxyOptions(opts);
				this[kAgent] = new Agent(opts);
				this[kInterceptors] =
					opts.interceptors &&
					opts.interceptors.ProxyAgent &&
					Array.isArray(opts.interceptors.ProxyAgent)
						? opts.interceptors.ProxyAgent
						: [];
				if (typeof opts === "string") {
					opts = { uri: opts };
				}
				if (!opts || !opts.uri) {
					throw new InvalidArgumentError("Proxy opts.uri is mandatory");
				}
				const { clientFactory = defaultFactory } = opts;
				if (typeof clientFactory !== "function") {
					throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
				}
				this[kRequestTls] = opts.requestTls;
				this[kProxyTls] = opts.proxyTls;
				this[kProxyHeaders] = opts.headers || {};
				const resolvedUrl = new URL2(opts.uri);
				const { origin, port, host, username, password } = resolvedUrl;
				if (opts.auth && opts.token) {
					throw new InvalidArgumentError(
						"opts.auth cannot be used in combination with opts.token",
					);
				} else if (opts.auth) {
					this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
				} else if (opts.token) {
					this[kProxyHeaders]["proxy-authorization"] = opts.token;
				} else if (username && password) {
					this[kProxyHeaders]["proxy-authorization"] =
						`Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
				}
				const connect = buildConnector({ ...opts.proxyTls });
				this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
				this[kClient] = clientFactory(resolvedUrl, { connect });
				this[kAgent] = new Agent({
					...opts,
					connect: async (opts2, callback) => {
						let requestedHost = opts2.host;
						if (!opts2.port) {
							requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;
						}
						try {
							const { socket, statusCode } = await this[kClient].connect({
								origin,
								port,
								path: requestedHost,
								signal: opts2.signal,
								headers: {
									...this[kProxyHeaders],
									host,
								},
							});
							if (statusCode !== 200) {
								socket.on("error", () => {}).destroy();
								callback(
									new RequestAbortedError(
										`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`,
									),
								);
							}
							if (opts2.protocol !== "https:") {
								callback(null, socket);
								return;
							}
							let servername;
							if (this[kRequestTls]) {
								servername = this[kRequestTls].servername;
							} else {
								servername = opts2.servername;
							}
							this[kConnectEndpoint](
								{ ...opts2, servername, httpSocket: socket },
								callback,
							);
						} catch (err) {
							callback(err);
						}
					},
				});
			}
			dispatch(opts, handler) {
				const { host } = new URL2(opts.origin);
				const headers = buildHeaders(opts.headers);
				throwIfProxyAuthIsSent(headers);
				return this[kAgent].dispatch(
					{
						...opts,
						headers: {
							...headers,
							host,
						},
					},
					handler,
				);
			}
			async [kClose]() {
				await this[kAgent].close();
				await this[kClient].close();
			}
			async [kDestroy]() {
				await this[kAgent].destroy();
				await this[kClient].destroy();
			}
		};
		function buildHeaders(headers) {
			if (Array.isArray(headers)) {
				const headersPair = {};
				for (let i = 0; i < headers.length; i += 2) {
					headersPair[headers[i]] = headers[i + 1];
				}
				return headersPair;
			}
			return headers;
		}
		function throwIfProxyAuthIsSent(headers) {
			const existProxyAuth =
				headers &&
				Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
			if (existProxyAuth) {
				throw new InvalidArgumentError(
					"Proxy-Authorization should be sent in ProxyAgent constructor",
				);
			}
		}
		module2.exports = ProxyAgent;
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/handler/RetryHandler.js
var require_RetryHandler = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/handler/RetryHandler.js"(
		exports2,
		module2,
	) {
		"use strict";
		var assert = require("assert");
		var { kRetryHandlerDefaultRetry } = require_symbols();
		var { RequestRetryError } = require_errors2();
		var { isDisturbed, parseHeaders, parseRangeHeader } = require_util2();
		function calculateRetryAfterHeader(retryAfter) {
			const current = Date.now();
			const diff = new Date(retryAfter).getTime() - current;
			return diff;
		}
		var RetryHandler = class _RetryHandler {
			constructor(opts, handlers) {
				const { retryOptions, ...dispatchOpts } = opts;
				const {
					// Retry scoped
					retry: retryFn,
					maxRetries,
					maxTimeout,
					minTimeout,
					timeoutFactor,
					// Response scoped
					methods,
					errorCodes,
					retryAfter,
					statusCodes,
				} = retryOptions ?? {};
				this.dispatch = handlers.dispatch;
				this.handler = handlers.handler;
				this.opts = dispatchOpts;
				this.abort = null;
				this.aborted = false;
				this.retryOpts = {
					retry: retryFn ?? _RetryHandler[kRetryHandlerDefaultRetry],
					retryAfter: retryAfter ?? true,
					maxTimeout: maxTimeout ?? 30 * 1e3,
					// 30s,
					timeout: minTimeout ?? 500,
					// .5s
					timeoutFactor: timeoutFactor ?? 2,
					maxRetries: maxRetries ?? 5,
					// What errors we should retry
					methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
					// Indicates which errors to retry
					statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
					// List of errors to retry
					errorCodes: errorCodes ?? [
						"ECONNRESET",
						"ECONNREFUSED",
						"ENOTFOUND",
						"ENETDOWN",
						"ENETUNREACH",
						"EHOSTDOWN",
						"EHOSTUNREACH",
						"EPIPE",
					],
				};
				this.retryCount = 0;
				this.start = 0;
				this.end = null;
				this.etag = null;
				this.resume = null;
				this.handler.onConnect((reason) => {
					this.aborted = true;
					if (this.abort) {
						this.abort(reason);
					} else {
						this.reason = reason;
					}
				});
			}
			onRequestSent() {
				if (this.handler.onRequestSent) {
					this.handler.onRequestSent();
				}
			}
			onUpgrade(statusCode, headers, socket) {
				if (this.handler.onUpgrade) {
					this.handler.onUpgrade(statusCode, headers, socket);
				}
			}
			onConnect(abort) {
				if (this.aborted) {
					abort(this.reason);
				} else {
					this.abort = abort;
				}
			}
			onBodySent(chunk) {
				if (this.handler.onBodySent) return this.handler.onBodySent(chunk);
			}
			static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
				const { statusCode, code, headers } = err;
				const { method, retryOptions } = opts;
				const {
					maxRetries,
					timeout,
					maxTimeout,
					timeoutFactor,
					statusCodes,
					errorCodes,
					methods,
				} = retryOptions;
				let { counter, currentTimeout } = state;
				currentTimeout =
					currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout;
				if (
					code &&
					code !== "UND_ERR_REQ_RETRY" &&
					code !== "UND_ERR_SOCKET" &&
					!errorCodes.includes(code)
				) {
					cb(err);
					return;
				}
				if (Array.isArray(methods) && !methods.includes(method)) {
					cb(err);
					return;
				}
				if (
					statusCode != null &&
					Array.isArray(statusCodes) &&
					!statusCodes.includes(statusCode)
				) {
					cb(err);
					return;
				}
				if (counter > maxRetries) {
					cb(err);
					return;
				}
				let retryAfterHeader = headers != null && headers["retry-after"];
				if (retryAfterHeader) {
					retryAfterHeader = Number(retryAfterHeader);
					retryAfterHeader = isNaN(retryAfterHeader)
						? calculateRetryAfterHeader(retryAfterHeader)
						: retryAfterHeader * 1e3;
				}
				const retryTimeout =
					retryAfterHeader > 0
						? Math.min(retryAfterHeader, maxTimeout)
						: Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);
				state.currentTimeout = retryTimeout;
				setTimeout(() => cb(null), retryTimeout);
			}
			onHeaders(statusCode, rawHeaders, resume, statusMessage) {
				const headers = parseHeaders(rawHeaders);
				this.retryCount += 1;
				if (statusCode >= 300) {
					this.abort(
						new RequestRetryError("Request failed", statusCode, {
							headers,
							count: this.retryCount,
						}),
					);
					return false;
				}
				if (this.resume != null) {
					this.resume = null;
					if (statusCode !== 206) {
						return true;
					}
					const contentRange = parseRangeHeader(headers["content-range"]);
					if (!contentRange) {
						this.abort(
							new RequestRetryError("Content-Range mismatch", statusCode, {
								headers,
								count: this.retryCount,
							}),
						);
						return false;
					}
					if (this.etag != null && this.etag !== headers.etag) {
						this.abort(
							new RequestRetryError("ETag mismatch", statusCode, {
								headers,
								count: this.retryCount,
							}),
						);
						return false;
					}
					const { start, size, end = size } = contentRange;
					assert(this.start === start, "content-range mismatch");
					assert(this.end == null || this.end === end, "content-range mismatch");
					this.resume = resume;
					return true;
				}
				if (this.end == null) {
					if (statusCode === 206) {
						const range = parseRangeHeader(headers["content-range"]);
						if (range == null) {
							return this.handler.onHeaders(
								statusCode,
								rawHeaders,
								resume,
								statusMessage,
							);
						}
						const { start, size, end = size } = range;
						assert(
							start != null && Number.isFinite(start) && this.start !== start,
							"content-range mismatch",
						);
						assert(Number.isFinite(start));
						assert(
							end != null && Number.isFinite(end) && this.end !== end,
							"invalid content-length",
						);
						this.start = start;
						this.end = end;
					}
					if (this.end == null) {
						const contentLength = headers["content-length"];
						this.end = contentLength != null ? Number(contentLength) : null;
					}
					assert(Number.isFinite(this.start));
					assert(this.end == null || Number.isFinite(this.end), "invalid content-length");
					this.resume = resume;
					this.etag = headers.etag != null ? headers.etag : null;
					return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
				}
				const err = new RequestRetryError("Request failed", statusCode, {
					headers,
					count: this.retryCount,
				});
				this.abort(err);
				return false;
			}
			onData(chunk) {
				this.start += chunk.length;
				return this.handler.onData(chunk);
			}
			onComplete(rawTrailers) {
				this.retryCount = 0;
				return this.handler.onComplete(rawTrailers);
			}
			onError(err) {
				if (this.aborted || isDisturbed(this.opts.body)) {
					return this.handler.onError(err);
				}
				this.retryOpts.retry(
					err,
					{
						state: { counter: this.retryCount++, currentTimeout: this.retryAfter },
						opts: { retryOptions: this.retryOpts, ...this.opts },
					},
					onRetry.bind(this),
				);
				function onRetry(err2) {
					if (err2 != null || this.aborted || isDisturbed(this.opts.body)) {
						return this.handler.onError(err2);
					}
					if (this.start !== 0) {
						this.opts = {
							...this.opts,
							headers: {
								...this.opts.headers,
								range: `bytes=${this.start}-${this.end ?? ""}`,
							},
						};
					}
					try {
						this.dispatch(this.opts, this);
					} catch (err3) {
						this.handler.onError(err3);
					}
				}
			}
		};
		module2.exports = RetryHandler;
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/global.js
var require_global2 = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/global.js"(exports2, module2) {
		"use strict";
		var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
		var { InvalidArgumentError } = require_errors2();
		var Agent = require_agent();
		if (getGlobalDispatcher() === void 0) {
			setGlobalDispatcher(new Agent());
		}
		function setGlobalDispatcher(agent) {
			if (!agent || typeof agent.dispatch !== "function") {
				throw new InvalidArgumentError("Argument agent must implement Agent");
			}
			Object.defineProperty(globalThis, globalDispatcher, {
				value: agent,
				writable: true,
				enumerable: false,
				configurable: false,
			});
		}
		function getGlobalDispatcher() {
			return globalThis[globalDispatcher];
		}
		module2.exports = {
			setGlobalDispatcher,
			getGlobalDispatcher,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/handler/DecoratorHandler.js
var require_DecoratorHandler = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/handler/DecoratorHandler.js"(
		exports2,
		module2,
	) {
		"use strict";
		module2.exports = class DecoratorHandler {
			constructor(handler) {
				this.handler = handler;
			}
			onConnect(...args) {
				return this.handler.onConnect(...args);
			}
			onError(...args) {
				return this.handler.onError(...args);
			}
			onUpgrade(...args) {
				return this.handler.onUpgrade(...args);
			}
			onHeaders(...args) {
				return this.handler.onHeaders(...args);
			}
			onData(...args) {
				return this.handler.onData(...args);
			}
			onComplete(...args) {
				return this.handler.onComplete(...args);
			}
			onBodySent(...args) {
				return this.handler.onBodySent(...args);
			}
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/headers.js
var require_headers = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/headers.js"(exports2, module2) {
		"use strict";
		var { kHeadersList, kConstruct } = require_symbols();
		var { kGuard } = require_symbols2();
		var { kEnumerableProperty } = require_util2();
		var { makeIterator, isValidHeaderName, isValidHeaderValue } = require_util3();
		var { webidl } = require_webidl();
		var assert = require("assert");
		var kHeadersMap = Symbol("headers map");
		var kHeadersSortedMap = Symbol("headers map sorted");
		function isHTTPWhiteSpaceCharCode(code) {
			return code === 10 || code === 13 || code === 9 || code === 32;
		}
		function headerValueNormalize(potentialValue) {
			let i = 0;
			let j = potentialValue.length;
			while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j;
			while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i;
			return i === 0 && j === potentialValue.length
				? potentialValue
				: potentialValue.substring(i, j);
		}
		function fill(headers, object) {
			if (Array.isArray(object)) {
				for (let i = 0; i < object.length; ++i) {
					const header = object[i];
					if (header.length !== 2) {
						throw webidl.errors.exception({
							header: "Headers constructor",
							message: `expected name/value pair to be length 2, found ${header.length}.`,
						});
					}
					appendHeader(headers, header[0], header[1]);
				}
			} else if (typeof object === "object" && object !== null) {
				const keys = Object.keys(object);
				for (let i = 0; i < keys.length; ++i) {
					appendHeader(headers, keys[i], object[keys[i]]);
				}
			} else {
				throw webidl.errors.conversionFailed({
					prefix: "Headers constructor",
					argument: "Argument 1",
					types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"],
				});
			}
		}
		function appendHeader(headers, name, value) {
			value = headerValueNormalize(value);
			if (!isValidHeaderName(name)) {
				throw webidl.errors.invalidArgument({
					prefix: "Headers.append",
					value: name,
					type: "header name",
				});
			} else if (!isValidHeaderValue(value)) {
				throw webidl.errors.invalidArgument({
					prefix: "Headers.append",
					value,
					type: "header value",
				});
			}
			if (headers[kGuard] === "immutable") {
				throw new TypeError("immutable");
			} else if (headers[kGuard] === "request-no-cors") {
			}
			return headers[kHeadersList].append(name, value);
		}
		var HeadersList = class _HeadersList {
			/** @type {[string, string][]|null} */
			cookies = null;
			constructor(init) {
				if (init instanceof _HeadersList) {
					this[kHeadersMap] = new Map(init[kHeadersMap]);
					this[kHeadersSortedMap] = init[kHeadersSortedMap];
					this.cookies = init.cookies === null ? null : [...init.cookies];
				} else {
					this[kHeadersMap] = new Map(init);
					this[kHeadersSortedMap] = null;
				}
			}
			// https://fetch.spec.whatwg.org/#header-list-contains
			contains(name) {
				name = name.toLowerCase();
				return this[kHeadersMap].has(name);
			}
			clear() {
				this[kHeadersMap].clear();
				this[kHeadersSortedMap] = null;
				this.cookies = null;
			}
			// https://fetch.spec.whatwg.org/#concept-header-list-append
			append(name, value) {
				this[kHeadersSortedMap] = null;
				const lowercaseName = name.toLowerCase();
				const exists = this[kHeadersMap].get(lowercaseName);
				if (exists) {
					const delimiter = lowercaseName === "cookie" ? "; " : ", ";
					this[kHeadersMap].set(lowercaseName, {
						name: exists.name,
						value: `${exists.value}${delimiter}${value}`,
					});
				} else {
					this[kHeadersMap].set(lowercaseName, { name, value });
				}
				if (lowercaseName === "set-cookie") {
					this.cookies ??= [];
					this.cookies.push(value);
				}
			}
			// https://fetch.spec.whatwg.org/#concept-header-list-set
			set(name, value) {
				this[kHeadersSortedMap] = null;
				const lowercaseName = name.toLowerCase();
				if (lowercaseName === "set-cookie") {
					this.cookies = [value];
				}
				this[kHeadersMap].set(lowercaseName, { name, value });
			}
			// https://fetch.spec.whatwg.org/#concept-header-list-delete
			delete(name) {
				this[kHeadersSortedMap] = null;
				name = name.toLowerCase();
				if (name === "set-cookie") {
					this.cookies = null;
				}
				this[kHeadersMap].delete(name);
			}
			// https://fetch.spec.whatwg.org/#concept-header-list-get
			get(name) {
				const value = this[kHeadersMap].get(name.toLowerCase());
				return value === void 0 ? null : value.value;
			}
			*[Symbol.iterator]() {
				for (const [name, { value }] of this[kHeadersMap]) {
					yield [name, value];
				}
			}
			get entries() {
				const headers = {};
				if (this[kHeadersMap].size) {
					for (const { name, value } of this[kHeadersMap].values()) {
						headers[name] = value;
					}
				}
				return headers;
			}
		};
		var Headers2 = class _Headers {
			constructor(init = void 0) {
				if (init === kConstruct) {
					return;
				}
				this[kHeadersList] = new HeadersList();
				this[kGuard] = "none";
				if (init !== void 0) {
					init = webidl.converters.HeadersInit(init);
					fill(this, init);
				}
			}
			// https://fetch.spec.whatwg.org/#dom-headers-append
			append(name, value) {
				webidl.brandCheck(this, _Headers);
				webidl.argumentLengthCheck(arguments, 2, { header: "Headers.append" });
				name = webidl.converters.ByteString(name);
				value = webidl.converters.ByteString(value);
				return appendHeader(this, name, value);
			}
			// https://fetch.spec.whatwg.org/#dom-headers-delete
			delete(name) {
				webidl.brandCheck(this, _Headers);
				webidl.argumentLengthCheck(arguments, 1, { header: "Headers.delete" });
				name = webidl.converters.ByteString(name);
				if (!isValidHeaderName(name)) {
					throw webidl.errors.invalidArgument({
						prefix: "Headers.delete",
						value: name,
						type: "header name",
					});
				}
				if (this[kGuard] === "immutable") {
					throw new TypeError("immutable");
				} else if (this[kGuard] === "request-no-cors") {
				}
				if (!this[kHeadersList].contains(name)) {
					return;
				}
				this[kHeadersList].delete(name);
			}
			// https://fetch.spec.whatwg.org/#dom-headers-get
			get(name) {
				webidl.brandCheck(this, _Headers);
				webidl.argumentLengthCheck(arguments, 1, { header: "Headers.get" });
				name = webidl.converters.ByteString(name);
				if (!isValidHeaderName(name)) {
					throw webidl.errors.invalidArgument({
						prefix: "Headers.get",
						value: name,
						type: "header name",
					});
				}
				return this[kHeadersList].get(name);
			}
			// https://fetch.spec.whatwg.org/#dom-headers-has
			has(name) {
				webidl.brandCheck(this, _Headers);
				webidl.argumentLengthCheck(arguments, 1, { header: "Headers.has" });
				name = webidl.converters.ByteString(name);
				if (!isValidHeaderName(name)) {
					throw webidl.errors.invalidArgument({
						prefix: "Headers.has",
						value: name,
						type: "header name",
					});
				}
				return this[kHeadersList].contains(name);
			}
			// https://fetch.spec.whatwg.org/#dom-headers-set
			set(name, value) {
				webidl.brandCheck(this, _Headers);
				webidl.argumentLengthCheck(arguments, 2, { header: "Headers.set" });
				name = webidl.converters.ByteString(name);
				value = webidl.converters.ByteString(value);
				value = headerValueNormalize(value);
				if (!isValidHeaderName(name)) {
					throw webidl.errors.invalidArgument({
						prefix: "Headers.set",
						value: name,
						type: "header name",
					});
				} else if (!isValidHeaderValue(value)) {
					throw webidl.errors.invalidArgument({
						prefix: "Headers.set",
						value,
						type: "header value",
					});
				}
				if (this[kGuard] === "immutable") {
					throw new TypeError("immutable");
				} else if (this[kGuard] === "request-no-cors") {
				}
				this[kHeadersList].set(name, value);
			}
			// https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
			getSetCookie() {
				webidl.brandCheck(this, _Headers);
				const list = this[kHeadersList].cookies;
				if (list) {
					return [...list];
				}
				return [];
			}
			// https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
			get [kHeadersSortedMap]() {
				if (this[kHeadersList][kHeadersSortedMap]) {
					return this[kHeadersList][kHeadersSortedMap];
				}
				const headers = [];
				const names = [...this[kHeadersList]].sort((a, b) => (a[0] < b[0] ? -1 : 1));
				const cookies = this[kHeadersList].cookies;
				for (let i = 0; i < names.length; ++i) {
					const [name, value] = names[i];
					if (name === "set-cookie") {
						for (let j = 0; j < cookies.length; ++j) {
							headers.push([name, cookies[j]]);
						}
					} else {
						assert(value !== null);
						headers.push([name, value]);
					}
				}
				this[kHeadersList][kHeadersSortedMap] = headers;
				return headers;
			}
			keys() {
				webidl.brandCheck(this, _Headers);
				if (this[kGuard] === "immutable") {
					const value = this[kHeadersSortedMap];
					return makeIterator(() => value, "Headers", "key");
				}
				return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "key");
			}
			values() {
				webidl.brandCheck(this, _Headers);
				if (this[kGuard] === "immutable") {
					const value = this[kHeadersSortedMap];
					return makeIterator(() => value, "Headers", "value");
				}
				return makeIterator(
					() => [...this[kHeadersSortedMap].values()],
					"Headers",
					"value",
				);
			}
			entries() {
				webidl.brandCheck(this, _Headers);
				if (this[kGuard] === "immutable") {
					const value = this[kHeadersSortedMap];
					return makeIterator(() => value, "Headers", "key+value");
				}
				return makeIterator(
					() => [...this[kHeadersSortedMap].values()],
					"Headers",
					"key+value",
				);
			}
			/**
			 * @param {(value: string, key: string, self: Headers) => void} callbackFn
			 * @param {unknown} thisArg
			 */
			forEach(callbackFn, thisArg = globalThis) {
				webidl.brandCheck(this, _Headers);
				webidl.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" });
				if (typeof callbackFn !== "function") {
					throw new TypeError(
						"Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.",
					);
				}
				for (const [key, value] of this) {
					callbackFn.apply(thisArg, [value, key, this]);
				}
			}
			[Symbol.for("nodejs.util.inspect.custom")]() {
				webidl.brandCheck(this, _Headers);
				return this[kHeadersList];
			}
		};
		Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
		Object.defineProperties(Headers2.prototype, {
			append: kEnumerableProperty,
			delete: kEnumerableProperty,
			get: kEnumerableProperty,
			has: kEnumerableProperty,
			set: kEnumerableProperty,
			getSetCookie: kEnumerableProperty,
			keys: kEnumerableProperty,
			values: kEnumerableProperty,
			entries: kEnumerableProperty,
			forEach: kEnumerableProperty,
			[Symbol.iterator]: { enumerable: false },
			[Symbol.toStringTag]: {
				value: "Headers",
				configurable: true,
			},
		});
		webidl.converters.HeadersInit = function (V) {
			if (webidl.util.Type(V) === "Object") {
				if (V[Symbol.iterator]) {
					return webidl.converters["sequence<sequence<ByteString>>"](V);
				}
				return webidl.converters["record<ByteString, ByteString>"](V);
			}
			throw webidl.errors.conversionFailed({
				prefix: "Headers constructor",
				argument: "Argument 1",
				types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"],
			});
		};
		module2.exports = {
			fill,
			Headers: Headers2,
			HeadersList,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/response.js
var require_response = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/response.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { Headers: Headers2, HeadersList, fill } = require_headers();
		var { extractBody, cloneBody, mixinBody } = require_body();
		var util = require_util2();
		var { kEnumerableProperty } = util;
		var {
			isValidReasonPhrase,
			isCancelled,
			isAborted,
			isBlobLike,
			serializeJavascriptValueToJSONString,
			isErrorLike,
			isomorphicEncode,
		} = require_util3();
		var {
			redirectStatusSet,
			nullBodyStatus,
			DOMException: DOMException2,
		} = require_constants3();
		var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
		var { webidl } = require_webidl();
		var { FormData: FormData2 } = require_formdata();
		var { getGlobalOrigin } = require_global();
		var { URLSerializer } = require_dataURL();
		var { kHeadersList, kConstruct } = require_symbols();
		var assert = require("assert");
		var { types } = require("util");
		var ReadableStream = globalThis.ReadableStream || require("stream/web").ReadableStream;
		var textEncoder = new TextEncoder("utf-8");
		var Response = class _Response {
			// Creates network error Response.
			static error() {
				const relevantRealm = { settingsObject: {} };
				const responseObject = new _Response();
				responseObject[kState] = makeNetworkError();
				responseObject[kRealm] = relevantRealm;
				responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
				responseObject[kHeaders][kGuard] = "immutable";
				responseObject[kHeaders][kRealm] = relevantRealm;
				return responseObject;
			}
			// https://fetch.spec.whatwg.org/#dom-response-json
			static json(data, init = {}) {
				webidl.argumentLengthCheck(arguments, 1, { header: "Response.json" });
				if (init !== null) {
					init = webidl.converters.ResponseInit(init);
				}
				const bytes = textEncoder.encode(serializeJavascriptValueToJSONString(data));
				const body = extractBody(bytes);
				const relevantRealm = { settingsObject: {} };
				const responseObject = new _Response();
				responseObject[kRealm] = relevantRealm;
				responseObject[kHeaders][kGuard] = "response";
				responseObject[kHeaders][kRealm] = relevantRealm;
				initializeResponse(responseObject, init, {
					body: body[0],
					type: "application/json",
				});
				return responseObject;
			}
			// Creates a redirect Response that redirects to url with status status.
			static redirect(url, status = 302) {
				const relevantRealm = { settingsObject: {} };
				webidl.argumentLengthCheck(arguments, 1, { header: "Response.redirect" });
				url = webidl.converters.USVString(url);
				status = webidl.converters["unsigned short"](status);
				let parsedURL;
				try {
					parsedURL = new URL(url, getGlobalOrigin());
				} catch (err) {
					throw Object.assign(new TypeError("Failed to parse URL from " + url), {
						cause: err,
					});
				}
				if (!redirectStatusSet.has(status)) {
					throw new RangeError("Invalid status code " + status);
				}
				const responseObject = new _Response();
				responseObject[kRealm] = relevantRealm;
				responseObject[kHeaders][kGuard] = "immutable";
				responseObject[kHeaders][kRealm] = relevantRealm;
				responseObject[kState].status = status;
				const value = isomorphicEncode(URLSerializer(parsedURL));
				responseObject[kState].headersList.append("location", value);
				return responseObject;
			}
			// https://fetch.spec.whatwg.org/#dom-response
			constructor(body = null, init = {}) {
				if (body !== null) {
					body = webidl.converters.BodyInit(body);
				}
				init = webidl.converters.ResponseInit(init);
				this[kRealm] = { settingsObject: {} };
				this[kState] = makeResponse({});
				this[kHeaders] = new Headers2(kConstruct);
				this[kHeaders][kGuard] = "response";
				this[kHeaders][kHeadersList] = this[kState].headersList;
				this[kHeaders][kRealm] = this[kRealm];
				let bodyWithType = null;
				if (body != null) {
					const [extractedBody, type] = extractBody(body);
					bodyWithType = { body: extractedBody, type };
				}
				initializeResponse(this, init, bodyWithType);
			}
			// Returns responses type, e.g., "cors".
			get type() {
				webidl.brandCheck(this, _Response);
				return this[kState].type;
			}
			// Returns responses URL, if it has one; otherwise the empty string.
			get url() {
				webidl.brandCheck(this, _Response);
				const urlList = this[kState].urlList;
				const url = urlList[urlList.length - 1] ?? null;
				if (url === null) {
					return "";
				}
				return URLSerializer(url, true);
			}
			// Returns whether response was obtained through a redirect.
			get redirected() {
				webidl.brandCheck(this, _Response);
				return this[kState].urlList.length > 1;
			}
			// Returns responses status.
			get status() {
				webidl.brandCheck(this, _Response);
				return this[kState].status;
			}
			// Returns whether responses status is an ok status.
			get ok() {
				webidl.brandCheck(this, _Response);
				return this[kState].status >= 200 && this[kState].status <= 299;
			}
			// Returns responses status message.
			get statusText() {
				webidl.brandCheck(this, _Response);
				return this[kState].statusText;
			}
			// Returns responses headers as Headers.
			get headers() {
				webidl.brandCheck(this, _Response);
				return this[kHeaders];
			}
			get body() {
				webidl.brandCheck(this, _Response);
				return this[kState].body ? this[kState].body.stream : null;
			}
			get bodyUsed() {
				webidl.brandCheck(this, _Response);
				return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
			}
			// Returns a clone of response.
			clone() {
				webidl.brandCheck(this, _Response);
				if (this.bodyUsed || (this.body && this.body.locked)) {
					throw webidl.errors.exception({
						header: "Response.clone",
						message: "Body has already been consumed.",
					});
				}
				const clonedResponse = cloneResponse(this[kState]);
				const clonedResponseObject = new _Response();
				clonedResponseObject[kState] = clonedResponse;
				clonedResponseObject[kRealm] = this[kRealm];
				clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
				clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
				clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];
				return clonedResponseObject;
			}
		};
		mixinBody(Response);
		Object.defineProperties(Response.prototype, {
			type: kEnumerableProperty,
			url: kEnumerableProperty,
			status: kEnumerableProperty,
			ok: kEnumerableProperty,
			redirected: kEnumerableProperty,
			statusText: kEnumerableProperty,
			headers: kEnumerableProperty,
			clone: kEnumerableProperty,
			body: kEnumerableProperty,
			bodyUsed: kEnumerableProperty,
			[Symbol.toStringTag]: {
				value: "Response",
				configurable: true,
			},
		});
		Object.defineProperties(Response, {
			json: kEnumerableProperty,
			redirect: kEnumerableProperty,
			error: kEnumerableProperty,
		});
		function cloneResponse(response) {
			if (response.internalResponse) {
				return filterResponse(cloneResponse(response.internalResponse), response.type);
			}
			const newResponse = makeResponse({ ...response, body: null });
			if (response.body != null) {
				newResponse.body = cloneBody(response.body);
			}
			return newResponse;
		}
		function makeResponse(init) {
			return {
				aborted: false,
				rangeRequested: false,
				timingAllowPassed: false,
				requestIncludesCredentials: false,
				type: "default",
				status: 200,
				timingInfo: null,
				cacheState: "",
				statusText: "",
				...init,
				headersList: init.headersList
					? new HeadersList(init.headersList)
					: new HeadersList(),
				urlList: init.urlList ? [...init.urlList] : [],
			};
		}
		function makeNetworkError(reason) {
			const isError = isErrorLike(reason);
			return makeResponse({
				type: "error",
				status: 0,
				error: isError ? reason : new Error(reason ? String(reason) : reason),
				aborted: reason && reason.name === "AbortError",
			});
		}
		function makeFilteredResponse(response, state) {
			state = {
				internalResponse: response,
				...state,
			};
			return new Proxy(response, {
				get(target, p) {
					return p in state ? state[p] : target[p];
				},
				set(target, p, value) {
					assert(!(p in state));
					target[p] = value;
					return true;
				},
			});
		}
		function filterResponse(response, type) {
			if (type === "basic") {
				return makeFilteredResponse(response, {
					type: "basic",
					headersList: response.headersList,
				});
			} else if (type === "cors") {
				return makeFilteredResponse(response, {
					type: "cors",
					headersList: response.headersList,
				});
			} else if (type === "opaque") {
				return makeFilteredResponse(response, {
					type: "opaque",
					urlList: Object.freeze([]),
					status: 0,
					statusText: "",
					body: null,
				});
			} else if (type === "opaqueredirect") {
				return makeFilteredResponse(response, {
					type: "opaqueredirect",
					status: 0,
					statusText: "",
					headersList: [],
					body: null,
				});
			} else {
				assert(false);
			}
		}
		function makeAppropriateNetworkError(fetchParams, err = null) {
			assert(isCancelled(fetchParams));
			return isAborted(fetchParams)
				? makeNetworkError(
						Object.assign(
							new DOMException2("The operation was aborted.", "AbortError"),
							{ cause: err },
						),
					)
				: makeNetworkError(
						Object.assign(new DOMException2("Request was cancelled."), { cause: err }),
					);
		}
		function initializeResponse(response, init, body) {
			if (init.status !== null && (init.status < 200 || init.status > 599)) {
				throw new RangeError(
					'init["status"] must be in the range of 200 to 599, inclusive.',
				);
			}
			if ("statusText" in init && init.statusText != null) {
				if (!isValidReasonPhrase(String(init.statusText))) {
					throw new TypeError("Invalid statusText");
				}
			}
			if ("status" in init && init.status != null) {
				response[kState].status = init.status;
			}
			if ("statusText" in init && init.statusText != null) {
				response[kState].statusText = init.statusText;
			}
			if ("headers" in init && init.headers != null) {
				fill(response[kHeaders], init.headers);
			}
			if (body) {
				if (nullBodyStatus.includes(response.status)) {
					throw webidl.errors.exception({
						header: "Response constructor",
						message: "Invalid response status code " + response.status,
					});
				}
				response[kState].body = body.body;
				if (body.type != null && !response[kState].headersList.contains("Content-Type")) {
					response[kState].headersList.append("content-type", body.type);
				}
			}
		}
		webidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream);
		webidl.converters.FormData = webidl.interfaceConverter(FormData2);
		webidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams);
		webidl.converters.XMLHttpRequestBodyInit = function (V) {
			if (typeof V === "string") {
				return webidl.converters.USVString(V);
			}
			if (isBlobLike(V)) {
				return webidl.converters.Blob(V, { strict: false });
			}
			if (types.isArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {
				return webidl.converters.BufferSource(V);
			}
			if (util.isFormDataLike(V)) {
				return webidl.converters.FormData(V, { strict: false });
			}
			if (V instanceof URLSearchParams) {
				return webidl.converters.URLSearchParams(V);
			}
			return webidl.converters.DOMString(V);
		};
		webidl.converters.BodyInit = function (V) {
			if (V instanceof ReadableStream) {
				return webidl.converters.ReadableStream(V);
			}
			if (V?.[Symbol.asyncIterator]) {
				return V;
			}
			return webidl.converters.XMLHttpRequestBodyInit(V);
		};
		webidl.converters.ResponseInit = webidl.dictionaryConverter([
			{
				key: "status",
				converter: webidl.converters["unsigned short"],
				defaultValue: 200,
			},
			{
				key: "statusText",
				converter: webidl.converters.ByteString,
				defaultValue: "",
			},
			{
				key: "headers",
				converter: webidl.converters.HeadersInit,
			},
		]);
		module2.exports = {
			makeNetworkError,
			makeResponse,
			makeAppropriateNetworkError,
			filterResponse,
			Response,
			cloneResponse,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/request.js
var require_request2 = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/request.js"(exports2, module2) {
		"use strict";
		var { extractBody, mixinBody, cloneBody } = require_body();
		var { Headers: Headers2, fill: fillHeaders, HeadersList } = require_headers();
		var { FinalizationRegistry: FinalizationRegistry2 } = require_dispatcher_weakref()();
		var util = require_util2();
		var {
			isValidHTTPToken,
			sameOrigin,
			normalizeMethod,
			makePolicyContainer,
			normalizeMethodRecord,
		} = require_util3();
		var {
			forbiddenMethodsSet,
			corsSafeListedMethodsSet,
			referrerPolicy,
			requestRedirect,
			requestMode,
			requestCredentials,
			requestCache,
			requestDuplex,
		} = require_constants3();
		var { kEnumerableProperty } = util;
		var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols2();
		var { webidl } = require_webidl();
		var { getGlobalOrigin } = require_global();
		var { URLSerializer } = require_dataURL();
		var { kHeadersList, kConstruct } = require_symbols();
		var assert = require("assert");
		var {
			getMaxListeners,
			setMaxListeners,
			getEventListeners,
			defaultMaxListeners,
		} = require("events");
		var TransformStream = globalThis.TransformStream;
		var kAbortController = Symbol("abortController");
		var requestFinalizer = new FinalizationRegistry2(({ signal, abort }) => {
			signal.removeEventListener("abort", abort);
		});
		var Request = class _Request {
			// https://fetch.spec.whatwg.org/#dom-request
			constructor(input, init = {}) {
				if (input === kConstruct) {
					return;
				}
				webidl.argumentLengthCheck(arguments, 1, { header: "Request constructor" });
				input = webidl.converters.RequestInfo(input);
				init = webidl.converters.RequestInit(init);
				this[kRealm] = {
					settingsObject: {
						baseUrl: getGlobalOrigin(),
						get origin() {
							return this.baseUrl?.origin;
						},
						policyContainer: makePolicyContainer(),
					},
				};
				let request = null;
				let fallbackMode = null;
				const baseUrl = this[kRealm].settingsObject.baseUrl;
				let signal = null;
				if (typeof input === "string") {
					let parsedURL;
					try {
						parsedURL = new URL(input, baseUrl);
					} catch (err) {
						throw new TypeError("Failed to parse URL from " + input, { cause: err });
					}
					if (parsedURL.username || parsedURL.password) {
						throw new TypeError(
							"Request cannot be constructed from a URL that includes credentials: " +
								input,
						);
					}
					request = makeRequest({ urlList: [parsedURL] });
					fallbackMode = "cors";
				} else {
					assert(input instanceof _Request);
					request = input[kState];
					signal = input[kSignal];
				}
				const origin = this[kRealm].settingsObject.origin;
				let window2 = "client";
				if (
					request.window?.constructor?.name === "EnvironmentSettingsObject" &&
					sameOrigin(request.window, origin)
				) {
					window2 = request.window;
				}
				if (init.window != null) {
					throw new TypeError(`'window' option '${window2}' must be null`);
				}
				if ("window" in init) {
					window2 = "no-window";
				}
				request = makeRequest({
					// URL requests URL.
					// undici implementation note: this is set as the first item in request's urlList in makeRequest
					// method requests method.
					method: request.method,
					// header list A copy of requests header list.
					// undici implementation note: headersList is cloned in makeRequest
					headersList: request.headersList,
					// unsafe-request flag Set.
					unsafeRequest: request.unsafeRequest,
					// client Thiss relevant settings object.
					client: this[kRealm].settingsObject,
					// window window.
					window: window2,
					// priority requests priority.
					priority: request.priority,
					// origin requests origin. The propagation of the origin is only significant for navigation requests
					// being handled by a service worker. In this scenario a request can have an origin that is different
					// from the current client.
					origin: request.origin,
					// referrer requests referrer.
					referrer: request.referrer,
					// referrer policy requests referrer policy.
					referrerPolicy: request.referrerPolicy,
					// mode requests mode.
					mode: request.mode,
					// credentials mode requests credentials mode.
					credentials: request.credentials,
					// cache mode requests cache mode.
					cache: request.cache,
					// redirect mode requests redirect mode.
					redirect: request.redirect,
					// integrity metadata requests integrity metadata.
					integrity: request.integrity,
					// keepalive requests keepalive.
					keepalive: request.keepalive,
					// reload-navigation flag requests reload-navigation flag.
					reloadNavigation: request.reloadNavigation,
					// history-navigation flag requests history-navigation flag.
					historyNavigation: request.historyNavigation,
					// URL list A clone of requests URL list.
					urlList: [...request.urlList],
				});
				const initHasKey = Object.keys(init).length !== 0;
				if (initHasKey) {
					if (request.mode === "navigate") {
						request.mode = "same-origin";
					}
					request.reloadNavigation = false;
					request.historyNavigation = false;
					request.origin = "client";
					request.referrer = "client";
					request.referrerPolicy = "";
					request.url = request.urlList[request.urlList.length - 1];
					request.urlList = [request.url];
				}
				if (init.referrer !== void 0) {
					const referrer = init.referrer;
					if (referrer === "") {
						request.referrer = "no-referrer";
					} else {
						let parsedReferrer;
						try {
							parsedReferrer = new URL(referrer, baseUrl);
						} catch (err) {
							throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, {
								cause: err,
							});
						}
						if (
							(parsedReferrer.protocol === "about:" &&
								parsedReferrer.hostname === "client") ||
							(origin &&
								!sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl))
						) {
							request.referrer = "client";
						} else {
							request.referrer = parsedReferrer;
						}
					}
				}
				if (init.referrerPolicy !== void 0) {
					request.referrerPolicy = init.referrerPolicy;
				}
				let mode;
				if (init.mode !== void 0) {
					mode = init.mode;
				} else {
					mode = fallbackMode;
				}
				if (mode === "navigate") {
					throw webidl.errors.exception({
						header: "Request constructor",
						message: "invalid request mode navigate.",
					});
				}
				if (mode != null) {
					request.mode = mode;
				}
				if (init.credentials !== void 0) {
					request.credentials = init.credentials;
				}
				if (init.cache !== void 0) {
					request.cache = init.cache;
				}
				if (request.cache === "only-if-cached" && request.mode !== "same-origin") {
					throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
				}
				if (init.redirect !== void 0) {
					request.redirect = init.redirect;
				}
				if (init.integrity != null) {
					request.integrity = String(init.integrity);
				}
				if (init.keepalive !== void 0) {
					request.keepalive = Boolean(init.keepalive);
				}
				if (init.method !== void 0) {
					let method = init.method;
					if (!isValidHTTPToken(method)) {
						throw new TypeError(`'${method}' is not a valid HTTP method.`);
					}
					if (forbiddenMethodsSet.has(method.toUpperCase())) {
						throw new TypeError(`'${method}' HTTP method is unsupported.`);
					}
					method = normalizeMethodRecord[method] ?? normalizeMethod(method);
					request.method = method;
				}
				if (init.signal !== void 0) {
					signal = init.signal;
				}
				this[kState] = request;
				const ac = new AbortController();
				this[kSignal] = ac.signal;
				this[kSignal][kRealm] = this[kRealm];
				if (signal != null) {
					if (
						!signal ||
						typeof signal.aborted !== "boolean" ||
						typeof signal.addEventListener !== "function"
					) {
						throw new TypeError(
							"Failed to construct 'Request': member signal is not of type AbortSignal.",
						);
					}
					if (signal.aborted) {
						ac.abort(signal.reason);
					} else {
						this[kAbortController] = ac;
						const acRef = new WeakRef(ac);
						const abort = function () {
							const ac2 = acRef.deref();
							if (ac2 !== void 0) {
								ac2.abort(this.reason);
							}
						};
						try {
							if (
								typeof getMaxListeners === "function" &&
								getMaxListeners(signal) === defaultMaxListeners
							) {
								setMaxListeners(100, signal);
							} else if (
								getEventListeners(signal, "abort").length >= defaultMaxListeners
							) {
								setMaxListeners(100, signal);
							}
						} catch {}
						util.addAbortListener(signal, abort);
						requestFinalizer.register(ac, { signal, abort });
					}
				}
				this[kHeaders] = new Headers2(kConstruct);
				this[kHeaders][kHeadersList] = request.headersList;
				this[kHeaders][kGuard] = "request";
				this[kHeaders][kRealm] = this[kRealm];
				if (mode === "no-cors") {
					if (!corsSafeListedMethodsSet.has(request.method)) {
						throw new TypeError(`'${request.method} is unsupported in no-cors mode.`);
					}
					this[kHeaders][kGuard] = "request-no-cors";
				}
				if (initHasKey) {
					const headersList = this[kHeaders][kHeadersList];
					const headers =
						init.headers !== void 0 ? init.headers : new HeadersList(headersList);
					headersList.clear();
					if (headers instanceof HeadersList) {
						for (const [key, val] of headers) {
							headersList.append(key, val);
						}
						headersList.cookies = headers.cookies;
					} else {
						fillHeaders(this[kHeaders], headers);
					}
				}
				const inputBody = input instanceof _Request ? input[kState].body : null;
				if (
					(init.body != null || inputBody != null) &&
					(request.method === "GET" || request.method === "HEAD")
				) {
					throw new TypeError("Request with GET/HEAD method cannot have body.");
				}
				let initBody = null;
				if (init.body != null) {
					const [extractedBody, contentType] = extractBody(init.body, request.keepalive);
					initBody = extractedBody;
					if (contentType && !this[kHeaders][kHeadersList].contains("content-type")) {
						this[kHeaders].append("content-type", contentType);
					}
				}
				const inputOrInitBody = initBody ?? inputBody;
				if (inputOrInitBody != null && inputOrInitBody.source == null) {
					if (initBody != null && init.duplex == null) {
						throw new TypeError(
							"RequestInit: duplex option is required when sending a body.",
						);
					}
					if (request.mode !== "same-origin" && request.mode !== "cors") {
						throw new TypeError(
							'If request is made from ReadableStream, mode should be "same-origin" or "cors"',
						);
					}
					request.useCORSPreflightFlag = true;
				}
				let finalBody = inputOrInitBody;
				if (initBody == null && inputBody != null) {
					if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
						throw new TypeError(
							"Cannot construct a Request with a Request object that has already been used.",
						);
					}
					if (!TransformStream) {
						TransformStream = require("stream/web").TransformStream;
					}
					const identityTransform = new TransformStream();
					inputBody.stream.pipeThrough(identityTransform);
					finalBody = {
						source: inputBody.source,
						length: inputBody.length,
						stream: identityTransform.readable,
					};
				}
				this[kState].body = finalBody;
			}
			// Returns requests HTTP method, which is "GET" by default.
			get method() {
				webidl.brandCheck(this, _Request);
				return this[kState].method;
			}
			// Returns the URL of request as a string.
			get url() {
				webidl.brandCheck(this, _Request);
				return URLSerializer(this[kState].url);
			}
			// Returns a Headers object consisting of the headers associated with request.
			// Note that headers added in the network layer by the user agent will not
			// be accounted for in this object, e.g., the "Host" header.
			get headers() {
				webidl.brandCheck(this, _Request);
				return this[kHeaders];
			}
			// Returns the kind of resource requested by request, e.g., "document"
			// or "script".
			get destination() {
				webidl.brandCheck(this, _Request);
				return this[kState].destination;
			}
			// Returns the referrer of request. Its value can be a same-origin URL if
			// explicitly set in init, the empty string to indicate no referrer, and
			// "about:client" when defaulting to the globals default. This is used
			// during fetching to determine the value of the `Referer` header of the
			// request being made.
			get referrer() {
				webidl.brandCheck(this, _Request);
				if (this[kState].referrer === "no-referrer") {
					return "";
				}
				if (this[kState].referrer === "client") {
					return "about:client";
				}
				return this[kState].referrer.toString();
			}
			// Returns the referrer policy associated with request.
			// This is used during fetching to compute the value of the requests
			// referrer.
			get referrerPolicy() {
				webidl.brandCheck(this, _Request);
				return this[kState].referrerPolicy;
			}
			// Returns the mode associated with request, which is a string indicating
			// whether the request will use CORS, or will be restricted to same-origin
			// URLs.
			get mode() {
				webidl.brandCheck(this, _Request);
				return this[kState].mode;
			}
			// Returns the credentials mode associated with request,
			// which is a string indicating whether credentials will be sent with the
			// request always, never, or only when sent to a same-origin URL.
			get credentials() {
				return this[kState].credentials;
			}
			// Returns the cache mode associated with request,
			// which is a string indicating how the request will
			// interact with the browsers cache when fetching.
			get cache() {
				webidl.brandCheck(this, _Request);
				return this[kState].cache;
			}
			// Returns the redirect mode associated with request,
			// which is a string indicating how redirects for the
			// request will be handled during fetching. A request
			// will follow redirects by default.
			get redirect() {
				webidl.brandCheck(this, _Request);
				return this[kState].redirect;
			}
			// Returns requests subresource integrity metadata, which is a
			// cryptographic hash of the resource being fetched. Its value
			// consists of multiple hashes separated by whitespace. [SRI]
			get integrity() {
				webidl.brandCheck(this, _Request);
				return this[kState].integrity;
			}
			// Returns a boolean indicating whether or not request can outlive the
			// global in which it was created.
			get keepalive() {
				webidl.brandCheck(this, _Request);
				return this[kState].keepalive;
			}
			// Returns a boolean indicating whether or not request is for a reload
			// navigation.
			get isReloadNavigation() {
				webidl.brandCheck(this, _Request);
				return this[kState].reloadNavigation;
			}
			// Returns a boolean indicating whether or not request is for a history
			// navigation (a.k.a. back-foward navigation).
			get isHistoryNavigation() {
				webidl.brandCheck(this, _Request);
				return this[kState].historyNavigation;
			}
			// Returns the signal associated with request, which is an AbortSignal
			// object indicating whether or not request has been aborted, and its
			// abort event handler.
			get signal() {
				webidl.brandCheck(this, _Request);
				return this[kSignal];
			}
			get body() {
				webidl.brandCheck(this, _Request);
				return this[kState].body ? this[kState].body.stream : null;
			}
			get bodyUsed() {
				webidl.brandCheck(this, _Request);
				return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
			}
			get duplex() {
				webidl.brandCheck(this, _Request);
				return "half";
			}
			// Returns a clone of request.
			clone() {
				webidl.brandCheck(this, _Request);
				if (this.bodyUsed || this.body?.locked) {
					throw new TypeError("unusable");
				}
				const clonedRequest = cloneRequest(this[kState]);
				const clonedRequestObject = new _Request(kConstruct);
				clonedRequestObject[kState] = clonedRequest;
				clonedRequestObject[kRealm] = this[kRealm];
				clonedRequestObject[kHeaders] = new Headers2(kConstruct);
				clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
				clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
				clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
				const ac = new AbortController();
				if (this.signal.aborted) {
					ac.abort(this.signal.reason);
				} else {
					util.addAbortListener(this.signal, () => {
						ac.abort(this.signal.reason);
					});
				}
				clonedRequestObject[kSignal] = ac.signal;
				return clonedRequestObject;
			}
		};
		mixinBody(Request);
		function makeRequest(init) {
			const request = {
				method: "GET",
				localURLsOnly: false,
				unsafeRequest: false,
				body: null,
				client: null,
				reservedClient: null,
				replacesClientId: "",
				window: "client",
				keepalive: false,
				serviceWorkers: "all",
				initiator: "",
				destination: "",
				priority: null,
				origin: "client",
				policyContainer: "client",
				referrer: "client",
				referrerPolicy: "",
				mode: "no-cors",
				useCORSPreflightFlag: false,
				credentials: "same-origin",
				useCredentials: false,
				cache: "default",
				redirect: "follow",
				integrity: "",
				cryptoGraphicsNonceMetadata: "",
				parserMetadata: "",
				reloadNavigation: false,
				historyNavigation: false,
				userActivation: false,
				taintedOrigin: false,
				redirectCount: 0,
				responseTainting: "basic",
				preventNoCacheCacheControlHeaderModification: false,
				done: false,
				timingAllowFailed: false,
				...init,
				headersList: init.headersList
					? new HeadersList(init.headersList)
					: new HeadersList(),
			};
			request.url = request.urlList[0];
			return request;
		}
		function cloneRequest(request) {
			const newRequest = makeRequest({ ...request, body: null });
			if (request.body != null) {
				newRequest.body = cloneBody(request.body);
			}
			return newRequest;
		}
		Object.defineProperties(Request.prototype, {
			method: kEnumerableProperty,
			url: kEnumerableProperty,
			headers: kEnumerableProperty,
			redirect: kEnumerableProperty,
			clone: kEnumerableProperty,
			signal: kEnumerableProperty,
			duplex: kEnumerableProperty,
			destination: kEnumerableProperty,
			body: kEnumerableProperty,
			bodyUsed: kEnumerableProperty,
			isHistoryNavigation: kEnumerableProperty,
			isReloadNavigation: kEnumerableProperty,
			keepalive: kEnumerableProperty,
			integrity: kEnumerableProperty,
			cache: kEnumerableProperty,
			credentials: kEnumerableProperty,
			attribute: kEnumerableProperty,
			referrerPolicy: kEnumerableProperty,
			referrer: kEnumerableProperty,
			mode: kEnumerableProperty,
			[Symbol.toStringTag]: {
				value: "Request",
				configurable: true,
			},
		});
		webidl.converters.Request = webidl.interfaceConverter(Request);
		webidl.converters.RequestInfo = function (V) {
			if (typeof V === "string") {
				return webidl.converters.USVString(V);
			}
			if (V instanceof Request) {
				return webidl.converters.Request(V);
			}
			return webidl.converters.USVString(V);
		};
		webidl.converters.AbortSignal = webidl.interfaceConverter(AbortSignal);
		webidl.converters.RequestInit = webidl.dictionaryConverter([
			{
				key: "method",
				converter: webidl.converters.ByteString,
			},
			{
				key: "headers",
				converter: webidl.converters.HeadersInit,
			},
			{
				key: "body",
				converter: webidl.nullableConverter(webidl.converters.BodyInit),
			},
			{
				key: "referrer",
				converter: webidl.converters.USVString,
			},
			{
				key: "referrerPolicy",
				converter: webidl.converters.DOMString,
				// https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
				allowedValues: referrerPolicy,
			},
			{
				key: "mode",
				converter: webidl.converters.DOMString,
				// https://fetch.spec.whatwg.org/#concept-request-mode
				allowedValues: requestMode,
			},
			{
				key: "credentials",
				converter: webidl.converters.DOMString,
				// https://fetch.spec.whatwg.org/#requestcredentials
				allowedValues: requestCredentials,
			},
			{
				key: "cache",
				converter: webidl.converters.DOMString,
				// https://fetch.spec.whatwg.org/#requestcache
				allowedValues: requestCache,
			},
			{
				key: "redirect",
				converter: webidl.converters.DOMString,
				// https://fetch.spec.whatwg.org/#requestredirect
				allowedValues: requestRedirect,
			},
			{
				key: "integrity",
				converter: webidl.converters.DOMString,
			},
			{
				key: "keepalive",
				converter: webidl.converters.boolean,
			},
			{
				key: "signal",
				converter: webidl.nullableConverter((signal) =>
					webidl.converters.AbortSignal(signal, { strict: false }),
				),
			},
			{
				key: "window",
				converter: webidl.converters.any,
			},
			{
				key: "duplex",
				converter: webidl.converters.DOMString,
				allowedValues: requestDuplex,
			},
		]);
		module2.exports = { Request, makeRequest };
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/index.js
var require_fetch = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fetch/index.js"(exports2, module2) {
		"use strict";
		var {
			Response,
			makeNetworkError,
			makeAppropriateNetworkError,
			filterResponse,
			makeResponse,
		} = require_response();
		var { Headers: Headers2 } = require_headers();
		var { Request, makeRequest } = require_request2();
		var zlib = require("zlib");
		var {
			bytesMatch,
			makePolicyContainer,
			clonePolicyContainer,
			requestBadPort,
			TAOCheck,
			appendRequestOriginHeader,
			responseLocationURL,
			requestCurrentURL,
			setRequestReferrerPolicyOnRedirect,
			tryUpgradeRequestToAPotentiallyTrustworthyURL,
			createOpaqueTimingInfo,
			appendFetchMetadata,
			corsCheck,
			crossOriginResourcePolicyCheck,
			determineRequestsReferrer,
			coarsenedSharedCurrentTime,
			createDeferredPromise,
			isBlobLike,
			sameOrigin,
			isCancelled,
			isAborted,
			isErrorLike,
			fullyReadBody,
			readableStreamClose,
			isomorphicEncode,
			urlIsLocal,
			urlIsHttpHttpsScheme,
			urlHasHttpsScheme,
		} = require_util3();
		var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
		var assert = require("assert");
		var { safelyExtractBody } = require_body();
		var {
			redirectStatusSet,
			nullBodyStatus,
			safeMethodsSet,
			requestBodyHeader,
			subresourceSet,
			DOMException: DOMException2,
		} = require_constants3();
		var { kHeadersList } = require_symbols();
		var EE = require("events");
		var { Readable, pipeline } = require("stream");
		var { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = require_util2();
		var { dataURLProcessor, serializeAMimeType } = require_dataURL();
		var { TransformStream } = require("stream/web");
		var { getGlobalDispatcher } = require_global2();
		var { webidl } = require_webidl();
		var { STATUS_CODES } = require("http");
		var GET_OR_HEAD = ["GET", "HEAD"];
		var resolveObjectURL;
		var ReadableStream = globalThis.ReadableStream;
		var Fetch = class extends EE {
			constructor(dispatcher) {
				super();
				this.dispatcher = dispatcher;
				this.connection = null;
				this.dump = false;
				this.state = "ongoing";
				this.setMaxListeners(21);
			}
			terminate(reason) {
				if (this.state !== "ongoing") {
					return;
				}
				this.state = "terminated";
				this.connection?.destroy(reason);
				this.emit("terminated", reason);
			}
			// https://fetch.spec.whatwg.org/#fetch-controller-abort
			abort(error) {
				if (this.state !== "ongoing") {
					return;
				}
				this.state = "aborted";
				if (!error) {
					error = new DOMException2("The operation was aborted.", "AbortError");
				}
				this.serializedAbortReason = error;
				this.connection?.destroy(error);
				this.emit("terminated", error);
			}
		};
		function fetch2(input, init = {}) {
			webidl.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
			const p = createDeferredPromise();
			let requestObject;
			try {
				requestObject = new Request(input, init);
			} catch (e) {
				p.reject(e);
				return p.promise;
			}
			const request = requestObject[kState];
			if (requestObject.signal.aborted) {
				abortFetch(p, request, null, requestObject.signal.reason);
				return p.promise;
			}
			const globalObject = request.client.globalObject;
			if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
				request.serviceWorkers = "none";
			}
			let responseObject = null;
			const relevantRealm = null;
			let locallyAborted = false;
			let controller = null;
			addAbortListener(requestObject.signal, () => {
				locallyAborted = true;
				assert(controller != null);
				controller.abort(requestObject.signal.reason);
				abortFetch(p, request, responseObject, requestObject.signal.reason);
			});
			const handleFetchDone = (response) => finalizeAndReportTiming(response, "fetch");
			const processResponse = (response) => {
				if (locallyAborted) {
					return Promise.resolve();
				}
				if (response.aborted) {
					abortFetch(p, request, responseObject, controller.serializedAbortReason);
					return Promise.resolve();
				}
				if (response.type === "error") {
					p.reject(
						Object.assign(new TypeError("fetch failed"), { cause: response.error }),
					);
					return Promise.resolve();
				}
				responseObject = new Response();
				responseObject[kState] = response;
				responseObject[kRealm] = relevantRealm;
				responseObject[kHeaders][kHeadersList] = response.headersList;
				responseObject[kHeaders][kGuard] = "immutable";
				responseObject[kHeaders][kRealm] = relevantRealm;
				p.resolve(responseObject);
			};
			controller = fetching({
				request,
				processResponseEndOfBody: handleFetchDone,
				processResponse,
				dispatcher: init.dispatcher ?? getGlobalDispatcher(),
				// undici
			});
			return p.promise;
		}
		function finalizeAndReportTiming(response, initiatorType = "other") {
			if (response.type === "error" && response.aborted) {
				return;
			}
			if (!response.urlList?.length) {
				return;
			}
			const originalURL = response.urlList[0];
			let timingInfo = response.timingInfo;
			let cacheState = response.cacheState;
			if (!urlIsHttpHttpsScheme(originalURL)) {
				return;
			}
			if (timingInfo === null) {
				return;
			}
			if (!response.timingAllowPassed) {
				timingInfo = createOpaqueTimingInfo({
					startTime: timingInfo.startTime,
				});
				cacheState = "";
			}
			timingInfo.endTime = coarsenedSharedCurrentTime();
			response.timingInfo = timingInfo;
			markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState);
		}
		function markResourceTiming(
			timingInfo,
			originalURL,
			initiatorType,
			globalThis2,
			cacheState,
		) {
			if (nodeMajor > 18 || (nodeMajor === 18 && nodeMinor >= 2)) {
				performance.markResourceTiming(
					timingInfo,
					originalURL.href,
					initiatorType,
					globalThis2,
					cacheState,
				);
			}
		}
		function abortFetch(p, request, responseObject, error) {
			if (!error) {
				error = new DOMException2("The operation was aborted.", "AbortError");
			}
			p.reject(error);
			if (request.body != null && isReadable(request.body?.stream)) {
				request.body.stream.cancel(error).catch((err) => {
					if (err.code === "ERR_INVALID_STATE") {
						return;
					}
					throw err;
				});
			}
			if (responseObject == null) {
				return;
			}
			const response = responseObject[kState];
			if (response.body != null && isReadable(response.body?.stream)) {
				response.body.stream.cancel(error).catch((err) => {
					if (err.code === "ERR_INVALID_STATE") {
						return;
					}
					throw err;
				});
			}
		}
		function fetching({
			request,
			processRequestBodyChunkLength,
			processRequestEndOfBody,
			processResponse,
			processResponseEndOfBody,
			processResponseConsumeBody,
			useParallelQueue = false,
			dispatcher,
			// undici
		}) {
			let taskDestination = null;
			let crossOriginIsolatedCapability = false;
			if (request.client != null) {
				taskDestination = request.client.globalObject;
				crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
			}
			const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
			const timingInfo = createOpaqueTimingInfo({
				startTime: currenTime,
			});
			const fetchParams = {
				controller: new Fetch(dispatcher),
				request,
				timingInfo,
				processRequestBodyChunkLength,
				processRequestEndOfBody,
				processResponse,
				processResponseConsumeBody,
				processResponseEndOfBody,
				taskDestination,
				crossOriginIsolatedCapability,
			};
			assert(!request.body || request.body.stream);
			if (request.window === "client") {
				request.window =
					request.client?.globalObject?.constructor?.name === "Window"
						? request.client
						: "no-window";
			}
			if (request.origin === "client") {
				request.origin = request.client?.origin;
			}
			if (request.policyContainer === "client") {
				if (request.client != null) {
					request.policyContainer = clonePolicyContainer(request.client.policyContainer);
				} else {
					request.policyContainer = makePolicyContainer();
				}
			}
			if (!request.headersList.contains("accept")) {
				const value = "*/*";
				request.headersList.append("accept", value);
			}
			if (!request.headersList.contains("accept-language")) {
				request.headersList.append("accept-language", "*");
			}
			if (request.priority === null) {
			}
			if (subresourceSet.has(request.destination)) {
			}
			mainFetch(fetchParams).catch((err) => {
				fetchParams.controller.terminate(err);
			});
			return fetchParams.controller;
		}
		async function mainFetch(fetchParams, recursive = false) {
			const request = fetchParams.request;
			let response = null;
			if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
				response = makeNetworkError("local URLs only");
			}
			tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
			if (requestBadPort(request) === "blocked") {
				response = makeNetworkError("bad port");
			}
			if (request.referrerPolicy === "") {
				request.referrerPolicy = request.policyContainer.referrerPolicy;
			}
			if (request.referrer !== "no-referrer") {
				request.referrer = determineRequestsReferrer(request);
			}
			if (response === null) {
				response = await (async () => {
					const currentURL = requestCurrentURL(request);
					if (
						// - requests current URLs origin is same origin with requests origin,
						//   and requests response tainting is "basic"
						(sameOrigin(currentURL, request.url) &&
							request.responseTainting === "basic") || // requests current URLs scheme is "data"
						currentURL.protocol === "data:" || // - requests mode is "navigate" or "websocket"
						request.mode === "navigate" ||
						request.mode === "websocket"
					) {
						request.responseTainting = "basic";
						return await schemeFetch(fetchParams);
					}
					if (request.mode === "same-origin") {
						return makeNetworkError('request mode cannot be "same-origin"');
					}
					if (request.mode === "no-cors") {
						if (request.redirect !== "follow") {
							return makeNetworkError(
								'redirect mode cannot be "follow" for "no-cors" request',
							);
						}
						request.responseTainting = "opaque";
						return await schemeFetch(fetchParams);
					}
					if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
						return makeNetworkError("URL scheme must be a HTTP(S) scheme");
					}
					request.responseTainting = "cors";
					return await httpFetch(fetchParams);
				})();
			}
			if (recursive) {
				return response;
			}
			if (response.status !== 0 && !response.internalResponse) {
				if (request.responseTainting === "cors") {
				}
				if (request.responseTainting === "basic") {
					response = filterResponse(response, "basic");
				} else if (request.responseTainting === "cors") {
					response = filterResponse(response, "cors");
				} else if (request.responseTainting === "opaque") {
					response = filterResponse(response, "opaque");
				} else {
					assert(false);
				}
			}
			let internalResponse = response.status === 0 ? response : response.internalResponse;
			if (internalResponse.urlList.length === 0) {
				internalResponse.urlList.push(...request.urlList);
			}
			if (!request.timingAllowFailed) {
				response.timingAllowPassed = true;
			}
			if (
				response.type === "opaque" &&
				internalResponse.status === 206 &&
				internalResponse.rangeRequested &&
				!request.headers.contains("range")
			) {
				response = internalResponse = makeNetworkError();
			}
			if (
				response.status !== 0 &&
				(request.method === "HEAD" ||
					request.method === "CONNECT" ||
					nullBodyStatus.includes(internalResponse.status))
			) {
				internalResponse.body = null;
				fetchParams.controller.dump = true;
			}
			if (request.integrity) {
				const processBodyError = (reason) =>
					fetchFinale(fetchParams, makeNetworkError(reason));
				if (request.responseTainting === "opaque" || response.body == null) {
					processBodyError(response.error);
					return;
				}
				const processBody = (bytes) => {
					if (!bytesMatch(bytes, request.integrity)) {
						processBodyError("integrity mismatch");
						return;
					}
					response.body = safelyExtractBody(bytes)[0];
					fetchFinale(fetchParams, response);
				};
				await fullyReadBody(response.body, processBody, processBodyError);
			} else {
				fetchFinale(fetchParams, response);
			}
		}
		function schemeFetch(fetchParams) {
			if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
				return Promise.resolve(makeAppropriateNetworkError(fetchParams));
			}
			const { request } = fetchParams;
			const { protocol: scheme } = requestCurrentURL(request);
			switch (scheme) {
				case "about:": {
					return Promise.resolve(makeNetworkError("about scheme is not supported"));
				}
				case "blob:": {
					if (!resolveObjectURL) {
						resolveObjectURL = require("buffer").resolveObjectURL;
					}
					const blobURLEntry = requestCurrentURL(request);
					if (blobURLEntry.search.length !== 0) {
						return Promise.resolve(
							makeNetworkError("NetworkError when attempting to fetch resource."),
						);
					}
					const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
					if (request.method !== "GET" || !isBlobLike(blobURLEntryObject)) {
						return Promise.resolve(makeNetworkError("invalid method"));
					}
					const bodyWithType = safelyExtractBody(blobURLEntryObject);
					const body = bodyWithType[0];
					const length = isomorphicEncode(`${body.length}`);
					const type = bodyWithType[1] ?? "";
					const response = makeResponse({
						statusText: "OK",
						headersList: [
							["content-length", { name: "Content-Length", value: length }],
							["content-type", { name: "Content-Type", value: type }],
						],
					});
					response.body = body;
					return Promise.resolve(response);
				}
				case "data:": {
					const currentURL = requestCurrentURL(request);
					const dataURLStruct = dataURLProcessor(currentURL);
					if (dataURLStruct === "failure") {
						return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
					}
					const mimeType = serializeAMimeType(dataURLStruct.mimeType);
					return Promise.resolve(
						makeResponse({
							statusText: "OK",
							headersList: [
								["content-type", { name: "Content-Type", value: mimeType }],
							],
							body: safelyExtractBody(dataURLStruct.body)[0],
						}),
					);
				}
				case "file:": {
					return Promise.resolve(makeNetworkError("not implemented... yet..."));
				}
				case "http:":
				case "https:": {
					return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
				}
				default: {
					return Promise.resolve(makeNetworkError("unknown scheme"));
				}
			}
		}
		function finalizeResponse(fetchParams, response) {
			fetchParams.request.done = true;
			if (fetchParams.processResponseDone != null) {
				queueMicrotask(() => fetchParams.processResponseDone(response));
			}
		}
		function fetchFinale(fetchParams, response) {
			if (response.type === "error") {
				response.urlList = [fetchParams.request.urlList[0]];
				response.timingInfo = createOpaqueTimingInfo({
					startTime: fetchParams.timingInfo.startTime,
				});
			}
			const processResponseEndOfBody = () => {
				fetchParams.request.done = true;
				if (fetchParams.processResponseEndOfBody != null) {
					queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
				}
			};
			if (fetchParams.processResponse != null) {
				queueMicrotask(() => fetchParams.processResponse(response));
			}
			if (response.body == null) {
				processResponseEndOfBody();
			} else {
				const identityTransformAlgorithm = (chunk, controller) => {
					controller.enqueue(chunk);
				};
				const transformStream = new TransformStream(
					{
						start() {},
						transform: identityTransformAlgorithm,
						flush: processResponseEndOfBody,
					},
					{
						size() {
							return 1;
						},
					},
					{
						size() {
							return 1;
						},
					},
				);
				response.body = { stream: response.body.stream.pipeThrough(transformStream) };
			}
			if (fetchParams.processResponseConsumeBody != null) {
				const processBody = (nullOrBytes) =>
					fetchParams.processResponseConsumeBody(response, nullOrBytes);
				const processBodyError = (failure) =>
					fetchParams.processResponseConsumeBody(response, failure);
				if (response.body == null) {
					queueMicrotask(() => processBody(null));
				} else {
					return fullyReadBody(response.body, processBody, processBodyError);
				}
				return Promise.resolve();
			}
		}
		async function httpFetch(fetchParams) {
			const request = fetchParams.request;
			let response = null;
			let actualResponse = null;
			const timingInfo = fetchParams.timingInfo;
			if (request.serviceWorkers === "all") {
			}
			if (response === null) {
				if (request.redirect === "follow") {
					request.serviceWorkers = "none";
				}
				actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
				if (
					request.responseTainting === "cors" &&
					corsCheck(request, response) === "failure"
				) {
					return makeNetworkError("cors failure");
				}
				if (TAOCheck(request, response) === "failure") {
					request.timingAllowFailed = true;
				}
			}
			if (
				(request.responseTainting === "opaque" || response.type === "opaque") &&
				crossOriginResourcePolicyCheck(
					request.origin,
					request.client,
					request.destination,
					actualResponse,
				) === "blocked"
			) {
				return makeNetworkError("blocked");
			}
			if (redirectStatusSet.has(actualResponse.status)) {
				if (request.redirect !== "manual") {
					fetchParams.controller.connection.destroy();
				}
				if (request.redirect === "error") {
					response = makeNetworkError("unexpected redirect");
				} else if (request.redirect === "manual") {
					response = actualResponse;
				} else if (request.redirect === "follow") {
					response = await httpRedirectFetch(fetchParams, response);
				} else {
					assert(false);
				}
			}
			response.timingInfo = timingInfo;
			return response;
		}
		function httpRedirectFetch(fetchParams, response) {
			const request = fetchParams.request;
			const actualResponse = response.internalResponse ? response.internalResponse : response;
			let locationURL;
			try {
				locationURL = responseLocationURL(actualResponse, requestCurrentURL(request).hash);
				if (locationURL == null) {
					return response;
				}
			} catch (err) {
				return Promise.resolve(makeNetworkError(err));
			}
			if (!urlIsHttpHttpsScheme(locationURL)) {
				return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
			}
			if (request.redirectCount === 20) {
				return Promise.resolve(makeNetworkError("redirect count exceeded"));
			}
			request.redirectCount += 1;
			if (
				request.mode === "cors" &&
				(locationURL.username || locationURL.password) &&
				!sameOrigin(request, locationURL)
			) {
				return Promise.resolve(
					makeNetworkError('cross origin not allowed for request mode "cors"'),
				);
			}
			if (
				request.responseTainting === "cors" &&
				(locationURL.username || locationURL.password)
			) {
				return Promise.resolve(
					makeNetworkError('URL cannot contain credentials for request mode "cors"'),
				);
			}
			if (
				actualResponse.status !== 303 &&
				request.body != null &&
				request.body.source == null
			) {
				return Promise.resolve(makeNetworkError());
			}
			if (
				([301, 302].includes(actualResponse.status) && request.method === "POST") ||
				(actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method))
			) {
				request.method = "GET";
				request.body = null;
				for (const headerName of requestBodyHeader) {
					request.headersList.delete(headerName);
				}
			}
			if (!sameOrigin(requestCurrentURL(request), locationURL)) {
				request.headersList.delete("authorization");
				request.headersList.delete("proxy-authorization", true);
				request.headersList.delete("cookie");
				request.headersList.delete("host");
			}
			if (request.body != null) {
				assert(request.body.source != null);
				request.body = safelyExtractBody(request.body.source)[0];
			}
			const timingInfo = fetchParams.timingInfo;
			timingInfo.redirectEndTime = timingInfo.postRedirectStartTime =
				coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
			if (timingInfo.redirectStartTime === 0) {
				timingInfo.redirectStartTime = timingInfo.startTime;
			}
			request.urlList.push(locationURL);
			setRequestReferrerPolicyOnRedirect(request, actualResponse);
			return mainFetch(fetchParams, true);
		}
		async function httpNetworkOrCacheFetch(
			fetchParams,
			isAuthenticationFetch = false,
			isNewConnectionFetch = false,
		) {
			const request = fetchParams.request;
			let httpFetchParams = null;
			let httpRequest = null;
			let response = null;
			const httpCache = null;
			const revalidatingFlag = false;
			if (request.window === "no-window" && request.redirect === "error") {
				httpFetchParams = fetchParams;
				httpRequest = request;
			} else {
				httpRequest = makeRequest(request);
				httpFetchParams = { ...fetchParams };
				httpFetchParams.request = httpRequest;
			}
			const includeCredentials =
				request.credentials === "include" ||
				(request.credentials === "same-origin" && request.responseTainting === "basic");
			const contentLength = httpRequest.body ? httpRequest.body.length : null;
			let contentLengthHeaderValue = null;
			if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
				contentLengthHeaderValue = "0";
			}
			if (contentLength != null) {
				contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
			}
			if (contentLengthHeaderValue != null) {
				httpRequest.headersList.append("content-length", contentLengthHeaderValue);
			}
			if (contentLength != null && httpRequest.keepalive) {
			}
			if (httpRequest.referrer instanceof URL) {
				httpRequest.headersList.append(
					"referer",
					isomorphicEncode(httpRequest.referrer.href),
				);
			}
			appendRequestOriginHeader(httpRequest);
			appendFetchMetadata(httpRequest);
			if (!httpRequest.headersList.contains("user-agent")) {
				httpRequest.headersList.append(
					"user-agent",
					typeof esbuildDetection === "undefined" ? "undici" : "node",
				);
			}
			if (
				httpRequest.cache === "default" &&
				(httpRequest.headersList.contains("if-modified-since") ||
					httpRequest.headersList.contains("if-none-match") ||
					httpRequest.headersList.contains("if-unmodified-since") ||
					httpRequest.headersList.contains("if-match") ||
					httpRequest.headersList.contains("if-range"))
			) {
				httpRequest.cache = "no-store";
			}
			if (
				httpRequest.cache === "no-cache" &&
				!httpRequest.preventNoCacheCacheControlHeaderModification &&
				!httpRequest.headersList.contains("cache-control")
			) {
				httpRequest.headersList.append("cache-control", "max-age=0");
			}
			if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
				if (!httpRequest.headersList.contains("pragma")) {
					httpRequest.headersList.append("pragma", "no-cache");
				}
				if (!httpRequest.headersList.contains("cache-control")) {
					httpRequest.headersList.append("cache-control", "no-cache");
				}
			}
			if (httpRequest.headersList.contains("range")) {
				httpRequest.headersList.append("accept-encoding", "identity");
			}
			if (!httpRequest.headersList.contains("accept-encoding")) {
				if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
					httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
				} else {
					httpRequest.headersList.append("accept-encoding", "gzip, deflate");
				}
			}
			httpRequest.headersList.delete("host");
			if (includeCredentials) {
			}
			if (httpCache == null) {
				httpRequest.cache = "no-store";
			}
			if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") {
			}
			if (response == null) {
				if (httpRequest.mode === "only-if-cached") {
					return makeNetworkError("only if cached");
				}
				const forwardResponse = await httpNetworkFetch(
					httpFetchParams,
					includeCredentials,
					isNewConnectionFetch,
				);
				if (
					!safeMethodsSet.has(httpRequest.method) &&
					forwardResponse.status >= 200 &&
					forwardResponse.status <= 399
				) {
				}
				if (revalidatingFlag && forwardResponse.status === 304) {
				}
				if (response == null) {
					response = forwardResponse;
				}
			}
			response.urlList = [...httpRequest.urlList];
			if (httpRequest.headersList.contains("range")) {
				response.rangeRequested = true;
			}
			response.requestIncludesCredentials = includeCredentials;
			if (response.status === 407) {
				if (request.window === "no-window") {
					return makeNetworkError();
				}
				if (isCancelled(fetchParams)) {
					return makeAppropriateNetworkError(fetchParams);
				}
				return makeNetworkError("proxy authentication required");
			}
			if (
				// responses status is 421
				response.status === 421 && // isNewConnectionFetch is false
				!isNewConnectionFetch && // requests body is null, or requests body is non-null and requests bodys source is non-null
				(request.body == null || request.body.source != null)
			) {
				if (isCancelled(fetchParams)) {
					return makeAppropriateNetworkError(fetchParams);
				}
				fetchParams.controller.connection.destroy();
				response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);
			}
			if (isAuthenticationFetch) {
			}
			return response;
		}
		async function httpNetworkFetch(
			fetchParams,
			includeCredentials = false,
			forceNewConnection = false,
		) {
			assert(
				!fetchParams.controller.connection || fetchParams.controller.connection.destroyed,
			);
			fetchParams.controller.connection = {
				abort: null,
				destroyed: false,
				destroy(err) {
					if (!this.destroyed) {
						this.destroyed = true;
						this.abort?.(
							err ?? new DOMException2("The operation was aborted.", "AbortError"),
						);
					}
				},
			};
			const request = fetchParams.request;
			let response = null;
			const timingInfo = fetchParams.timingInfo;
			const httpCache = null;
			if (httpCache == null) {
				request.cache = "no-store";
			}
			const newConnection = forceNewConnection ? "yes" : "no";
			if (request.mode === "websocket") {
			} else {
			}
			let requestBody = null;
			if (request.body == null && fetchParams.processRequestEndOfBody) {
				queueMicrotask(() => fetchParams.processRequestEndOfBody());
			} else if (request.body != null) {
				const processBodyChunk = async function* (bytes) {
					if (isCancelled(fetchParams)) {
						return;
					}
					yield bytes;
					fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
				};
				const processEndOfBody = () => {
					if (isCancelled(fetchParams)) {
						return;
					}
					if (fetchParams.processRequestEndOfBody) {
						fetchParams.processRequestEndOfBody();
					}
				};
				const processBodyError = (e) => {
					if (isCancelled(fetchParams)) {
						return;
					}
					if (e.name === "AbortError") {
						fetchParams.controller.abort();
					} else {
						fetchParams.controller.terminate(e);
					}
				};
				requestBody = (async function* () {
					try {
						for await (const bytes of request.body.stream) {
							yield* processBodyChunk(bytes);
						}
						processEndOfBody();
					} catch (err) {
						processBodyError(err);
					}
				})();
			}
			try {
				const { body, status, statusText, headersList, socket } = await dispatch({
					body: requestBody,
				});
				if (socket) {
					response = makeResponse({ status, statusText, headersList, socket });
				} else {
					const iterator = body[Symbol.asyncIterator]();
					fetchParams.controller.next = () => iterator.next();
					response = makeResponse({ status, statusText, headersList });
				}
			} catch (err) {
				if (err.name === "AbortError") {
					fetchParams.controller.connection.destroy();
					return makeAppropriateNetworkError(fetchParams, err);
				}
				return makeNetworkError(err);
			}
			const pullAlgorithm = () => {
				fetchParams.controller.resume();
			};
			const cancelAlgorithm = (reason) => {
				fetchParams.controller.abort(reason);
			};
			if (!ReadableStream) {
				ReadableStream = require("stream/web").ReadableStream;
			}
			const stream = new ReadableStream(
				{
					async start(controller) {
						fetchParams.controller.controller = controller;
					},
					async pull(controller) {
						await pullAlgorithm(controller);
					},
					async cancel(reason) {
						await cancelAlgorithm(reason);
					},
				},
				{
					highWaterMark: 0,
					size() {
						return 1;
					},
				},
			);
			response.body = { stream };
			fetchParams.controller.on("terminated", onAborted);
			fetchParams.controller.resume = async () => {
				while (true) {
					let bytes;
					let isFailure;
					try {
						const { done, value } = await fetchParams.controller.next();
						if (isAborted(fetchParams)) {
							break;
						}
						bytes = done ? void 0 : value;
					} catch (err) {
						if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
							bytes = void 0;
						} else {
							bytes = err;
							isFailure = true;
						}
					}
					if (bytes === void 0) {
						readableStreamClose(fetchParams.controller.controller);
						finalizeResponse(fetchParams, response);
						return;
					}
					timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
					if (isFailure) {
						fetchParams.controller.terminate(bytes);
						return;
					}
					fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
					if (isErrored(stream)) {
						fetchParams.controller.terminate();
						return;
					}
					if (!fetchParams.controller.controller.desiredSize) {
						return;
					}
				}
			};
			function onAborted(reason) {
				if (isAborted(fetchParams)) {
					response.aborted = true;
					if (isReadable(stream)) {
						fetchParams.controller.controller.error(
							fetchParams.controller.serializedAbortReason,
						);
					}
				} else {
					if (isReadable(stream)) {
						fetchParams.controller.controller.error(
							new TypeError("terminated", {
								cause: isErrorLike(reason) ? reason : void 0,
							}),
						);
					}
				}
				fetchParams.controller.connection.destroy();
			}
			return response;
			async function dispatch({ body }) {
				const url = requestCurrentURL(request);
				const agent = fetchParams.controller.dispatcher;
				return new Promise((resolve, reject) =>
					agent.dispatch(
						{
							path: url.pathname + url.search,
							origin: url.origin,
							method: request.method,
							body: fetchParams.controller.dispatcher.isMockActive
								? request.body && (request.body.source || request.body.stream)
								: body,
							headers: request.headersList.entries,
							maxRedirections: 0,
							upgrade: request.mode === "websocket" ? "websocket" : void 0,
						},
						{
							body: null,
							abort: null,
							onConnect(abort) {
								const { connection } = fetchParams.controller;
								if (connection.destroyed) {
									abort(
										new DOMException2(
											"The operation was aborted.",
											"AbortError",
										),
									);
								} else {
									fetchParams.controller.on("terminated", abort);
									this.abort = connection.abort = abort;
								}
							},
							onHeaders(status, headersList, resume, statusText) {
								if (status < 200) {
									return;
								}
								let codings = [];
								let location = "";
								const headers = new Headers2();
								if (Array.isArray(headersList)) {
									for (let n = 0; n < headersList.length; n += 2) {
										const key = headersList[n + 0].toString("latin1");
										const val = headersList[n + 1].toString("latin1");
										if (key.toLowerCase() === "content-encoding") {
											codings = val
												.toLowerCase()
												.split(",")
												.map((x) => x.trim());
										} else if (key.toLowerCase() === "location") {
											location = val;
										}
										headers[kHeadersList].append(key, val);
									}
								} else {
									const keys = Object.keys(headersList);
									for (const key of keys) {
										const val = headersList[key];
										if (key.toLowerCase() === "content-encoding") {
											codings = val
												.toLowerCase()
												.split(",")
												.map((x) => x.trim())
												.reverse();
										} else if (key.toLowerCase() === "location") {
											location = val;
										}
										headers[kHeadersList].append(key, val);
									}
								}
								this.body = new Readable({ read: resume });
								const decoders = [];
								const willFollow =
									request.redirect === "follow" &&
									location &&
									redirectStatusSet.has(status);
								if (
									request.method !== "HEAD" &&
									request.method !== "CONNECT" &&
									!nullBodyStatus.includes(status) &&
									!willFollow
								) {
									for (const coding of codings) {
										if (coding === "x-gzip" || coding === "gzip") {
											decoders.push(
												zlib.createGunzip({
													// Be less strict when decoding compressed responses, since sometimes
													// servers send slightly invalid responses that are still accepted
													// by common browsers.
													// Always using Z_SYNC_FLUSH is what cURL does.
													flush: zlib.constants.Z_SYNC_FLUSH,
													finishFlush: zlib.constants.Z_SYNC_FLUSH,
												}),
											);
										} else if (coding === "deflate") {
											decoders.push(zlib.createInflate());
										} else if (coding === "br") {
											decoders.push(zlib.createBrotliDecompress());
										} else {
											decoders.length = 0;
											break;
										}
									}
								}
								resolve({
									status,
									statusText,
									headersList: headers[kHeadersList],
									body: decoders.length
										? pipeline(this.body, ...decoders, () => {})
										: this.body.on("error", () => {}),
								});
								return true;
							},
							onData(chunk) {
								if (fetchParams.controller.dump) {
									return;
								}
								const bytes = chunk;
								timingInfo.encodedBodySize += bytes.byteLength;
								return this.body.push(bytes);
							},
							onComplete() {
								if (this.abort) {
									fetchParams.controller.off("terminated", this.abort);
								}
								fetchParams.controller.ended = true;
								this.body.push(null);
							},
							onError(error) {
								if (this.abort) {
									fetchParams.controller.off("terminated", this.abort);
								}
								this.body?.destroy(error);
								fetchParams.controller.terminate(error);
								reject(error);
							},
							onUpgrade(status, headersList, socket) {
								if (status !== 101) {
									return;
								}
								const headers = new Headers2();
								for (let n = 0; n < headersList.length; n += 2) {
									const key = headersList[n + 0].toString("latin1");
									const val = headersList[n + 1].toString("latin1");
									headers[kHeadersList].append(key, val);
								}
								resolve({
									status,
									statusText: STATUS_CODES[status],
									headersList: headers[kHeadersList],
									socket,
								});
								return true;
							},
						},
					),
				);
			}
		}
		module2.exports = {
			fetch: fetch2,
			Fetch,
			fetching,
			finalizeAndReportTiming,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fileapi/symbols.js
var require_symbols3 = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fileapi/symbols.js"(
		exports2,
		module2,
	) {
		"use strict";
		module2.exports = {
			kState: Symbol("FileReader state"),
			kResult: Symbol("FileReader result"),
			kError: Symbol("FileReader error"),
			kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
			kEvents: Symbol("FileReader events"),
			kAborted: Symbol("FileReader aborted"),
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fileapi/progressevent.js
var require_progressevent = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fileapi/progressevent.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { webidl } = require_webidl();
		var kState = Symbol("ProgressEvent state");
		var ProgressEvent = class _ProgressEvent extends Event {
			constructor(type, eventInitDict = {}) {
				type = webidl.converters.DOMString(type);
				eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
				super(type, eventInitDict);
				this[kState] = {
					lengthComputable: eventInitDict.lengthComputable,
					loaded: eventInitDict.loaded,
					total: eventInitDict.total,
				};
			}
			get lengthComputable() {
				webidl.brandCheck(this, _ProgressEvent);
				return this[kState].lengthComputable;
			}
			get loaded() {
				webidl.brandCheck(this, _ProgressEvent);
				return this[kState].loaded;
			}
			get total() {
				webidl.brandCheck(this, _ProgressEvent);
				return this[kState].total;
			}
		};
		webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
			{
				key: "lengthComputable",
				converter: webidl.converters.boolean,
				defaultValue: false,
			},
			{
				key: "loaded",
				converter: webidl.converters["unsigned long long"],
				defaultValue: 0,
			},
			{
				key: "total",
				converter: webidl.converters["unsigned long long"],
				defaultValue: 0,
			},
			{
				key: "bubbles",
				converter: webidl.converters.boolean,
				defaultValue: false,
			},
			{
				key: "cancelable",
				converter: webidl.converters.boolean,
				defaultValue: false,
			},
			{
				key: "composed",
				converter: webidl.converters.boolean,
				defaultValue: false,
			},
		]);
		module2.exports = {
			ProgressEvent,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fileapi/encoding.js
var require_encoding = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fileapi/encoding.js"(
		exports2,
		module2,
	) {
		"use strict";
		function getEncoding(label) {
			if (!label) {
				return "failure";
			}
			switch (label.trim().toLowerCase()) {
				case "unicode-1-1-utf-8":
				case "unicode11utf8":
				case "unicode20utf8":
				case "utf-8":
				case "utf8":
				case "x-unicode20utf8":
					return "UTF-8";
				case "866":
				case "cp866":
				case "csibm866":
				case "ibm866":
					return "IBM866";
				case "csisolatin2":
				case "iso-8859-2":
				case "iso-ir-101":
				case "iso8859-2":
				case "iso88592":
				case "iso_8859-2":
				case "iso_8859-2:1987":
				case "l2":
				case "latin2":
					return "ISO-8859-2";
				case "csisolatin3":
				case "iso-8859-3":
				case "iso-ir-109":
				case "iso8859-3":
				case "iso88593":
				case "iso_8859-3":
				case "iso_8859-3:1988":
				case "l3":
				case "latin3":
					return "ISO-8859-3";
				case "csisolatin4":
				case "iso-8859-4":
				case "iso-ir-110":
				case "iso8859-4":
				case "iso88594":
				case "iso_8859-4":
				case "iso_8859-4:1988":
				case "l4":
				case "latin4":
					return "ISO-8859-4";
				case "csisolatincyrillic":
				case "cyrillic":
				case "iso-8859-5":
				case "iso-ir-144":
				case "iso8859-5":
				case "iso88595":
				case "iso_8859-5":
				case "iso_8859-5:1988":
					return "ISO-8859-5";
				case "arabic":
				case "asmo-708":
				case "csiso88596e":
				case "csiso88596i":
				case "csisolatinarabic":
				case "ecma-114":
				case "iso-8859-6":
				case "iso-8859-6-e":
				case "iso-8859-6-i":
				case "iso-ir-127":
				case "iso8859-6":
				case "iso88596":
				case "iso_8859-6":
				case "iso_8859-6:1987":
					return "ISO-8859-6";
				case "csisolatingreek":
				case "ecma-118":
				case "elot_928":
				case "greek":
				case "greek8":
				case "iso-8859-7":
				case "iso-ir-126":
				case "iso8859-7":
				case "iso88597":
				case "iso_8859-7":
				case "iso_8859-7:1987":
				case "sun_eu_greek":
					return "ISO-8859-7";
				case "csiso88598e":
				case "csisolatinhebrew":
				case "hebrew":
				case "iso-8859-8":
				case "iso-8859-8-e":
				case "iso-ir-138":
				case "iso8859-8":
				case "iso88598":
				case "iso_8859-8":
				case "iso_8859-8:1988":
				case "visual":
					return "ISO-8859-8";
				case "csiso88598i":
				case "iso-8859-8-i":
				case "logical":
					return "ISO-8859-8-I";
				case "csisolatin6":
				case "iso-8859-10":
				case "iso-ir-157":
				case "iso8859-10":
				case "iso885910":
				case "l6":
				case "latin6":
					return "ISO-8859-10";
				case "iso-8859-13":
				case "iso8859-13":
				case "iso885913":
					return "ISO-8859-13";
				case "iso-8859-14":
				case "iso8859-14":
				case "iso885914":
					return "ISO-8859-14";
				case "csisolatin9":
				case "iso-8859-15":
				case "iso8859-15":
				case "iso885915":
				case "iso_8859-15":
				case "l9":
					return "ISO-8859-15";
				case "iso-8859-16":
					return "ISO-8859-16";
				case "cskoi8r":
				case "koi":
				case "koi8":
				case "koi8-r":
				case "koi8_r":
					return "KOI8-R";
				case "koi8-ru":
				case "koi8-u":
					return "KOI8-U";
				case "csmacintosh":
				case "mac":
				case "macintosh":
				case "x-mac-roman":
					return "macintosh";
				case "iso-8859-11":
				case "iso8859-11":
				case "iso885911":
				case "tis-620":
				case "windows-874":
					return "windows-874";
				case "cp1250":
				case "windows-1250":
				case "x-cp1250":
					return "windows-1250";
				case "cp1251":
				case "windows-1251":
				case "x-cp1251":
					return "windows-1251";
				case "ansi_x3.4-1968":
				case "ascii":
				case "cp1252":
				case "cp819":
				case "csisolatin1":
				case "ibm819":
				case "iso-8859-1":
				case "iso-ir-100":
				case "iso8859-1":
				case "iso88591":
				case "iso_8859-1":
				case "iso_8859-1:1987":
				case "l1":
				case "latin1":
				case "us-ascii":
				case "windows-1252":
				case "x-cp1252":
					return "windows-1252";
				case "cp1253":
				case "windows-1253":
				case "x-cp1253":
					return "windows-1253";
				case "cp1254":
				case "csisolatin5":
				case "iso-8859-9":
				case "iso-ir-148":
				case "iso8859-9":
				case "iso88599":
				case "iso_8859-9":
				case "iso_8859-9:1989":
				case "l5":
				case "latin5":
				case "windows-1254":
				case "x-cp1254":
					return "windows-1254";
				case "cp1255":
				case "windows-1255":
				case "x-cp1255":
					return "windows-1255";
				case "cp1256":
				case "windows-1256":
				case "x-cp1256":
					return "windows-1256";
				case "cp1257":
				case "windows-1257":
				case "x-cp1257":
					return "windows-1257";
				case "cp1258":
				case "windows-1258":
				case "x-cp1258":
					return "windows-1258";
				case "x-mac-cyrillic":
				case "x-mac-ukrainian":
					return "x-mac-cyrillic";
				case "chinese":
				case "csgb2312":
				case "csiso58gb231280":
				case "gb2312":
				case "gb_2312":
				case "gb_2312-80":
				case "gbk":
				case "iso-ir-58":
				case "x-gbk":
					return "GBK";
				case "gb18030":
					return "gb18030";
				case "big5":
				case "big5-hkscs":
				case "cn-big5":
				case "csbig5":
				case "x-x-big5":
					return "Big5";
				case "cseucpkdfmtjapanese":
				case "euc-jp":
				case "x-euc-jp":
					return "EUC-JP";
				case "csiso2022jp":
				case "iso-2022-jp":
					return "ISO-2022-JP";
				case "csshiftjis":
				case "ms932":
				case "ms_kanji":
				case "shift-jis":
				case "shift_jis":
				case "sjis":
				case "windows-31j":
				case "x-sjis":
					return "Shift_JIS";
				case "cseuckr":
				case "csksc56011987":
				case "euc-kr":
				case "iso-ir-149":
				case "korean":
				case "ks_c_5601-1987":
				case "ks_c_5601-1989":
				case "ksc5601":
				case "ksc_5601":
				case "windows-949":
					return "EUC-KR";
				case "csiso2022kr":
				case "hz-gb-2312":
				case "iso-2022-cn":
				case "iso-2022-cn-ext":
				case "iso-2022-kr":
				case "replacement":
					return "replacement";
				case "unicodefffe":
				case "utf-16be":
					return "UTF-16BE";
				case "csunicode":
				case "iso-10646-ucs-2":
				case "ucs-2":
				case "unicode":
				case "unicodefeff":
				case "utf-16":
				case "utf-16le":
					return "UTF-16LE";
				case "x-user-defined":
					return "x-user-defined";
				default:
					return "failure";
			}
		}
		module2.exports = {
			getEncoding,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fileapi/util.js
var require_util5 = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fileapi/util.js"(exports2, module2) {
		"use strict";
		var { kState, kError, kResult, kAborted, kLastProgressEventFired } = require_symbols3();
		var { ProgressEvent } = require_progressevent();
		var { getEncoding } = require_encoding();
		var { DOMException: DOMException2 } = require_constants3();
		var { serializeAMimeType, parseMIMEType } = require_dataURL();
		var { types } = require("util");
		var { StringDecoder } = require("string_decoder");
		var { btoa } = require("buffer");
		var staticPropertyDescriptors = {
			enumerable: true,
			writable: false,
			configurable: false,
		};
		function readOperation(fr, blob, type, encodingName) {
			if (fr[kState] === "loading") {
				throw new DOMException2("Invalid state", "InvalidStateError");
			}
			fr[kState] = "loading";
			fr[kResult] = null;
			fr[kError] = null;
			const stream = blob.stream();
			const reader = stream.getReader();
			const bytes = [];
			let chunkPromise = reader.read();
			let isFirstChunk = true;
			(async () => {
				while (!fr[kAborted]) {
					try {
						const { done, value } = await chunkPromise;
						if (isFirstChunk && !fr[kAborted]) {
							queueMicrotask(() => {
								fireAProgressEvent("loadstart", fr);
							});
						}
						isFirstChunk = false;
						if (!done && types.isUint8Array(value)) {
							bytes.push(value);
							if (
								(fr[kLastProgressEventFired] === void 0 ||
									Date.now() - fr[kLastProgressEventFired] >= 50) &&
								!fr[kAborted]
							) {
								fr[kLastProgressEventFired] = Date.now();
								queueMicrotask(() => {
									fireAProgressEvent("progress", fr);
								});
							}
							chunkPromise = reader.read();
						} else if (done) {
							queueMicrotask(() => {
								fr[kState] = "done";
								try {
									const result = packageData(
										bytes,
										type,
										blob.type,
										encodingName,
									);
									if (fr[kAborted]) {
										return;
									}
									fr[kResult] = result;
									fireAProgressEvent("load", fr);
								} catch (error) {
									fr[kError] = error;
									fireAProgressEvent("error", fr);
								}
								if (fr[kState] !== "loading") {
									fireAProgressEvent("loadend", fr);
								}
							});
							break;
						}
					} catch (error) {
						if (fr[kAborted]) {
							return;
						}
						queueMicrotask(() => {
							fr[kState] = "done";
							fr[kError] = error;
							fireAProgressEvent("error", fr);
							if (fr[kState] !== "loading") {
								fireAProgressEvent("loadend", fr);
							}
						});
						break;
					}
				}
			})();
		}
		function fireAProgressEvent(e, reader) {
			const event = new ProgressEvent(e, {
				bubbles: false,
				cancelable: false,
			});
			reader.dispatchEvent(event);
		}
		function packageData(bytes, type, mimeType, encodingName) {
			switch (type) {
				case "DataURL": {
					let dataURL = "data:";
					const parsed = parseMIMEType(mimeType || "application/octet-stream");
					if (parsed !== "failure") {
						dataURL += serializeAMimeType(parsed);
					}
					dataURL += ";base64,";
					const decoder = new StringDecoder("latin1");
					for (const chunk of bytes) {
						dataURL += btoa(decoder.write(chunk));
					}
					dataURL += btoa(decoder.end());
					return dataURL;
				}
				case "Text": {
					let encoding = "failure";
					if (encodingName) {
						encoding = getEncoding(encodingName);
					}
					if (encoding === "failure" && mimeType) {
						const type2 = parseMIMEType(mimeType);
						if (type2 !== "failure") {
							encoding = getEncoding(type2.parameters.get("charset"));
						}
					}
					if (encoding === "failure") {
						encoding = "UTF-8";
					}
					return decode(bytes, encoding);
				}
				case "ArrayBuffer": {
					const sequence = combineByteSequences(bytes);
					return sequence.buffer;
				}
				case "BinaryString": {
					let binaryString = "";
					const decoder = new StringDecoder("latin1");
					for (const chunk of bytes) {
						binaryString += decoder.write(chunk);
					}
					binaryString += decoder.end();
					return binaryString;
				}
			}
		}
		function decode(ioQueue, encoding) {
			const bytes = combineByteSequences(ioQueue);
			const BOMEncoding = BOMSniffing(bytes);
			let slice = 0;
			if (BOMEncoding !== null) {
				encoding = BOMEncoding;
				slice = BOMEncoding === "UTF-8" ? 3 : 2;
			}
			const sliced = bytes.slice(slice);
			return new TextDecoder(encoding).decode(sliced);
		}
		function BOMSniffing(ioQueue) {
			const [a, b, c] = ioQueue;
			if (a === 239 && b === 187 && c === 191) {
				return "UTF-8";
			} else if (a === 254 && b === 255) {
				return "UTF-16BE";
			} else if (a === 255 && b === 254) {
				return "UTF-16LE";
			}
			return null;
		}
		function combineByteSequences(sequences) {
			const size = sequences.reduce((a, b) => {
				return a + b.byteLength;
			}, 0);
			let offset = 0;
			return sequences.reduce((a, b) => {
				a.set(b, offset);
				offset += b.byteLength;
				return a;
			}, new Uint8Array(size));
		}
		module2.exports = {
			staticPropertyDescriptors,
			readOperation,
			fireAProgressEvent,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fileapi/filereader.js
var require_filereader = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/fileapi/filereader.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { staticPropertyDescriptors, readOperation, fireAProgressEvent } = require_util5();
		var { kState, kError, kResult, kEvents, kAborted } = require_symbols3();
		var { webidl } = require_webidl();
		var { kEnumerableProperty } = require_util2();
		var FileReader = class _FileReader extends EventTarget {
			constructor() {
				super();
				this[kState] = "empty";
				this[kResult] = null;
				this[kError] = null;
				this[kEvents] = {
					loadend: null,
					error: null,
					abort: null,
					load: null,
					progress: null,
					loadstart: null,
				};
			}
			/**
			 * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
			 * @param {import('buffer').Blob} blob
			 */
			readAsArrayBuffer(blob) {
				webidl.brandCheck(this, _FileReader);
				webidl.argumentLengthCheck(arguments, 1, {
					header: "FileReader.readAsArrayBuffer",
				});
				blob = webidl.converters.Blob(blob, { strict: false });
				readOperation(this, blob, "ArrayBuffer");
			}
			/**
			 * @see https://w3c.github.io/FileAPI/#readAsBinaryString
			 * @param {import('buffer').Blob} blob
			 */
			readAsBinaryString(blob) {
				webidl.brandCheck(this, _FileReader);
				webidl.argumentLengthCheck(arguments, 1, {
					header: "FileReader.readAsBinaryString",
				});
				blob = webidl.converters.Blob(blob, { strict: false });
				readOperation(this, blob, "BinaryString");
			}
			/**
			 * @see https://w3c.github.io/FileAPI/#readAsDataText
			 * @param {import('buffer').Blob} blob
			 * @param {string?} encoding
			 */
			readAsText(blob, encoding = void 0) {
				webidl.brandCheck(this, _FileReader);
				webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" });
				blob = webidl.converters.Blob(blob, { strict: false });
				if (encoding !== void 0) {
					encoding = webidl.converters.DOMString(encoding);
				}
				readOperation(this, blob, "Text", encoding);
			}
			/**
			 * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
			 * @param {import('buffer').Blob} blob
			 */
			readAsDataURL(blob) {
				webidl.brandCheck(this, _FileReader);
				webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" });
				blob = webidl.converters.Blob(blob, { strict: false });
				readOperation(this, blob, "DataURL");
			}
			/**
			 * @see https://w3c.github.io/FileAPI/#dfn-abort
			 */
			abort() {
				if (this[kState] === "empty" || this[kState] === "done") {
					this[kResult] = null;
					return;
				}
				if (this[kState] === "loading") {
					this[kState] = "done";
					this[kResult] = null;
				}
				this[kAborted] = true;
				fireAProgressEvent("abort", this);
				if (this[kState] !== "loading") {
					fireAProgressEvent("loadend", this);
				}
			}
			/**
			 * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
			 */
			get readyState() {
				webidl.brandCheck(this, _FileReader);
				switch (this[kState]) {
					case "empty":
						return this.EMPTY;
					case "loading":
						return this.LOADING;
					case "done":
						return this.DONE;
				}
			}
			/**
			 * @see https://w3c.github.io/FileAPI/#dom-filereader-result
			 */
			get result() {
				webidl.brandCheck(this, _FileReader);
				return this[kResult];
			}
			/**
			 * @see https://w3c.github.io/FileAPI/#dom-filereader-error
			 */
			get error() {
				webidl.brandCheck(this, _FileReader);
				return this[kError];
			}
			get onloadend() {
				webidl.brandCheck(this, _FileReader);
				return this[kEvents].loadend;
			}
			set onloadend(fn) {
				webidl.brandCheck(this, _FileReader);
				if (this[kEvents].loadend) {
					this.removeEventListener("loadend", this[kEvents].loadend);
				}
				if (typeof fn === "function") {
					this[kEvents].loadend = fn;
					this.addEventListener("loadend", fn);
				} else {
					this[kEvents].loadend = null;
				}
			}
			get onerror() {
				webidl.brandCheck(this, _FileReader);
				return this[kEvents].error;
			}
			set onerror(fn) {
				webidl.brandCheck(this, _FileReader);
				if (this[kEvents].error) {
					this.removeEventListener("error", this[kEvents].error);
				}
				if (typeof fn === "function") {
					this[kEvents].error = fn;
					this.addEventListener("error", fn);
				} else {
					this[kEvents].error = null;
				}
			}
			get onloadstart() {
				webidl.brandCheck(this, _FileReader);
				return this[kEvents].loadstart;
			}
			set onloadstart(fn) {
				webidl.brandCheck(this, _FileReader);
				if (this[kEvents].loadstart) {
					this.removeEventListener("loadstart", this[kEvents].loadstart);
				}
				if (typeof fn === "function") {
					this[kEvents].loadstart = fn;
					this.addEventListener("loadstart", fn);
				} else {
					this[kEvents].loadstart = null;
				}
			}
			get onprogress() {
				webidl.brandCheck(this, _FileReader);
				return this[kEvents].progress;
			}
			set onprogress(fn) {
				webidl.brandCheck(this, _FileReader);
				if (this[kEvents].progress) {
					this.removeEventListener("progress", this[kEvents].progress);
				}
				if (typeof fn === "function") {
					this[kEvents].progress = fn;
					this.addEventListener("progress", fn);
				} else {
					this[kEvents].progress = null;
				}
			}
			get onload() {
				webidl.brandCheck(this, _FileReader);
				return this[kEvents].load;
			}
			set onload(fn) {
				webidl.brandCheck(this, _FileReader);
				if (this[kEvents].load) {
					this.removeEventListener("load", this[kEvents].load);
				}
				if (typeof fn === "function") {
					this[kEvents].load = fn;
					this.addEventListener("load", fn);
				} else {
					this[kEvents].load = null;
				}
			}
			get onabort() {
				webidl.brandCheck(this, _FileReader);
				return this[kEvents].abort;
			}
			set onabort(fn) {
				webidl.brandCheck(this, _FileReader);
				if (this[kEvents].abort) {
					this.removeEventListener("abort", this[kEvents].abort);
				}
				if (typeof fn === "function") {
					this[kEvents].abort = fn;
					this.addEventListener("abort", fn);
				} else {
					this[kEvents].abort = null;
				}
			}
		};
		FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
		FileReader.LOADING = FileReader.prototype.LOADING = 1;
		FileReader.DONE = FileReader.prototype.DONE = 2;
		Object.defineProperties(FileReader.prototype, {
			EMPTY: staticPropertyDescriptors,
			LOADING: staticPropertyDescriptors,
			DONE: staticPropertyDescriptors,
			readAsArrayBuffer: kEnumerableProperty,
			readAsBinaryString: kEnumerableProperty,
			readAsText: kEnumerableProperty,
			readAsDataURL: kEnumerableProperty,
			abort: kEnumerableProperty,
			readyState: kEnumerableProperty,
			result: kEnumerableProperty,
			error: kEnumerableProperty,
			onloadstart: kEnumerableProperty,
			onprogress: kEnumerableProperty,
			onload: kEnumerableProperty,
			onabort: kEnumerableProperty,
			onerror: kEnumerableProperty,
			onloadend: kEnumerableProperty,
			[Symbol.toStringTag]: {
				value: "FileReader",
				writable: false,
				enumerable: false,
				configurable: true,
			},
		});
		Object.defineProperties(FileReader, {
			EMPTY: staticPropertyDescriptors,
			LOADING: staticPropertyDescriptors,
			DONE: staticPropertyDescriptors,
		});
		module2.exports = {
			FileReader,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/cache/symbols.js
var require_symbols4 = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/cache/symbols.js"(exports2, module2) {
		"use strict";
		module2.exports = {
			kConstruct: require_symbols().kConstruct,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/cache/util.js
var require_util6 = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/cache/util.js"(exports2, module2) {
		"use strict";
		var assert = require("assert");
		var { URLSerializer } = require_dataURL();
		var { isValidHeaderName } = require_util3();
		function urlEquals(A, B, excludeFragment = false) {
			const serializedA = URLSerializer(A, excludeFragment);
			const serializedB = URLSerializer(B, excludeFragment);
			return serializedA === serializedB;
		}
		function fieldValues(header) {
			assert(header !== null);
			const values = [];
			for (let value of header.split(",")) {
				value = value.trim();
				if (!value.length) {
					continue;
				} else if (!isValidHeaderName(value)) {
					continue;
				}
				values.push(value);
			}
			return values;
		}
		module2.exports = {
			urlEquals,
			fieldValues,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/cache/cache.js
var require_cache = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/cache/cache.js"(exports2, module2) {
		"use strict";
		var { kConstruct } = require_symbols4();
		var { urlEquals, fieldValues: getFieldValues } = require_util6();
		var { kEnumerableProperty, isDisturbed } = require_util2();
		var { kHeadersList } = require_symbols();
		var { webidl } = require_webidl();
		var { Response, cloneResponse } = require_response();
		var { Request } = require_request2();
		var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
		var { fetching } = require_fetch();
		var { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util3();
		var assert = require("assert");
		var { getGlobalDispatcher } = require_global2();
		var Cache = class _Cache {
			/**
			 * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
			 * @type {requestResponseList}
			 */
			#relevantRequestResponseList;
			constructor() {
				if (arguments[0] !== kConstruct) {
					webidl.illegalConstructor();
				}
				this.#relevantRequestResponseList = arguments[1];
			}
			async match(request, options = {}) {
				webidl.brandCheck(this, _Cache);
				webidl.argumentLengthCheck(arguments, 1, { header: "Cache.match" });
				request = webidl.converters.RequestInfo(request);
				options = webidl.converters.CacheQueryOptions(options);
				const p = await this.matchAll(request, options);
				if (p.length === 0) {
					return;
				}
				return p[0];
			}
			async matchAll(request = void 0, options = {}) {
				webidl.brandCheck(this, _Cache);
				if (request !== void 0) request = webidl.converters.RequestInfo(request);
				options = webidl.converters.CacheQueryOptions(options);
				let r = null;
				if (request !== void 0) {
					if (request instanceof Request) {
						r = request[kState];
						if (r.method !== "GET" && !options.ignoreMethod) {
							return [];
						}
					} else if (typeof request === "string") {
						r = new Request(request)[kState];
					}
				}
				const responses = [];
				if (request === void 0) {
					for (const requestResponse of this.#relevantRequestResponseList) {
						responses.push(requestResponse[1]);
					}
				} else {
					const requestResponses = this.#queryCache(r, options);
					for (const requestResponse of requestResponses) {
						responses.push(requestResponse[1]);
					}
				}
				const responseList = [];
				for (const response of responses) {
					const responseObject = new Response(response.body?.source ?? null);
					const body = responseObject[kState].body;
					responseObject[kState] = response;
					responseObject[kState].body = body;
					responseObject[kHeaders][kHeadersList] = response.headersList;
					responseObject[kHeaders][kGuard] = "immutable";
					responseList.push(responseObject);
				}
				return Object.freeze(responseList);
			}
			async add(request) {
				webidl.brandCheck(this, _Cache);
				webidl.argumentLengthCheck(arguments, 1, { header: "Cache.add" });
				request = webidl.converters.RequestInfo(request);
				const requests = [request];
				const responseArrayPromise = this.addAll(requests);
				return await responseArrayPromise;
			}
			async addAll(requests) {
				webidl.brandCheck(this, _Cache);
				webidl.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });
				requests = webidl.converters["sequence<RequestInfo>"](requests);
				const responsePromises = [];
				const requestList = [];
				for (const request of requests) {
					if (typeof request === "string") {
						continue;
					}
					const r = request[kState];
					if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
						throw webidl.errors.exception({
							header: "Cache.addAll",
							message: "Expected http/s scheme when method is not GET.",
						});
					}
				}
				const fetchControllers = [];
				for (const request of requests) {
					const r = new Request(request)[kState];
					if (!urlIsHttpHttpsScheme(r.url)) {
						throw webidl.errors.exception({
							header: "Cache.addAll",
							message: "Expected http/s scheme.",
						});
					}
					r.initiator = "fetch";
					r.destination = "subresource";
					requestList.push(r);
					const responsePromise = createDeferredPromise();
					fetchControllers.push(
						fetching({
							request: r,
							dispatcher: getGlobalDispatcher(),
							processResponse(response) {
								if (
									response.type === "error" ||
									response.status === 206 ||
									response.status < 200 ||
									response.status > 299
								) {
									responsePromise.reject(
										webidl.errors.exception({
											header: "Cache.addAll",
											message:
												"Received an invalid status code or the request failed.",
										}),
									);
								} else if (response.headersList.contains("vary")) {
									const fieldValues = getFieldValues(
										response.headersList.get("vary"),
									);
									for (const fieldValue of fieldValues) {
										if (fieldValue === "*") {
											responsePromise.reject(
												webidl.errors.exception({
													header: "Cache.addAll",
													message: "invalid vary field value",
												}),
											);
											for (const controller of fetchControllers) {
												controller.abort();
											}
											return;
										}
									}
								}
							},
							processResponseEndOfBody(response) {
								if (response.aborted) {
									responsePromise.reject(
										new DOMException("aborted", "AbortError"),
									);
									return;
								}
								responsePromise.resolve(response);
							},
						}),
					);
					responsePromises.push(responsePromise.promise);
				}
				const p = Promise.all(responsePromises);
				const responses = await p;
				const operations = [];
				let index = 0;
				for (const response of responses) {
					const operation = {
						type: "put",
						// 7.3.2
						request: requestList[index],
						// 7.3.3
						response,
						// 7.3.4
					};
					operations.push(operation);
					index++;
				}
				const cacheJobPromise = createDeferredPromise();
				let errorData = null;
				try {
					this.#batchCacheOperations(operations);
				} catch (e) {
					errorData = e;
				}
				queueMicrotask(() => {
					if (errorData === null) {
						cacheJobPromise.resolve(void 0);
					} else {
						cacheJobPromise.reject(errorData);
					}
				});
				return cacheJobPromise.promise;
			}
			async put(request, response) {
				webidl.brandCheck(this, _Cache);
				webidl.argumentLengthCheck(arguments, 2, { header: "Cache.put" });
				request = webidl.converters.RequestInfo(request);
				response = webidl.converters.Response(response);
				let innerRequest = null;
				if (request instanceof Request) {
					innerRequest = request[kState];
				} else {
					innerRequest = new Request(request)[kState];
				}
				if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
					throw webidl.errors.exception({
						header: "Cache.put",
						message: "Expected an http/s scheme when method is not GET",
					});
				}
				const innerResponse = response[kState];
				if (innerResponse.status === 206) {
					throw webidl.errors.exception({
						header: "Cache.put",
						message: "Got 206 status",
					});
				}
				if (innerResponse.headersList.contains("vary")) {
					const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
					for (const fieldValue of fieldValues) {
						if (fieldValue === "*") {
							throw webidl.errors.exception({
								header: "Cache.put",
								message: "Got * vary field value",
							});
						}
					}
				}
				if (
					innerResponse.body &&
					(isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)
				) {
					throw webidl.errors.exception({
						header: "Cache.put",
						message: "Response body is locked or disturbed",
					});
				}
				const clonedResponse = cloneResponse(innerResponse);
				const bodyReadPromise = createDeferredPromise();
				if (innerResponse.body != null) {
					const stream = innerResponse.body.stream;
					const reader = stream.getReader();
					readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
				} else {
					bodyReadPromise.resolve(void 0);
				}
				const operations = [];
				const operation = {
					type: "put",
					// 14.
					request: innerRequest,
					// 15.
					response: clonedResponse,
					// 16.
				};
				operations.push(operation);
				const bytes = await bodyReadPromise.promise;
				if (clonedResponse.body != null) {
					clonedResponse.body.source = bytes;
				}
				const cacheJobPromise = createDeferredPromise();
				let errorData = null;
				try {
					this.#batchCacheOperations(operations);
				} catch (e) {
					errorData = e;
				}
				queueMicrotask(() => {
					if (errorData === null) {
						cacheJobPromise.resolve();
					} else {
						cacheJobPromise.reject(errorData);
					}
				});
				return cacheJobPromise.promise;
			}
			async delete(request, options = {}) {
				webidl.brandCheck(this, _Cache);
				webidl.argumentLengthCheck(arguments, 1, { header: "Cache.delete" });
				request = webidl.converters.RequestInfo(request);
				options = webidl.converters.CacheQueryOptions(options);
				let r = null;
				if (request instanceof Request) {
					r = request[kState];
					if (r.method !== "GET" && !options.ignoreMethod) {
						return false;
					}
				} else {
					assert(typeof request === "string");
					r = new Request(request)[kState];
				}
				const operations = [];
				const operation = {
					type: "delete",
					request: r,
					options,
				};
				operations.push(operation);
				const cacheJobPromise = createDeferredPromise();
				let errorData = null;
				let requestResponses;
				try {
					requestResponses = this.#batchCacheOperations(operations);
				} catch (e) {
					errorData = e;
				}
				queueMicrotask(() => {
					if (errorData === null) {
						cacheJobPromise.resolve(!!requestResponses?.length);
					} else {
						cacheJobPromise.reject(errorData);
					}
				});
				return cacheJobPromise.promise;
			}
			/**
			 * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
			 * @param {any} request
			 * @param {import('../../types/cache').CacheQueryOptions} options
			 * @returns {readonly Request[]}
			 */
			async keys(request = void 0, options = {}) {
				webidl.brandCheck(this, _Cache);
				if (request !== void 0) request = webidl.converters.RequestInfo(request);
				options = webidl.converters.CacheQueryOptions(options);
				let r = null;
				if (request !== void 0) {
					if (request instanceof Request) {
						r = request[kState];
						if (r.method !== "GET" && !options.ignoreMethod) {
							return [];
						}
					} else if (typeof request === "string") {
						r = new Request(request)[kState];
					}
				}
				const promise = createDeferredPromise();
				const requests = [];
				if (request === void 0) {
					for (const requestResponse of this.#relevantRequestResponseList) {
						requests.push(requestResponse[0]);
					}
				} else {
					const requestResponses = this.#queryCache(r, options);
					for (const requestResponse of requestResponses) {
						requests.push(requestResponse[0]);
					}
				}
				queueMicrotask(() => {
					const requestList = [];
					for (const request2 of requests) {
						const requestObject = new Request("https://a");
						requestObject[kState] = request2;
						requestObject[kHeaders][kHeadersList] = request2.headersList;
						requestObject[kHeaders][kGuard] = "immutable";
						requestObject[kRealm] = request2.client;
						requestList.push(requestObject);
					}
					promise.resolve(Object.freeze(requestList));
				});
				return promise.promise;
			}
			/**
			 * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
			 * @param {CacheBatchOperation[]} operations
			 * @returns {requestResponseList}
			 */
			#batchCacheOperations(operations) {
				const cache = this.#relevantRequestResponseList;
				const backupCache = [...cache];
				const addedItems = [];
				const resultList = [];
				try {
					for (const operation of operations) {
						if (operation.type !== "delete" && operation.type !== "put") {
							throw webidl.errors.exception({
								header: "Cache.#batchCacheOperations",
								message: 'operation type does not match "delete" or "put"',
							});
						}
						if (operation.type === "delete" && operation.response != null) {
							throw webidl.errors.exception({
								header: "Cache.#batchCacheOperations",
								message: "delete operation should not have an associated response",
							});
						}
						if (
							this.#queryCache(operation.request, operation.options, addedItems)
								.length
						) {
							throw new DOMException("???", "InvalidStateError");
						}
						let requestResponses;
						if (operation.type === "delete") {
							requestResponses = this.#queryCache(
								operation.request,
								operation.options,
							);
							if (requestResponses.length === 0) {
								return [];
							}
							for (const requestResponse of requestResponses) {
								const idx = cache.indexOf(requestResponse);
								assert(idx !== -1);
								cache.splice(idx, 1);
							}
						} else if (operation.type === "put") {
							if (operation.response == null) {
								throw webidl.errors.exception({
									header: "Cache.#batchCacheOperations",
									message: "put operation should have an associated response",
								});
							}
							const r = operation.request;
							if (!urlIsHttpHttpsScheme(r.url)) {
								throw webidl.errors.exception({
									header: "Cache.#batchCacheOperations",
									message: "expected http or https scheme",
								});
							}
							if (r.method !== "GET") {
								throw webidl.errors.exception({
									header: "Cache.#batchCacheOperations",
									message: "not get method",
								});
							}
							if (operation.options != null) {
								throw webidl.errors.exception({
									header: "Cache.#batchCacheOperations",
									message: "options must not be defined",
								});
							}
							requestResponses = this.#queryCache(operation.request);
							for (const requestResponse of requestResponses) {
								const idx = cache.indexOf(requestResponse);
								assert(idx !== -1);
								cache.splice(idx, 1);
							}
							cache.push([operation.request, operation.response]);
							addedItems.push([operation.request, operation.response]);
						}
						resultList.push([operation.request, operation.response]);
					}
					return resultList;
				} catch (e) {
					this.#relevantRequestResponseList.length = 0;
					this.#relevantRequestResponseList = backupCache;
					throw e;
				}
			}
			/**
			 * @see https://w3c.github.io/ServiceWorker/#query-cache
			 * @param {any} requestQuery
			 * @param {import('../../types/cache').CacheQueryOptions} options
			 * @param {requestResponseList} targetStorage
			 * @returns {requestResponseList}
			 */
			#queryCache(requestQuery, options, targetStorage) {
				const resultList = [];
				const storage = targetStorage ?? this.#relevantRequestResponseList;
				for (const requestResponse of storage) {
					const [cachedRequest, cachedResponse] = requestResponse;
					if (
						this.#requestMatchesCachedItem(
							requestQuery,
							cachedRequest,
							cachedResponse,
							options,
						)
					) {
						resultList.push(requestResponse);
					}
				}
				return resultList;
			}
			/**
			 * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
			 * @param {any} requestQuery
			 * @param {any} request
			 * @param {any | null} response
			 * @param {import('../../types/cache').CacheQueryOptions | undefined} options
			 * @returns {boolean}
			 */
			#requestMatchesCachedItem(requestQuery, request, response = null, options) {
				const queryURL = new URL(requestQuery.url);
				const cachedURL = new URL(request.url);
				if (options?.ignoreSearch) {
					cachedURL.search = "";
					queryURL.search = "";
				}
				if (!urlEquals(queryURL, cachedURL, true)) {
					return false;
				}
				if (
					response == null ||
					options?.ignoreVary ||
					!response.headersList.contains("vary")
				) {
					return true;
				}
				const fieldValues = getFieldValues(response.headersList.get("vary"));
				for (const fieldValue of fieldValues) {
					if (fieldValue === "*") {
						return false;
					}
					const requestValue = request.headersList.get(fieldValue);
					const queryValue = requestQuery.headersList.get(fieldValue);
					if (requestValue !== queryValue) {
						return false;
					}
				}
				return true;
			}
		};
		Object.defineProperties(Cache.prototype, {
			[Symbol.toStringTag]: {
				value: "Cache",
				configurable: true,
			},
			match: kEnumerableProperty,
			matchAll: kEnumerableProperty,
			add: kEnumerableProperty,
			addAll: kEnumerableProperty,
			put: kEnumerableProperty,
			delete: kEnumerableProperty,
			keys: kEnumerableProperty,
		});
		var cacheQueryOptionConverters = [
			{
				key: "ignoreSearch",
				converter: webidl.converters.boolean,
				defaultValue: false,
			},
			{
				key: "ignoreMethod",
				converter: webidl.converters.boolean,
				defaultValue: false,
			},
			{
				key: "ignoreVary",
				converter: webidl.converters.boolean,
				defaultValue: false,
			},
		];
		webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(
			cacheQueryOptionConverters,
		);
		webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
			...cacheQueryOptionConverters,
			{
				key: "cacheName",
				converter: webidl.converters.DOMString,
			},
		]);
		webidl.converters.Response = webidl.interfaceConverter(Response);
		webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(
			webidl.converters.RequestInfo,
		);
		module2.exports = {
			Cache,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/cache/cachestorage.js
var require_cachestorage = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/cache/cachestorage.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { kConstruct } = require_symbols4();
		var { Cache } = require_cache();
		var { webidl } = require_webidl();
		var { kEnumerableProperty } = require_util2();
		var CacheStorage = class _CacheStorage {
			/**
			 * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
			 * @type {Map<string, import('./cache').requestResponseList}
			 */
			#caches = /* @__PURE__ */ new Map();
			constructor() {
				if (arguments[0] !== kConstruct) {
					webidl.illegalConstructor();
				}
			}
			async match(request, options = {}) {
				webidl.brandCheck(this, _CacheStorage);
				webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" });
				request = webidl.converters.RequestInfo(request);
				options = webidl.converters.MultiCacheQueryOptions(options);
				if (options.cacheName != null) {
					if (this.#caches.has(options.cacheName)) {
						const cacheList = this.#caches.get(options.cacheName);
						const cache = new Cache(kConstruct, cacheList);
						return await cache.match(request, options);
					}
				} else {
					for (const cacheList of this.#caches.values()) {
						const cache = new Cache(kConstruct, cacheList);
						const response = await cache.match(request, options);
						if (response !== void 0) {
							return response;
						}
					}
				}
			}
			/**
			 * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
			 * @param {string} cacheName
			 * @returns {Promise<boolean>}
			 */
			async has(cacheName) {
				webidl.brandCheck(this, _CacheStorage);
				webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" });
				cacheName = webidl.converters.DOMString(cacheName);
				return this.#caches.has(cacheName);
			}
			/**
			 * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
			 * @param {string} cacheName
			 * @returns {Promise<Cache>}
			 */
			async open(cacheName) {
				webidl.brandCheck(this, _CacheStorage);
				webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" });
				cacheName = webidl.converters.DOMString(cacheName);
				if (this.#caches.has(cacheName)) {
					const cache2 = this.#caches.get(cacheName);
					return new Cache(kConstruct, cache2);
				}
				const cache = [];
				this.#caches.set(cacheName, cache);
				return new Cache(kConstruct, cache);
			}
			/**
			 * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
			 * @param {string} cacheName
			 * @returns {Promise<boolean>}
			 */
			async delete(cacheName) {
				webidl.brandCheck(this, _CacheStorage);
				webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" });
				cacheName = webidl.converters.DOMString(cacheName);
				return this.#caches.delete(cacheName);
			}
			/**
			 * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
			 * @returns {string[]}
			 */
			async keys() {
				webidl.brandCheck(this, _CacheStorage);
				const keys = this.#caches.keys();
				return [...keys];
			}
		};
		Object.defineProperties(CacheStorage.prototype, {
			[Symbol.toStringTag]: {
				value: "CacheStorage",
				configurable: true,
			},
			match: kEnumerableProperty,
			has: kEnumerableProperty,
			open: kEnumerableProperty,
			delete: kEnumerableProperty,
			keys: kEnumerableProperty,
		});
		module2.exports = {
			CacheStorage,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/cookies/constants.js
var require_constants5 = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/cookies/constants.js"(
		exports2,
		module2,
	) {
		"use strict";
		var maxAttributeValueSize = 1024;
		var maxNameValuePairSize = 4096;
		module2.exports = {
			maxAttributeValueSize,
			maxNameValuePairSize,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/cookies/util.js
var require_util7 = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/cookies/util.js"(exports2, module2) {
		"use strict";
		var assert = require("assert");
		var { kHeadersList } = require_symbols();
		function isCTLExcludingHtab(value) {
			if (value.length === 0) {
				return false;
			}
			for (const char of value) {
				const code = char.charCodeAt(0);
				if (code >= 0 || code <= 8 || code >= 10 || code <= 31 || code === 127) {
					return false;
				}
			}
		}
		function validateCookieName(name) {
			for (const char of name) {
				const code = char.charCodeAt(0);
				if (
					code <= 32 ||
					code > 127 ||
					char === "(" ||
					char === ")" ||
					char === ">" ||
					char === "<" ||
					char === "@" ||
					char === "," ||
					char === ";" ||
					char === ":" ||
					char === "\\" ||
					char === '"' ||
					char === "/" ||
					char === "[" ||
					char === "]" ||
					char === "?" ||
					char === "=" ||
					char === "{" ||
					char === "}"
				) {
					throw new Error("Invalid cookie name");
				}
			}
		}
		function validateCookieValue(value) {
			for (const char of value) {
				const code = char.charCodeAt(0);
				if (
					code < 33 || // exclude CTLs (0-31)
					code === 34 ||
					code === 44 ||
					code === 59 ||
					code === 92 ||
					code > 126
				) {
					throw new Error("Invalid header value");
				}
			}
		}
		function validateCookiePath(path) {
			for (const char of path) {
				const code = char.charCodeAt(0);
				if (code < 33 || char === ";") {
					throw new Error("Invalid cookie path");
				}
			}
		}
		function validateCookieDomain(domain) {
			if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
				throw new Error("Invalid cookie domain");
			}
		}
		function toIMFDate(date) {
			if (typeof date === "number") {
				date = new Date(date);
			}
			const days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
			const months = [
				"Jan",
				"Feb",
				"Mar",
				"Apr",
				"May",
				"Jun",
				"Jul",
				"Aug",
				"Sep",
				"Oct",
				"Nov",
				"Dec",
			];
			const dayName = days[date.getUTCDay()];
			const day = date.getUTCDate().toString().padStart(2, "0");
			const month = months[date.getUTCMonth()];
			const year = date.getUTCFullYear();
			const hour = date.getUTCHours().toString().padStart(2, "0");
			const minute = date.getUTCMinutes().toString().padStart(2, "0");
			const second = date.getUTCSeconds().toString().padStart(2, "0");
			return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
		}
		function validateCookieMaxAge(maxAge) {
			if (maxAge < 0) {
				throw new Error("Invalid cookie max-age");
			}
		}
		function stringify(cookie) {
			if (cookie.name.length === 0) {
				return null;
			}
			validateCookieName(cookie.name);
			validateCookieValue(cookie.value);
			const out = [`${cookie.name}=${cookie.value}`];
			if (cookie.name.startsWith("__Secure-")) {
				cookie.secure = true;
			}
			if (cookie.name.startsWith("__Host-")) {
				cookie.secure = true;
				cookie.domain = null;
				cookie.path = "/";
			}
			if (cookie.secure) {
				out.push("Secure");
			}
			if (cookie.httpOnly) {
				out.push("HttpOnly");
			}
			if (typeof cookie.maxAge === "number") {
				validateCookieMaxAge(cookie.maxAge);
				out.push(`Max-Age=${cookie.maxAge}`);
			}
			if (cookie.domain) {
				validateCookieDomain(cookie.domain);
				out.push(`Domain=${cookie.domain}`);
			}
			if (cookie.path) {
				validateCookiePath(cookie.path);
				out.push(`Path=${cookie.path}`);
			}
			if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
				out.push(`Expires=${toIMFDate(cookie.expires)}`);
			}
			if (cookie.sameSite) {
				out.push(`SameSite=${cookie.sameSite}`);
			}
			for (const part of cookie.unparsed) {
				if (!part.includes("=")) {
					throw new Error("Invalid unparsed");
				}
				const [key, ...value] = part.split("=");
				out.push(`${key.trim()}=${value.join("=")}`);
			}
			return out.join("; ");
		}
		var kHeadersListNode;
		function getHeadersList(headers) {
			if (headers[kHeadersList]) {
				return headers[kHeadersList];
			}
			if (!kHeadersListNode) {
				kHeadersListNode = Object.getOwnPropertySymbols(headers).find(
					(symbol) => symbol.description === "headers list",
				);
				assert(kHeadersListNode, "Headers cannot be parsed");
			}
			const headersList = headers[kHeadersListNode];
			assert(headersList);
			return headersList;
		}
		module2.exports = {
			isCTLExcludingHtab,
			stringify,
			getHeadersList,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/cookies/parse.js
var require_parse = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/cookies/parse.js"(exports2, module2) {
		"use strict";
		var { maxNameValuePairSize, maxAttributeValueSize } = require_constants5();
		var { isCTLExcludingHtab } = require_util7();
		var { collectASequenceOfCodePointsFast } = require_dataURL();
		var assert = require("assert");
		function parseSetCookie(header) {
			if (isCTLExcludingHtab(header)) {
				return null;
			}
			let nameValuePair = "";
			let unparsedAttributes = "";
			let name = "";
			let value = "";
			if (header.includes(";")) {
				const position = { position: 0 };
				nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
				unparsedAttributes = header.slice(position.position);
			} else {
				nameValuePair = header;
			}
			if (!nameValuePair.includes("=")) {
				value = nameValuePair;
			} else {
				const position = { position: 0 };
				name = collectASequenceOfCodePointsFast("=", nameValuePair, position);
				value = nameValuePair.slice(position.position + 1);
			}
			name = name.trim();
			value = value.trim();
			if (name.length + value.length > maxNameValuePairSize) {
				return null;
			}
			return {
				name,
				value,
				...parseUnparsedAttributes(unparsedAttributes),
			};
		}
		function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
			if (unparsedAttributes.length === 0) {
				return cookieAttributeList;
			}
			assert(unparsedAttributes[0] === ";");
			unparsedAttributes = unparsedAttributes.slice(1);
			let cookieAv = "";
			if (unparsedAttributes.includes(";")) {
				cookieAv = collectASequenceOfCodePointsFast(";", unparsedAttributes, {
					position: 0,
				});
				unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
			} else {
				cookieAv = unparsedAttributes;
				unparsedAttributes = "";
			}
			let attributeName = "";
			let attributeValue = "";
			if (cookieAv.includes("=")) {
				const position = { position: 0 };
				attributeName = collectASequenceOfCodePointsFast("=", cookieAv, position);
				attributeValue = cookieAv.slice(position.position + 1);
			} else {
				attributeName = cookieAv;
			}
			attributeName = attributeName.trim();
			attributeValue = attributeValue.trim();
			if (attributeValue.length > maxAttributeValueSize) {
				return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
			}
			const attributeNameLowercase = attributeName.toLowerCase();
			if (attributeNameLowercase === "expires") {
				const expiryTime = new Date(attributeValue);
				cookieAttributeList.expires = expiryTime;
			} else if (attributeNameLowercase === "max-age") {
				const charCode = attributeValue.charCodeAt(0);
				if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
					return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
				}
				if (!/^\d+$/.test(attributeValue)) {
					return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
				}
				const deltaSeconds = Number(attributeValue);
				cookieAttributeList.maxAge = deltaSeconds;
			} else if (attributeNameLowercase === "domain") {
				let cookieDomain = attributeValue;
				if (cookieDomain[0] === ".") {
					cookieDomain = cookieDomain.slice(1);
				}
				cookieDomain = cookieDomain.toLowerCase();
				cookieAttributeList.domain = cookieDomain;
			} else if (attributeNameLowercase === "path") {
				let cookiePath = "";
				if (attributeValue.length === 0 || attributeValue[0] !== "/") {
					cookiePath = "/";
				} else {
					cookiePath = attributeValue;
				}
				cookieAttributeList.path = cookiePath;
			} else if (attributeNameLowercase === "secure") {
				cookieAttributeList.secure = true;
			} else if (attributeNameLowercase === "httponly") {
				cookieAttributeList.httpOnly = true;
			} else if (attributeNameLowercase === "samesite") {
				let enforcement = "Default";
				const attributeValueLowercase = attributeValue.toLowerCase();
				if (attributeValueLowercase.includes("none")) {
					enforcement = "None";
				}
				if (attributeValueLowercase.includes("strict")) {
					enforcement = "Strict";
				}
				if (attributeValueLowercase.includes("lax")) {
					enforcement = "Lax";
				}
				cookieAttributeList.sameSite = enforcement;
			} else {
				cookieAttributeList.unparsed ??= [];
				cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
			}
			return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
		}
		module2.exports = {
			parseSetCookie,
			parseUnparsedAttributes,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/cookies/index.js
var require_cookies = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/cookies/index.js"(exports2, module2) {
		"use strict";
		var { parseSetCookie } = require_parse();
		var { stringify, getHeadersList } = require_util7();
		var { webidl } = require_webidl();
		var { Headers: Headers2 } = require_headers();
		function getCookies(headers) {
			webidl.argumentLengthCheck(arguments, 1, { header: "getCookies" });
			webidl.brandCheck(headers, Headers2, { strict: false });
			const cookie = headers.get("cookie");
			const out = {};
			if (!cookie) {
				return out;
			}
			for (const piece of cookie.split(";")) {
				const [name, ...value] = piece.split("=");
				out[name.trim()] = value.join("=");
			}
			return out;
		}
		function deleteCookie(headers, name, attributes) {
			webidl.argumentLengthCheck(arguments, 2, { header: "deleteCookie" });
			webidl.brandCheck(headers, Headers2, { strict: false });
			name = webidl.converters.DOMString(name);
			attributes = webidl.converters.DeleteCookieAttributes(attributes);
			setCookie(headers, {
				name,
				value: "",
				expires: /* @__PURE__ */ new Date(0),
				...attributes,
			});
		}
		function getSetCookies(headers) {
			webidl.argumentLengthCheck(arguments, 1, { header: "getSetCookies" });
			webidl.brandCheck(headers, Headers2, { strict: false });
			const cookies = getHeadersList(headers).cookies;
			if (!cookies) {
				return [];
			}
			return cookies.map((pair) => parseSetCookie(Array.isArray(pair) ? pair[1] : pair));
		}
		function setCookie(headers, cookie) {
			webidl.argumentLengthCheck(arguments, 2, { header: "setCookie" });
			webidl.brandCheck(headers, Headers2, { strict: false });
			cookie = webidl.converters.Cookie(cookie);
			const str = stringify(cookie);
			if (str) {
				headers.append("Set-Cookie", stringify(cookie));
			}
		}
		webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
			{
				converter: webidl.nullableConverter(webidl.converters.DOMString),
				key: "path",
				defaultValue: null,
			},
			{
				converter: webidl.nullableConverter(webidl.converters.DOMString),
				key: "domain",
				defaultValue: null,
			},
		]);
		webidl.converters.Cookie = webidl.dictionaryConverter([
			{
				converter: webidl.converters.DOMString,
				key: "name",
			},
			{
				converter: webidl.converters.DOMString,
				key: "value",
			},
			{
				converter: webidl.nullableConverter((value) => {
					if (typeof value === "number") {
						return webidl.converters["unsigned long long"](value);
					}
					return new Date(value);
				}),
				key: "expires",
				defaultValue: null,
			},
			{
				converter: webidl.nullableConverter(webidl.converters["long long"]),
				key: "maxAge",
				defaultValue: null,
			},
			{
				converter: webidl.nullableConverter(webidl.converters.DOMString),
				key: "domain",
				defaultValue: null,
			},
			{
				converter: webidl.nullableConverter(webidl.converters.DOMString),
				key: "path",
				defaultValue: null,
			},
			{
				converter: webidl.nullableConverter(webidl.converters.boolean),
				key: "secure",
				defaultValue: null,
			},
			{
				converter: webidl.nullableConverter(webidl.converters.boolean),
				key: "httpOnly",
				defaultValue: null,
			},
			{
				converter: webidl.converters.USVString,
				key: "sameSite",
				allowedValues: ["Strict", "Lax", "None"],
			},
			{
				converter: webidl.sequenceConverter(webidl.converters.DOMString),
				key: "unparsed",
				defaultValue: [],
			},
		]);
		module2.exports = {
			getCookies,
			deleteCookie,
			getSetCookies,
			setCookie,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/websocket/constants.js
var require_constants6 = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/websocket/constants.js"(
		exports2,
		module2,
	) {
		"use strict";
		var uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
		var staticPropertyDescriptors = {
			enumerable: true,
			writable: false,
			configurable: false,
		};
		var states = {
			CONNECTING: 0,
			OPEN: 1,
			CLOSING: 2,
			CLOSED: 3,
		};
		var opcodes = {
			CONTINUATION: 0,
			TEXT: 1,
			BINARY: 2,
			CLOSE: 8,
			PING: 9,
			PONG: 10,
		};
		var maxUnsigned16Bit = 2 ** 16 - 1;
		var parserStates = {
			INFO: 0,
			PAYLOADLENGTH_16: 2,
			PAYLOADLENGTH_64: 3,
			READ_DATA: 4,
		};
		var emptyBuffer = Buffer.allocUnsafe(0);
		module2.exports = {
			uid,
			staticPropertyDescriptors,
			states,
			opcodes,
			maxUnsigned16Bit,
			parserStates,
			emptyBuffer,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/websocket/symbols.js
var require_symbols5 = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/websocket/symbols.js"(
		exports2,
		module2,
	) {
		"use strict";
		module2.exports = {
			kWebSocketURL: Symbol("url"),
			kReadyState: Symbol("ready state"),
			kController: Symbol("controller"),
			kResponse: Symbol("response"),
			kBinaryType: Symbol("binary type"),
			kSentClose: Symbol("sent close"),
			kReceivedClose: Symbol("received close"),
			kByteParser: Symbol("byte parser"),
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/websocket/events.js
var require_events = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/websocket/events.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { webidl } = require_webidl();
		var { kEnumerableProperty } = require_util2();
		var { MessagePort } = require("worker_threads");
		var MessageEvent = class _MessageEvent extends Event {
			#eventInit;
			constructor(type, eventInitDict = {}) {
				webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" });
				type = webidl.converters.DOMString(type);
				eventInitDict = webidl.converters.MessageEventInit(eventInitDict);
				super(type, eventInitDict);
				this.#eventInit = eventInitDict;
			}
			get data() {
				webidl.brandCheck(this, _MessageEvent);
				return this.#eventInit.data;
			}
			get origin() {
				webidl.brandCheck(this, _MessageEvent);
				return this.#eventInit.origin;
			}
			get lastEventId() {
				webidl.brandCheck(this, _MessageEvent);
				return this.#eventInit.lastEventId;
			}
			get source() {
				webidl.brandCheck(this, _MessageEvent);
				return this.#eventInit.source;
			}
			get ports() {
				webidl.brandCheck(this, _MessageEvent);
				if (!Object.isFrozen(this.#eventInit.ports)) {
					Object.freeze(this.#eventInit.ports);
				}
				return this.#eventInit.ports;
			}
			initMessageEvent(
				type,
				bubbles = false,
				cancelable = false,
				data = null,
				origin = "",
				lastEventId = "",
				source = null,
				ports = [],
			) {
				webidl.brandCheck(this, _MessageEvent);
				webidl.argumentLengthCheck(arguments, 1, {
					header: "MessageEvent.initMessageEvent",
				});
				return new _MessageEvent(type, {
					bubbles,
					cancelable,
					data,
					origin,
					lastEventId,
					source,
					ports,
				});
			}
		};
		var CloseEvent = class _CloseEvent extends Event {
			#eventInit;
			constructor(type, eventInitDict = {}) {
				webidl.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" });
				type = webidl.converters.DOMString(type);
				eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
				super(type, eventInitDict);
				this.#eventInit = eventInitDict;
			}
			get wasClean() {
				webidl.brandCheck(this, _CloseEvent);
				return this.#eventInit.wasClean;
			}
			get code() {
				webidl.brandCheck(this, _CloseEvent);
				return this.#eventInit.code;
			}
			get reason() {
				webidl.brandCheck(this, _CloseEvent);
				return this.#eventInit.reason;
			}
		};
		var ErrorEvent = class _ErrorEvent extends Event {
			#eventInit;
			constructor(type, eventInitDict) {
				webidl.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
				super(type, eventInitDict);
				type = webidl.converters.DOMString(type);
				eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
				this.#eventInit = eventInitDict;
			}
			get message() {
				webidl.brandCheck(this, _ErrorEvent);
				return this.#eventInit.message;
			}
			get filename() {
				webidl.brandCheck(this, _ErrorEvent);
				return this.#eventInit.filename;
			}
			get lineno() {
				webidl.brandCheck(this, _ErrorEvent);
				return this.#eventInit.lineno;
			}
			get colno() {
				webidl.brandCheck(this, _ErrorEvent);
				return this.#eventInit.colno;
			}
			get error() {
				webidl.brandCheck(this, _ErrorEvent);
				return this.#eventInit.error;
			}
		};
		Object.defineProperties(MessageEvent.prototype, {
			[Symbol.toStringTag]: {
				value: "MessageEvent",
				configurable: true,
			},
			data: kEnumerableProperty,
			origin: kEnumerableProperty,
			lastEventId: kEnumerableProperty,
			source: kEnumerableProperty,
			ports: kEnumerableProperty,
			initMessageEvent: kEnumerableProperty,
		});
		Object.defineProperties(CloseEvent.prototype, {
			[Symbol.toStringTag]: {
				value: "CloseEvent",
				configurable: true,
			},
			reason: kEnumerableProperty,
			code: kEnumerableProperty,
			wasClean: kEnumerableProperty,
		});
		Object.defineProperties(ErrorEvent.prototype, {
			[Symbol.toStringTag]: {
				value: "ErrorEvent",
				configurable: true,
			},
			message: kEnumerableProperty,
			filename: kEnumerableProperty,
			lineno: kEnumerableProperty,
			colno: kEnumerableProperty,
			error: kEnumerableProperty,
		});
		webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
		webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(
			webidl.converters.MessagePort,
		);
		var eventInit = [
			{
				key: "bubbles",
				converter: webidl.converters.boolean,
				defaultValue: false,
			},
			{
				key: "cancelable",
				converter: webidl.converters.boolean,
				defaultValue: false,
			},
			{
				key: "composed",
				converter: webidl.converters.boolean,
				defaultValue: false,
			},
		];
		webidl.converters.MessageEventInit = webidl.dictionaryConverter([
			...eventInit,
			{
				key: "data",
				converter: webidl.converters.any,
				defaultValue: null,
			},
			{
				key: "origin",
				converter: webidl.converters.USVString,
				defaultValue: "",
			},
			{
				key: "lastEventId",
				converter: webidl.converters.DOMString,
				defaultValue: "",
			},
			{
				key: "source",
				// Node doesn't implement WindowProxy or ServiceWorker, so the only
				// valid value for source is a MessagePort.
				converter: webidl.nullableConverter(webidl.converters.MessagePort),
				defaultValue: null,
			},
			{
				key: "ports",
				converter: webidl.converters["sequence<MessagePort>"],
				get defaultValue() {
					return [];
				},
			},
		]);
		webidl.converters.CloseEventInit = webidl.dictionaryConverter([
			...eventInit,
			{
				key: "wasClean",
				converter: webidl.converters.boolean,
				defaultValue: false,
			},
			{
				key: "code",
				converter: webidl.converters["unsigned short"],
				defaultValue: 0,
			},
			{
				key: "reason",
				converter: webidl.converters.USVString,
				defaultValue: "",
			},
		]);
		webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
			...eventInit,
			{
				key: "message",
				converter: webidl.converters.DOMString,
				defaultValue: "",
			},
			{
				key: "filename",
				converter: webidl.converters.USVString,
				defaultValue: "",
			},
			{
				key: "lineno",
				converter: webidl.converters["unsigned long"],
				defaultValue: 0,
			},
			{
				key: "colno",
				converter: webidl.converters["unsigned long"],
				defaultValue: 0,
			},
			{
				key: "error",
				converter: webidl.converters.any,
			},
		]);
		module2.exports = {
			MessageEvent,
			CloseEvent,
			ErrorEvent,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/websocket/util.js
var require_util8 = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/websocket/util.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } =
			require_symbols5();
		var { states, opcodes } = require_constants6();
		var { MessageEvent, ErrorEvent } = require_events();
		function isEstablished(ws) {
			return ws[kReadyState] === states.OPEN;
		}
		function isClosing(ws) {
			return ws[kReadyState] === states.CLOSING;
		}
		function isClosed(ws) {
			return ws[kReadyState] === states.CLOSED;
		}
		function fireEvent(e, target, eventConstructor = Event, eventInitDict) {
			const event = new eventConstructor(e, eventInitDict);
			target.dispatchEvent(event);
		}
		function websocketMessageReceived(ws, type, data) {
			if (ws[kReadyState] !== states.OPEN) {
				return;
			}
			let dataForEvent;
			if (type === opcodes.TEXT) {
				try {
					dataForEvent = new TextDecoder("utf-8", { fatal: true }).decode(data);
				} catch {
					failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
					return;
				}
			} else if (type === opcodes.BINARY) {
				if (ws[kBinaryType] === "blob") {
					dataForEvent = new Blob([data]);
				} else {
					dataForEvent = new Uint8Array(data).buffer;
				}
			}
			fireEvent("message", ws, MessageEvent, {
				origin: ws[kWebSocketURL].origin,
				data: dataForEvent,
			});
		}
		function isValidSubprotocol(protocol) {
			if (protocol.length === 0) {
				return false;
			}
			for (const char of protocol) {
				const code = char.charCodeAt(0);
				if (
					code < 33 ||
					code > 126 ||
					char === "(" ||
					char === ")" ||
					char === "<" ||
					char === ">" ||
					char === "@" ||
					char === "," ||
					char === ";" ||
					char === ":" ||
					char === "\\" ||
					char === '"' ||
					char === "/" ||
					char === "[" ||
					char === "]" ||
					char === "?" ||
					char === "=" ||
					char === "{" ||
					char === "}" ||
					code === 32 || // SP
					code === 9
				) {
					return false;
				}
			}
			return true;
		}
		function isValidStatusCode(code) {
			if (code >= 1e3 && code < 1015) {
				return (
					code !== 1004 && // reserved
					code !== 1005 && // "MUST NOT be set as a status code"
					code !== 1006
				);
			}
			return code >= 3e3 && code <= 4999;
		}
		function failWebsocketConnection(ws, reason) {
			const { [kController]: controller, [kResponse]: response } = ws;
			controller.abort();
			if (response?.socket && !response.socket.destroyed) {
				response.socket.destroy();
			}
			if (reason) {
				fireEvent("error", ws, ErrorEvent, {
					error: new Error(reason),
				});
			}
		}
		module2.exports = {
			isEstablished,
			isClosing,
			isClosed,
			fireEvent,
			isValidSubprotocol,
			isValidStatusCode,
			failWebsocketConnection,
			websocketMessageReceived,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/websocket/connection.js
var require_connection = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/websocket/connection.js"(
		exports2,
		module2,
	) {
		"use strict";
		var diagnosticsChannel = require("diagnostics_channel");
		var { uid, states } = require_constants6();
		var { kReadyState, kSentClose, kByteParser, kReceivedClose } = require_symbols5();
		var { fireEvent, failWebsocketConnection } = require_util8();
		var { CloseEvent } = require_events();
		var { makeRequest } = require_request2();
		var { fetching } = require_fetch();
		var { Headers: Headers2 } = require_headers();
		var { getGlobalDispatcher } = require_global2();
		var { kHeadersList } = require_symbols();
		var channels = {};
		channels.open = diagnosticsChannel.channel("undici:websocket:open");
		channels.close = diagnosticsChannel.channel("undici:websocket:close");
		channels.socketError = diagnosticsChannel.channel("undici:websocket:socket_error");
		var crypto;
		try {
			crypto = require("crypto");
		} catch {}
		function establishWebSocketConnection(url, protocols, ws, onEstablish, options) {
			const requestURL = url;
			requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
			const request = makeRequest({
				urlList: [requestURL],
				serviceWorkers: "none",
				referrer: "no-referrer",
				mode: "websocket",
				credentials: "include",
				cache: "no-store",
				redirect: "error",
			});
			if (options.headers) {
				const headersList = new Headers2(options.headers)[kHeadersList];
				request.headersList = headersList;
			}
			const keyValue = crypto.randomBytes(16).toString("base64");
			request.headersList.append("sec-websocket-key", keyValue);
			request.headersList.append("sec-websocket-version", "13");
			for (const protocol of protocols) {
				request.headersList.append("sec-websocket-protocol", protocol);
			}
			const permessageDeflate = "";
			const controller = fetching({
				request,
				useParallelQueue: true,
				dispatcher: options.dispatcher ?? getGlobalDispatcher(),
				processResponse(response) {
					if (response.type === "error" || response.status !== 101) {
						failWebsocketConnection(
							ws,
							"Received network error or non-101 status code.",
						);
						return;
					}
					if (
						protocols.length !== 0 &&
						!response.headersList.get("Sec-WebSocket-Protocol")
					) {
						failWebsocketConnection(ws, "Server did not respond with sent protocols.");
						return;
					}
					if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
						failWebsocketConnection(
							ws,
							'Server did not set Upgrade header to "websocket".',
						);
						return;
					}
					if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
						failWebsocketConnection(
							ws,
							'Server did not set Connection header to "upgrade".',
						);
						return;
					}
					const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
					const digest = crypto
						.createHash("sha1")
						.update(keyValue + uid)
						.digest("base64");
					if (secWSAccept !== digest) {
						failWebsocketConnection(
							ws,
							"Incorrect hash received in Sec-WebSocket-Accept header.",
						);
						return;
					}
					const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
					if (secExtension !== null && secExtension !== permessageDeflate) {
						failWebsocketConnection(
							ws,
							"Received different permessage-deflate than the one set.",
						);
						return;
					}
					const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
					if (
						secProtocol !== null &&
						secProtocol !== request.headersList.get("Sec-WebSocket-Protocol")
					) {
						failWebsocketConnection(
							ws,
							"Protocol was not set in the opening handshake.",
						);
						return;
					}
					response.socket.on("data", onSocketData);
					response.socket.on("close", onSocketClose);
					response.socket.on("error", onSocketError);
					if (channels.open.hasSubscribers) {
						channels.open.publish({
							address: response.socket.address(),
							protocol: secProtocol,
							extensions: secExtension,
						});
					}
					onEstablish(response);
				},
			});
			return controller;
		}
		function onSocketData(chunk) {
			if (!this.ws[kByteParser].write(chunk)) {
				this.pause();
			}
		}
		function onSocketClose() {
			const { ws } = this;
			const wasClean = ws[kSentClose] && ws[kReceivedClose];
			let code = 1005;
			let reason = "";
			const result = ws[kByteParser].closingInfo;
			if (result) {
				code = result.code ?? 1005;
				reason = result.reason;
			} else if (!ws[kSentClose]) {
				code = 1006;
			}
			ws[kReadyState] = states.CLOSED;
			fireEvent("close", ws, CloseEvent, {
				wasClean,
				code,
				reason,
			});
			if (channels.close.hasSubscribers) {
				channels.close.publish({
					websocket: ws,
					code,
					reason,
				});
			}
		}
		function onSocketError(error) {
			const { ws } = this;
			ws[kReadyState] = states.CLOSING;
			if (channels.socketError.hasSubscribers) {
				channels.socketError.publish(error);
			}
			this.destroy();
		}
		module2.exports = {
			establishWebSocketConnection,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/websocket/frame.js
var require_frame = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/websocket/frame.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { maxUnsigned16Bit } = require_constants6();
		var crypto;
		try {
			crypto = require("crypto");
		} catch {}
		var WebsocketFrameSend = class {
			/**
			 * @param {Buffer|undefined} data
			 */
			constructor(data) {
				this.frameData = data;
				this.maskKey = crypto.randomBytes(4);
			}
			createFrame(opcode) {
				const bodyLength = this.frameData?.byteLength ?? 0;
				let payloadLength = bodyLength;
				let offset = 6;
				if (bodyLength > maxUnsigned16Bit) {
					offset += 8;
					payloadLength = 127;
				} else if (bodyLength > 125) {
					offset += 2;
					payloadLength = 126;
				}
				const buffer = Buffer.allocUnsafe(bodyLength + offset);
				buffer[0] = buffer[1] = 0;
				buffer[0] |= 128;
				buffer[0] = (buffer[0] & 240) + opcode;
				buffer[offset - 4] = this.maskKey[0];
				buffer[offset - 3] = this.maskKey[1];
				buffer[offset - 2] = this.maskKey[2];
				buffer[offset - 1] = this.maskKey[3];
				buffer[1] = payloadLength;
				if (payloadLength === 126) {
					buffer.writeUInt16BE(bodyLength, 2);
				} else if (payloadLength === 127) {
					buffer[2] = buffer[3] = 0;
					buffer.writeUIntBE(bodyLength, 4, 6);
				}
				buffer[1] |= 128;
				for (let i = 0; i < bodyLength; i++) {
					buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];
				}
				return buffer;
			}
		};
		module2.exports = {
			WebsocketFrameSend,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/websocket/receiver.js
var require_receiver = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/websocket/receiver.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { Writable } = require("stream");
		var diagnosticsChannel = require("diagnostics_channel");
		var { parserStates, opcodes, states, emptyBuffer } = require_constants6();
		var { kReadyState, kSentClose, kResponse, kReceivedClose } = require_symbols5();
		var { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } =
			require_util8();
		var { WebsocketFrameSend } = require_frame();
		var channels = {};
		channels.ping = diagnosticsChannel.channel("undici:websocket:ping");
		channels.pong = diagnosticsChannel.channel("undici:websocket:pong");
		var ByteParser = class extends Writable {
			#buffers = [];
			#byteOffset = 0;
			#state = parserStates.INFO;
			#info = {};
			#fragments = [];
			constructor(ws) {
				super();
				this.ws = ws;
			}
			/**
			 * @param {Buffer} chunk
			 * @param {() => void} callback
			 */
			_write(chunk, _, callback) {
				this.#buffers.push(chunk);
				this.#byteOffset += chunk.length;
				this.run(callback);
			}
			/**
			 * Runs whenever a new chunk is received.
			 * Callback is called whenever there are no more chunks buffering,
			 * or not enough bytes are buffered to parse.
			 */
			run(callback) {
				while (true) {
					if (this.#state === parserStates.INFO) {
						if (this.#byteOffset < 2) {
							return callback();
						}
						const buffer = this.consume(2);
						this.#info.fin = (buffer[0] & 128) !== 0;
						this.#info.opcode = buffer[0] & 15;
						this.#info.originalOpcode ??= this.#info.opcode;
						this.#info.fragmented =
							!this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION;
						if (
							this.#info.fragmented &&
							this.#info.opcode !== opcodes.BINARY &&
							this.#info.opcode !== opcodes.TEXT
						) {
							failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
							return;
						}
						const payloadLength = buffer[1] & 127;
						if (payloadLength <= 125) {
							this.#info.payloadLength = payloadLength;
							this.#state = parserStates.READ_DATA;
						} else if (payloadLength === 126) {
							this.#state = parserStates.PAYLOADLENGTH_16;
						} else if (payloadLength === 127) {
							this.#state = parserStates.PAYLOADLENGTH_64;
						}
						if (this.#info.fragmented && payloadLength > 125) {
							failWebsocketConnection(
								this.ws,
								"Fragmented frame exceeded 125 bytes.",
							);
							return;
						} else if (
							(this.#info.opcode === opcodes.PING ||
								this.#info.opcode === opcodes.PONG ||
								this.#info.opcode === opcodes.CLOSE) &&
							payloadLength > 125
						) {
							failWebsocketConnection(
								this.ws,
								"Payload length for control frame exceeded 125 bytes.",
							);
							return;
						} else if (this.#info.opcode === opcodes.CLOSE) {
							if (payloadLength === 1) {
								failWebsocketConnection(
									this.ws,
									"Received close frame with a 1-byte body.",
								);
								return;
							}
							const body = this.consume(payloadLength);
							this.#info.closeInfo = this.parseCloseBody(false, body);
							if (!this.ws[kSentClose]) {
								const body2 = Buffer.allocUnsafe(2);
								body2.writeUInt16BE(this.#info.closeInfo.code, 0);
								const closeFrame = new WebsocketFrameSend(body2);
								this.ws[kResponse].socket.write(
									closeFrame.createFrame(opcodes.CLOSE),
									(err) => {
										if (!err) {
											this.ws[kSentClose] = true;
										}
									},
								);
							}
							this.ws[kReadyState] = states.CLOSING;
							this.ws[kReceivedClose] = true;
							this.end();
							return;
						} else if (this.#info.opcode === opcodes.PING) {
							const body = this.consume(payloadLength);
							if (!this.ws[kReceivedClose]) {
								const frame = new WebsocketFrameSend(body);
								this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));
								if (channels.ping.hasSubscribers) {
									channels.ping.publish({
										payload: body,
									});
								}
							}
							this.#state = parserStates.INFO;
							if (this.#byteOffset > 0) {
								continue;
							} else {
								callback();
								return;
							}
						} else if (this.#info.opcode === opcodes.PONG) {
							const body = this.consume(payloadLength);
							if (channels.pong.hasSubscribers) {
								channels.pong.publish({
									payload: body,
								});
							}
							if (this.#byteOffset > 0) {
								continue;
							} else {
								callback();
								return;
							}
						}
					} else if (this.#state === parserStates.PAYLOADLENGTH_16) {
						if (this.#byteOffset < 2) {
							return callback();
						}
						const buffer = this.consume(2);
						this.#info.payloadLength = buffer.readUInt16BE(0);
						this.#state = parserStates.READ_DATA;
					} else if (this.#state === parserStates.PAYLOADLENGTH_64) {
						if (this.#byteOffset < 8) {
							return callback();
						}
						const buffer = this.consume(8);
						const upper = buffer.readUInt32BE(0);
						if (upper > 2 ** 31 - 1) {
							failWebsocketConnection(
								this.ws,
								"Received payload length > 2^31 bytes.",
							);
							return;
						}
						const lower = buffer.readUInt32BE(4);
						this.#info.payloadLength = (upper << 8) + lower;
						this.#state = parserStates.READ_DATA;
					} else if (this.#state === parserStates.READ_DATA) {
						if (this.#byteOffset < this.#info.payloadLength) {
							return callback();
						} else if (this.#byteOffset >= this.#info.payloadLength) {
							const body = this.consume(this.#info.payloadLength);
							this.#fragments.push(body);
							if (
								!this.#info.fragmented ||
								(this.#info.fin && this.#info.opcode === opcodes.CONTINUATION)
							) {
								const fullMessage = Buffer.concat(this.#fragments);
								websocketMessageReceived(
									this.ws,
									this.#info.originalOpcode,
									fullMessage,
								);
								this.#info = {};
								this.#fragments.length = 0;
							}
							this.#state = parserStates.INFO;
						}
					}
					if (this.#byteOffset > 0) {
						continue;
					} else {
						callback();
						break;
					}
				}
			}
			/**
			 * Take n bytes from the buffered Buffers
			 * @param {number} n
			 * @returns {Buffer|null}
			 */
			consume(n) {
				if (n > this.#byteOffset) {
					return null;
				} else if (n === 0) {
					return emptyBuffer;
				}
				if (this.#buffers[0].length === n) {
					this.#byteOffset -= this.#buffers[0].length;
					return this.#buffers.shift();
				}
				const buffer = Buffer.allocUnsafe(n);
				let offset = 0;
				while (offset !== n) {
					const next = this.#buffers[0];
					const { length } = next;
					if (length + offset === n) {
						buffer.set(this.#buffers.shift(), offset);
						break;
					} else if (length + offset > n) {
						buffer.set(next.subarray(0, n - offset), offset);
						this.#buffers[0] = next.subarray(n - offset);
						break;
					} else {
						buffer.set(this.#buffers.shift(), offset);
						offset += next.length;
					}
				}
				this.#byteOffset -= n;
				return buffer;
			}
			parseCloseBody(onlyCode, data) {
				let code;
				if (data.length >= 2) {
					code = data.readUInt16BE(0);
				}
				if (onlyCode) {
					if (!isValidStatusCode(code)) {
						return null;
					}
					return { code };
				}
				let reason = data.subarray(2);
				if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
					reason = reason.subarray(3);
				}
				if (code !== void 0 && !isValidStatusCode(code)) {
					return null;
				}
				try {
					reason = new TextDecoder("utf-8", { fatal: true }).decode(reason);
				} catch {
					return null;
				}
				return { code, reason };
			}
			get closingInfo() {
				return this.#info.closeInfo;
			}
		};
		module2.exports = {
			ByteParser,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/websocket/websocket.js
var require_websocket = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/lib/websocket/websocket.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { webidl } = require_webidl();
		var { DOMException: DOMException2 } = require_constants3();
		var { URLSerializer } = require_dataURL();
		var { getGlobalOrigin } = require_global();
		var { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants6();
		var {
			kWebSocketURL,
			kReadyState,
			kController,
			kBinaryType,
			kResponse,
			kSentClose,
			kByteParser,
		} = require_symbols5();
		var { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } =
			require_util8();
		var { establishWebSocketConnection } = require_connection();
		var { WebsocketFrameSend } = require_frame();
		var { ByteParser } = require_receiver();
		var { kEnumerableProperty, isBlobLike } = require_util2();
		var { getGlobalDispatcher } = require_global2();
		var { types } = require("util");
		var experimentalWarned = false;
		var WebSocket = class _WebSocket extends EventTarget {
			#events = {
				open: null,
				error: null,
				close: null,
				message: null,
			};
			#bufferedAmount = 0;
			#protocol = "";
			#extensions = "";
			/**
			 * @param {string} url
			 * @param {string|string[]} protocols
			 */
			constructor(url, protocols = []) {
				super();
				webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" });
				if (!experimentalWarned) {
					experimentalWarned = true;
					process.emitWarning(
						"WebSockets are experimental, expect them to change at any time.",
						{
							code: "UNDICI-WS",
						},
					);
				}
				const options =
					webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](
						protocols,
					);
				url = webidl.converters.USVString(url);
				protocols = options.protocols;
				const baseURL = getGlobalOrigin();
				let urlRecord;
				try {
					urlRecord = new URL(url, baseURL);
				} catch (e) {
					throw new DOMException2(e, "SyntaxError");
				}
				if (urlRecord.protocol === "http:") {
					urlRecord.protocol = "ws:";
				} else if (urlRecord.protocol === "https:") {
					urlRecord.protocol = "wss:";
				}
				if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
					throw new DOMException2(
						`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,
						"SyntaxError",
					);
				}
				if (urlRecord.hash || urlRecord.href.endsWith("#")) {
					throw new DOMException2("Got fragment", "SyntaxError");
				}
				if (typeof protocols === "string") {
					protocols = [protocols];
				}
				if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
					throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
				}
				if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
					throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
				}
				this[kWebSocketURL] = new URL(urlRecord.href);
				this[kController] = establishWebSocketConnection(
					urlRecord,
					protocols,
					this,
					(response) => this.#onConnectionEstablished(response),
					options,
				);
				this[kReadyState] = _WebSocket.CONNECTING;
				this[kBinaryType] = "blob";
			}
			/**
			 * @see https://websockets.spec.whatwg.org/#dom-websocket-close
			 * @param {number|undefined} code
			 * @param {string|undefined} reason
			 */
			close(code = void 0, reason = void 0) {
				webidl.brandCheck(this, _WebSocket);
				if (code !== void 0) {
					code = webidl.converters["unsigned short"](code, { clamp: true });
				}
				if (reason !== void 0) {
					reason = webidl.converters.USVString(reason);
				}
				if (code !== void 0) {
					if (code !== 1e3 && (code < 3e3 || code > 4999)) {
						throw new DOMException2("invalid code", "InvalidAccessError");
					}
				}
				let reasonByteLength = 0;
				if (reason !== void 0) {
					reasonByteLength = Buffer.byteLength(reason);
					if (reasonByteLength > 123) {
						throw new DOMException2(
							`Reason must be less than 123 bytes; received ${reasonByteLength}`,
							"SyntaxError",
						);
					}
				}
				if (
					this[kReadyState] === _WebSocket.CLOSING ||
					this[kReadyState] === _WebSocket.CLOSED
				) {
				} else if (!isEstablished(this)) {
					failWebsocketConnection(
						this,
						"Connection was closed before it was established.",
					);
					this[kReadyState] = _WebSocket.CLOSING;
				} else if (!isClosing(this)) {
					const frame = new WebsocketFrameSend();
					if (code !== void 0 && reason === void 0) {
						frame.frameData = Buffer.allocUnsafe(2);
						frame.frameData.writeUInt16BE(code, 0);
					} else if (code !== void 0 && reason !== void 0) {
						frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
						frame.frameData.writeUInt16BE(code, 0);
						frame.frameData.write(reason, 2, "utf-8");
					} else {
						frame.frameData = emptyBuffer;
					}
					const socket = this[kResponse].socket;
					socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
						if (!err) {
							this[kSentClose] = true;
						}
					});
					this[kReadyState] = states.CLOSING;
				} else {
					this[kReadyState] = _WebSocket.CLOSING;
				}
			}
			/**
			 * @see https://websockets.spec.whatwg.org/#dom-websocket-send
			 * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
			 */
			send(data) {
				webidl.brandCheck(this, _WebSocket);
				webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" });
				data = webidl.converters.WebSocketSendData(data);
				if (this[kReadyState] === _WebSocket.CONNECTING) {
					throw new DOMException2("Sent before connected.", "InvalidStateError");
				}
				if (!isEstablished(this) || isClosing(this)) {
					return;
				}
				const socket = this[kResponse].socket;
				if (typeof data === "string") {
					const value = Buffer.from(data);
					const frame = new WebsocketFrameSend(value);
					const buffer = frame.createFrame(opcodes.TEXT);
					this.#bufferedAmount += value.byteLength;
					socket.write(buffer, () => {
						this.#bufferedAmount -= value.byteLength;
					});
				} else if (types.isArrayBuffer(data)) {
					const value = Buffer.from(data);
					const frame = new WebsocketFrameSend(value);
					const buffer = frame.createFrame(opcodes.BINARY);
					this.#bufferedAmount += value.byteLength;
					socket.write(buffer, () => {
						this.#bufferedAmount -= value.byteLength;
					});
				} else if (ArrayBuffer.isView(data)) {
					const ab = Buffer.from(data, data.byteOffset, data.byteLength);
					const frame = new WebsocketFrameSend(ab);
					const buffer = frame.createFrame(opcodes.BINARY);
					this.#bufferedAmount += ab.byteLength;
					socket.write(buffer, () => {
						this.#bufferedAmount -= ab.byteLength;
					});
				} else if (isBlobLike(data)) {
					const frame = new WebsocketFrameSend();
					data.arrayBuffer().then((ab) => {
						const value = Buffer.from(ab);
						frame.frameData = value;
						const buffer = frame.createFrame(opcodes.BINARY);
						this.#bufferedAmount += value.byteLength;
						socket.write(buffer, () => {
							this.#bufferedAmount -= value.byteLength;
						});
					});
				}
			}
			get readyState() {
				webidl.brandCheck(this, _WebSocket);
				return this[kReadyState];
			}
			get bufferedAmount() {
				webidl.brandCheck(this, _WebSocket);
				return this.#bufferedAmount;
			}
			get url() {
				webidl.brandCheck(this, _WebSocket);
				return URLSerializer(this[kWebSocketURL]);
			}
			get extensions() {
				webidl.brandCheck(this, _WebSocket);
				return this.#extensions;
			}
			get protocol() {
				webidl.brandCheck(this, _WebSocket);
				return this.#protocol;
			}
			get onopen() {
				webidl.brandCheck(this, _WebSocket);
				return this.#events.open;
			}
			set onopen(fn) {
				webidl.brandCheck(this, _WebSocket);
				if (this.#events.open) {
					this.removeEventListener("open", this.#events.open);
				}
				if (typeof fn === "function") {
					this.#events.open = fn;
					this.addEventListener("open", fn);
				} else {
					this.#events.open = null;
				}
			}
			get onerror() {
				webidl.brandCheck(this, _WebSocket);
				return this.#events.error;
			}
			set onerror(fn) {
				webidl.brandCheck(this, _WebSocket);
				if (this.#events.error) {
					this.removeEventListener("error", this.#events.error);
				}
				if (typeof fn === "function") {
					this.#events.error = fn;
					this.addEventListener("error", fn);
				} else {
					this.#events.error = null;
				}
			}
			get onclose() {
				webidl.brandCheck(this, _WebSocket);
				return this.#events.close;
			}
			set onclose(fn) {
				webidl.brandCheck(this, _WebSocket);
				if (this.#events.close) {
					this.removeEventListener("close", this.#events.close);
				}
				if (typeof fn === "function") {
					this.#events.close = fn;
					this.addEventListener("close", fn);
				} else {
					this.#events.close = null;
				}
			}
			get onmessage() {
				webidl.brandCheck(this, _WebSocket);
				return this.#events.message;
			}
			set onmessage(fn) {
				webidl.brandCheck(this, _WebSocket);
				if (this.#events.message) {
					this.removeEventListener("message", this.#events.message);
				}
				if (typeof fn === "function") {
					this.#events.message = fn;
					this.addEventListener("message", fn);
				} else {
					this.#events.message = null;
				}
			}
			get binaryType() {
				webidl.brandCheck(this, _WebSocket);
				return this[kBinaryType];
			}
			set binaryType(type) {
				webidl.brandCheck(this, _WebSocket);
				if (type !== "blob" && type !== "arraybuffer") {
					this[kBinaryType] = "blob";
				} else {
					this[kBinaryType] = type;
				}
			}
			/**
			 * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
			 */
			#onConnectionEstablished(response) {
				this[kResponse] = response;
				const parser = new ByteParser(this);
				parser.on("drain", function onParserDrain() {
					this.ws[kResponse].socket.resume();
				});
				response.socket.ws = this;
				this[kByteParser] = parser;
				this[kReadyState] = states.OPEN;
				const extensions = response.headersList.get("sec-websocket-extensions");
				if (extensions !== null) {
					this.#extensions = extensions;
				}
				const protocol = response.headersList.get("sec-websocket-protocol");
				if (protocol !== null) {
					this.#protocol = protocol;
				}
				fireEvent("open", this);
			}
		};
		WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
		WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
		WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
		WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
		Object.defineProperties(WebSocket.prototype, {
			CONNECTING: staticPropertyDescriptors,
			OPEN: staticPropertyDescriptors,
			CLOSING: staticPropertyDescriptors,
			CLOSED: staticPropertyDescriptors,
			url: kEnumerableProperty,
			readyState: kEnumerableProperty,
			bufferedAmount: kEnumerableProperty,
			onopen: kEnumerableProperty,
			onerror: kEnumerableProperty,
			onclose: kEnumerableProperty,
			close: kEnumerableProperty,
			onmessage: kEnumerableProperty,
			binaryType: kEnumerableProperty,
			send: kEnumerableProperty,
			extensions: kEnumerableProperty,
			protocol: kEnumerableProperty,
			[Symbol.toStringTag]: {
				value: "WebSocket",
				writable: false,
				enumerable: false,
				configurable: true,
			},
		});
		Object.defineProperties(WebSocket, {
			CONNECTING: staticPropertyDescriptors,
			OPEN: staticPropertyDescriptors,
			CLOSING: staticPropertyDescriptors,
			CLOSED: staticPropertyDescriptors,
		});
		webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(
			webidl.converters.DOMString,
		);
		webidl.converters["DOMString or sequence<DOMString>"] = function (V) {
			if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) {
				return webidl.converters["sequence<DOMString>"](V);
			}
			return webidl.converters.DOMString(V);
		};
		webidl.converters.WebSocketInit = webidl.dictionaryConverter([
			{
				key: "protocols",
				converter: webidl.converters["DOMString or sequence<DOMString>"],
				get defaultValue() {
					return [];
				},
			},
			{
				key: "dispatcher",
				converter: (V) => V,
				get defaultValue() {
					return getGlobalDispatcher();
				},
			},
			{
				key: "headers",
				converter: webidl.nullableConverter(webidl.converters.HeadersInit),
			},
		]);
		webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function (V) {
			if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) {
				return webidl.converters.WebSocketInit(V);
			}
			return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
		};
		webidl.converters.WebSocketSendData = function (V) {
			if (webidl.util.Type(V) === "Object") {
				if (isBlobLike(V)) {
					return webidl.converters.Blob(V, { strict: false });
				}
				if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
					return webidl.converters.BufferSource(V);
				}
			}
			return webidl.converters.USVString(V);
		};
		module2.exports = {
			WebSocket,
		};
	},
});

// node_modules/.pnpm/undici@5.28.4/node_modules/undici/index.js
var require_undici = __commonJS({
	"node_modules/.pnpm/undici@5.28.4/node_modules/undici/index.js"(exports2, module2) {
		"use strict";
		var Client = require_client();
		var Dispatcher = require_dispatcher();
		var errors = require_errors2();
		var Pool = require_pool();
		var BalancedPool = require_balanced_pool();
		var Agent = require_agent();
		var util = require_util2();
		var { InvalidArgumentError } = errors;
		var api = require_api();
		var buildConnector = require_connect();
		var MockClient = require_mock_client();
		var MockAgent = require_mock_agent();
		var MockPool = require_mock_pool();
		var mockErrors = require_mock_errors();
		var ProxyAgent = require_proxy_agent();
		var RetryHandler = require_RetryHandler();
		var { getGlobalDispatcher, setGlobalDispatcher } = require_global2();
		var DecoratorHandler = require_DecoratorHandler();
		var RedirectHandler = require_RedirectHandler();
		var createRedirectInterceptor = require_redirectInterceptor();
		var hasCrypto;
		try {
			require("crypto");
			hasCrypto = true;
		} catch {
			hasCrypto = false;
		}
		Object.assign(Dispatcher.prototype, api);
		module2.exports.Dispatcher = Dispatcher;
		module2.exports.Client = Client;
		module2.exports.Pool = Pool;
		module2.exports.BalancedPool = BalancedPool;
		module2.exports.Agent = Agent;
		module2.exports.ProxyAgent = ProxyAgent;
		module2.exports.RetryHandler = RetryHandler;
		module2.exports.DecoratorHandler = DecoratorHandler;
		module2.exports.RedirectHandler = RedirectHandler;
		module2.exports.createRedirectInterceptor = createRedirectInterceptor;
		module2.exports.buildConnector = buildConnector;
		module2.exports.errors = errors;
		function makeDispatcher(fn) {
			return (url, opts, handler) => {
				if (typeof opts === "function") {
					handler = opts;
					opts = null;
				}
				if (
					!url ||
					(typeof url !== "string" && typeof url !== "object" && !(url instanceof URL))
				) {
					throw new InvalidArgumentError("invalid url");
				}
				if (opts != null && typeof opts !== "object") {
					throw new InvalidArgumentError("invalid opts");
				}
				if (opts && opts.path != null) {
					if (typeof opts.path !== "string") {
						throw new InvalidArgumentError("invalid opts.path");
					}
					let path = opts.path;
					if (!opts.path.startsWith("/")) {
						path = `/${path}`;
					}
					url = new URL(util.parseOrigin(url).origin + path);
				} else {
					if (!opts) {
						opts = typeof url === "object" ? url : {};
					}
					url = util.parseURL(url);
				}
				const { agent, dispatcher = getGlobalDispatcher() } = opts;
				if (agent) {
					throw new InvalidArgumentError(
						"unsupported opts.agent. Did you mean opts.client?",
					);
				}
				return fn.call(
					dispatcher,
					{
						...opts,
						origin: url.origin,
						path: url.search ? `${url.pathname}${url.search}` : url.pathname,
						method: opts.method || (opts.body ? "PUT" : "GET"),
					},
					handler,
				);
			};
		}
		module2.exports.setGlobalDispatcher = setGlobalDispatcher;
		module2.exports.getGlobalDispatcher = getGlobalDispatcher;
		if (util.nodeMajor > 16 || (util.nodeMajor === 16 && util.nodeMinor >= 8)) {
			let fetchImpl = null;
			module2.exports.fetch = async function fetch2(resource) {
				if (!fetchImpl) {
					fetchImpl = require_fetch().fetch;
				}
				try {
					return await fetchImpl(...arguments);
				} catch (err) {
					if (typeof err === "object") {
						Error.captureStackTrace(err, this);
					}
					throw err;
				}
			};
			module2.exports.Headers = require_headers().Headers;
			module2.exports.Response = require_response().Response;
			module2.exports.Request = require_request2().Request;
			module2.exports.FormData = require_formdata().FormData;
			module2.exports.File = require_file().File;
			module2.exports.FileReader = require_filereader().FileReader;
			const { setGlobalOrigin, getGlobalOrigin } = require_global();
			module2.exports.setGlobalOrigin = setGlobalOrigin;
			module2.exports.getGlobalOrigin = getGlobalOrigin;
			const { CacheStorage } = require_cachestorage();
			const { kConstruct } = require_symbols4();
			module2.exports.caches = new CacheStorage(kConstruct);
		}
		if (util.nodeMajor >= 16) {
			const { deleteCookie, getCookies, getSetCookies, setCookie } = require_cookies();
			module2.exports.deleteCookie = deleteCookie;
			module2.exports.getCookies = getCookies;
			module2.exports.getSetCookies = getSetCookies;
			module2.exports.setCookie = setCookie;
			const { parseMIMEType, serializeAMimeType } = require_dataURL();
			module2.exports.parseMIMEType = parseMIMEType;
			module2.exports.serializeAMimeType = serializeAMimeType;
		}
		if (util.nodeMajor >= 18 && hasCrypto) {
			const { WebSocket } = require_websocket();
			module2.exports.WebSocket = WebSocket;
		}
		module2.exports.request = makeDispatcher(api.request);
		module2.exports.stream = makeDispatcher(api.stream);
		module2.exports.pipeline = makeDispatcher(api.pipeline);
		module2.exports.connect = makeDispatcher(api.connect);
		module2.exports.upgrade = makeDispatcher(api.upgrade);
		module2.exports.MockClient = MockClient;
		module2.exports.MockPool = MockPool;
		module2.exports.MockAgent = MockAgent;
		module2.exports.mockErrors = mockErrors;
	},
});

// node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/constants.js
var require_constants7 = __commonJS({
	"node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/constants.js"(exports2, module2) {
		"use strict";
		var BINARY_TYPES = ["nodebuffer", "arraybuffer", "fragments"];
		var hasBlob = typeof Blob !== "undefined";
		if (hasBlob) BINARY_TYPES.push("blob");
		module2.exports = {
			BINARY_TYPES,
			EMPTY_BUFFER: Buffer.alloc(0),
			GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
			hasBlob,
			kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
			kListener: Symbol("kListener"),
			kStatusCode: Symbol("status-code"),
			kWebSocket: Symbol("websocket"),
			NOOP: () => {},
		};
	},
});

// node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
	"node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/buffer-util.js"(exports2, module2) {
		"use strict";
		var { EMPTY_BUFFER } = require_constants7();
		var FastBuffer = Buffer[Symbol.species];
		function concat(list, totalLength) {
			if (list.length === 0) return EMPTY_BUFFER;
			if (list.length === 1) return list[0];
			const target = Buffer.allocUnsafe(totalLength);
			let offset = 0;
			for (let i = 0; i < list.length; i++) {
				const buf = list[i];
				target.set(buf, offset);
				offset += buf.length;
			}
			if (offset < totalLength) {
				return new FastBuffer(target.buffer, target.byteOffset, offset);
			}
			return target;
		}
		function _mask(source, mask, output, offset, length) {
			for (let i = 0; i < length; i++) {
				output[offset + i] = source[i] ^ mask[i & 3];
			}
		}
		function _unmask(buffer, mask) {
			for (let i = 0; i < buffer.length; i++) {
				buffer[i] ^= mask[i & 3];
			}
		}
		function toArrayBuffer(buf) {
			if (buf.length === buf.buffer.byteLength) {
				return buf.buffer;
			}
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
		}
		function toBuffer(data) {
			toBuffer.readOnly = true;
			if (Buffer.isBuffer(data)) return data;
			let buf;
			if (data instanceof ArrayBuffer) {
				buf = new FastBuffer(data);
			} else if (ArrayBuffer.isView(data)) {
				buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
			} else {
				buf = Buffer.from(data);
				toBuffer.readOnly = false;
			}
			return buf;
		}
		module2.exports = {
			concat,
			mask: _mask,
			toArrayBuffer,
			toBuffer,
			unmask: _unmask,
		};
		if (!process.env.WS_NO_BUFFER_UTIL) {
			try {
				const bufferUtil = require("bufferutil");
				module2.exports.mask = function (source, mask, output, offset, length) {
					if (length < 48) _mask(source, mask, output, offset, length);
					else bufferUtil.mask(source, mask, output, offset, length);
				};
				module2.exports.unmask = function (buffer, mask) {
					if (buffer.length < 32) _unmask(buffer, mask);
					else bufferUtil.unmask(buffer, mask);
				};
			} catch (e) {}
		}
	},
});

// node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
	"node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/limiter.js"(exports2, module2) {
		"use strict";
		var kDone = Symbol("kDone");
		var kRun = Symbol("kRun");
		var Limiter = class {
			/**
			 * Creates a new `Limiter`.
			 *
			 * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
			 *     to run concurrently
			 */
			constructor(concurrency) {
				this[kDone] = () => {
					this.pending--;
					this[kRun]();
				};
				this.concurrency = concurrency || Infinity;
				this.jobs = [];
				this.pending = 0;
			}
			/**
			 * Adds a job to the queue.
			 *
			 * @param {Function} job The job to run
			 * @public
			 */
			add(job) {
				this.jobs.push(job);
				this[kRun]();
			}
			/**
			 * Removes a job from the queue and runs it if possible.
			 *
			 * @private
			 */
			[kRun]() {
				if (this.pending === this.concurrency) return;
				if (this.jobs.length) {
					const job = this.jobs.shift();
					this.pending++;
					job(this[kDone]);
				}
			}
		};
		module2.exports = Limiter;
	},
});

// node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
	"node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
		"use strict";
		var zlib = require("zlib");
		var bufferUtil = require_buffer_util();
		var Limiter = require_limiter();
		var { kStatusCode } = require_constants7();
		var FastBuffer = Buffer[Symbol.species];
		var TRAILER = Buffer.from([0, 0, 255, 255]);
		var kPerMessageDeflate = Symbol("permessage-deflate");
		var kTotalLength = Symbol("total-length");
		var kCallback = Symbol("callback");
		var kBuffers = Symbol("buffers");
		var kError = Symbol("error");
		var zlibLimiter;
		var PerMessageDeflate = class {
			/**
			 * Creates a PerMessageDeflate instance.
			 *
			 * @param {Object} [options] Configuration options
			 * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
			 *     for, or request, a custom client window size
			 * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
			 *     acknowledge disabling of client context takeover
			 * @param {Number} [options.concurrencyLimit=10] The number of concurrent
			 *     calls to zlib
			 * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
			 *     use of a custom server window size
			 * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
			 *     disabling of server context takeover
			 * @param {Number} [options.threshold=1024] Size (in bytes) below which
			 *     messages should not be compressed if context takeover is disabled
			 * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
			 *     deflate
			 * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
			 *     inflate
			 * @param {Boolean} [isServer=false] Create the instance in either server or
			 *     client mode
			 * @param {Number} [maxPayload=0] The maximum allowed message length
			 */
			constructor(options, isServer, maxPayload) {
				this._maxPayload = maxPayload | 0;
				this._options = options || {};
				this._threshold =
					this._options.threshold !== void 0 ? this._options.threshold : 1024;
				this._isServer = !!isServer;
				this._deflate = null;
				this._inflate = null;
				this.params = null;
				if (!zlibLimiter) {
					const concurrency =
						this._options.concurrencyLimit !== void 0
							? this._options.concurrencyLimit
							: 10;
					zlibLimiter = new Limiter(concurrency);
				}
			}
			/**
			 * @type {String}
			 */
			static get extensionName() {
				return "permessage-deflate";
			}
			/**
			 * Create an extension negotiation offer.
			 *
			 * @return {Object} Extension parameters
			 * @public
			 */
			offer() {
				const params = {};
				if (this._options.serverNoContextTakeover) {
					params.server_no_context_takeover = true;
				}
				if (this._options.clientNoContextTakeover) {
					params.client_no_context_takeover = true;
				}
				if (this._options.serverMaxWindowBits) {
					params.server_max_window_bits = this._options.serverMaxWindowBits;
				}
				if (this._options.clientMaxWindowBits) {
					params.client_max_window_bits = this._options.clientMaxWindowBits;
				} else if (this._options.clientMaxWindowBits == null) {
					params.client_max_window_bits = true;
				}
				return params;
			}
			/**
			 * Accept an extension negotiation offer/response.
			 *
			 * @param {Array} configurations The extension negotiation offers/reponse
			 * @return {Object} Accepted configuration
			 * @public
			 */
			accept(configurations) {
				configurations = this.normalizeParams(configurations);
				this.params = this._isServer
					? this.acceptAsServer(configurations)
					: this.acceptAsClient(configurations);
				return this.params;
			}
			/**
			 * Releases all resources used by the extension.
			 *
			 * @public
			 */
			cleanup() {
				if (this._inflate) {
					this._inflate.close();
					this._inflate = null;
				}
				if (this._deflate) {
					const callback = this._deflate[kCallback];
					this._deflate.close();
					this._deflate = null;
					if (callback) {
						callback(
							new Error(
								"The deflate stream was closed while data was being processed",
							),
						);
					}
				}
			}
			/**
			 *  Accept an extension negotiation offer.
			 *
			 * @param {Array} offers The extension negotiation offers
			 * @return {Object} Accepted configuration
			 * @private
			 */
			acceptAsServer(offers) {
				const opts = this._options;
				const accepted = offers.find((params) => {
					if (
						(opts.serverNoContextTakeover === false &&
							params.server_no_context_takeover) ||
						(params.server_max_window_bits &&
							(opts.serverMaxWindowBits === false ||
								(typeof opts.serverMaxWindowBits === "number" &&
									opts.serverMaxWindowBits > params.server_max_window_bits))) ||
						(typeof opts.clientMaxWindowBits === "number" &&
							!params.client_max_window_bits)
					) {
						return false;
					}
					return true;
				});
				if (!accepted) {
					throw new Error("None of the extension offers can be accepted");
				}
				if (opts.serverNoContextTakeover) {
					accepted.server_no_context_takeover = true;
				}
				if (opts.clientNoContextTakeover) {
					accepted.client_no_context_takeover = true;
				}
				if (typeof opts.serverMaxWindowBits === "number") {
					accepted.server_max_window_bits = opts.serverMaxWindowBits;
				}
				if (typeof opts.clientMaxWindowBits === "number") {
					accepted.client_max_window_bits = opts.clientMaxWindowBits;
				} else if (
					accepted.client_max_window_bits === true ||
					opts.clientMaxWindowBits === false
				) {
					delete accepted.client_max_window_bits;
				}
				return accepted;
			}
			/**
			 * Accept the extension negotiation response.
			 *
			 * @param {Array} response The extension negotiation response
			 * @return {Object} Accepted configuration
			 * @private
			 */
			acceptAsClient(response) {
				const params = response[0];
				if (
					this._options.clientNoContextTakeover === false &&
					params.client_no_context_takeover
				) {
					throw new Error('Unexpected parameter "client_no_context_takeover"');
				}
				if (!params.client_max_window_bits) {
					if (typeof this._options.clientMaxWindowBits === "number") {
						params.client_max_window_bits = this._options.clientMaxWindowBits;
					}
				} else if (
					this._options.clientMaxWindowBits === false ||
					(typeof this._options.clientMaxWindowBits === "number" &&
						params.client_max_window_bits > this._options.clientMaxWindowBits)
				) {
					throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
				}
				return params;
			}
			/**
			 * Normalize parameters.
			 *
			 * @param {Array} configurations The extension negotiation offers/reponse
			 * @return {Array} The offers/response with normalized parameters
			 * @private
			 */
			normalizeParams(configurations) {
				configurations.forEach((params) => {
					Object.keys(params).forEach((key) => {
						let value = params[key];
						if (value.length > 1) {
							throw new Error(`Parameter "${key}" must have only a single value`);
						}
						value = value[0];
						if (key === "client_max_window_bits") {
							if (value !== true) {
								const num = +value;
								if (!Number.isInteger(num) || num < 8 || num > 15) {
									throw new TypeError(
										`Invalid value for parameter "${key}": ${value}`,
									);
								}
								value = num;
							} else if (!this._isServer) {
								throw new TypeError(
									`Invalid value for parameter "${key}": ${value}`,
								);
							}
						} else if (key === "server_max_window_bits") {
							const num = +value;
							if (!Number.isInteger(num) || num < 8 || num > 15) {
								throw new TypeError(
									`Invalid value for parameter "${key}": ${value}`,
								);
							}
							value = num;
						} else if (
							key === "client_no_context_takeover" ||
							key === "server_no_context_takeover"
						) {
							if (value !== true) {
								throw new TypeError(
									`Invalid value for parameter "${key}": ${value}`,
								);
							}
						} else {
							throw new Error(`Unknown parameter "${key}"`);
						}
						params[key] = value;
					});
				});
				return configurations;
			}
			/**
			 * Decompress data. Concurrency limited.
			 *
			 * @param {Buffer} data Compressed data
			 * @param {Boolean} fin Specifies whether or not this is the last fragment
			 * @param {Function} callback Callback
			 * @public
			 */
			decompress(data, fin, callback) {
				zlibLimiter.add((done) => {
					this._decompress(data, fin, (err, result) => {
						done();
						callback(err, result);
					});
				});
			}
			/**
			 * Compress data. Concurrency limited.
			 *
			 * @param {(Buffer|String)} data Data to compress
			 * @param {Boolean} fin Specifies whether or not this is the last fragment
			 * @param {Function} callback Callback
			 * @public
			 */
			compress(data, fin, callback) {
				zlibLimiter.add((done) => {
					this._compress(data, fin, (err, result) => {
						done();
						callback(err, result);
					});
				});
			}
			/**
			 * Decompress data.
			 *
			 * @param {Buffer} data Compressed data
			 * @param {Boolean} fin Specifies whether or not this is the last fragment
			 * @param {Function} callback Callback
			 * @private
			 */
			_decompress(data, fin, callback) {
				const endpoint = this._isServer ? "client" : "server";
				if (!this._inflate) {
					const key = `${endpoint}_max_window_bits`;
					const windowBits =
						typeof this.params[key] !== "number"
							? zlib.Z_DEFAULT_WINDOWBITS
							: this.params[key];
					this._inflate = zlib.createInflateRaw({
						...this._options.zlibInflateOptions,
						windowBits,
					});
					this._inflate[kPerMessageDeflate] = this;
					this._inflate[kTotalLength] = 0;
					this._inflate[kBuffers] = [];
					this._inflate.on("error", inflateOnError);
					this._inflate.on("data", inflateOnData);
				}
				this._inflate[kCallback] = callback;
				this._inflate.write(data);
				if (fin) this._inflate.write(TRAILER);
				this._inflate.flush(() => {
					const err = this._inflate[kError];
					if (err) {
						this._inflate.close();
						this._inflate = null;
						callback(err);
						return;
					}
					const data2 = bufferUtil.concat(
						this._inflate[kBuffers],
						this._inflate[kTotalLength],
					);
					if (this._inflate._readableState.endEmitted) {
						this._inflate.close();
						this._inflate = null;
					} else {
						this._inflate[kTotalLength] = 0;
						this._inflate[kBuffers] = [];
						if (fin && this.params[`${endpoint}_no_context_takeover`]) {
							this._inflate.reset();
						}
					}
					callback(null, data2);
				});
			}
			/**
			 * Compress data.
			 *
			 * @param {(Buffer|String)} data Data to compress
			 * @param {Boolean} fin Specifies whether or not this is the last fragment
			 * @param {Function} callback Callback
			 * @private
			 */
			_compress(data, fin, callback) {
				const endpoint = this._isServer ? "server" : "client";
				if (!this._deflate) {
					const key = `${endpoint}_max_window_bits`;
					const windowBits =
						typeof this.params[key] !== "number"
							? zlib.Z_DEFAULT_WINDOWBITS
							: this.params[key];
					this._deflate = zlib.createDeflateRaw({
						...this._options.zlibDeflateOptions,
						windowBits,
					});
					this._deflate[kTotalLength] = 0;
					this._deflate[kBuffers] = [];
					this._deflate.on("data", deflateOnData);
				}
				this._deflate[kCallback] = callback;
				this._deflate.write(data);
				this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
					if (!this._deflate) {
						return;
					}
					let data2 = bufferUtil.concat(
						this._deflate[kBuffers],
						this._deflate[kTotalLength],
					);
					if (fin) {
						data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
					}
					this._deflate[kCallback] = null;
					this._deflate[kTotalLength] = 0;
					this._deflate[kBuffers] = [];
					if (fin && this.params[`${endpoint}_no_context_takeover`]) {
						this._deflate.reset();
					}
					callback(null, data2);
				});
			}
		};
		module2.exports = PerMessageDeflate;
		function deflateOnData(chunk) {
			this[kBuffers].push(chunk);
			this[kTotalLength] += chunk.length;
		}
		function inflateOnData(chunk) {
			this[kTotalLength] += chunk.length;
			if (
				this[kPerMessageDeflate]._maxPayload < 1 ||
				this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
			) {
				this[kBuffers].push(chunk);
				return;
			}
			this[kError] = new RangeError("Max payload size exceeded");
			this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
			this[kError][kStatusCode] = 1009;
			this.removeListener("data", inflateOnData);
			this.reset();
		}
		function inflateOnError(err) {
			this[kPerMessageDeflate]._inflate = null;
			err[kStatusCode] = 1007;
			this[kCallback](err);
		}
	},
});

// node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/validation.js
var require_validation = __commonJS({
	"node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/validation.js"(exports2, module2) {
		"use strict";
		var { isUtf8 } = require("buffer");
		var { hasBlob } = require_constants7();
		var tokenChars = [
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			// 0 - 15
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			// 16 - 31
			0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0,
			// 32 - 47
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
			// 48 - 63
			0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			// 64 - 79
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,
			// 80 - 95
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
			// 96 - 111
			1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0,
			// 112 - 127
		];
		function isValidStatusCode(code) {
			return (
				(code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006) ||
				(code >= 3e3 && code <= 4999)
			);
		}
		function _isValidUTF8(buf) {
			const len = buf.length;
			let i = 0;
			while (i < len) {
				if ((buf[i] & 128) === 0) {
					i++;
				} else if ((buf[i] & 224) === 192) {
					if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
						return false;
					}
					i += 2;
				} else if ((buf[i] & 240) === 224) {
					if (
						i + 2 >= len ||
						(buf[i + 1] & 192) !== 128 ||
						(buf[i + 2] & 192) !== 128 ||
						(buf[i] === 224 && (buf[i + 1] & 224) === 128) || // Overlong
						(buf[i] === 237 && (buf[i + 1] & 224) === 160)
					) {
						return false;
					}
					i += 3;
				} else if ((buf[i] & 248) === 240) {
					if (
						i + 3 >= len ||
						(buf[i + 1] & 192) !== 128 ||
						(buf[i + 2] & 192) !== 128 ||
						(buf[i + 3] & 192) !== 128 ||
						(buf[i] === 240 && (buf[i + 1] & 240) === 128) || // Overlong
						(buf[i] === 244 && buf[i + 1] > 143) ||
						buf[i] > 244
					) {
						return false;
					}
					i += 4;
				} else {
					return false;
				}
			}
			return true;
		}
		function isBlob(value) {
			return (
				hasBlob &&
				typeof value === "object" &&
				typeof value.arrayBuffer === "function" &&
				typeof value.type === "string" &&
				typeof value.stream === "function" &&
				(value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File")
			);
		}
		module2.exports = {
			isBlob,
			isValidStatusCode,
			isValidUTF8: _isValidUTF8,
			tokenChars,
		};
		if (isUtf8) {
			module2.exports.isValidUTF8 = function (buf) {
				return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
			};
		} else if (!process.env.WS_NO_UTF_8_VALIDATE) {
			try {
				const isValidUTF8 = require("utf-8-validate");
				module2.exports.isValidUTF8 = function (buf) {
					return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
				};
			} catch (e) {}
		}
	},
});

// node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/receiver.js
var require_receiver2 = __commonJS({
	"node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/receiver.js"(exports2, module2) {
		"use strict";
		var { Writable } = require("stream");
		var PerMessageDeflate = require_permessage_deflate();
		var { BINARY_TYPES, EMPTY_BUFFER, kStatusCode, kWebSocket } = require_constants7();
		var { concat, toArrayBuffer, unmask } = require_buffer_util();
		var { isValidStatusCode, isValidUTF8 } = require_validation();
		var FastBuffer = Buffer[Symbol.species];
		var GET_INFO = 0;
		var GET_PAYLOAD_LENGTH_16 = 1;
		var GET_PAYLOAD_LENGTH_64 = 2;
		var GET_MASK = 3;
		var GET_DATA = 4;
		var INFLATING = 5;
		var DEFER_EVENT = 6;
		var Receiver = class extends Writable {
			/**
			 * Creates a Receiver instance.
			 *
			 * @param {Object} [options] Options object
			 * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
			 *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
			 *     multiple times in the same tick
			 * @param {String} [options.binaryType=nodebuffer] The type for binary data
			 * @param {Object} [options.extensions] An object containing the negotiated
			 *     extensions
			 * @param {Boolean} [options.isServer=false] Specifies whether to operate in
			 *     client or server mode
			 * @param {Number} [options.maxPayload=0] The maximum allowed message length
			 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
			 *     not to skip UTF-8 validation for text and close messages
			 */
			constructor(options = {}) {
				super();
				this._allowSynchronousEvents =
					options.allowSynchronousEvents !== void 0
						? options.allowSynchronousEvents
						: true;
				this._binaryType = options.binaryType || BINARY_TYPES[0];
				this._extensions = options.extensions || {};
				this._isServer = !!options.isServer;
				this._maxPayload = options.maxPayload | 0;
				this._skipUTF8Validation = !!options.skipUTF8Validation;
				this[kWebSocket] = void 0;
				this._bufferedBytes = 0;
				this._buffers = [];
				this._compressed = false;
				this._payloadLength = 0;
				this._mask = void 0;
				this._fragmented = 0;
				this._masked = false;
				this._fin = false;
				this._opcode = 0;
				this._totalPayloadLength = 0;
				this._messageLength = 0;
				this._fragments = [];
				this._errored = false;
				this._loop = false;
				this._state = GET_INFO;
			}
			/**
			 * Implements `Writable.prototype._write()`.
			 *
			 * @param {Buffer} chunk The chunk of data to write
			 * @param {String} encoding The character encoding of `chunk`
			 * @param {Function} cb Callback
			 * @private
			 */
			_write(chunk, encoding, cb) {
				if (this._opcode === 8 && this._state == GET_INFO) return cb();
				this._bufferedBytes += chunk.length;
				this._buffers.push(chunk);
				this.startLoop(cb);
			}
			/**
			 * Consumes `n` bytes from the buffered data.
			 *
			 * @param {Number} n The number of bytes to consume
			 * @return {Buffer} The consumed bytes
			 * @private
			 */
			consume(n) {
				this._bufferedBytes -= n;
				if (n === this._buffers[0].length) return this._buffers.shift();
				if (n < this._buffers[0].length) {
					const buf = this._buffers[0];
					this._buffers[0] = new FastBuffer(
						buf.buffer,
						buf.byteOffset + n,
						buf.length - n,
					);
					return new FastBuffer(buf.buffer, buf.byteOffset, n);
				}
				const dst = Buffer.allocUnsafe(n);
				do {
					const buf = this._buffers[0];
					const offset = dst.length - n;
					if (n >= buf.length) {
						dst.set(this._buffers.shift(), offset);
					} else {
						dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
						this._buffers[0] = new FastBuffer(
							buf.buffer,
							buf.byteOffset + n,
							buf.length - n,
						);
					}
					n -= buf.length;
				} while (n > 0);
				return dst;
			}
			/**
			 * Starts the parsing loop.
			 *
			 * @param {Function} cb Callback
			 * @private
			 */
			startLoop(cb) {
				this._loop = true;
				do {
					switch (this._state) {
						case GET_INFO:
							this.getInfo(cb);
							break;
						case GET_PAYLOAD_LENGTH_16:
							this.getPayloadLength16(cb);
							break;
						case GET_PAYLOAD_LENGTH_64:
							this.getPayloadLength64(cb);
							break;
						case GET_MASK:
							this.getMask();
							break;
						case GET_DATA:
							this.getData(cb);
							break;
						case INFLATING:
						case DEFER_EVENT:
							this._loop = false;
							return;
					}
				} while (this._loop);
				if (!this._errored) cb();
			}
			/**
			 * Reads the first two bytes of a frame.
			 *
			 * @param {Function} cb Callback
			 * @private
			 */
			getInfo(cb) {
				if (this._bufferedBytes < 2) {
					this._loop = false;
					return;
				}
				const buf = this.consume(2);
				if ((buf[0] & 48) !== 0) {
					const error = this.createError(
						RangeError,
						"RSV2 and RSV3 must be clear",
						true,
						1002,
						"WS_ERR_UNEXPECTED_RSV_2_3",
					);
					cb(error);
					return;
				}
				const compressed = (buf[0] & 64) === 64;
				if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
					const error = this.createError(
						RangeError,
						"RSV1 must be clear",
						true,
						1002,
						"WS_ERR_UNEXPECTED_RSV_1",
					);
					cb(error);
					return;
				}
				this._fin = (buf[0] & 128) === 128;
				this._opcode = buf[0] & 15;
				this._payloadLength = buf[1] & 127;
				if (this._opcode === 0) {
					if (compressed) {
						const error = this.createError(
							RangeError,
							"RSV1 must be clear",
							true,
							1002,
							"WS_ERR_UNEXPECTED_RSV_1",
						);
						cb(error);
						return;
					}
					if (!this._fragmented) {
						const error = this.createError(
							RangeError,
							"invalid opcode 0",
							true,
							1002,
							"WS_ERR_INVALID_OPCODE",
						);
						cb(error);
						return;
					}
					this._opcode = this._fragmented;
				} else if (this._opcode === 1 || this._opcode === 2) {
					if (this._fragmented) {
						const error = this.createError(
							RangeError,
							`invalid opcode ${this._opcode}`,
							true,
							1002,
							"WS_ERR_INVALID_OPCODE",
						);
						cb(error);
						return;
					}
					this._compressed = compressed;
				} else if (this._opcode > 7 && this._opcode < 11) {
					if (!this._fin) {
						const error = this.createError(
							RangeError,
							"FIN must be set",
							true,
							1002,
							"WS_ERR_EXPECTED_FIN",
						);
						cb(error);
						return;
					}
					if (compressed) {
						const error = this.createError(
							RangeError,
							"RSV1 must be clear",
							true,
							1002,
							"WS_ERR_UNEXPECTED_RSV_1",
						);
						cb(error);
						return;
					}
					if (
						this._payloadLength > 125 ||
						(this._opcode === 8 && this._payloadLength === 1)
					) {
						const error = this.createError(
							RangeError,
							`invalid payload length ${this._payloadLength}`,
							true,
							1002,
							"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH",
						);
						cb(error);
						return;
					}
				} else {
					const error = this.createError(
						RangeError,
						`invalid opcode ${this._opcode}`,
						true,
						1002,
						"WS_ERR_INVALID_OPCODE",
					);
					cb(error);
					return;
				}
				if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
				this._masked = (buf[1] & 128) === 128;
				if (this._isServer) {
					if (!this._masked) {
						const error = this.createError(
							RangeError,
							"MASK must be set",
							true,
							1002,
							"WS_ERR_EXPECTED_MASK",
						);
						cb(error);
						return;
					}
				} else if (this._masked) {
					const error = this.createError(
						RangeError,
						"MASK must be clear",
						true,
						1002,
						"WS_ERR_UNEXPECTED_MASK",
					);
					cb(error);
					return;
				}
				if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
				else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
				else this.haveLength(cb);
			}
			/**
			 * Gets extended payload length (7+16).
			 *
			 * @param {Function} cb Callback
			 * @private
			 */
			getPayloadLength16(cb) {
				if (this._bufferedBytes < 2) {
					this._loop = false;
					return;
				}
				this._payloadLength = this.consume(2).readUInt16BE(0);
				this.haveLength(cb);
			}
			/**
			 * Gets extended payload length (7+64).
			 *
			 * @param {Function} cb Callback
			 * @private
			 */
			getPayloadLength64(cb) {
				if (this._bufferedBytes < 8) {
					this._loop = false;
					return;
				}
				const buf = this.consume(8);
				const num = buf.readUInt32BE(0);
				if (num > Math.pow(2, 53 - 32) - 1) {
					const error = this.createError(
						RangeError,
						"Unsupported WebSocket frame: payload length > 2^53 - 1",
						false,
						1009,
						"WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH",
					);
					cb(error);
					return;
				}
				this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
				this.haveLength(cb);
			}
			/**
			 * Payload length has been read.
			 *
			 * @param {Function} cb Callback
			 * @private
			 */
			haveLength(cb) {
				if (this._payloadLength && this._opcode < 8) {
					this._totalPayloadLength += this._payloadLength;
					if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
						const error = this.createError(
							RangeError,
							"Max payload size exceeded",
							false,
							1009,
							"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH",
						);
						cb(error);
						return;
					}
				}
				if (this._masked) this._state = GET_MASK;
				else this._state = GET_DATA;
			}
			/**
			 * Reads mask bytes.
			 *
			 * @private
			 */
			getMask() {
				if (this._bufferedBytes < 4) {
					this._loop = false;
					return;
				}
				this._mask = this.consume(4);
				this._state = GET_DATA;
			}
			/**
			 * Reads data bytes.
			 *
			 * @param {Function} cb Callback
			 * @private
			 */
			getData(cb) {
				let data = EMPTY_BUFFER;
				if (this._payloadLength) {
					if (this._bufferedBytes < this._payloadLength) {
						this._loop = false;
						return;
					}
					data = this.consume(this._payloadLength);
					if (
						this._masked &&
						(this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0
					) {
						unmask(data, this._mask);
					}
				}
				if (this._opcode > 7) {
					this.controlMessage(data, cb);
					return;
				}
				if (this._compressed) {
					this._state = INFLATING;
					this.decompress(data, cb);
					return;
				}
				if (data.length) {
					this._messageLength = this._totalPayloadLength;
					this._fragments.push(data);
				}
				this.dataMessage(cb);
			}
			/**
			 * Decompresses data.
			 *
			 * @param {Buffer} data Compressed data
			 * @param {Function} cb Callback
			 * @private
			 */
			decompress(data, cb) {
				const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
				perMessageDeflate.decompress(data, this._fin, (err, buf) => {
					if (err) return cb(err);
					if (buf.length) {
						this._messageLength += buf.length;
						if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
							const error = this.createError(
								RangeError,
								"Max payload size exceeded",
								false,
								1009,
								"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH",
							);
							cb(error);
							return;
						}
						this._fragments.push(buf);
					}
					this.dataMessage(cb);
					if (this._state === GET_INFO) this.startLoop(cb);
				});
			}
			/**
			 * Handles a data message.
			 *
			 * @param {Function} cb Callback
			 * @private
			 */
			dataMessage(cb) {
				if (!this._fin) {
					this._state = GET_INFO;
					return;
				}
				const messageLength = this._messageLength;
				const fragments = this._fragments;
				this._totalPayloadLength = 0;
				this._messageLength = 0;
				this._fragmented = 0;
				this._fragments = [];
				if (this._opcode === 2) {
					let data;
					if (this._binaryType === "nodebuffer") {
						data = concat(fragments, messageLength);
					} else if (this._binaryType === "arraybuffer") {
						data = toArrayBuffer(concat(fragments, messageLength));
					} else if (this._binaryType === "blob") {
						data = new Blob(fragments);
					} else {
						data = fragments;
					}
					if (this._allowSynchronousEvents) {
						this.emit("message", data, true);
						this._state = GET_INFO;
					} else {
						this._state = DEFER_EVENT;
						setImmediate(() => {
							this.emit("message", data, true);
							this._state = GET_INFO;
							this.startLoop(cb);
						});
					}
				} else {
					const buf = concat(fragments, messageLength);
					if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
						const error = this.createError(
							Error,
							"invalid UTF-8 sequence",
							true,
							1007,
							"WS_ERR_INVALID_UTF8",
						);
						cb(error);
						return;
					}
					if (this._state === INFLATING || this._allowSynchronousEvents) {
						this.emit("message", buf, false);
						this._state = GET_INFO;
					} else {
						this._state = DEFER_EVENT;
						setImmediate(() => {
							this.emit("message", buf, false);
							this._state = GET_INFO;
							this.startLoop(cb);
						});
					}
				}
			}
			/**
			 * Handles a control message.
			 *
			 * @param {Buffer} data Data to handle
			 * @return {(Error|RangeError|undefined)} A possible error
			 * @private
			 */
			controlMessage(data, cb) {
				if (this._opcode === 8) {
					if (data.length === 0) {
						this._loop = false;
						this.emit("conclude", 1005, EMPTY_BUFFER);
						this.end();
					} else {
						const code = data.readUInt16BE(0);
						if (!isValidStatusCode(code)) {
							const error = this.createError(
								RangeError,
								`invalid status code ${code}`,
								true,
								1002,
								"WS_ERR_INVALID_CLOSE_CODE",
							);
							cb(error);
							return;
						}
						const buf = new FastBuffer(
							data.buffer,
							data.byteOffset + 2,
							data.length - 2,
						);
						if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
							const error = this.createError(
								Error,
								"invalid UTF-8 sequence",
								true,
								1007,
								"WS_ERR_INVALID_UTF8",
							);
							cb(error);
							return;
						}
						this._loop = false;
						this.emit("conclude", code, buf);
						this.end();
					}
					this._state = GET_INFO;
					return;
				}
				if (this._allowSynchronousEvents) {
					this.emit(this._opcode === 9 ? "ping" : "pong", data);
					this._state = GET_INFO;
				} else {
					this._state = DEFER_EVENT;
					setImmediate(() => {
						this.emit(this._opcode === 9 ? "ping" : "pong", data);
						this._state = GET_INFO;
						this.startLoop(cb);
					});
				}
			}
			/**
			 * Builds an error object.
			 *
			 * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
			 * @param {String} message The error message
			 * @param {Boolean} prefix Specifies whether or not to add a default prefix to
			 *     `message`
			 * @param {Number} statusCode The status code
			 * @param {String} errorCode The exposed error code
			 * @return {(Error|RangeError)} The error
			 * @private
			 */
			createError(ErrorCtor, message, prefix, statusCode, errorCode) {
				this._loop = false;
				this._errored = true;
				const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
				Error.captureStackTrace(err, this.createError);
				err.code = errorCode;
				err[kStatusCode] = statusCode;
				return err;
			}
		};
		module2.exports = Receiver;
	},
});

// node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/sender.js
var require_sender = __commonJS({
	"node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/sender.js"(exports2, module2) {
		"use strict";
		var { Duplex } = require("stream");
		var { randomFillSync } = require("crypto");
		var PerMessageDeflate = require_permessage_deflate();
		var { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants7();
		var { isBlob, isValidStatusCode } = require_validation();
		var { mask: applyMask, toBuffer } = require_buffer_util();
		var kByteLength = Symbol("kByteLength");
		var maskBuffer = Buffer.alloc(4);
		var RANDOM_POOL_SIZE = 8 * 1024;
		var randomPool;
		var randomPoolPointer = RANDOM_POOL_SIZE;
		var DEFAULT = 0;
		var DEFLATING = 1;
		var GET_BLOB_DATA = 2;
		var Sender = class _Sender {
			/**
			 * Creates a Sender instance.
			 *
			 * @param {Duplex} socket The connection socket
			 * @param {Object} [extensions] An object containing the negotiated extensions
			 * @param {Function} [generateMask] The function used to generate the masking
			 *     key
			 */
			constructor(socket, extensions, generateMask) {
				this._extensions = extensions || {};
				if (generateMask) {
					this._generateMask = generateMask;
					this._maskBuffer = Buffer.alloc(4);
				}
				this._socket = socket;
				this._firstFragment = true;
				this._compress = false;
				this._bufferedBytes = 0;
				this._queue = [];
				this._state = DEFAULT;
				this.onerror = NOOP;
				this[kWebSocket] = void 0;
			}
			/**
			 * Frames a piece of data according to the HyBi WebSocket protocol.
			 *
			 * @param {(Buffer|String)} data The data to frame
			 * @param {Object} options Options object
			 * @param {Boolean} [options.fin=false] Specifies whether or not to set the
			 *     FIN bit
			 * @param {Function} [options.generateMask] The function used to generate the
			 *     masking key
			 * @param {Boolean} [options.mask=false] Specifies whether or not to mask
			 *     `data`
			 * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
			 *     key
			 * @param {Number} options.opcode The opcode
			 * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
			 *     modified
			 * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
			 *     RSV1 bit
			 * @return {(Buffer|String)[]} The framed data
			 * @public
			 */
			static frame(data, options) {
				let mask;
				let merge = false;
				let offset = 2;
				let skipMasking = false;
				if (options.mask) {
					mask = options.maskBuffer || maskBuffer;
					if (options.generateMask) {
						options.generateMask(mask);
					} else {
						if (randomPoolPointer === RANDOM_POOL_SIZE) {
							if (randomPool === void 0) {
								randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
							}
							randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
							randomPoolPointer = 0;
						}
						mask[0] = randomPool[randomPoolPointer++];
						mask[1] = randomPool[randomPoolPointer++];
						mask[2] = randomPool[randomPoolPointer++];
						mask[3] = randomPool[randomPoolPointer++];
					}
					skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
					offset = 6;
				}
				let dataLength;
				if (typeof data === "string") {
					if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
						dataLength = options[kByteLength];
					} else {
						data = Buffer.from(data);
						dataLength = data.length;
					}
				} else {
					dataLength = data.length;
					merge = options.mask && options.readOnly && !skipMasking;
				}
				let payloadLength = dataLength;
				if (dataLength >= 65536) {
					offset += 8;
					payloadLength = 127;
				} else if (dataLength > 125) {
					offset += 2;
					payloadLength = 126;
				}
				const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
				target[0] = options.fin ? options.opcode | 128 : options.opcode;
				if (options.rsv1) target[0] |= 64;
				target[1] = payloadLength;
				if (payloadLength === 126) {
					target.writeUInt16BE(dataLength, 2);
				} else if (payloadLength === 127) {
					target[2] = target[3] = 0;
					target.writeUIntBE(dataLength, 4, 6);
				}
				if (!options.mask) return [target, data];
				target[1] |= 128;
				target[offset - 4] = mask[0];
				target[offset - 3] = mask[1];
				target[offset - 2] = mask[2];
				target[offset - 1] = mask[3];
				if (skipMasking) return [target, data];
				if (merge) {
					applyMask(data, mask, target, offset, dataLength);
					return [target];
				}
				applyMask(data, mask, data, 0, dataLength);
				return [target, data];
			}
			/**
			 * Sends a close message to the other peer.
			 *
			 * @param {Number} [code] The status code component of the body
			 * @param {(String|Buffer)} [data] The message component of the body
			 * @param {Boolean} [mask=false] Specifies whether or not to mask the message
			 * @param {Function} [cb] Callback
			 * @public
			 */
			close(code, data, mask, cb) {
				let buf;
				if (code === void 0) {
					buf = EMPTY_BUFFER;
				} else if (typeof code !== "number" || !isValidStatusCode(code)) {
					throw new TypeError("First argument must be a valid error code number");
				} else if (data === void 0 || !data.length) {
					buf = Buffer.allocUnsafe(2);
					buf.writeUInt16BE(code, 0);
				} else {
					const length = Buffer.byteLength(data);
					if (length > 123) {
						throw new RangeError("The message must not be greater than 123 bytes");
					}
					buf = Buffer.allocUnsafe(2 + length);
					buf.writeUInt16BE(code, 0);
					if (typeof data === "string") {
						buf.write(data, 2);
					} else {
						buf.set(data, 2);
					}
				}
				const options = {
					[kByteLength]: buf.length,
					fin: true,
					generateMask: this._generateMask,
					mask,
					maskBuffer: this._maskBuffer,
					opcode: 8,
					readOnly: false,
					rsv1: false,
				};
				if (this._state !== DEFAULT) {
					this.enqueue([this.dispatch, buf, false, options, cb]);
				} else {
					this.sendFrame(_Sender.frame(buf, options), cb);
				}
			}
			/**
			 * Sends a ping message to the other peer.
			 *
			 * @param {*} data The message to send
			 * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
			 * @param {Function} [cb] Callback
			 * @public
			 */
			ping(data, mask, cb) {
				let byteLength;
				let readOnly;
				if (typeof data === "string") {
					byteLength = Buffer.byteLength(data);
					readOnly = false;
				} else if (isBlob(data)) {
					byteLength = data.size;
					readOnly = false;
				} else {
					data = toBuffer(data);
					byteLength = data.length;
					readOnly = toBuffer.readOnly;
				}
				if (byteLength > 125) {
					throw new RangeError("The data size must not be greater than 125 bytes");
				}
				const options = {
					[kByteLength]: byteLength,
					fin: true,
					generateMask: this._generateMask,
					mask,
					maskBuffer: this._maskBuffer,
					opcode: 9,
					readOnly,
					rsv1: false,
				};
				if (isBlob(data)) {
					if (this._state !== DEFAULT) {
						this.enqueue([this.getBlobData, data, false, options, cb]);
					} else {
						this.getBlobData(data, false, options, cb);
					}
				} else if (this._state !== DEFAULT) {
					this.enqueue([this.dispatch, data, false, options, cb]);
				} else {
					this.sendFrame(_Sender.frame(data, options), cb);
				}
			}
			/**
			 * Sends a pong message to the other peer.
			 *
			 * @param {*} data The message to send
			 * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
			 * @param {Function} [cb] Callback
			 * @public
			 */
			pong(data, mask, cb) {
				let byteLength;
				let readOnly;
				if (typeof data === "string") {
					byteLength = Buffer.byteLength(data);
					readOnly = false;
				} else if (isBlob(data)) {
					byteLength = data.size;
					readOnly = false;
				} else {
					data = toBuffer(data);
					byteLength = data.length;
					readOnly = toBuffer.readOnly;
				}
				if (byteLength > 125) {
					throw new RangeError("The data size must not be greater than 125 bytes");
				}
				const options = {
					[kByteLength]: byteLength,
					fin: true,
					generateMask: this._generateMask,
					mask,
					maskBuffer: this._maskBuffer,
					opcode: 10,
					readOnly,
					rsv1: false,
				};
				if (isBlob(data)) {
					if (this._state !== DEFAULT) {
						this.enqueue([this.getBlobData, data, false, options, cb]);
					} else {
						this.getBlobData(data, false, options, cb);
					}
				} else if (this._state !== DEFAULT) {
					this.enqueue([this.dispatch, data, false, options, cb]);
				} else {
					this.sendFrame(_Sender.frame(data, options), cb);
				}
			}
			/**
			 * Sends a data message to the other peer.
			 *
			 * @param {*} data The message to send
			 * @param {Object} options Options object
			 * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
			 *     or text
			 * @param {Boolean} [options.compress=false] Specifies whether or not to
			 *     compress `data`
			 * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
			 *     last one
			 * @param {Boolean} [options.mask=false] Specifies whether or not to mask
			 *     `data`
			 * @param {Function} [cb] Callback
			 * @public
			 */
			send(data, options, cb) {
				const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
				let opcode = options.binary ? 2 : 1;
				let rsv1 = options.compress;
				let byteLength;
				let readOnly;
				if (typeof data === "string") {
					byteLength = Buffer.byteLength(data);
					readOnly = false;
				} else if (isBlob(data)) {
					byteLength = data.size;
					readOnly = false;
				} else {
					data = toBuffer(data);
					byteLength = data.length;
					readOnly = toBuffer.readOnly;
				}
				if (this._firstFragment) {
					this._firstFragment = false;
					if (
						rsv1 &&
						perMessageDeflate &&
						perMessageDeflate.params[
							perMessageDeflate._isServer
								? "server_no_context_takeover"
								: "client_no_context_takeover"
						]
					) {
						rsv1 = byteLength >= perMessageDeflate._threshold;
					}
					this._compress = rsv1;
				} else {
					rsv1 = false;
					opcode = 0;
				}
				if (options.fin) this._firstFragment = true;
				const opts = {
					[kByteLength]: byteLength,
					fin: options.fin,
					generateMask: this._generateMask,
					mask: options.mask,
					maskBuffer: this._maskBuffer,
					opcode,
					readOnly,
					rsv1,
				};
				if (isBlob(data)) {
					if (this._state !== DEFAULT) {
						this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
					} else {
						this.getBlobData(data, this._compress, opts, cb);
					}
				} else if (this._state !== DEFAULT) {
					this.enqueue([this.dispatch, data, this._compress, opts, cb]);
				} else {
					this.dispatch(data, this._compress, opts, cb);
				}
			}
			/**
			 * Gets the contents of a blob as binary data.
			 *
			 * @param {Blob} blob The blob
			 * @param {Boolean} [compress=false] Specifies whether or not to compress
			 *     the data
			 * @param {Object} options Options object
			 * @param {Boolean} [options.fin=false] Specifies whether or not to set the
			 *     FIN bit
			 * @param {Function} [options.generateMask] The function used to generate the
			 *     masking key
			 * @param {Boolean} [options.mask=false] Specifies whether or not to mask
			 *     `data`
			 * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
			 *     key
			 * @param {Number} options.opcode The opcode
			 * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
			 *     modified
			 * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
			 *     RSV1 bit
			 * @param {Function} [cb] Callback
			 * @private
			 */
			getBlobData(blob, compress, options, cb) {
				this._bufferedBytes += options[kByteLength];
				this._state = GET_BLOB_DATA;
				blob.arrayBuffer()
					.then((arrayBuffer) => {
						if (this._socket.destroyed) {
							const err = new Error(
								"The socket was closed while the blob was being read",
							);
							process.nextTick(callCallbacks, this, err, cb);
							return;
						}
						this._bufferedBytes -= options[kByteLength];
						const data = toBuffer(arrayBuffer);
						if (!compress) {
							this._state = DEFAULT;
							this.sendFrame(_Sender.frame(data, options), cb);
							this.dequeue();
						} else {
							this.dispatch(data, compress, options, cb);
						}
					})
					.catch((err) => {
						process.nextTick(onError, this, err, cb);
					});
			}
			/**
			 * Dispatches a message.
			 *
			 * @param {(Buffer|String)} data The message to send
			 * @param {Boolean} [compress=false] Specifies whether or not to compress
			 *     `data`
			 * @param {Object} options Options object
			 * @param {Boolean} [options.fin=false] Specifies whether or not to set the
			 *     FIN bit
			 * @param {Function} [options.generateMask] The function used to generate the
			 *     masking key
			 * @param {Boolean} [options.mask=false] Specifies whether or not to mask
			 *     `data`
			 * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
			 *     key
			 * @param {Number} options.opcode The opcode
			 * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
			 *     modified
			 * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
			 *     RSV1 bit
			 * @param {Function} [cb] Callback
			 * @private
			 */
			dispatch(data, compress, options, cb) {
				if (!compress) {
					this.sendFrame(_Sender.frame(data, options), cb);
					return;
				}
				const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
				this._bufferedBytes += options[kByteLength];
				this._state = DEFLATING;
				perMessageDeflate.compress(data, options.fin, (_, buf) => {
					if (this._socket.destroyed) {
						const err = new Error(
							"The socket was closed while data was being compressed",
						);
						callCallbacks(this, err, cb);
						return;
					}
					this._bufferedBytes -= options[kByteLength];
					this._state = DEFAULT;
					options.readOnly = false;
					this.sendFrame(_Sender.frame(buf, options), cb);
					this.dequeue();
				});
			}
			/**
			 * Executes queued send operations.
			 *
			 * @private
			 */
			dequeue() {
				while (this._state === DEFAULT && this._queue.length) {
					const params = this._queue.shift();
					this._bufferedBytes -= params[3][kByteLength];
					Reflect.apply(params[0], this, params.slice(1));
				}
			}
			/**
			 * Enqueues a send operation.
			 *
			 * @param {Array} params Send operation parameters.
			 * @private
			 */
			enqueue(params) {
				this._bufferedBytes += params[3][kByteLength];
				this._queue.push(params);
			}
			/**
			 * Sends a frame.
			 *
			 * @param {Buffer[]} list The frame to send
			 * @param {Function} [cb] Callback
			 * @private
			 */
			sendFrame(list, cb) {
				if (list.length === 2) {
					this._socket.cork();
					this._socket.write(list[0]);
					this._socket.write(list[1], cb);
					this._socket.uncork();
				} else {
					this._socket.write(list[0], cb);
				}
			}
		};
		module2.exports = Sender;
		function callCallbacks(sender, err, cb) {
			if (typeof cb === "function") cb(err);
			for (let i = 0; i < sender._queue.length; i++) {
				const params = sender._queue[i];
				const callback = params[params.length - 1];
				if (typeof callback === "function") callback(err);
			}
		}
		function onError(sender, err, cb) {
			callCallbacks(sender, err, cb);
			sender.onerror(err);
		}
	},
});

// node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
	"node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/event-target.js"(exports2, module2) {
		"use strict";
		var { kForOnEventAttribute, kListener } = require_constants7();
		var kCode = Symbol("kCode");
		var kData = Symbol("kData");
		var kError = Symbol("kError");
		var kMessage = Symbol("kMessage");
		var kReason = Symbol("kReason");
		var kTarget = Symbol("kTarget");
		var kType = Symbol("kType");
		var kWasClean = Symbol("kWasClean");
		var Event2 = class {
			/**
			 * Create a new `Event`.
			 *
			 * @param {String} type The name of the event
			 * @throws {TypeError} If the `type` argument is not specified
			 */
			constructor(type) {
				this[kTarget] = null;
				this[kType] = type;
			}
			/**
			 * @type {*}
			 */
			get target() {
				return this[kTarget];
			}
			/**
			 * @type {String}
			 */
			get type() {
				return this[kType];
			}
		};
		Object.defineProperty(Event2.prototype, "target", { enumerable: true });
		Object.defineProperty(Event2.prototype, "type", { enumerable: true });
		var CloseEvent = class extends Event2 {
			/**
			 * Create a new `CloseEvent`.
			 *
			 * @param {String} type The name of the event
			 * @param {Object} [options] A dictionary object that allows for setting
			 *     attributes via object members of the same name
			 * @param {Number} [options.code=0] The status code explaining why the
			 *     connection was closed
			 * @param {String} [options.reason=''] A human-readable string explaining why
			 *     the connection was closed
			 * @param {Boolean} [options.wasClean=false] Indicates whether or not the
			 *     connection was cleanly closed
			 */
			constructor(type, options = {}) {
				super(type);
				this[kCode] = options.code === void 0 ? 0 : options.code;
				this[kReason] = options.reason === void 0 ? "" : options.reason;
				this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
			}
			/**
			 * @type {Number}
			 */
			get code() {
				return this[kCode];
			}
			/**
			 * @type {String}
			 */
			get reason() {
				return this[kReason];
			}
			/**
			 * @type {Boolean}
			 */
			get wasClean() {
				return this[kWasClean];
			}
		};
		Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
		Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
		Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
		var ErrorEvent = class extends Event2 {
			/**
			 * Create a new `ErrorEvent`.
			 *
			 * @param {String} type The name of the event
			 * @param {Object} [options] A dictionary object that allows for setting
			 *     attributes via object members of the same name
			 * @param {*} [options.error=null] The error that generated this event
			 * @param {String} [options.message=''] The error message
			 */
			constructor(type, options = {}) {
				super(type);
				this[kError] = options.error === void 0 ? null : options.error;
				this[kMessage] = options.message === void 0 ? "" : options.message;
			}
			/**
			 * @type {*}
			 */
			get error() {
				return this[kError];
			}
			/**
			 * @type {String}
			 */
			get message() {
				return this[kMessage];
			}
		};
		Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
		Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
		var MessageEvent = class extends Event2 {
			/**
			 * Create a new `MessageEvent`.
			 *
			 * @param {String} type The name of the event
			 * @param {Object} [options] A dictionary object that allows for setting
			 *     attributes via object members of the same name
			 * @param {*} [options.data=null] The message content
			 */
			constructor(type, options = {}) {
				super(type);
				this[kData] = options.data === void 0 ? null : options.data;
			}
			/**
			 * @type {*}
			 */
			get data() {
				return this[kData];
			}
		};
		Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
		var EventTarget2 = {
			/**
			 * Register an event listener.
			 *
			 * @param {String} type A string representing the event type to listen for
			 * @param {(Function|Object)} handler The listener to add
			 * @param {Object} [options] An options object specifies characteristics about
			 *     the event listener
			 * @param {Boolean} [options.once=false] A `Boolean` indicating that the
			 *     listener should be invoked at most once after being added. If `true`,
			 *     the listener would be automatically removed when invoked.
			 * @public
			 */
			addEventListener(type, handler, options = {}) {
				for (const listener of this.listeners(type)) {
					if (
						!options[kForOnEventAttribute] &&
						listener[kListener] === handler &&
						!listener[kForOnEventAttribute]
					) {
						return;
					}
				}
				let wrapper;
				if (type === "message") {
					wrapper = function onMessage(data, isBinary) {
						const event = new MessageEvent("message", {
							data: isBinary ? data : data.toString(),
						});
						event[kTarget] = this;
						callListener(handler, this, event);
					};
				} else if (type === "close") {
					wrapper = function onClose(code, message) {
						const event = new CloseEvent("close", {
							code,
							reason: message.toString(),
							wasClean: this._closeFrameReceived && this._closeFrameSent,
						});
						event[kTarget] = this;
						callListener(handler, this, event);
					};
				} else if (type === "error") {
					wrapper = function onError(error) {
						const event = new ErrorEvent("error", {
							error,
							message: error.message,
						});
						event[kTarget] = this;
						callListener(handler, this, event);
					};
				} else if (type === "open") {
					wrapper = function onOpen() {
						const event = new Event2("open");
						event[kTarget] = this;
						callListener(handler, this, event);
					};
				} else {
					return;
				}
				wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
				wrapper[kListener] = handler;
				if (options.once) {
					this.once(type, wrapper);
				} else {
					this.on(type, wrapper);
				}
			},
			/**
			 * Remove an event listener.
			 *
			 * @param {String} type A string representing the event type to remove
			 * @param {(Function|Object)} handler The listener to remove
			 * @public
			 */
			removeEventListener(type, handler) {
				for (const listener of this.listeners(type)) {
					if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
						this.removeListener(type, listener);
						break;
					}
				}
			},
		};
		module2.exports = {
			CloseEvent,
			ErrorEvent,
			Event: Event2,
			EventTarget: EventTarget2,
			MessageEvent,
		};
		function callListener(listener, thisArg, event) {
			if (typeof listener === "object" && listener.handleEvent) {
				listener.handleEvent.call(listener, event);
			} else {
				listener.call(thisArg, event);
			}
		}
	},
});

// node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/extension.js
var require_extension = __commonJS({
	"node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/extension.js"(exports2, module2) {
		"use strict";
		var { tokenChars } = require_validation();
		function push(dest, name, elem) {
			if (dest[name] === void 0) dest[name] = [elem];
			else dest[name].push(elem);
		}
		function parse(header) {
			const offers = /* @__PURE__ */ Object.create(null);
			let params = /* @__PURE__ */ Object.create(null);
			let mustUnescape = false;
			let isEscaping = false;
			let inQuotes = false;
			let extensionName;
			let paramName;
			let start = -1;
			let code = -1;
			let end = -1;
			let i = 0;
			for (; i < header.length; i++) {
				code = header.charCodeAt(i);
				if (extensionName === void 0) {
					if (end === -1 && tokenChars[code] === 1) {
						if (start === -1) start = i;
					} else if (i !== 0 && (code === 32 || code === 9)) {
						if (end === -1 && start !== -1) end = i;
					} else if (code === 59 || code === 44) {
						if (start === -1) {
							throw new SyntaxError(`Unexpected character at index ${i}`);
						}
						if (end === -1) end = i;
						const name = header.slice(start, end);
						if (code === 44) {
							push(offers, name, params);
							params = /* @__PURE__ */ Object.create(null);
						} else {
							extensionName = name;
						}
						start = end = -1;
					} else {
						throw new SyntaxError(`Unexpected character at index ${i}`);
					}
				} else if (paramName === void 0) {
					if (end === -1 && tokenChars[code] === 1) {
						if (start === -1) start = i;
					} else if (code === 32 || code === 9) {
						if (end === -1 && start !== -1) end = i;
					} else if (code === 59 || code === 44) {
						if (start === -1) {
							throw new SyntaxError(`Unexpected character at index ${i}`);
						}
						if (end === -1) end = i;
						push(params, header.slice(start, end), true);
						if (code === 44) {
							push(offers, extensionName, params);
							params = /* @__PURE__ */ Object.create(null);
							extensionName = void 0;
						}
						start = end = -1;
					} else if (code === 61 && start !== -1 && end === -1) {
						paramName = header.slice(start, i);
						start = end = -1;
					} else {
						throw new SyntaxError(`Unexpected character at index ${i}`);
					}
				} else {
					if (isEscaping) {
						if (tokenChars[code] !== 1) {
							throw new SyntaxError(`Unexpected character at index ${i}`);
						}
						if (start === -1) start = i;
						else if (!mustUnescape) mustUnescape = true;
						isEscaping = false;
					} else if (inQuotes) {
						if (tokenChars[code] === 1) {
							if (start === -1) start = i;
						} else if (code === 34 && start !== -1) {
							inQuotes = false;
							end = i;
						} else if (code === 92) {
							isEscaping = true;
						} else {
							throw new SyntaxError(`Unexpected character at index ${i}`);
						}
					} else if (code === 34 && header.charCodeAt(i - 1) === 61) {
						inQuotes = true;
					} else if (end === -1 && tokenChars[code] === 1) {
						if (start === -1) start = i;
					} else if (start !== -1 && (code === 32 || code === 9)) {
						if (end === -1) end = i;
					} else if (code === 59 || code === 44) {
						if (start === -1) {
							throw new SyntaxError(`Unexpected character at index ${i}`);
						}
						if (end === -1) end = i;
						let value = header.slice(start, end);
						if (mustUnescape) {
							value = value.replace(/\\/g, "");
							mustUnescape = false;
						}
						push(params, paramName, value);
						if (code === 44) {
							push(offers, extensionName, params);
							params = /* @__PURE__ */ Object.create(null);
							extensionName = void 0;
						}
						paramName = void 0;
						start = end = -1;
					} else {
						throw new SyntaxError(`Unexpected character at index ${i}`);
					}
				}
			}
			if (start === -1 || inQuotes || code === 32 || code === 9) {
				throw new SyntaxError("Unexpected end of input");
			}
			if (end === -1) end = i;
			const token = header.slice(start, end);
			if (extensionName === void 0) {
				push(offers, token, params);
			} else {
				if (paramName === void 0) {
					push(params, token, true);
				} else if (mustUnescape) {
					push(params, paramName, token.replace(/\\/g, ""));
				} else {
					push(params, paramName, token);
				}
				push(offers, extensionName, params);
			}
			return offers;
		}
		function format(extensions) {
			return Object.keys(extensions)
				.map((extension) => {
					let configurations = extensions[extension];
					if (!Array.isArray(configurations)) configurations = [configurations];
					return configurations
						.map((params) => {
							return [extension]
								.concat(
									Object.keys(params).map((k) => {
										let values = params[k];
										if (!Array.isArray(values)) values = [values];
										return values
											.map((v) => (v === true ? k : `${k}=${v}`))
											.join("; ");
									}),
								)
								.join("; ");
						})
						.join(", ");
				})
				.join(", ");
		}
		module2.exports = { format, parse };
	},
});

// node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/websocket.js
var require_websocket2 = __commonJS({
	"node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/websocket.js"(exports2, module2) {
		"use strict";
		var EventEmitter = require("events");
		var https = require("https");
		var http = require("http");
		var net = require("net");
		var tls = require("tls");
		var { randomBytes, createHash } = require("crypto");
		var { Duplex, Readable } = require("stream");
		var { URL: URL2 } = require("url");
		var PerMessageDeflate = require_permessage_deflate();
		var Receiver = require_receiver2();
		var Sender = require_sender();
		var { isBlob } = require_validation();
		var {
			BINARY_TYPES,
			EMPTY_BUFFER,
			GUID,
			kForOnEventAttribute,
			kListener,
			kStatusCode,
			kWebSocket,
			NOOP,
		} = require_constants7();
		var {
			EventTarget: { addEventListener, removeEventListener },
		} = require_event_target();
		var { format, parse } = require_extension();
		var { toBuffer } = require_buffer_util();
		var closeTimeout = 30 * 1e3;
		var kAborted = Symbol("kAborted");
		var protocolVersions = [8, 13];
		var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
		var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
		var WebSocket = class _WebSocket extends EventEmitter {
			/**
			 * Create a new `WebSocket`.
			 *
			 * @param {(String|URL)} address The URL to which to connect
			 * @param {(String|String[])} [protocols] The subprotocols
			 * @param {Object} [options] Connection options
			 */
			constructor(address, protocols, options) {
				super();
				this._binaryType = BINARY_TYPES[0];
				this._closeCode = 1006;
				this._closeFrameReceived = false;
				this._closeFrameSent = false;
				this._closeMessage = EMPTY_BUFFER;
				this._closeTimer = null;
				this._errorEmitted = false;
				this._extensions = {};
				this._paused = false;
				this._protocol = "";
				this._readyState = _WebSocket.CONNECTING;
				this._receiver = null;
				this._sender = null;
				this._socket = null;
				if (address !== null) {
					this._bufferedAmount = 0;
					this._isServer = false;
					this._redirects = 0;
					if (protocols === void 0) {
						protocols = [];
					} else if (!Array.isArray(protocols)) {
						if (typeof protocols === "object" && protocols !== null) {
							options = protocols;
							protocols = [];
						} else {
							protocols = [protocols];
						}
					}
					initAsClient(this, address, protocols, options);
				} else {
					this._autoPong = options.autoPong;
					this._isServer = true;
				}
			}
			/**
			 * For historical reasons, the custom "nodebuffer" type is used by the default
			 * instead of "blob".
			 *
			 * @type {String}
			 */
			get binaryType() {
				return this._binaryType;
			}
			set binaryType(type) {
				if (!BINARY_TYPES.includes(type)) return;
				this._binaryType = type;
				if (this._receiver) this._receiver._binaryType = type;
			}
			/**
			 * @type {Number}
			 */
			get bufferedAmount() {
				if (!this._socket) return this._bufferedAmount;
				return this._socket._writableState.length + this._sender._bufferedBytes;
			}
			/**
			 * @type {String}
			 */
			get extensions() {
				return Object.keys(this._extensions).join();
			}
			/**
			 * @type {Boolean}
			 */
			get isPaused() {
				return this._paused;
			}
			/**
			 * @type {Function}
			 */
			/* istanbul ignore next */
			get onclose() {
				return null;
			}
			/**
			 * @type {Function}
			 */
			/* istanbul ignore next */
			get onerror() {
				return null;
			}
			/**
			 * @type {Function}
			 */
			/* istanbul ignore next */
			get onopen() {
				return null;
			}
			/**
			 * @type {Function}
			 */
			/* istanbul ignore next */
			get onmessage() {
				return null;
			}
			/**
			 * @type {String}
			 */
			get protocol() {
				return this._protocol;
			}
			/**
			 * @type {Number}
			 */
			get readyState() {
				return this._readyState;
			}
			/**
			 * @type {String}
			 */
			get url() {
				return this._url;
			}
			/**
			 * Set up the socket and the internal resources.
			 *
			 * @param {Duplex} socket The network socket between the server and client
			 * @param {Buffer} head The first packet of the upgraded stream
			 * @param {Object} options Options object
			 * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
			 *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
			 *     multiple times in the same tick
			 * @param {Function} [options.generateMask] The function used to generate the
			 *     masking key
			 * @param {Number} [options.maxPayload=0] The maximum allowed message size
			 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
			 *     not to skip UTF-8 validation for text and close messages
			 * @private
			 */
			setSocket(socket, head, options) {
				const receiver = new Receiver({
					allowSynchronousEvents: options.allowSynchronousEvents,
					binaryType: this.binaryType,
					extensions: this._extensions,
					isServer: this._isServer,
					maxPayload: options.maxPayload,
					skipUTF8Validation: options.skipUTF8Validation,
				});
				const sender = new Sender(socket, this._extensions, options.generateMask);
				this._receiver = receiver;
				this._sender = sender;
				this._socket = socket;
				receiver[kWebSocket] = this;
				sender[kWebSocket] = this;
				socket[kWebSocket] = this;
				receiver.on("conclude", receiverOnConclude);
				receiver.on("drain", receiverOnDrain);
				receiver.on("error", receiverOnError);
				receiver.on("message", receiverOnMessage);
				receiver.on("ping", receiverOnPing);
				receiver.on("pong", receiverOnPong);
				sender.onerror = senderOnError;
				if (socket.setTimeout) socket.setTimeout(0);
				if (socket.setNoDelay) socket.setNoDelay();
				if (head.length > 0) socket.unshift(head);
				socket.on("close", socketOnClose);
				socket.on("data", socketOnData);
				socket.on("end", socketOnEnd);
				socket.on("error", socketOnError);
				this._readyState = _WebSocket.OPEN;
				this.emit("open");
			}
			/**
			 * Emit the `'close'` event.
			 *
			 * @private
			 */
			emitClose() {
				if (!this._socket) {
					this._readyState = _WebSocket.CLOSED;
					this.emit("close", this._closeCode, this._closeMessage);
					return;
				}
				if (this._extensions[PerMessageDeflate.extensionName]) {
					this._extensions[PerMessageDeflate.extensionName].cleanup();
				}
				this._receiver.removeAllListeners();
				this._readyState = _WebSocket.CLOSED;
				this.emit("close", this._closeCode, this._closeMessage);
			}
			/**
			 * Start a closing handshake.
			 *
			 *          +----------+   +-----------+   +----------+
			 *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
			 *    |     +----------+   +-----------+   +----------+     |
			 *          +----------+   +-----------+         |
			 * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
			 *          +----------+   +-----------+   |
			 *    |           |                        |   +---+        |
			 *                +------------------------+-->|fin| - - - -
			 *    |         +---+                      |   +---+
			 *     - - - - -|fin|<---------------------+
			 *              +---+
			 *
			 * @param {Number} [code] Status code explaining why the connection is closing
			 * @param {(String|Buffer)} [data] The reason why the connection is
			 *     closing
			 * @public
			 */
			close(code, data) {
				if (this.readyState === _WebSocket.CLOSED) return;
				if (this.readyState === _WebSocket.CONNECTING) {
					const msg = "WebSocket was closed before the connection was established";
					abortHandshake(this, this._req, msg);
					return;
				}
				if (this.readyState === _WebSocket.CLOSING) {
					if (
						this._closeFrameSent &&
						(this._closeFrameReceived || this._receiver._writableState.errorEmitted)
					) {
						this._socket.end();
					}
					return;
				}
				this._readyState = _WebSocket.CLOSING;
				this._sender.close(code, data, !this._isServer, (err) => {
					if (err) return;
					this._closeFrameSent = true;
					if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
						this._socket.end();
					}
				});
				setCloseTimer(this);
			}
			/**
			 * Pause the socket.
			 *
			 * @public
			 */
			pause() {
				if (
					this.readyState === _WebSocket.CONNECTING ||
					this.readyState === _WebSocket.CLOSED
				) {
					return;
				}
				this._paused = true;
				this._socket.pause();
			}
			/**
			 * Send a ping.
			 *
			 * @param {*} [data] The data to send
			 * @param {Boolean} [mask] Indicates whether or not to mask `data`
			 * @param {Function} [cb] Callback which is executed when the ping is sent
			 * @public
			 */
			ping(data, mask, cb) {
				if (this.readyState === _WebSocket.CONNECTING) {
					throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
				}
				if (typeof data === "function") {
					cb = data;
					data = mask = void 0;
				} else if (typeof mask === "function") {
					cb = mask;
					mask = void 0;
				}
				if (typeof data === "number") data = data.toString();
				if (this.readyState !== _WebSocket.OPEN) {
					sendAfterClose(this, data, cb);
					return;
				}
				if (mask === void 0) mask = !this._isServer;
				this._sender.ping(data || EMPTY_BUFFER, mask, cb);
			}
			/**
			 * Send a pong.
			 *
			 * @param {*} [data] The data to send
			 * @param {Boolean} [mask] Indicates whether or not to mask `data`
			 * @param {Function} [cb] Callback which is executed when the pong is sent
			 * @public
			 */
			pong(data, mask, cb) {
				if (this.readyState === _WebSocket.CONNECTING) {
					throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
				}
				if (typeof data === "function") {
					cb = data;
					data = mask = void 0;
				} else if (typeof mask === "function") {
					cb = mask;
					mask = void 0;
				}
				if (typeof data === "number") data = data.toString();
				if (this.readyState !== _WebSocket.OPEN) {
					sendAfterClose(this, data, cb);
					return;
				}
				if (mask === void 0) mask = !this._isServer;
				this._sender.pong(data || EMPTY_BUFFER, mask, cb);
			}
			/**
			 * Resume the socket.
			 *
			 * @public
			 */
			resume() {
				if (
					this.readyState === _WebSocket.CONNECTING ||
					this.readyState === _WebSocket.CLOSED
				) {
					return;
				}
				this._paused = false;
				if (!this._receiver._writableState.needDrain) this._socket.resume();
			}
			/**
			 * Send a data message.
			 *
			 * @param {*} data The message to send
			 * @param {Object} [options] Options object
			 * @param {Boolean} [options.binary] Specifies whether `data` is binary or
			 *     text
			 * @param {Boolean} [options.compress] Specifies whether or not to compress
			 *     `data`
			 * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
			 *     last one
			 * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
			 * @param {Function} [cb] Callback which is executed when data is written out
			 * @public
			 */
			send(data, options, cb) {
				if (this.readyState === _WebSocket.CONNECTING) {
					throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
				}
				if (typeof options === "function") {
					cb = options;
					options = {};
				}
				if (typeof data === "number") data = data.toString();
				if (this.readyState !== _WebSocket.OPEN) {
					sendAfterClose(this, data, cb);
					return;
				}
				const opts = {
					binary: typeof data !== "string",
					mask: !this._isServer,
					compress: true,
					fin: true,
					...options,
				};
				if (!this._extensions[PerMessageDeflate.extensionName]) {
					opts.compress = false;
				}
				this._sender.send(data || EMPTY_BUFFER, opts, cb);
			}
			/**
			 * Forcibly close the connection.
			 *
			 * @public
			 */
			terminate() {
				if (this.readyState === _WebSocket.CLOSED) return;
				if (this.readyState === _WebSocket.CONNECTING) {
					const msg = "WebSocket was closed before the connection was established";
					abortHandshake(this, this._req, msg);
					return;
				}
				if (this._socket) {
					this._readyState = _WebSocket.CLOSING;
					this._socket.destroy();
				}
			}
		};
		Object.defineProperty(WebSocket, "CONNECTING", {
			enumerable: true,
			value: readyStates.indexOf("CONNECTING"),
		});
		Object.defineProperty(WebSocket.prototype, "CONNECTING", {
			enumerable: true,
			value: readyStates.indexOf("CONNECTING"),
		});
		Object.defineProperty(WebSocket, "OPEN", {
			enumerable: true,
			value: readyStates.indexOf("OPEN"),
		});
		Object.defineProperty(WebSocket.prototype, "OPEN", {
			enumerable: true,
			value: readyStates.indexOf("OPEN"),
		});
		Object.defineProperty(WebSocket, "CLOSING", {
			enumerable: true,
			value: readyStates.indexOf("CLOSING"),
		});
		Object.defineProperty(WebSocket.prototype, "CLOSING", {
			enumerable: true,
			value: readyStates.indexOf("CLOSING"),
		});
		Object.defineProperty(WebSocket, "CLOSED", {
			enumerable: true,
			value: readyStates.indexOf("CLOSED"),
		});
		Object.defineProperty(WebSocket.prototype, "CLOSED", {
			enumerable: true,
			value: readyStates.indexOf("CLOSED"),
		});
		[
			"binaryType",
			"bufferedAmount",
			"extensions",
			"isPaused",
			"protocol",
			"readyState",
			"url",
		].forEach((property) => {
			Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
		});
		["open", "error", "close", "message"].forEach((method) => {
			Object.defineProperty(WebSocket.prototype, `on${method}`, {
				enumerable: true,
				get() {
					for (const listener of this.listeners(method)) {
						if (listener[kForOnEventAttribute]) return listener[kListener];
					}
					return null;
				},
				set(handler) {
					for (const listener of this.listeners(method)) {
						if (listener[kForOnEventAttribute]) {
							this.removeListener(method, listener);
							break;
						}
					}
					if (typeof handler !== "function") return;
					this.addEventListener(method, handler, {
						[kForOnEventAttribute]: true,
					});
				},
			});
		});
		WebSocket.prototype.addEventListener = addEventListener;
		WebSocket.prototype.removeEventListener = removeEventListener;
		module2.exports = WebSocket;
		function initAsClient(websocket, address, protocols, options) {
			const opts = {
				allowSynchronousEvents: true,
				autoPong: true,
				protocolVersion: protocolVersions[1],
				maxPayload: 100 * 1024 * 1024,
				skipUTF8Validation: false,
				perMessageDeflate: true,
				followRedirects: false,
				maxRedirects: 10,
				...options,
				socketPath: void 0,
				hostname: void 0,
				protocol: void 0,
				timeout: void 0,
				method: "GET",
				host: void 0,
				path: void 0,
				port: void 0,
			};
			websocket._autoPong = opts.autoPong;
			if (!protocolVersions.includes(opts.protocolVersion)) {
				throw new RangeError(
					`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`,
				);
			}
			let parsedUrl;
			if (address instanceof URL2) {
				parsedUrl = address;
			} else {
				try {
					parsedUrl = new URL2(address);
				} catch (e) {
					throw new SyntaxError(`Invalid URL: ${address}`);
				}
			}
			if (parsedUrl.protocol === "http:") {
				parsedUrl.protocol = "ws:";
			} else if (parsedUrl.protocol === "https:") {
				parsedUrl.protocol = "wss:";
			}
			websocket._url = parsedUrl.href;
			const isSecure = parsedUrl.protocol === "wss:";
			const isIpcUrl = parsedUrl.protocol === "ws+unix:";
			let invalidUrlMessage;
			if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
				invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", "http:", "https", or "ws+unix:"`;
			} else if (isIpcUrl && !parsedUrl.pathname) {
				invalidUrlMessage = "The URL's pathname is empty";
			} else if (parsedUrl.hash) {
				invalidUrlMessage = "The URL contains a fragment identifier";
			}
			if (invalidUrlMessage) {
				const err = new SyntaxError(invalidUrlMessage);
				if (websocket._redirects === 0) {
					throw err;
				} else {
					emitErrorAndClose(websocket, err);
					return;
				}
			}
			const defaultPort = isSecure ? 443 : 80;
			const key = randomBytes(16).toString("base64");
			const request = isSecure ? https.request : http.request;
			const protocolSet = /* @__PURE__ */ new Set();
			let perMessageDeflate;
			opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
			opts.defaultPort = opts.defaultPort || defaultPort;
			opts.port = parsedUrl.port || defaultPort;
			opts.host = parsedUrl.hostname.startsWith("[")
				? parsedUrl.hostname.slice(1, -1)
				: parsedUrl.hostname;
			opts.headers = {
				...opts.headers,
				"Sec-WebSocket-Version": opts.protocolVersion,
				"Sec-WebSocket-Key": key,
				Connection: "Upgrade",
				Upgrade: "websocket",
			};
			opts.path = parsedUrl.pathname + parsedUrl.search;
			opts.timeout = opts.handshakeTimeout;
			if (opts.perMessageDeflate) {
				perMessageDeflate = new PerMessageDeflate(
					opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
					false,
					opts.maxPayload,
				);
				opts.headers["Sec-WebSocket-Extensions"] = format({
					[PerMessageDeflate.extensionName]: perMessageDeflate.offer(),
				});
			}
			if (protocols.length) {
				for (const protocol of protocols) {
					if (
						typeof protocol !== "string" ||
						!subprotocolRegex.test(protocol) ||
						protocolSet.has(protocol)
					) {
						throw new SyntaxError("An invalid or duplicated subprotocol was specified");
					}
					protocolSet.add(protocol);
				}
				opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
			}
			if (opts.origin) {
				if (opts.protocolVersion < 13) {
					opts.headers["Sec-WebSocket-Origin"] = opts.origin;
				} else {
					opts.headers.Origin = opts.origin;
				}
			}
			if (parsedUrl.username || parsedUrl.password) {
				opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
			}
			if (isIpcUrl) {
				const parts = opts.path.split(":");
				opts.socketPath = parts[0];
				opts.path = parts[1];
			}
			let req;
			if (opts.followRedirects) {
				if (websocket._redirects === 0) {
					websocket._originalIpc = isIpcUrl;
					websocket._originalSecure = isSecure;
					websocket._originalHostOrSocketPath = isIpcUrl
						? opts.socketPath
						: parsedUrl.host;
					const headers = options && options.headers;
					options = { ...options, headers: {} };
					if (headers) {
						for (const [key2, value] of Object.entries(headers)) {
							options.headers[key2.toLowerCase()] = value;
						}
					}
				} else if (websocket.listenerCount("redirect") === 0) {
					const isSameHost = isIpcUrl
						? websocket._originalIpc
							? opts.socketPath === websocket._originalHostOrSocketPath
							: false
						: websocket._originalIpc
							? false
							: parsedUrl.host === websocket._originalHostOrSocketPath;
					if (!isSameHost || (websocket._originalSecure && !isSecure)) {
						delete opts.headers.authorization;
						delete opts.headers.cookie;
						if (!isSameHost) delete opts.headers.host;
						opts.auth = void 0;
					}
				}
				if (opts.auth && !options.headers.authorization) {
					options.headers.authorization =
						"Basic " + Buffer.from(opts.auth).toString("base64");
				}
				req = websocket._req = request(opts);
				if (websocket._redirects) {
					websocket.emit("redirect", websocket.url, req);
				}
			} else {
				req = websocket._req = request(opts);
			}
			if (opts.timeout) {
				req.on("timeout", () => {
					abortHandshake(websocket, req, "Opening handshake has timed out");
				});
			}
			req.on("error", (err) => {
				if (req === null || req[kAborted]) return;
				req = websocket._req = null;
				emitErrorAndClose(websocket, err);
			});
			req.on("response", (res) => {
				const location = res.headers.location;
				const statusCode = res.statusCode;
				if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
					if (++websocket._redirects > opts.maxRedirects) {
						abortHandshake(websocket, req, "Maximum redirects exceeded");
						return;
					}
					req.abort();
					let addr;
					try {
						addr = new URL2(location, address);
					} catch (e) {
						const err = new SyntaxError(`Invalid URL: ${location}`);
						emitErrorAndClose(websocket, err);
						return;
					}
					initAsClient(websocket, addr, protocols, options);
				} else if (!websocket.emit("unexpected-response", req, res)) {
					abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
				}
			});
			req.on("upgrade", (res, socket, head) => {
				websocket.emit("upgrade", res);
				if (websocket.readyState !== WebSocket.CONNECTING) return;
				req = websocket._req = null;
				const upgrade = res.headers.upgrade;
				if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
					abortHandshake(websocket, socket, "Invalid Upgrade header");
					return;
				}
				const digest = createHash("sha1")
					.update(key + GUID)
					.digest("base64");
				if (res.headers["sec-websocket-accept"] !== digest) {
					abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
					return;
				}
				const serverProt = res.headers["sec-websocket-protocol"];
				let protError;
				if (serverProt !== void 0) {
					if (!protocolSet.size) {
						protError = "Server sent a subprotocol but none was requested";
					} else if (!protocolSet.has(serverProt)) {
						protError = "Server sent an invalid subprotocol";
					}
				} else if (protocolSet.size) {
					protError = "Server sent no subprotocol";
				}
				if (protError) {
					abortHandshake(websocket, socket, protError);
					return;
				}
				if (serverProt) websocket._protocol = serverProt;
				const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
				if (secWebSocketExtensions !== void 0) {
					if (!perMessageDeflate) {
						const message =
							"Server sent a Sec-WebSocket-Extensions header but no extension was requested";
						abortHandshake(websocket, socket, message);
						return;
					}
					let extensions;
					try {
						extensions = parse(secWebSocketExtensions);
					} catch (err) {
						const message = "Invalid Sec-WebSocket-Extensions header";
						abortHandshake(websocket, socket, message);
						return;
					}
					const extensionNames = Object.keys(extensions);
					if (
						extensionNames.length !== 1 ||
						extensionNames[0] !== PerMessageDeflate.extensionName
					) {
						const message = "Server indicated an extension that was not requested";
						abortHandshake(websocket, socket, message);
						return;
					}
					try {
						perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
					} catch (err) {
						const message = "Invalid Sec-WebSocket-Extensions header";
						abortHandshake(websocket, socket, message);
						return;
					}
					websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
				}
				websocket.setSocket(socket, head, {
					allowSynchronousEvents: opts.allowSynchronousEvents,
					generateMask: opts.generateMask,
					maxPayload: opts.maxPayload,
					skipUTF8Validation: opts.skipUTF8Validation,
				});
			});
			if (opts.finishRequest) {
				opts.finishRequest(req, websocket);
			} else {
				req.end();
			}
		}
		function emitErrorAndClose(websocket, err) {
			websocket._readyState = WebSocket.CLOSING;
			websocket._errorEmitted = true;
			websocket.emit("error", err);
			websocket.emitClose();
		}
		function netConnect(options) {
			options.path = options.socketPath;
			return net.connect(options);
		}
		function tlsConnect(options) {
			options.path = void 0;
			if (!options.servername && options.servername !== "") {
				options.servername = net.isIP(options.host) ? "" : options.host;
			}
			return tls.connect(options);
		}
		function abortHandshake(websocket, stream, message) {
			websocket._readyState = WebSocket.CLOSING;
			const err = new Error(message);
			Error.captureStackTrace(err, abortHandshake);
			if (stream.setHeader) {
				stream[kAborted] = true;
				stream.abort();
				if (stream.socket && !stream.socket.destroyed) {
					stream.socket.destroy();
				}
				process.nextTick(emitErrorAndClose, websocket, err);
			} else {
				stream.destroy(err);
				stream.once("error", websocket.emit.bind(websocket, "error"));
				stream.once("close", websocket.emitClose.bind(websocket));
			}
		}
		function sendAfterClose(websocket, data, cb) {
			if (data) {
				const length = isBlob(data) ? data.size : toBuffer(data).length;
				if (websocket._socket) websocket._sender._bufferedBytes += length;
				else websocket._bufferedAmount += length;
			}
			if (cb) {
				const err = new Error(
					`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`,
				);
				process.nextTick(cb, err);
			}
		}
		function receiverOnConclude(code, reason) {
			const websocket = this[kWebSocket];
			websocket._closeFrameReceived = true;
			websocket._closeMessage = reason;
			websocket._closeCode = code;
			if (websocket._socket[kWebSocket] === void 0) return;
			websocket._socket.removeListener("data", socketOnData);
			process.nextTick(resume, websocket._socket);
			if (code === 1005) websocket.close();
			else websocket.close(code, reason);
		}
		function receiverOnDrain() {
			const websocket = this[kWebSocket];
			if (!websocket.isPaused) websocket._socket.resume();
		}
		function receiverOnError(err) {
			const websocket = this[kWebSocket];
			if (websocket._socket[kWebSocket] !== void 0) {
				websocket._socket.removeListener("data", socketOnData);
				process.nextTick(resume, websocket._socket);
				websocket.close(err[kStatusCode]);
			}
			if (!websocket._errorEmitted) {
				websocket._errorEmitted = true;
				websocket.emit("error", err);
			}
		}
		function receiverOnFinish() {
			this[kWebSocket].emitClose();
		}
		function receiverOnMessage(data, isBinary) {
			this[kWebSocket].emit("message", data, isBinary);
		}
		function receiverOnPing(data) {
			const websocket = this[kWebSocket];
			if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
			websocket.emit("ping", data);
		}
		function receiverOnPong(data) {
			this[kWebSocket].emit("pong", data);
		}
		function resume(stream) {
			stream.resume();
		}
		function senderOnError(err) {
			const websocket = this[kWebSocket];
			if (websocket.readyState === WebSocket.CLOSED) return;
			if (websocket.readyState === WebSocket.OPEN) {
				websocket._readyState = WebSocket.CLOSING;
				setCloseTimer(websocket);
			}
			this._socket.end();
			if (!websocket._errorEmitted) {
				websocket._errorEmitted = true;
				websocket.emit("error", err);
			}
		}
		function setCloseTimer(websocket) {
			websocket._closeTimer = setTimeout(
				websocket._socket.destroy.bind(websocket._socket),
				closeTimeout,
			);
		}
		function socketOnClose() {
			const websocket = this[kWebSocket];
			this.removeListener("close", socketOnClose);
			this.removeListener("data", socketOnData);
			this.removeListener("end", socketOnEnd);
			websocket._readyState = WebSocket.CLOSING;
			let chunk;
			if (
				!this._readableState.endEmitted &&
				!websocket._closeFrameReceived &&
				!websocket._receiver._writableState.errorEmitted &&
				(chunk = websocket._socket.read()) !== null
			) {
				websocket._receiver.write(chunk);
			}
			websocket._receiver.end();
			this[kWebSocket] = void 0;
			clearTimeout(websocket._closeTimer);
			if (
				websocket._receiver._writableState.finished ||
				websocket._receiver._writableState.errorEmitted
			) {
				websocket.emitClose();
			} else {
				websocket._receiver.on("error", receiverOnFinish);
				websocket._receiver.on("finish", receiverOnFinish);
			}
		}
		function socketOnData(chunk) {
			if (!this[kWebSocket]._receiver.write(chunk)) {
				this.pause();
			}
		}
		function socketOnEnd() {
			const websocket = this[kWebSocket];
			websocket._readyState = WebSocket.CLOSING;
			websocket._receiver.end();
			this.end();
		}
		function socketOnError() {
			const websocket = this[kWebSocket];
			this.removeListener("error", socketOnError);
			this.on("error", NOOP);
			if (websocket) {
				websocket._readyState = WebSocket.CLOSING;
				this.destroy();
			}
		}
	},
});

// node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/stream.js
var require_stream = __commonJS({
	"node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/stream.js"(exports2, module2) {
		"use strict";
		var { Duplex } = require("stream");
		function emitClose(stream) {
			stream.emit("close");
		}
		function duplexOnEnd() {
			if (!this.destroyed && this._writableState.finished) {
				this.destroy();
			}
		}
		function duplexOnError(err) {
			this.removeListener("error", duplexOnError);
			this.destroy();
			if (this.listenerCount("error") === 0) {
				this.emit("error", err);
			}
		}
		function createWebSocketStream(ws, options) {
			let terminateOnDestroy = true;
			const duplex = new Duplex({
				...options,
				autoDestroy: false,
				emitClose: false,
				objectMode: false,
				writableObjectMode: false,
			});
			ws.on("message", function message(msg, isBinary) {
				const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
				if (!duplex.push(data)) ws.pause();
			});
			ws.once("error", function error(err) {
				if (duplex.destroyed) return;
				terminateOnDestroy = false;
				duplex.destroy(err);
			});
			ws.once("close", function close() {
				if (duplex.destroyed) return;
				duplex.push(null);
			});
			duplex._destroy = function (err, callback) {
				if (ws.readyState === ws.CLOSED) {
					callback(err);
					process.nextTick(emitClose, duplex);
					return;
				}
				let called = false;
				ws.once("error", function error(err2) {
					called = true;
					callback(err2);
				});
				ws.once("close", function close() {
					if (!called) callback(err);
					process.nextTick(emitClose, duplex);
				});
				if (terminateOnDestroy) ws.terminate();
			};
			duplex._final = function (callback) {
				if (ws.readyState === ws.CONNECTING) {
					ws.once("open", function open() {
						duplex._final(callback);
					});
					return;
				}
				if (ws._socket === null) return;
				if (ws._socket._writableState.finished) {
					callback();
					if (duplex._readableState.endEmitted) duplex.destroy();
				} else {
					ws._socket.once("finish", function finish() {
						callback();
					});
					ws.close();
				}
			};
			duplex._read = function () {
				if (ws.isPaused) ws.resume();
			};
			duplex._write = function (chunk, encoding, callback) {
				if (ws.readyState === ws.CONNECTING) {
					ws.once("open", function open() {
						duplex._write(chunk, encoding, callback);
					});
					return;
				}
				ws.send(chunk, callback);
			};
			duplex.on("end", duplexOnEnd);
			duplex.on("error", duplexOnError);
			return duplex;
		}
		module2.exports = createWebSocketStream;
	},
});

// node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
	"node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/subprotocol.js"(exports2, module2) {
		"use strict";
		var { tokenChars } = require_validation();
		function parse(header) {
			const protocols = /* @__PURE__ */ new Set();
			let start = -1;
			let end = -1;
			let i = 0;
			for (i; i < header.length; i++) {
				const code = header.charCodeAt(i);
				if (end === -1 && tokenChars[code] === 1) {
					if (start === -1) start = i;
				} else if (i !== 0 && (code === 32 || code === 9)) {
					if (end === -1 && start !== -1) end = i;
				} else if (code === 44) {
					if (start === -1) {
						throw new SyntaxError(`Unexpected character at index ${i}`);
					}
					if (end === -1) end = i;
					const protocol2 = header.slice(start, end);
					if (protocols.has(protocol2)) {
						throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
					}
					protocols.add(protocol2);
					start = end = -1;
				} else {
					throw new SyntaxError(`Unexpected character at index ${i}`);
				}
			}
			if (start === -1 || end !== -1) {
				throw new SyntaxError("Unexpected end of input");
			}
			const protocol = header.slice(start, i);
			if (protocols.has(protocol)) {
				throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
			}
			protocols.add(protocol);
			return protocols;
		}
		module2.exports = { parse };
	},
});

// node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
	"node_modules/.pnpm/ws@8.18.0/node_modules/ws/lib/websocket-server.js"(exports2, module2) {
		"use strict";
		var EventEmitter = require("events");
		var http = require("http");
		var { Duplex } = require("stream");
		var { createHash } = require("crypto");
		var extension = require_extension();
		var PerMessageDeflate = require_permessage_deflate();
		var subprotocol = require_subprotocol();
		var WebSocket = require_websocket2();
		var { GUID, kWebSocket } = require_constants7();
		var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
		var RUNNING = 0;
		var CLOSING = 1;
		var CLOSED = 2;
		var WebSocketServer = class extends EventEmitter {
			/**
			 * Create a `WebSocketServer` instance.
			 *
			 * @param {Object} options Configuration options
			 * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
			 *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
			 *     multiple times in the same tick
			 * @param {Boolean} [options.autoPong=true] Specifies whether or not to
			 *     automatically send a pong in response to a ping
			 * @param {Number} [options.backlog=511] The maximum length of the queue of
			 *     pending connections
			 * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
			 *     track clients
			 * @param {Function} [options.handleProtocols] A hook to handle protocols
			 * @param {String} [options.host] The hostname where to bind the server
			 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
			 *     size
			 * @param {Boolean} [options.noServer=false] Enable no server mode
			 * @param {String} [options.path] Accept only connections matching this path
			 * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
			 *     permessage-deflate
			 * @param {Number} [options.port] The port where to bind the server
			 * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
			 *     server to use
			 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
			 *     not to skip UTF-8 validation for text and close messages
			 * @param {Function} [options.verifyClient] A hook to reject connections
			 * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
			 *     class to use. It must be the `WebSocket` class or class that extends it
			 * @param {Function} [callback] A listener for the `listening` event
			 */
			constructor(options, callback) {
				super();
				options = {
					allowSynchronousEvents: true,
					autoPong: true,
					maxPayload: 100 * 1024 * 1024,
					skipUTF8Validation: false,
					perMessageDeflate: false,
					handleProtocols: null,
					clientTracking: true,
					verifyClient: null,
					noServer: false,
					backlog: null,
					// use default (511 as implemented in net.js)
					server: null,
					host: null,
					path: null,
					port: null,
					WebSocket,
					...options,
				};
				if (
					(options.port == null && !options.server && !options.noServer) ||
					(options.port != null && (options.server || options.noServer)) ||
					(options.server && options.noServer)
				) {
					throw new TypeError(
						'One and only one of the "port", "server", or "noServer" options must be specified',
					);
				}
				if (options.port != null) {
					this._server = http.createServer((req, res) => {
						const body = http.STATUS_CODES[426];
						res.writeHead(426, {
							"Content-Length": body.length,
							"Content-Type": "text/plain",
						});
						res.end(body);
					});
					this._server.listen(options.port, options.host, options.backlog, callback);
				} else if (options.server) {
					this._server = options.server;
				}
				if (this._server) {
					const emitConnection = this.emit.bind(this, "connection");
					this._removeListeners = addListeners(this._server, {
						listening: this.emit.bind(this, "listening"),
						error: this.emit.bind(this, "error"),
						upgrade: (req, socket, head) => {
							this.handleUpgrade(req, socket, head, emitConnection);
						},
					});
				}
				if (options.perMessageDeflate === true) options.perMessageDeflate = {};
				if (options.clientTracking) {
					this.clients = /* @__PURE__ */ new Set();
					this._shouldEmitClose = false;
				}
				this.options = options;
				this._state = RUNNING;
			}
			/**
			 * Returns the bound address, the address family name, and port of the server
			 * as reported by the operating system if listening on an IP socket.
			 * If the server is listening on a pipe or UNIX domain socket, the name is
			 * returned as a string.
			 *
			 * @return {(Object|String|null)} The address of the server
			 * @public
			 */
			address() {
				if (this.options.noServer) {
					throw new Error('The server is operating in "noServer" mode');
				}
				if (!this._server) return null;
				return this._server.address();
			}
			/**
			 * Stop the server from accepting new connections and emit the `'close'` event
			 * when all existing connections are closed.
			 *
			 * @param {Function} [cb] A one-time listener for the `'close'` event
			 * @public
			 */
			close(cb) {
				if (this._state === CLOSED) {
					if (cb) {
						this.once("close", () => {
							cb(new Error("The server is not running"));
						});
					}
					process.nextTick(emitClose, this);
					return;
				}
				if (cb) this.once("close", cb);
				if (this._state === CLOSING) return;
				this._state = CLOSING;
				if (this.options.noServer || this.options.server) {
					if (this._server) {
						this._removeListeners();
						this._removeListeners = this._server = null;
					}
					if (this.clients) {
						if (!this.clients.size) {
							process.nextTick(emitClose, this);
						} else {
							this._shouldEmitClose = true;
						}
					} else {
						process.nextTick(emitClose, this);
					}
				} else {
					const server = this._server;
					this._removeListeners();
					this._removeListeners = this._server = null;
					server.close(() => {
						emitClose(this);
					});
				}
			}
			/**
			 * See if a given request should be handled by this server instance.
			 *
			 * @param {http.IncomingMessage} req Request object to inspect
			 * @return {Boolean} `true` if the request is valid, else `false`
			 * @public
			 */
			shouldHandle(req) {
				if (this.options.path) {
					const index = req.url.indexOf("?");
					const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
					if (pathname !== this.options.path) return false;
				}
				return true;
			}
			/**
			 * Handle a HTTP Upgrade request.
			 *
			 * @param {http.IncomingMessage} req The request object
			 * @param {Duplex} socket The network socket between the server and client
			 * @param {Buffer} head The first packet of the upgraded stream
			 * @param {Function} cb Callback
			 * @public
			 */
			handleUpgrade(req, socket, head, cb) {
				socket.on("error", socketOnError);
				const key = req.headers["sec-websocket-key"];
				const upgrade = req.headers.upgrade;
				const version = +req.headers["sec-websocket-version"];
				if (req.method !== "GET") {
					const message = "Invalid HTTP method";
					abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
					return;
				}
				if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
					const message = "Invalid Upgrade header";
					abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
					return;
				}
				if (key === void 0 || !keyRegex.test(key)) {
					const message = "Missing or invalid Sec-WebSocket-Key header";
					abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
					return;
				}
				if (version !== 8 && version !== 13) {
					const message = "Missing or invalid Sec-WebSocket-Version header";
					abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
					return;
				}
				if (!this.shouldHandle(req)) {
					abortHandshake(socket, 400);
					return;
				}
				const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
				let protocols = /* @__PURE__ */ new Set();
				if (secWebSocketProtocol !== void 0) {
					try {
						protocols = subprotocol.parse(secWebSocketProtocol);
					} catch (err) {
						const message = "Invalid Sec-WebSocket-Protocol header";
						abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
						return;
					}
				}
				const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
				const extensions = {};
				if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
					const perMessageDeflate = new PerMessageDeflate(
						this.options.perMessageDeflate,
						true,
						this.options.maxPayload,
					);
					try {
						const offers = extension.parse(secWebSocketExtensions);
						if (offers[PerMessageDeflate.extensionName]) {
							perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
							extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
						}
					} catch (err) {
						const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
						abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
						return;
					}
				}
				if (this.options.verifyClient) {
					const info = {
						origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
						secure: !!(req.socket.authorized || req.socket.encrypted),
						req,
					};
					if (this.options.verifyClient.length === 2) {
						this.options.verifyClient(info, (verified, code, message, headers) => {
							if (!verified) {
								return abortHandshake(socket, code || 401, message, headers);
							}
							this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
						});
						return;
					}
					if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
				}
				this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
			}
			/**
			 * Upgrade the connection to WebSocket.
			 *
			 * @param {Object} extensions The accepted extensions
			 * @param {String} key The value of the `Sec-WebSocket-Key` header
			 * @param {Set} protocols The subprotocols
			 * @param {http.IncomingMessage} req The request object
			 * @param {Duplex} socket The network socket between the server and client
			 * @param {Buffer} head The first packet of the upgraded stream
			 * @param {Function} cb Callback
			 * @throws {Error} If called more than once with the same socket
			 * @private
			 */
			completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
				if (!socket.readable || !socket.writable) return socket.destroy();
				if (socket[kWebSocket]) {
					throw new Error(
						"server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration",
					);
				}
				if (this._state > RUNNING) return abortHandshake(socket, 503);
				const digest = createHash("sha1")
					.update(key + GUID)
					.digest("base64");
				const headers = [
					"HTTP/1.1 101 Switching Protocols",
					"Upgrade: websocket",
					"Connection: Upgrade",
					`Sec-WebSocket-Accept: ${digest}`,
				];
				const ws = new this.options.WebSocket(null, void 0, this.options);
				if (protocols.size) {
					const protocol = this.options.handleProtocols
						? this.options.handleProtocols(protocols, req)
						: protocols.values().next().value;
					if (protocol) {
						headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
						ws._protocol = protocol;
					}
				}
				if (extensions[PerMessageDeflate.extensionName]) {
					const params = extensions[PerMessageDeflate.extensionName].params;
					const value = extension.format({
						[PerMessageDeflate.extensionName]: [params],
					});
					headers.push(`Sec-WebSocket-Extensions: ${value}`);
					ws._extensions = extensions;
				}
				this.emit("headers", headers, req);
				socket.write(headers.concat("\r\n").join("\r\n"));
				socket.removeListener("error", socketOnError);
				ws.setSocket(socket, head, {
					allowSynchronousEvents: this.options.allowSynchronousEvents,
					maxPayload: this.options.maxPayload,
					skipUTF8Validation: this.options.skipUTF8Validation,
				});
				if (this.clients) {
					this.clients.add(ws);
					ws.on("close", () => {
						this.clients.delete(ws);
						if (this._shouldEmitClose && !this.clients.size) {
							process.nextTick(emitClose, this);
						}
					});
				}
				cb(ws, req);
			}
		};
		module2.exports = WebSocketServer;
		function addListeners(server, map) {
			for (const event of Object.keys(map)) server.on(event, map[event]);
			return function removeListeners() {
				for (const event of Object.keys(map)) {
					server.removeListener(event, map[event]);
				}
			};
		}
		function emitClose(server) {
			server._state = CLOSED;
			server.emit("close");
		}
		function socketOnError() {
			this.destroy();
		}
		function abortHandshake(socket, code, message, headers) {
			message = message || http.STATUS_CODES[code];
			headers = {
				Connection: "close",
				"Content-Type": "text/html",
				"Content-Length": Buffer.byteLength(message),
				...headers,
			};
			socket.once("finish", socket.destroy);
			socket.end(
				`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` +
					Object.keys(headers)
						.map((h) => `${h}: ${headers[h]}`)
						.join("\r\n") +
					"\r\n\r\n" +
					message,
			);
		}
		function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
			if (server.listenerCount("wsClientError")) {
				const err = new Error(message);
				Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
				server.emit("wsClientError", err, socket, req);
			} else {
				abortHandshake(socket, code, message);
			}
		}
	},
});

// node_modules/.pnpm/ws@8.18.0/node_modules/ws/index.js
var require_ws = __commonJS({
	"node_modules/.pnpm/ws@8.18.0/node_modules/ws/index.js"(exports2, module2) {
		"use strict";
		var WebSocket = require_websocket2();
		WebSocket.createWebSocketStream = require_stream();
		WebSocket.Server = require_websocket_server();
		WebSocket.Receiver = require_receiver2();
		WebSocket.Sender = require_sender();
		WebSocket.WebSocket = WebSocket;
		WebSocket.WebSocketServer = WebSocket.Server;
		module2.exports = WebSocket;
	},
});

// node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/helpers/util.js
var require_util9 = __commonJS({
	"node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/helpers/util.js"(exports2) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.getParsedType =
			exports2.ZodParsedType =
			exports2.objectUtil =
			exports2.util =
				void 0;
		var util;
		(function (util2) {
			util2.assertEqual = (val) => val;
			function assertIs(_arg) {}
			util2.assertIs = assertIs;
			function assertNever(_x) {
				throw new Error();
			}
			util2.assertNever = assertNever;
			util2.arrayToEnum = (items) => {
				const obj = {};
				for (const item of items) {
					obj[item] = item;
				}
				return obj;
			};
			util2.getValidEnumValues = (obj) => {
				const validKeys = util2
					.objectKeys(obj)
					.filter((k) => typeof obj[obj[k]] !== "number");
				const filtered = {};
				for (const k of validKeys) {
					filtered[k] = obj[k];
				}
				return util2.objectValues(filtered);
			};
			util2.objectValues = (obj) => {
				return util2.objectKeys(obj).map(function (e) {
					return obj[e];
				});
			};
			util2.objectKeys =
				typeof Object.keys === "function"
					? (obj) => Object.keys(obj)
					: (object) => {
							const keys = [];
							for (const key in object) {
								if (Object.prototype.hasOwnProperty.call(object, key)) {
									keys.push(key);
								}
							}
							return keys;
						};
			util2.find = (arr, checker) => {
				for (const item of arr) {
					if (checker(item)) return item;
				}
				return void 0;
			};
			util2.isInteger =
				typeof Number.isInteger === "function"
					? (val) => Number.isInteger(val)
					: (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
			function joinValues(array, separator = " | ") {
				return array
					.map((val) => (typeof val === "string" ? `'${val}'` : val))
					.join(separator);
			}
			util2.joinValues = joinValues;
			util2.jsonStringifyReplacer = (_, value) => {
				if (typeof value === "bigint") {
					return value.toString();
				}
				return value;
			};
		})((util = exports2.util || (exports2.util = {})));
		var objectUtil;
		(function (objectUtil2) {
			objectUtil2.mergeShapes = (first, second) => {
				return {
					...first,
					...second,
					// second overwrites first
				};
			};
		})((objectUtil = exports2.objectUtil || (exports2.objectUtil = {})));
		exports2.ZodParsedType = util.arrayToEnum([
			"string",
			"nan",
			"number",
			"integer",
			"float",
			"boolean",
			"date",
			"bigint",
			"symbol",
			"function",
			"undefined",
			"null",
			"array",
			"object",
			"unknown",
			"promise",
			"void",
			"never",
			"map",
			"set",
		]);
		var getParsedType = (data) => {
			const t = typeof data;
			switch (t) {
				case "undefined":
					return exports2.ZodParsedType.undefined;
				case "string":
					return exports2.ZodParsedType.string;
				case "number":
					return isNaN(data) ? exports2.ZodParsedType.nan : exports2.ZodParsedType.number;
				case "boolean":
					return exports2.ZodParsedType.boolean;
				case "function":
					return exports2.ZodParsedType.function;
				case "bigint":
					return exports2.ZodParsedType.bigint;
				case "symbol":
					return exports2.ZodParsedType.symbol;
				case "object":
					if (Array.isArray(data)) {
						return exports2.ZodParsedType.array;
					}
					if (data === null) {
						return exports2.ZodParsedType.null;
					}
					if (
						data.then &&
						typeof data.then === "function" &&
						data.catch &&
						typeof data.catch === "function"
					) {
						return exports2.ZodParsedType.promise;
					}
					if (typeof Map !== "undefined" && data instanceof Map) {
						return exports2.ZodParsedType.map;
					}
					if (typeof Set !== "undefined" && data instanceof Set) {
						return exports2.ZodParsedType.set;
					}
					if (typeof Date !== "undefined" && data instanceof Date) {
						return exports2.ZodParsedType.date;
					}
					return exports2.ZodParsedType.object;
				default:
					return exports2.ZodParsedType.unknown;
			}
		};
		exports2.getParsedType = getParsedType;
	},
});

// node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/ZodError.js
var require_ZodError = __commonJS({
	"node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/ZodError.js"(exports2) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.ZodError = exports2.quotelessJson = exports2.ZodIssueCode = void 0;
		var util_1 = require_util9();
		exports2.ZodIssueCode = util_1.util.arrayToEnum([
			"invalid_type",
			"invalid_literal",
			"custom",
			"invalid_union",
			"invalid_union_discriminator",
			"invalid_enum_value",
			"unrecognized_keys",
			"invalid_arguments",
			"invalid_return_type",
			"invalid_date",
			"invalid_string",
			"too_small",
			"too_big",
			"invalid_intersection_types",
			"not_multiple_of",
			"not_finite",
		]);
		var quotelessJson = (obj) => {
			const json = JSON.stringify(obj, null, 2);
			return json.replace(/"([^"]+)":/g, "$1:");
		};
		exports2.quotelessJson = quotelessJson;
		var ZodError = class _ZodError extends Error {
			constructor(issues) {
				super();
				this.issues = [];
				this.addIssue = (sub) => {
					this.issues = [...this.issues, sub];
				};
				this.addIssues = (subs = []) => {
					this.issues = [...this.issues, ...subs];
				};
				const actualProto = new.target.prototype;
				if (Object.setPrototypeOf) {
					Object.setPrototypeOf(this, actualProto);
				} else {
					this.__proto__ = actualProto;
				}
				this.name = "ZodError";
				this.issues = issues;
			}
			get errors() {
				return this.issues;
			}
			format(_mapper) {
				const mapper =
					_mapper ||
					function (issue) {
						return issue.message;
					};
				const fieldErrors = { _errors: [] };
				const processError = (error) => {
					for (const issue of error.issues) {
						if (issue.code === "invalid_union") {
							issue.unionErrors.map(processError);
						} else if (issue.code === "invalid_return_type") {
							processError(issue.returnTypeError);
						} else if (issue.code === "invalid_arguments") {
							processError(issue.argumentsError);
						} else if (issue.path.length === 0) {
							fieldErrors._errors.push(mapper(issue));
						} else {
							let curr = fieldErrors;
							let i = 0;
							while (i < issue.path.length) {
								const el = issue.path[i];
								const terminal = i === issue.path.length - 1;
								if (!terminal) {
									curr[el] = curr[el] || { _errors: [] };
								} else {
									curr[el] = curr[el] || { _errors: [] };
									curr[el]._errors.push(mapper(issue));
								}
								curr = curr[el];
								i++;
							}
						}
					}
				};
				processError(this);
				return fieldErrors;
			}
			static assert(value) {
				if (!(value instanceof _ZodError)) {
					throw new Error(`Not a ZodError: ${value}`);
				}
			}
			toString() {
				return this.message;
			}
			get message() {
				return JSON.stringify(this.issues, util_1.util.jsonStringifyReplacer, 2);
			}
			get isEmpty() {
				return this.issues.length === 0;
			}
			flatten(mapper = (issue) => issue.message) {
				const fieldErrors = {};
				const formErrors = [];
				for (const sub of this.issues) {
					if (sub.path.length > 0) {
						fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
						fieldErrors[sub.path[0]].push(mapper(sub));
					} else {
						formErrors.push(mapper(sub));
					}
				}
				return { formErrors, fieldErrors };
			}
			get formErrors() {
				return this.flatten();
			}
		};
		exports2.ZodError = ZodError;
		ZodError.create = (issues) => {
			const error = new ZodError(issues);
			return error;
		};
	},
});

// node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/locales/en.js
var require_en = __commonJS({
	"node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/locales/en.js"(exports2) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		var util_1 = require_util9();
		var ZodError_1 = require_ZodError();
		var errorMap = (issue, _ctx) => {
			let message;
			switch (issue.code) {
				case ZodError_1.ZodIssueCode.invalid_type:
					if (issue.received === util_1.ZodParsedType.undefined) {
						message = "Required";
					} else {
						message = `Expected ${issue.expected}, received ${issue.received}`;
					}
					break;
				case ZodError_1.ZodIssueCode.invalid_literal:
					message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_1.util.jsonStringifyReplacer)}`;
					break;
				case ZodError_1.ZodIssueCode.unrecognized_keys:
					message = `Unrecognized key(s) in object: ${util_1.util.joinValues(issue.keys, ", ")}`;
					break;
				case ZodError_1.ZodIssueCode.invalid_union:
					message = `Invalid input`;
					break;
				case ZodError_1.ZodIssueCode.invalid_union_discriminator:
					message = `Invalid discriminator value. Expected ${util_1.util.joinValues(issue.options)}`;
					break;
				case ZodError_1.ZodIssueCode.invalid_enum_value:
					message = `Invalid enum value. Expected ${util_1.util.joinValues(issue.options)}, received '${issue.received}'`;
					break;
				case ZodError_1.ZodIssueCode.invalid_arguments:
					message = `Invalid function arguments`;
					break;
				case ZodError_1.ZodIssueCode.invalid_return_type:
					message = `Invalid function return type`;
					break;
				case ZodError_1.ZodIssueCode.invalid_date:
					message = `Invalid date`;
					break;
				case ZodError_1.ZodIssueCode.invalid_string:
					if (typeof issue.validation === "object") {
						if ("includes" in issue.validation) {
							message = `Invalid input: must include "${issue.validation.includes}"`;
							if (typeof issue.validation.position === "number") {
								message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
							}
						} else if ("startsWith" in issue.validation) {
							message = `Invalid input: must start with "${issue.validation.startsWith}"`;
						} else if ("endsWith" in issue.validation) {
							message = `Invalid input: must end with "${issue.validation.endsWith}"`;
						} else {
							util_1.util.assertNever(issue.validation);
						}
					} else if (issue.validation !== "regex") {
						message = `Invalid ${issue.validation}`;
					} else {
						message = "Invalid";
					}
					break;
				case ZodError_1.ZodIssueCode.too_small:
					if (issue.type === "array")
						message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
					else if (issue.type === "string")
						message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
					else if (issue.type === "number")
						message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
					else if (issue.type === "date")
						message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
					else message = "Invalid input";
					break;
				case ZodError_1.ZodIssueCode.too_big:
					if (issue.type === "array")
						message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
					else if (issue.type === "string")
						message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
					else if (issue.type === "number")
						message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
					else if (issue.type === "bigint")
						message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
					else if (issue.type === "date")
						message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
					else message = "Invalid input";
					break;
				case ZodError_1.ZodIssueCode.custom:
					message = `Invalid input`;
					break;
				case ZodError_1.ZodIssueCode.invalid_intersection_types:
					message = `Intersection results could not be merged`;
					break;
				case ZodError_1.ZodIssueCode.not_multiple_of:
					message = `Number must be a multiple of ${issue.multipleOf}`;
					break;
				case ZodError_1.ZodIssueCode.not_finite:
					message = "Number must be finite";
					break;
				default:
					message = _ctx.defaultError;
					util_1.util.assertNever(issue);
			}
			return { message };
		};
		exports2.default = errorMap;
	},
});

// node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/errors.js
var require_errors3 = __commonJS({
	"node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/errors.js"(exports2) {
		"use strict";
		var __importDefault2 =
			(exports2 && exports2.__importDefault) ||
			function (mod) {
				return mod && mod.__esModule ? mod : { default: mod };
			};
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.getErrorMap = exports2.setErrorMap = exports2.defaultErrorMap = void 0;
		var en_1 = __importDefault2(require_en());
		exports2.defaultErrorMap = en_1.default;
		var overrideErrorMap = en_1.default;
		function setErrorMap(map) {
			overrideErrorMap = map;
		}
		exports2.setErrorMap = setErrorMap;
		function getErrorMap() {
			return overrideErrorMap;
		}
		exports2.getErrorMap = getErrorMap;
	},
});

// node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/helpers/parseUtil.js
var require_parseUtil = __commonJS({
	"node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/helpers/parseUtil.js"(exports2) {
		"use strict";
		var __importDefault2 =
			(exports2 && exports2.__importDefault) ||
			function (mod) {
				return mod && mod.__esModule ? mod : { default: mod };
			};
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.isAsync =
			exports2.isValid =
			exports2.isDirty =
			exports2.isAborted =
			exports2.OK =
			exports2.DIRTY =
			exports2.INVALID =
			exports2.ParseStatus =
			exports2.addIssueToContext =
			exports2.EMPTY_PATH =
			exports2.makeIssue =
				void 0;
		var errors_1 = require_errors3();
		var en_1 = __importDefault2(require_en());
		var makeIssue = (params) => {
			const { data, path, errorMaps, issueData } = params;
			const fullPath = [...path, ...(issueData.path || [])];
			const fullIssue = {
				...issueData,
				path: fullPath,
			};
			if (issueData.message !== void 0) {
				return {
					...issueData,
					path: fullPath,
					message: issueData.message,
				};
			}
			let errorMessage = "";
			const maps = errorMaps
				.filter((m) => !!m)
				.slice()
				.reverse();
			for (const map of maps) {
				errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
			}
			return {
				...issueData,
				path: fullPath,
				message: errorMessage,
			};
		};
		exports2.makeIssue = makeIssue;
		exports2.EMPTY_PATH = [];
		function addIssueToContext(ctx, issueData) {
			const overrideMap = (0, errors_1.getErrorMap)();
			const issue = (0, exports2.makeIssue)({
				issueData,
				data: ctx.data,
				path: ctx.path,
				errorMaps: [
					ctx.common.contextualErrorMap,
					ctx.schemaErrorMap,
					overrideMap,
					overrideMap === en_1.default ? void 0 : en_1.default,
					// then global default map
				].filter((x) => !!x),
			});
			ctx.common.issues.push(issue);
		}
		exports2.addIssueToContext = addIssueToContext;
		var ParseStatus = class _ParseStatus {
			constructor() {
				this.value = "valid";
			}
			dirty() {
				if (this.value === "valid") this.value = "dirty";
			}
			abort() {
				if (this.value !== "aborted") this.value = "aborted";
			}
			static mergeArray(status, results) {
				const arrayValue = [];
				for (const s of results) {
					if (s.status === "aborted") return exports2.INVALID;
					if (s.status === "dirty") status.dirty();
					arrayValue.push(s.value);
				}
				return { status: status.value, value: arrayValue };
			}
			static async mergeObjectAsync(status, pairs) {
				const syncPairs = [];
				for (const pair of pairs) {
					const key = await pair.key;
					const value = await pair.value;
					syncPairs.push({
						key,
						value,
					});
				}
				return _ParseStatus.mergeObjectSync(status, syncPairs);
			}
			static mergeObjectSync(status, pairs) {
				const finalObject = {};
				for (const pair of pairs) {
					const { key, value } = pair;
					if (key.status === "aborted") return exports2.INVALID;
					if (value.status === "aborted") return exports2.INVALID;
					if (key.status === "dirty") status.dirty();
					if (value.status === "dirty") status.dirty();
					if (
						key.value !== "__proto__" &&
						(typeof value.value !== "undefined" || pair.alwaysSet)
					) {
						finalObject[key.value] = value.value;
					}
				}
				return { status: status.value, value: finalObject };
			}
		};
		exports2.ParseStatus = ParseStatus;
		exports2.INVALID = Object.freeze({
			status: "aborted",
		});
		var DIRTY = (value) => ({ status: "dirty", value });
		exports2.DIRTY = DIRTY;
		var OK = (value) => ({ status: "valid", value });
		exports2.OK = OK;
		var isAborted = (x) => x.status === "aborted";
		exports2.isAborted = isAborted;
		var isDirty = (x) => x.status === "dirty";
		exports2.isDirty = isDirty;
		var isValid = (x) => x.status === "valid";
		exports2.isValid = isValid;
		var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
		exports2.isAsync = isAsync;
	},
});

// node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/helpers/typeAliases.js
var require_typeAliases = __commonJS({
	"node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/helpers/typeAliases.js"(exports2) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
	},
});

// node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/helpers/errorUtil.js
var require_errorUtil = __commonJS({
	"node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/helpers/errorUtil.js"(exports2) {
		"use strict";
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.errorUtil = void 0;
		var errorUtil;
		(function (errorUtil2) {
			errorUtil2.errToObj = (message) =>
				typeof message === "string" ? { message } : message || {};
			errorUtil2.toString = (message) =>
				typeof message === "string"
					? message
					: message === null || message === void 0
						? void 0
						: message.message;
		})((errorUtil = exports2.errorUtil || (exports2.errorUtil = {})));
	},
});

// node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/types.js
var require_types2 = __commonJS({
	"node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/types.js"(exports2) {
		"use strict";
		var __classPrivateFieldGet2 =
			(exports2 && exports2.__classPrivateFieldGet) ||
			function (receiver, state, kind, f) {
				if (kind === "a" && !f)
					throw new TypeError("Private accessor was defined without a getter");
				if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
					throw new TypeError(
						"Cannot read private member from an object whose class did not declare it",
					);
				return kind === "m"
					? f
					: kind === "a"
						? f.call(receiver)
						: f
							? f.value
							: state.get(receiver);
			};
		var __classPrivateFieldSet2 =
			(exports2 && exports2.__classPrivateFieldSet) ||
			function (receiver, state, value, kind, f) {
				if (kind === "m") throw new TypeError("Private method is not writable");
				if (kind === "a" && !f)
					throw new TypeError("Private accessor was defined without a setter");
				if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
					throw new TypeError(
						"Cannot write private member to an object whose class did not declare it",
					);
				return (
					kind === "a"
						? f.call(receiver, value)
						: f
							? (f.value = value)
							: state.set(receiver, value),
					value
				);
			};
		var _ZodEnum_cache;
		var _ZodNativeEnum_cache;
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.boolean =
			exports2.bigint =
			exports2.array =
			exports2.any =
			exports2.coerce =
			exports2.ZodFirstPartyTypeKind =
			exports2.late =
			exports2.ZodSchema =
			exports2.Schema =
			exports2.custom =
			exports2.ZodReadonly =
			exports2.ZodPipeline =
			exports2.ZodBranded =
			exports2.BRAND =
			exports2.ZodNaN =
			exports2.ZodCatch =
			exports2.ZodDefault =
			exports2.ZodNullable =
			exports2.ZodOptional =
			exports2.ZodTransformer =
			exports2.ZodEffects =
			exports2.ZodPromise =
			exports2.ZodNativeEnum =
			exports2.ZodEnum =
			exports2.ZodLiteral =
			exports2.ZodLazy =
			exports2.ZodFunction =
			exports2.ZodSet =
			exports2.ZodMap =
			exports2.ZodRecord =
			exports2.ZodTuple =
			exports2.ZodIntersection =
			exports2.ZodDiscriminatedUnion =
			exports2.ZodUnion =
			exports2.ZodObject =
			exports2.ZodArray =
			exports2.ZodVoid =
			exports2.ZodNever =
			exports2.ZodUnknown =
			exports2.ZodAny =
			exports2.ZodNull =
			exports2.ZodUndefined =
			exports2.ZodSymbol =
			exports2.ZodDate =
			exports2.ZodBoolean =
			exports2.ZodBigInt =
			exports2.ZodNumber =
			exports2.ZodString =
			exports2.datetimeRegex =
			exports2.ZodType =
				void 0;
		exports2.NEVER =
			exports2.void =
			exports2.unknown =
			exports2.union =
			exports2.undefined =
			exports2.tuple =
			exports2.transformer =
			exports2.symbol =
			exports2.string =
			exports2.strictObject =
			exports2.set =
			exports2.record =
			exports2.promise =
			exports2.preprocess =
			exports2.pipeline =
			exports2.ostring =
			exports2.optional =
			exports2.onumber =
			exports2.oboolean =
			exports2.object =
			exports2.number =
			exports2.nullable =
			exports2.null =
			exports2.never =
			exports2.nativeEnum =
			exports2.nan =
			exports2.map =
			exports2.literal =
			exports2.lazy =
			exports2.intersection =
			exports2.instanceof =
			exports2.function =
			exports2.enum =
			exports2.effect =
			exports2.discriminatedUnion =
			exports2.date =
				void 0;
		var errors_1 = require_errors3();
		var errorUtil_1 = require_errorUtil();
		var parseUtil_1 = require_parseUtil();
		var util_1 = require_util9();
		var ZodError_1 = require_ZodError();
		var ParseInputLazyPath = class {
			constructor(parent, value, path, key) {
				this._cachedPath = [];
				this.parent = parent;
				this.data = value;
				this._path = path;
				this._key = key;
			}
			get path() {
				if (!this._cachedPath.length) {
					if (this._key instanceof Array) {
						this._cachedPath.push(...this._path, ...this._key);
					} else {
						this._cachedPath.push(...this._path, this._key);
					}
				}
				return this._cachedPath;
			}
		};
		var handleResult = (ctx, result) => {
			if ((0, parseUtil_1.isValid)(result)) {
				return { success: true, data: result.value };
			} else {
				if (!ctx.common.issues.length) {
					throw new Error("Validation failed but no issues detected.");
				}
				return {
					success: false,
					get error() {
						if (this._error) return this._error;
						const error = new ZodError_1.ZodError(ctx.common.issues);
						this._error = error;
						return this._error;
					},
				};
			}
		};
		function processCreateParams(params) {
			if (!params) return {};
			const { errorMap, invalid_type_error, required_error, description } = params;
			if (errorMap && (invalid_type_error || required_error)) {
				throw new Error(
					`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`,
				);
			}
			if (errorMap) return { errorMap, description };
			const customMap = (iss, ctx) => {
				var _a, _b;
				const { message } = params;
				if (iss.code === "invalid_enum_value") {
					return {
						message:
							message !== null && message !== void 0 ? message : ctx.defaultError,
					};
				}
				if (typeof ctx.data === "undefined") {
					return {
						message:
							(_a =
								message !== null && message !== void 0
									? message
									: required_error) !== null && _a !== void 0
								? _a
								: ctx.defaultError,
					};
				}
				if (iss.code !== "invalid_type") return { message: ctx.defaultError };
				return {
					message:
						(_b =
							message !== null && message !== void 0
								? message
								: invalid_type_error) !== null && _b !== void 0
							? _b
							: ctx.defaultError,
				};
			};
			return { errorMap: customMap, description };
		}
		var ZodType = class {
			constructor(def) {
				this.spa = this.safeParseAsync;
				this._def = def;
				this.parse = this.parse.bind(this);
				this.safeParse = this.safeParse.bind(this);
				this.parseAsync = this.parseAsync.bind(this);
				this.safeParseAsync = this.safeParseAsync.bind(this);
				this.spa = this.spa.bind(this);
				this.refine = this.refine.bind(this);
				this.refinement = this.refinement.bind(this);
				this.superRefine = this.superRefine.bind(this);
				this.optional = this.optional.bind(this);
				this.nullable = this.nullable.bind(this);
				this.nullish = this.nullish.bind(this);
				this.array = this.array.bind(this);
				this.promise = this.promise.bind(this);
				this.or = this.or.bind(this);
				this.and = this.and.bind(this);
				this.transform = this.transform.bind(this);
				this.brand = this.brand.bind(this);
				this.default = this.default.bind(this);
				this.catch = this.catch.bind(this);
				this.describe = this.describe.bind(this);
				this.pipe = this.pipe.bind(this);
				this.readonly = this.readonly.bind(this);
				this.isNullable = this.isNullable.bind(this);
				this.isOptional = this.isOptional.bind(this);
			}
			get description() {
				return this._def.description;
			}
			_getType(input) {
				return (0, util_1.getParsedType)(input.data);
			}
			_getOrReturnCtx(input, ctx) {
				return (
					ctx || {
						common: input.parent.common,
						data: input.data,
						parsedType: (0, util_1.getParsedType)(input.data),
						schemaErrorMap: this._def.errorMap,
						path: input.path,
						parent: input.parent,
					}
				);
			}
			_processInputParams(input) {
				return {
					status: new parseUtil_1.ParseStatus(),
					ctx: {
						common: input.parent.common,
						data: input.data,
						parsedType: (0, util_1.getParsedType)(input.data),
						schemaErrorMap: this._def.errorMap,
						path: input.path,
						parent: input.parent,
					},
				};
			}
			_parseSync(input) {
				const result = this._parse(input);
				if ((0, parseUtil_1.isAsync)(result)) {
					throw new Error("Synchronous parse encountered promise.");
				}
				return result;
			}
			_parseAsync(input) {
				const result = this._parse(input);
				return Promise.resolve(result);
			}
			parse(data, params) {
				const result = this.safeParse(data, params);
				if (result.success) return result.data;
				throw result.error;
			}
			safeParse(data, params) {
				var _a;
				const ctx = {
					common: {
						issues: [],
						async:
							(_a = params === null || params === void 0 ? void 0 : params.async) !==
								null && _a !== void 0
								? _a
								: false,
						contextualErrorMap:
							params === null || params === void 0 ? void 0 : params.errorMap,
					},
					path: (params === null || params === void 0 ? void 0 : params.path) || [],
					schemaErrorMap: this._def.errorMap,
					parent: null,
					data,
					parsedType: (0, util_1.getParsedType)(data),
				};
				const result = this._parseSync({ data, path: ctx.path, parent: ctx });
				return handleResult(ctx, result);
			}
			async parseAsync(data, params) {
				const result = await this.safeParseAsync(data, params);
				if (result.success) return result.data;
				throw result.error;
			}
			async safeParseAsync(data, params) {
				const ctx = {
					common: {
						issues: [],
						contextualErrorMap:
							params === null || params === void 0 ? void 0 : params.errorMap,
						async: true,
					},
					path: (params === null || params === void 0 ? void 0 : params.path) || [],
					schemaErrorMap: this._def.errorMap,
					parent: null,
					data,
					parsedType: (0, util_1.getParsedType)(data),
				};
				const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
				const result = await ((0, parseUtil_1.isAsync)(maybeAsyncResult)
					? maybeAsyncResult
					: Promise.resolve(maybeAsyncResult));
				return handleResult(ctx, result);
			}
			refine(check, message) {
				const getIssueProperties = (val) => {
					if (typeof message === "string" || typeof message === "undefined") {
						return { message };
					} else if (typeof message === "function") {
						return message(val);
					} else {
						return message;
					}
				};
				return this._refinement((val, ctx) => {
					const result = check(val);
					const setError = () =>
						ctx.addIssue({
							code: ZodError_1.ZodIssueCode.custom,
							...getIssueProperties(val),
						});
					if (typeof Promise !== "undefined" && result instanceof Promise) {
						return result.then((data) => {
							if (!data) {
								setError();
								return false;
							} else {
								return true;
							}
						});
					}
					if (!result) {
						setError();
						return false;
					} else {
						return true;
					}
				});
			}
			refinement(check, refinementData) {
				return this._refinement((val, ctx) => {
					if (!check(val)) {
						ctx.addIssue(
							typeof refinementData === "function"
								? refinementData(val, ctx)
								: refinementData,
						);
						return false;
					} else {
						return true;
					}
				});
			}
			_refinement(refinement) {
				return new ZodEffects({
					schema: this,
					typeName: ZodFirstPartyTypeKind.ZodEffects,
					effect: { type: "refinement", refinement },
				});
			}
			superRefine(refinement) {
				return this._refinement(refinement);
			}
			optional() {
				return ZodOptional.create(this, this._def);
			}
			nullable() {
				return ZodNullable.create(this, this._def);
			}
			nullish() {
				return this.nullable().optional();
			}
			array() {
				return ZodArray.create(this, this._def);
			}
			promise() {
				return ZodPromise.create(this, this._def);
			}
			or(option) {
				return ZodUnion.create([this, option], this._def);
			}
			and(incoming) {
				return ZodIntersection.create(this, incoming, this._def);
			}
			transform(transform) {
				return new ZodEffects({
					...processCreateParams(this._def),
					schema: this,
					typeName: ZodFirstPartyTypeKind.ZodEffects,
					effect: { type: "transform", transform },
				});
			}
			default(def) {
				const defaultValueFunc = typeof def === "function" ? def : () => def;
				return new ZodDefault({
					...processCreateParams(this._def),
					innerType: this,
					defaultValue: defaultValueFunc,
					typeName: ZodFirstPartyTypeKind.ZodDefault,
				});
			}
			brand() {
				return new ZodBranded({
					typeName: ZodFirstPartyTypeKind.ZodBranded,
					type: this,
					...processCreateParams(this._def),
				});
			}
			catch(def) {
				const catchValueFunc = typeof def === "function" ? def : () => def;
				return new ZodCatch({
					...processCreateParams(this._def),
					innerType: this,
					catchValue: catchValueFunc,
					typeName: ZodFirstPartyTypeKind.ZodCatch,
				});
			}
			describe(description) {
				const This = this.constructor;
				return new This({
					...this._def,
					description,
				});
			}
			pipe(target) {
				return ZodPipeline.create(this, target);
			}
			readonly() {
				return ZodReadonly.create(this);
			}
			isOptional() {
				return this.safeParse(void 0).success;
			}
			isNullable() {
				return this.safeParse(null).success;
			}
		};
		exports2.ZodType = ZodType;
		exports2.Schema = ZodType;
		exports2.ZodSchema = ZodType;
		var cuidRegex = /^c[^\s-]{8,}$/i;
		var cuid2Regex = /^[0-9a-z]+$/;
		var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
		var uuidRegex =
			/^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
		var nanoidRegex = /^[a-z0-9_-]{21}$/i;
		var durationRegex =
			/^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
		var emailRegex =
			/^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
		var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
		var emojiRegex;
		var ipv4Regex =
			/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
		var ipv6Regex =
			/^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
		var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
		var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
		var dateRegex = new RegExp(`^${dateRegexSource}$`);
		function timeRegexSource(args) {
			let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
			if (args.precision) {
				regex = `${regex}\\.\\d{${args.precision}}`;
			} else if (args.precision == null) {
				regex = `${regex}(\\.\\d+)?`;
			}
			return regex;
		}
		function timeRegex(args) {
			return new RegExp(`^${timeRegexSource(args)}$`);
		}
		function datetimeRegex(args) {
			let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
			const opts = [];
			opts.push(args.local ? `Z?` : `Z`);
			if (args.offset) opts.push(`([+-]\\d{2}:?\\d{2})`);
			regex = `${regex}(${opts.join("|")})`;
			return new RegExp(`^${regex}$`);
		}
		exports2.datetimeRegex = datetimeRegex;
		function isValidIP(ip, version) {
			if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
				return true;
			}
			if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
				return true;
			}
			return false;
		}
		var ZodString = class _ZodString extends ZodType {
			_parse(input) {
				if (this._def.coerce) {
					input.data = String(input.data);
				}
				const parsedType = this._getType(input);
				if (parsedType !== util_1.ZodParsedType.string) {
					const ctx2 = this._getOrReturnCtx(input);
					(0, parseUtil_1.addIssueToContext)(ctx2, {
						code: ZodError_1.ZodIssueCode.invalid_type,
						expected: util_1.ZodParsedType.string,
						received: ctx2.parsedType,
					});
					return parseUtil_1.INVALID;
				}
				const status = new parseUtil_1.ParseStatus();
				let ctx = void 0;
				for (const check of this._def.checks) {
					if (check.kind === "min") {
						if (input.data.length < check.value) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								code: ZodError_1.ZodIssueCode.too_small,
								minimum: check.value,
								type: "string",
								inclusive: true,
								exact: false,
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "max") {
						if (input.data.length > check.value) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								code: ZodError_1.ZodIssueCode.too_big,
								maximum: check.value,
								type: "string",
								inclusive: true,
								exact: false,
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "length") {
						const tooBig = input.data.length > check.value;
						const tooSmall = input.data.length < check.value;
						if (tooBig || tooSmall) {
							ctx = this._getOrReturnCtx(input, ctx);
							if (tooBig) {
								(0, parseUtil_1.addIssueToContext)(ctx, {
									code: ZodError_1.ZodIssueCode.too_big,
									maximum: check.value,
									type: "string",
									inclusive: true,
									exact: true,
									message: check.message,
								});
							} else if (tooSmall) {
								(0, parseUtil_1.addIssueToContext)(ctx, {
									code: ZodError_1.ZodIssueCode.too_small,
									minimum: check.value,
									type: "string",
									inclusive: true,
									exact: true,
									message: check.message,
								});
							}
							status.dirty();
						}
					} else if (check.kind === "email") {
						if (!emailRegex.test(input.data)) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								validation: "email",
								code: ZodError_1.ZodIssueCode.invalid_string,
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "emoji") {
						if (!emojiRegex) {
							emojiRegex = new RegExp(_emojiRegex, "u");
						}
						if (!emojiRegex.test(input.data)) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								validation: "emoji",
								code: ZodError_1.ZodIssueCode.invalid_string,
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "uuid") {
						if (!uuidRegex.test(input.data)) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								validation: "uuid",
								code: ZodError_1.ZodIssueCode.invalid_string,
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "nanoid") {
						if (!nanoidRegex.test(input.data)) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								validation: "nanoid",
								code: ZodError_1.ZodIssueCode.invalid_string,
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "cuid") {
						if (!cuidRegex.test(input.data)) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								validation: "cuid",
								code: ZodError_1.ZodIssueCode.invalid_string,
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "cuid2") {
						if (!cuid2Regex.test(input.data)) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								validation: "cuid2",
								code: ZodError_1.ZodIssueCode.invalid_string,
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "ulid") {
						if (!ulidRegex.test(input.data)) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								validation: "ulid",
								code: ZodError_1.ZodIssueCode.invalid_string,
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "url") {
						try {
							new URL(input.data);
						} catch (_a) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								validation: "url",
								code: ZodError_1.ZodIssueCode.invalid_string,
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "regex") {
						check.regex.lastIndex = 0;
						const testResult = check.regex.test(input.data);
						if (!testResult) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								validation: "regex",
								code: ZodError_1.ZodIssueCode.invalid_string,
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "trim") {
						input.data = input.data.trim();
					} else if (check.kind === "includes") {
						if (!input.data.includes(check.value, check.position)) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								code: ZodError_1.ZodIssueCode.invalid_string,
								validation: { includes: check.value, position: check.position },
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "toLowerCase") {
						input.data = input.data.toLowerCase();
					} else if (check.kind === "toUpperCase") {
						input.data = input.data.toUpperCase();
					} else if (check.kind === "startsWith") {
						if (!input.data.startsWith(check.value)) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								code: ZodError_1.ZodIssueCode.invalid_string,
								validation: { startsWith: check.value },
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "endsWith") {
						if (!input.data.endsWith(check.value)) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								code: ZodError_1.ZodIssueCode.invalid_string,
								validation: { endsWith: check.value },
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "datetime") {
						const regex = datetimeRegex(check);
						if (!regex.test(input.data)) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								code: ZodError_1.ZodIssueCode.invalid_string,
								validation: "datetime",
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "date") {
						const regex = dateRegex;
						if (!regex.test(input.data)) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								code: ZodError_1.ZodIssueCode.invalid_string,
								validation: "date",
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "time") {
						const regex = timeRegex(check);
						if (!regex.test(input.data)) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								code: ZodError_1.ZodIssueCode.invalid_string,
								validation: "time",
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "duration") {
						if (!durationRegex.test(input.data)) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								validation: "duration",
								code: ZodError_1.ZodIssueCode.invalid_string,
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "ip") {
						if (!isValidIP(input.data, check.version)) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								validation: "ip",
								code: ZodError_1.ZodIssueCode.invalid_string,
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "base64") {
						if (!base64Regex.test(input.data)) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								validation: "base64",
								code: ZodError_1.ZodIssueCode.invalid_string,
								message: check.message,
							});
							status.dirty();
						}
					} else {
						util_1.util.assertNever(check);
					}
				}
				return { status: status.value, value: input.data };
			}
			_regex(regex, validation, message) {
				return this.refinement((data) => regex.test(data), {
					validation,
					code: ZodError_1.ZodIssueCode.invalid_string,
					...errorUtil_1.errorUtil.errToObj(message),
				});
			}
			_addCheck(check) {
				return new _ZodString({
					...this._def,
					checks: [...this._def.checks, check],
				});
			}
			email(message) {
				return this._addCheck({
					kind: "email",
					...errorUtil_1.errorUtil.errToObj(message),
				});
			}
			url(message) {
				return this._addCheck({ kind: "url", ...errorUtil_1.errorUtil.errToObj(message) });
			}
			emoji(message) {
				return this._addCheck({
					kind: "emoji",
					...errorUtil_1.errorUtil.errToObj(message),
				});
			}
			uuid(message) {
				return this._addCheck({ kind: "uuid", ...errorUtil_1.errorUtil.errToObj(message) });
			}
			nanoid(message) {
				return this._addCheck({
					kind: "nanoid",
					...errorUtil_1.errorUtil.errToObj(message),
				});
			}
			cuid(message) {
				return this._addCheck({ kind: "cuid", ...errorUtil_1.errorUtil.errToObj(message) });
			}
			cuid2(message) {
				return this._addCheck({
					kind: "cuid2",
					...errorUtil_1.errorUtil.errToObj(message),
				});
			}
			ulid(message) {
				return this._addCheck({ kind: "ulid", ...errorUtil_1.errorUtil.errToObj(message) });
			}
			base64(message) {
				return this._addCheck({
					kind: "base64",
					...errorUtil_1.errorUtil.errToObj(message),
				});
			}
			ip(options) {
				return this._addCheck({ kind: "ip", ...errorUtil_1.errorUtil.errToObj(options) });
			}
			datetime(options) {
				var _a, _b;
				if (typeof options === "string") {
					return this._addCheck({
						kind: "datetime",
						precision: null,
						offset: false,
						local: false,
						message: options,
					});
				}
				return this._addCheck({
					kind: "datetime",
					precision:
						typeof (options === null || options === void 0
							? void 0
							: options.precision) === "undefined"
							? null
							: options === null || options === void 0
								? void 0
								: options.precision,
					offset:
						(_a = options === null || options === void 0 ? void 0 : options.offset) !==
							null && _a !== void 0
							? _a
							: false,
					local:
						(_b = options === null || options === void 0 ? void 0 : options.local) !==
							null && _b !== void 0
							? _b
							: false,
					...errorUtil_1.errorUtil.errToObj(
						options === null || options === void 0 ? void 0 : options.message,
					),
				});
			}
			date(message) {
				return this._addCheck({ kind: "date", message });
			}
			time(options) {
				if (typeof options === "string") {
					return this._addCheck({
						kind: "time",
						precision: null,
						message: options,
					});
				}
				return this._addCheck({
					kind: "time",
					precision:
						typeof (options === null || options === void 0
							? void 0
							: options.precision) === "undefined"
							? null
							: options === null || options === void 0
								? void 0
								: options.precision,
					...errorUtil_1.errorUtil.errToObj(
						options === null || options === void 0 ? void 0 : options.message,
					),
				});
			}
			duration(message) {
				return this._addCheck({
					kind: "duration",
					...errorUtil_1.errorUtil.errToObj(message),
				});
			}
			regex(regex, message) {
				return this._addCheck({
					kind: "regex",
					regex,
					...errorUtil_1.errorUtil.errToObj(message),
				});
			}
			includes(value, options) {
				return this._addCheck({
					kind: "includes",
					value,
					position: options === null || options === void 0 ? void 0 : options.position,
					...errorUtil_1.errorUtil.errToObj(
						options === null || options === void 0 ? void 0 : options.message,
					),
				});
			}
			startsWith(value, message) {
				return this._addCheck({
					kind: "startsWith",
					value,
					...errorUtil_1.errorUtil.errToObj(message),
				});
			}
			endsWith(value, message) {
				return this._addCheck({
					kind: "endsWith",
					value,
					...errorUtil_1.errorUtil.errToObj(message),
				});
			}
			min(minLength, message) {
				return this._addCheck({
					kind: "min",
					value: minLength,
					...errorUtil_1.errorUtil.errToObj(message),
				});
			}
			max(maxLength, message) {
				return this._addCheck({
					kind: "max",
					value: maxLength,
					...errorUtil_1.errorUtil.errToObj(message),
				});
			}
			length(len, message) {
				return this._addCheck({
					kind: "length",
					value: len,
					...errorUtil_1.errorUtil.errToObj(message),
				});
			}
			/**
			 * @deprecated Use z.string().min(1) instead.
			 * @see {@link ZodString.min}
			 */
			nonempty(message) {
				return this.min(1, errorUtil_1.errorUtil.errToObj(message));
			}
			trim() {
				return new _ZodString({
					...this._def,
					checks: [...this._def.checks, { kind: "trim" }],
				});
			}
			toLowerCase() {
				return new _ZodString({
					...this._def,
					checks: [...this._def.checks, { kind: "toLowerCase" }],
				});
			}
			toUpperCase() {
				return new _ZodString({
					...this._def,
					checks: [...this._def.checks, { kind: "toUpperCase" }],
				});
			}
			get isDatetime() {
				return !!this._def.checks.find((ch) => ch.kind === "datetime");
			}
			get isDate() {
				return !!this._def.checks.find((ch) => ch.kind === "date");
			}
			get isTime() {
				return !!this._def.checks.find((ch) => ch.kind === "time");
			}
			get isDuration() {
				return !!this._def.checks.find((ch) => ch.kind === "duration");
			}
			get isEmail() {
				return !!this._def.checks.find((ch) => ch.kind === "email");
			}
			get isURL() {
				return !!this._def.checks.find((ch) => ch.kind === "url");
			}
			get isEmoji() {
				return !!this._def.checks.find((ch) => ch.kind === "emoji");
			}
			get isUUID() {
				return !!this._def.checks.find((ch) => ch.kind === "uuid");
			}
			get isNANOID() {
				return !!this._def.checks.find((ch) => ch.kind === "nanoid");
			}
			get isCUID() {
				return !!this._def.checks.find((ch) => ch.kind === "cuid");
			}
			get isCUID2() {
				return !!this._def.checks.find((ch) => ch.kind === "cuid2");
			}
			get isULID() {
				return !!this._def.checks.find((ch) => ch.kind === "ulid");
			}
			get isIP() {
				return !!this._def.checks.find((ch) => ch.kind === "ip");
			}
			get isBase64() {
				return !!this._def.checks.find((ch) => ch.kind === "base64");
			}
			get minLength() {
				let min = null;
				for (const ch of this._def.checks) {
					if (ch.kind === "min") {
						if (min === null || ch.value > min) min = ch.value;
					}
				}
				return min;
			}
			get maxLength() {
				let max = null;
				for (const ch of this._def.checks) {
					if (ch.kind === "max") {
						if (max === null || ch.value < max) max = ch.value;
					}
				}
				return max;
			}
		};
		exports2.ZodString = ZodString;
		ZodString.create = (params) => {
			var _a;
			return new ZodString({
				checks: [],
				typeName: ZodFirstPartyTypeKind.ZodString,
				coerce:
					(_a = params === null || params === void 0 ? void 0 : params.coerce) !== null &&
					_a !== void 0
						? _a
						: false,
				...processCreateParams(params),
			});
		};
		function floatSafeRemainder(val, step) {
			const valDecCount = (val.toString().split(".")[1] || "").length;
			const stepDecCount = (step.toString().split(".")[1] || "").length;
			const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
			const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
			const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
			return (valInt % stepInt) / Math.pow(10, decCount);
		}
		var ZodNumber = class _ZodNumber extends ZodType {
			constructor() {
				super(...arguments);
				this.min = this.gte;
				this.max = this.lte;
				this.step = this.multipleOf;
			}
			_parse(input) {
				if (this._def.coerce) {
					input.data = Number(input.data);
				}
				const parsedType = this._getType(input);
				if (parsedType !== util_1.ZodParsedType.number) {
					const ctx2 = this._getOrReturnCtx(input);
					(0, parseUtil_1.addIssueToContext)(ctx2, {
						code: ZodError_1.ZodIssueCode.invalid_type,
						expected: util_1.ZodParsedType.number,
						received: ctx2.parsedType,
					});
					return parseUtil_1.INVALID;
				}
				let ctx = void 0;
				const status = new parseUtil_1.ParseStatus();
				for (const check of this._def.checks) {
					if (check.kind === "int") {
						if (!util_1.util.isInteger(input.data)) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								code: ZodError_1.ZodIssueCode.invalid_type,
								expected: "integer",
								received: "float",
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "min") {
						const tooSmall = check.inclusive
							? input.data < check.value
							: input.data <= check.value;
						if (tooSmall) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								code: ZodError_1.ZodIssueCode.too_small,
								minimum: check.value,
								type: "number",
								inclusive: check.inclusive,
								exact: false,
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "max") {
						const tooBig = check.inclusive
							? input.data > check.value
							: input.data >= check.value;
						if (tooBig) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								code: ZodError_1.ZodIssueCode.too_big,
								maximum: check.value,
								type: "number",
								inclusive: check.inclusive,
								exact: false,
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "multipleOf") {
						if (floatSafeRemainder(input.data, check.value) !== 0) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								code: ZodError_1.ZodIssueCode.not_multiple_of,
								multipleOf: check.value,
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "finite") {
						if (!Number.isFinite(input.data)) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								code: ZodError_1.ZodIssueCode.not_finite,
								message: check.message,
							});
							status.dirty();
						}
					} else {
						util_1.util.assertNever(check);
					}
				}
				return { status: status.value, value: input.data };
			}
			gte(value, message) {
				return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
			}
			gt(value, message) {
				return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
			}
			lte(value, message) {
				return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
			}
			lt(value, message) {
				return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
			}
			setLimit(kind, value, inclusive, message) {
				return new _ZodNumber({
					...this._def,
					checks: [
						...this._def.checks,
						{
							kind,
							value,
							inclusive,
							message: errorUtil_1.errorUtil.toString(message),
						},
					],
				});
			}
			_addCheck(check) {
				return new _ZodNumber({
					...this._def,
					checks: [...this._def.checks, check],
				});
			}
			int(message) {
				return this._addCheck({
					kind: "int",
					message: errorUtil_1.errorUtil.toString(message),
				});
			}
			positive(message) {
				return this._addCheck({
					kind: "min",
					value: 0,
					inclusive: false,
					message: errorUtil_1.errorUtil.toString(message),
				});
			}
			negative(message) {
				return this._addCheck({
					kind: "max",
					value: 0,
					inclusive: false,
					message: errorUtil_1.errorUtil.toString(message),
				});
			}
			nonpositive(message) {
				return this._addCheck({
					kind: "max",
					value: 0,
					inclusive: true,
					message: errorUtil_1.errorUtil.toString(message),
				});
			}
			nonnegative(message) {
				return this._addCheck({
					kind: "min",
					value: 0,
					inclusive: true,
					message: errorUtil_1.errorUtil.toString(message),
				});
			}
			multipleOf(value, message) {
				return this._addCheck({
					kind: "multipleOf",
					value,
					message: errorUtil_1.errorUtil.toString(message),
				});
			}
			finite(message) {
				return this._addCheck({
					kind: "finite",
					message: errorUtil_1.errorUtil.toString(message),
				});
			}
			safe(message) {
				return this._addCheck({
					kind: "min",
					inclusive: true,
					value: Number.MIN_SAFE_INTEGER,
					message: errorUtil_1.errorUtil.toString(message),
				})._addCheck({
					kind: "max",
					inclusive: true,
					value: Number.MAX_SAFE_INTEGER,
					message: errorUtil_1.errorUtil.toString(message),
				});
			}
			get minValue() {
				let min = null;
				for (const ch of this._def.checks) {
					if (ch.kind === "min") {
						if (min === null || ch.value > min) min = ch.value;
					}
				}
				return min;
			}
			get maxValue() {
				let max = null;
				for (const ch of this._def.checks) {
					if (ch.kind === "max") {
						if (max === null || ch.value < max) max = ch.value;
					}
				}
				return max;
			}
			get isInt() {
				return !!this._def.checks.find(
					(ch) =>
						ch.kind === "int" ||
						(ch.kind === "multipleOf" && util_1.util.isInteger(ch.value)),
				);
			}
			get isFinite() {
				let max = null,
					min = null;
				for (const ch of this._def.checks) {
					if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
						return true;
					} else if (ch.kind === "min") {
						if (min === null || ch.value > min) min = ch.value;
					} else if (ch.kind === "max") {
						if (max === null || ch.value < max) max = ch.value;
					}
				}
				return Number.isFinite(min) && Number.isFinite(max);
			}
		};
		exports2.ZodNumber = ZodNumber;
		ZodNumber.create = (params) => {
			return new ZodNumber({
				checks: [],
				typeName: ZodFirstPartyTypeKind.ZodNumber,
				coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
				...processCreateParams(params),
			});
		};
		var ZodBigInt = class _ZodBigInt extends ZodType {
			constructor() {
				super(...arguments);
				this.min = this.gte;
				this.max = this.lte;
			}
			_parse(input) {
				if (this._def.coerce) {
					input.data = BigInt(input.data);
				}
				const parsedType = this._getType(input);
				if (parsedType !== util_1.ZodParsedType.bigint) {
					const ctx2 = this._getOrReturnCtx(input);
					(0, parseUtil_1.addIssueToContext)(ctx2, {
						code: ZodError_1.ZodIssueCode.invalid_type,
						expected: util_1.ZodParsedType.bigint,
						received: ctx2.parsedType,
					});
					return parseUtil_1.INVALID;
				}
				let ctx = void 0;
				const status = new parseUtil_1.ParseStatus();
				for (const check of this._def.checks) {
					if (check.kind === "min") {
						const tooSmall = check.inclusive
							? input.data < check.value
							: input.data <= check.value;
						if (tooSmall) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								code: ZodError_1.ZodIssueCode.too_small,
								type: "bigint",
								minimum: check.value,
								inclusive: check.inclusive,
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "max") {
						const tooBig = check.inclusive
							? input.data > check.value
							: input.data >= check.value;
						if (tooBig) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								code: ZodError_1.ZodIssueCode.too_big,
								type: "bigint",
								maximum: check.value,
								inclusive: check.inclusive,
								message: check.message,
							});
							status.dirty();
						}
					} else if (check.kind === "multipleOf") {
						if (input.data % check.value !== BigInt(0)) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								code: ZodError_1.ZodIssueCode.not_multiple_of,
								multipleOf: check.value,
								message: check.message,
							});
							status.dirty();
						}
					} else {
						util_1.util.assertNever(check);
					}
				}
				return { status: status.value, value: input.data };
			}
			gte(value, message) {
				return this.setLimit("min", value, true, errorUtil_1.errorUtil.toString(message));
			}
			gt(value, message) {
				return this.setLimit("min", value, false, errorUtil_1.errorUtil.toString(message));
			}
			lte(value, message) {
				return this.setLimit("max", value, true, errorUtil_1.errorUtil.toString(message));
			}
			lt(value, message) {
				return this.setLimit("max", value, false, errorUtil_1.errorUtil.toString(message));
			}
			setLimit(kind, value, inclusive, message) {
				return new _ZodBigInt({
					...this._def,
					checks: [
						...this._def.checks,
						{
							kind,
							value,
							inclusive,
							message: errorUtil_1.errorUtil.toString(message),
						},
					],
				});
			}
			_addCheck(check) {
				return new _ZodBigInt({
					...this._def,
					checks: [...this._def.checks, check],
				});
			}
			positive(message) {
				return this._addCheck({
					kind: "min",
					value: BigInt(0),
					inclusive: false,
					message: errorUtil_1.errorUtil.toString(message),
				});
			}
			negative(message) {
				return this._addCheck({
					kind: "max",
					value: BigInt(0),
					inclusive: false,
					message: errorUtil_1.errorUtil.toString(message),
				});
			}
			nonpositive(message) {
				return this._addCheck({
					kind: "max",
					value: BigInt(0),
					inclusive: true,
					message: errorUtil_1.errorUtil.toString(message),
				});
			}
			nonnegative(message) {
				return this._addCheck({
					kind: "min",
					value: BigInt(0),
					inclusive: true,
					message: errorUtil_1.errorUtil.toString(message),
				});
			}
			multipleOf(value, message) {
				return this._addCheck({
					kind: "multipleOf",
					value,
					message: errorUtil_1.errorUtil.toString(message),
				});
			}
			get minValue() {
				let min = null;
				for (const ch of this._def.checks) {
					if (ch.kind === "min") {
						if (min === null || ch.value > min) min = ch.value;
					}
				}
				return min;
			}
			get maxValue() {
				let max = null;
				for (const ch of this._def.checks) {
					if (ch.kind === "max") {
						if (max === null || ch.value < max) max = ch.value;
					}
				}
				return max;
			}
		};
		exports2.ZodBigInt = ZodBigInt;
		ZodBigInt.create = (params) => {
			var _a;
			return new ZodBigInt({
				checks: [],
				typeName: ZodFirstPartyTypeKind.ZodBigInt,
				coerce:
					(_a = params === null || params === void 0 ? void 0 : params.coerce) !== null &&
					_a !== void 0
						? _a
						: false,
				...processCreateParams(params),
			});
		};
		var ZodBoolean = class extends ZodType {
			_parse(input) {
				if (this._def.coerce) {
					input.data = Boolean(input.data);
				}
				const parsedType = this._getType(input);
				if (parsedType !== util_1.ZodParsedType.boolean) {
					const ctx = this._getOrReturnCtx(input);
					(0, parseUtil_1.addIssueToContext)(ctx, {
						code: ZodError_1.ZodIssueCode.invalid_type,
						expected: util_1.ZodParsedType.boolean,
						received: ctx.parsedType,
					});
					return parseUtil_1.INVALID;
				}
				return (0, parseUtil_1.OK)(input.data);
			}
		};
		exports2.ZodBoolean = ZodBoolean;
		ZodBoolean.create = (params) => {
			return new ZodBoolean({
				typeName: ZodFirstPartyTypeKind.ZodBoolean,
				coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
				...processCreateParams(params),
			});
		};
		var ZodDate = class _ZodDate extends ZodType {
			_parse(input) {
				if (this._def.coerce) {
					input.data = new Date(input.data);
				}
				const parsedType = this._getType(input);
				if (parsedType !== util_1.ZodParsedType.date) {
					const ctx2 = this._getOrReturnCtx(input);
					(0, parseUtil_1.addIssueToContext)(ctx2, {
						code: ZodError_1.ZodIssueCode.invalid_type,
						expected: util_1.ZodParsedType.date,
						received: ctx2.parsedType,
					});
					return parseUtil_1.INVALID;
				}
				if (isNaN(input.data.getTime())) {
					const ctx2 = this._getOrReturnCtx(input);
					(0, parseUtil_1.addIssueToContext)(ctx2, {
						code: ZodError_1.ZodIssueCode.invalid_date,
					});
					return parseUtil_1.INVALID;
				}
				const status = new parseUtil_1.ParseStatus();
				let ctx = void 0;
				for (const check of this._def.checks) {
					if (check.kind === "min") {
						if (input.data.getTime() < check.value) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								code: ZodError_1.ZodIssueCode.too_small,
								message: check.message,
								inclusive: true,
								exact: false,
								minimum: check.value,
								type: "date",
							});
							status.dirty();
						}
					} else if (check.kind === "max") {
						if (input.data.getTime() > check.value) {
							ctx = this._getOrReturnCtx(input, ctx);
							(0, parseUtil_1.addIssueToContext)(ctx, {
								code: ZodError_1.ZodIssueCode.too_big,
								message: check.message,
								inclusive: true,
								exact: false,
								maximum: check.value,
								type: "date",
							});
							status.dirty();
						}
					} else {
						util_1.util.assertNever(check);
					}
				}
				return {
					status: status.value,
					value: new Date(input.data.getTime()),
				};
			}
			_addCheck(check) {
				return new _ZodDate({
					...this._def,
					checks: [...this._def.checks, check],
				});
			}
			min(minDate, message) {
				return this._addCheck({
					kind: "min",
					value: minDate.getTime(),
					message: errorUtil_1.errorUtil.toString(message),
				});
			}
			max(maxDate, message) {
				return this._addCheck({
					kind: "max",
					value: maxDate.getTime(),
					message: errorUtil_1.errorUtil.toString(message),
				});
			}
			get minDate() {
				let min = null;
				for (const ch of this._def.checks) {
					if (ch.kind === "min") {
						if (min === null || ch.value > min) min = ch.value;
					}
				}
				return min != null ? new Date(min) : null;
			}
			get maxDate() {
				let max = null;
				for (const ch of this._def.checks) {
					if (ch.kind === "max") {
						if (max === null || ch.value < max) max = ch.value;
					}
				}
				return max != null ? new Date(max) : null;
			}
		};
		exports2.ZodDate = ZodDate;
		ZodDate.create = (params) => {
			return new ZodDate({
				checks: [],
				coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
				typeName: ZodFirstPartyTypeKind.ZodDate,
				...processCreateParams(params),
			});
		};
		var ZodSymbol = class extends ZodType {
			_parse(input) {
				const parsedType = this._getType(input);
				if (parsedType !== util_1.ZodParsedType.symbol) {
					const ctx = this._getOrReturnCtx(input);
					(0, parseUtil_1.addIssueToContext)(ctx, {
						code: ZodError_1.ZodIssueCode.invalid_type,
						expected: util_1.ZodParsedType.symbol,
						received: ctx.parsedType,
					});
					return parseUtil_1.INVALID;
				}
				return (0, parseUtil_1.OK)(input.data);
			}
		};
		exports2.ZodSymbol = ZodSymbol;
		ZodSymbol.create = (params) => {
			return new ZodSymbol({
				typeName: ZodFirstPartyTypeKind.ZodSymbol,
				...processCreateParams(params),
			});
		};
		var ZodUndefined = class extends ZodType {
			_parse(input) {
				const parsedType = this._getType(input);
				if (parsedType !== util_1.ZodParsedType.undefined) {
					const ctx = this._getOrReturnCtx(input);
					(0, parseUtil_1.addIssueToContext)(ctx, {
						code: ZodError_1.ZodIssueCode.invalid_type,
						expected: util_1.ZodParsedType.undefined,
						received: ctx.parsedType,
					});
					return parseUtil_1.INVALID;
				}
				return (0, parseUtil_1.OK)(input.data);
			}
		};
		exports2.ZodUndefined = ZodUndefined;
		ZodUndefined.create = (params) => {
			return new ZodUndefined({
				typeName: ZodFirstPartyTypeKind.ZodUndefined,
				...processCreateParams(params),
			});
		};
		var ZodNull = class extends ZodType {
			_parse(input) {
				const parsedType = this._getType(input);
				if (parsedType !== util_1.ZodParsedType.null) {
					const ctx = this._getOrReturnCtx(input);
					(0, parseUtil_1.addIssueToContext)(ctx, {
						code: ZodError_1.ZodIssueCode.invalid_type,
						expected: util_1.ZodParsedType.null,
						received: ctx.parsedType,
					});
					return parseUtil_1.INVALID;
				}
				return (0, parseUtil_1.OK)(input.data);
			}
		};
		exports2.ZodNull = ZodNull;
		ZodNull.create = (params) => {
			return new ZodNull({
				typeName: ZodFirstPartyTypeKind.ZodNull,
				...processCreateParams(params),
			});
		};
		var ZodAny = class extends ZodType {
			constructor() {
				super(...arguments);
				this._any = true;
			}
			_parse(input) {
				return (0, parseUtil_1.OK)(input.data);
			}
		};
		exports2.ZodAny = ZodAny;
		ZodAny.create = (params) => {
			return new ZodAny({
				typeName: ZodFirstPartyTypeKind.ZodAny,
				...processCreateParams(params),
			});
		};
		var ZodUnknown = class extends ZodType {
			constructor() {
				super(...arguments);
				this._unknown = true;
			}
			_parse(input) {
				return (0, parseUtil_1.OK)(input.data);
			}
		};
		exports2.ZodUnknown = ZodUnknown;
		ZodUnknown.create = (params) => {
			return new ZodUnknown({
				typeName: ZodFirstPartyTypeKind.ZodUnknown,
				...processCreateParams(params),
			});
		};
		var ZodNever = class extends ZodType {
			_parse(input) {
				const ctx = this._getOrReturnCtx(input);
				(0, parseUtil_1.addIssueToContext)(ctx, {
					code: ZodError_1.ZodIssueCode.invalid_type,
					expected: util_1.ZodParsedType.never,
					received: ctx.parsedType,
				});
				return parseUtil_1.INVALID;
			}
		};
		exports2.ZodNever = ZodNever;
		ZodNever.create = (params) => {
			return new ZodNever({
				typeName: ZodFirstPartyTypeKind.ZodNever,
				...processCreateParams(params),
			});
		};
		var ZodVoid = class extends ZodType {
			_parse(input) {
				const parsedType = this._getType(input);
				if (parsedType !== util_1.ZodParsedType.undefined) {
					const ctx = this._getOrReturnCtx(input);
					(0, parseUtil_1.addIssueToContext)(ctx, {
						code: ZodError_1.ZodIssueCode.invalid_type,
						expected: util_1.ZodParsedType.void,
						received: ctx.parsedType,
					});
					return parseUtil_1.INVALID;
				}
				return (0, parseUtil_1.OK)(input.data);
			}
		};
		exports2.ZodVoid = ZodVoid;
		ZodVoid.create = (params) => {
			return new ZodVoid({
				typeName: ZodFirstPartyTypeKind.ZodVoid,
				...processCreateParams(params),
			});
		};
		var ZodArray = class _ZodArray extends ZodType {
			_parse(input) {
				const { ctx, status } = this._processInputParams(input);
				const def = this._def;
				if (ctx.parsedType !== util_1.ZodParsedType.array) {
					(0, parseUtil_1.addIssueToContext)(ctx, {
						code: ZodError_1.ZodIssueCode.invalid_type,
						expected: util_1.ZodParsedType.array,
						received: ctx.parsedType,
					});
					return parseUtil_1.INVALID;
				}
				if (def.exactLength !== null) {
					const tooBig = ctx.data.length > def.exactLength.value;
					const tooSmall = ctx.data.length < def.exactLength.value;
					if (tooBig || tooSmall) {
						(0, parseUtil_1.addIssueToContext)(ctx, {
							code: tooBig
								? ZodError_1.ZodIssueCode.too_big
								: ZodError_1.ZodIssueCode.too_small,
							minimum: tooSmall ? def.exactLength.value : void 0,
							maximum: tooBig ? def.exactLength.value : void 0,
							type: "array",
							inclusive: true,
							exact: true,
							message: def.exactLength.message,
						});
						status.dirty();
					}
				}
				if (def.minLength !== null) {
					if (ctx.data.length < def.minLength.value) {
						(0, parseUtil_1.addIssueToContext)(ctx, {
							code: ZodError_1.ZodIssueCode.too_small,
							minimum: def.minLength.value,
							type: "array",
							inclusive: true,
							exact: false,
							message: def.minLength.message,
						});
						status.dirty();
					}
				}
				if (def.maxLength !== null) {
					if (ctx.data.length > def.maxLength.value) {
						(0, parseUtil_1.addIssueToContext)(ctx, {
							code: ZodError_1.ZodIssueCode.too_big,
							maximum: def.maxLength.value,
							type: "array",
							inclusive: true,
							exact: false,
							message: def.maxLength.message,
						});
						status.dirty();
					}
				}
				if (ctx.common.async) {
					return Promise.all(
						[...ctx.data].map((item, i) => {
							return def.type._parseAsync(
								new ParseInputLazyPath(ctx, item, ctx.path, i),
							);
						}),
					).then((result2) => {
						return parseUtil_1.ParseStatus.mergeArray(status, result2);
					});
				}
				const result = [...ctx.data].map((item, i) => {
					return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
				});
				return parseUtil_1.ParseStatus.mergeArray(status, result);
			}
			get element() {
				return this._def.type;
			}
			min(minLength, message) {
				return new _ZodArray({
					...this._def,
					minLength: {
						value: minLength,
						message: errorUtil_1.errorUtil.toString(message),
					},
				});
			}
			max(maxLength, message) {
				return new _ZodArray({
					...this._def,
					maxLength: {
						value: maxLength,
						message: errorUtil_1.errorUtil.toString(message),
					},
				});
			}
			length(len, message) {
				return new _ZodArray({
					...this._def,
					exactLength: { value: len, message: errorUtil_1.errorUtil.toString(message) },
				});
			}
			nonempty(message) {
				return this.min(1, message);
			}
		};
		exports2.ZodArray = ZodArray;
		ZodArray.create = (schema, params) => {
			return new ZodArray({
				type: schema,
				minLength: null,
				maxLength: null,
				exactLength: null,
				typeName: ZodFirstPartyTypeKind.ZodArray,
				...processCreateParams(params),
			});
		};
		function deepPartialify(schema) {
			if (schema instanceof ZodObject) {
				const newShape = {};
				for (const key in schema.shape) {
					const fieldSchema = schema.shape[key];
					newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
				}
				return new ZodObject({
					...schema._def,
					shape: () => newShape,
				});
			} else if (schema instanceof ZodArray) {
				return new ZodArray({
					...schema._def,
					type: deepPartialify(schema.element),
				});
			} else if (schema instanceof ZodOptional) {
				return ZodOptional.create(deepPartialify(schema.unwrap()));
			} else if (schema instanceof ZodNullable) {
				return ZodNullable.create(deepPartialify(schema.unwrap()));
			} else if (schema instanceof ZodTuple) {
				return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
			} else {
				return schema;
			}
		}
		var ZodObject = class _ZodObject extends ZodType {
			constructor() {
				super(...arguments);
				this._cached = null;
				this.nonstrict = this.passthrough;
				this.augment = this.extend;
			}
			_getCached() {
				if (this._cached !== null) return this._cached;
				const shape = this._def.shape();
				const keys = util_1.util.objectKeys(shape);
				return (this._cached = { shape, keys });
			}
			_parse(input) {
				const parsedType = this._getType(input);
				if (parsedType !== util_1.ZodParsedType.object) {
					const ctx2 = this._getOrReturnCtx(input);
					(0, parseUtil_1.addIssueToContext)(ctx2, {
						code: ZodError_1.ZodIssueCode.invalid_type,
						expected: util_1.ZodParsedType.object,
						received: ctx2.parsedType,
					});
					return parseUtil_1.INVALID;
				}
				const { status, ctx } = this._processInputParams(input);
				const { shape, keys: shapeKeys } = this._getCached();
				const extraKeys = [];
				if (
					!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")
				) {
					for (const key in ctx.data) {
						if (!shapeKeys.includes(key)) {
							extraKeys.push(key);
						}
					}
				}
				const pairs = [];
				for (const key of shapeKeys) {
					const keyValidator = shape[key];
					const value = ctx.data[key];
					pairs.push({
						key: { status: "valid", value: key },
						value: keyValidator._parse(
							new ParseInputLazyPath(ctx, value, ctx.path, key),
						),
						alwaysSet: key in ctx.data,
					});
				}
				if (this._def.catchall instanceof ZodNever) {
					const unknownKeys = this._def.unknownKeys;
					if (unknownKeys === "passthrough") {
						for (const key of extraKeys) {
							pairs.push({
								key: { status: "valid", value: key },
								value: { status: "valid", value: ctx.data[key] },
							});
						}
					} else if (unknownKeys === "strict") {
						if (extraKeys.length > 0) {
							(0, parseUtil_1.addIssueToContext)(ctx, {
								code: ZodError_1.ZodIssueCode.unrecognized_keys,
								keys: extraKeys,
							});
							status.dirty();
						}
					} else if (unknownKeys === "strip") {
					} else {
						throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
					}
				} else {
					const catchall = this._def.catchall;
					for (const key of extraKeys) {
						const value = ctx.data[key];
						pairs.push({
							key: { status: "valid", value: key },
							value: catchall._parse(
								new ParseInputLazyPath(ctx, value, ctx.path, key),
								//, ctx.child(key), value, getParsedType(value)
							),
							alwaysSet: key in ctx.data,
						});
					}
				}
				if (ctx.common.async) {
					return Promise.resolve()
						.then(async () => {
							const syncPairs = [];
							for (const pair of pairs) {
								const key = await pair.key;
								const value = await pair.value;
								syncPairs.push({
									key,
									value,
									alwaysSet: pair.alwaysSet,
								});
							}
							return syncPairs;
						})
						.then((syncPairs) => {
							return parseUtil_1.ParseStatus.mergeObjectSync(status, syncPairs);
						});
				} else {
					return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
				}
			}
			get shape() {
				return this._def.shape();
			}
			strict(message) {
				errorUtil_1.errorUtil.errToObj;
				return new _ZodObject({
					...this._def,
					unknownKeys: "strict",
					...(message !== void 0
						? {
								errorMap: (issue, ctx) => {
									var _a, _b, _c, _d;
									const defaultError =
										(_c =
											(_b = (_a = this._def).errorMap) === null ||
											_b === void 0
												? void 0
												: _b.call(_a, issue, ctx).message) !== null &&
										_c !== void 0
											? _c
											: ctx.defaultError;
									if (issue.code === "unrecognized_keys")
										return {
											message:
												(_d =
													errorUtil_1.errorUtil.errToObj(
														message,
													).message) !== null && _d !== void 0
													? _d
													: defaultError,
										};
									return {
										message: defaultError,
									};
								},
							}
						: {}),
				});
			}
			strip() {
				return new _ZodObject({
					...this._def,
					unknownKeys: "strip",
				});
			}
			passthrough() {
				return new _ZodObject({
					...this._def,
					unknownKeys: "passthrough",
				});
			}
			// const AugmentFactory =
			//   <Def extends ZodObjectDef>(def: Def) =>
			//   <Augmentation extends ZodRawShape>(
			//     augmentation: Augmentation
			//   ): ZodObject<
			//     extendShape<ReturnType<Def["shape"]>, Augmentation>,
			//     Def["unknownKeys"],
			//     Def["catchall"]
			//   > => {
			//     return new ZodObject({
			//       ...def,
			//       shape: () => ({
			//         ...def.shape(),
			//         ...augmentation,
			//       }),
			//     }) as any;
			//   };
			extend(augmentation) {
				return new _ZodObject({
					...this._def,
					shape: () => ({
						...this._def.shape(),
						...augmentation,
					}),
				});
			}
			/**
			 * Prior to zod@1.0.12 there was a bug in the
			 * inferred type of merged objects. Please
			 * upgrade if you are experiencing issues.
			 */
			merge(merging) {
				const merged = new _ZodObject({
					unknownKeys: merging._def.unknownKeys,
					catchall: merging._def.catchall,
					shape: () => ({
						...this._def.shape(),
						...merging._def.shape(),
					}),
					typeName: ZodFirstPartyTypeKind.ZodObject,
				});
				return merged;
			}
			// merge<
			//   Incoming extends AnyZodObject,
			//   Augmentation extends Incoming["shape"],
			//   NewOutput extends {
			//     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
			//       ? Augmentation[k]["_output"]
			//       : k extends keyof Output
			//       ? Output[k]
			//       : never;
			//   },
			//   NewInput extends {
			//     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
			//       ? Augmentation[k]["_input"]
			//       : k extends keyof Input
			//       ? Input[k]
			//       : never;
			//   }
			// >(
			//   merging: Incoming
			// ): ZodObject<
			//   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
			//   Incoming["_def"]["unknownKeys"],
			//   Incoming["_def"]["catchall"],
			//   NewOutput,
			//   NewInput
			// > {
			//   const merged: any = new ZodObject({
			//     unknownKeys: merging._def.unknownKeys,
			//     catchall: merging._def.catchall,
			//     shape: () =>
			//       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
			//     typeName: ZodFirstPartyTypeKind.ZodObject,
			//   }) as any;
			//   return merged;
			// }
			setKey(key, schema) {
				return this.augment({ [key]: schema });
			}
			// merge<Incoming extends AnyZodObject>(
			//   merging: Incoming
			// ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
			// ZodObject<
			//   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
			//   Incoming["_def"]["unknownKeys"],
			//   Incoming["_def"]["catchall"]
			// > {
			//   // const mergedShape = objectUtil.mergeShapes(
			//   //   this._def.shape(),
			//   //   merging._def.shape()
			//   // );
			//   const merged: any = new ZodObject({
			//     unknownKeys: merging._def.unknownKeys,
			//     catchall: merging._def.catchall,
			//     shape: () =>
			//       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
			//     typeName: ZodFirstPartyTypeKind.ZodObject,
			//   }) as any;
			//   return merged;
			// }
			catchall(index) {
				return new _ZodObject({
					...this._def,
					catchall: index,
				});
			}
			pick(mask) {
				const shape = {};
				util_1.util.objectKeys(mask).forEach((key) => {
					if (mask[key] && this.shape[key]) {
						shape[key] = this.shape[key];
					}
				});
				return new _ZodObject({
					...this._def,
					shape: () => shape,
				});
			}
			omit(mask) {
				const shape = {};
				util_1.util.objectKeys(this.shape).forEach((key) => {
					if (!mask[key]) {
						shape[key] = this.shape[key];
					}
				});
				return new _ZodObject({
					...this._def,
					shape: () => shape,
				});
			}
			/**
			 * @deprecated
			 */
			deepPartial() {
				return deepPartialify(this);
			}
			partial(mask) {
				const newShape = {};
				util_1.util.objectKeys(this.shape).forEach((key) => {
					const fieldSchema = this.shape[key];
					if (mask && !mask[key]) {
						newShape[key] = fieldSchema;
					} else {
						newShape[key] = fieldSchema.optional();
					}
				});
				return new _ZodObject({
					...this._def,
					shape: () => newShape,
				});
			}
			required(mask) {
				const newShape = {};
				util_1.util.objectKeys(this.shape).forEach((key) => {
					if (mask && !mask[key]) {
						newShape[key] = this.shape[key];
					} else {
						const fieldSchema = this.shape[key];
						let newField = fieldSchema;
						while (newField instanceof ZodOptional) {
							newField = newField._def.innerType;
						}
						newShape[key] = newField;
					}
				});
				return new _ZodObject({
					...this._def,
					shape: () => newShape,
				});
			}
			keyof() {
				return createZodEnum(util_1.util.objectKeys(this.shape));
			}
		};
		exports2.ZodObject = ZodObject;
		ZodObject.create = (shape, params) => {
			return new ZodObject({
				shape: () => shape,
				unknownKeys: "strip",
				catchall: ZodNever.create(),
				typeName: ZodFirstPartyTypeKind.ZodObject,
				...processCreateParams(params),
			});
		};
		ZodObject.strictCreate = (shape, params) => {
			return new ZodObject({
				shape: () => shape,
				unknownKeys: "strict",
				catchall: ZodNever.create(),
				typeName: ZodFirstPartyTypeKind.ZodObject,
				...processCreateParams(params),
			});
		};
		ZodObject.lazycreate = (shape, params) => {
			return new ZodObject({
				shape,
				unknownKeys: "strip",
				catchall: ZodNever.create(),
				typeName: ZodFirstPartyTypeKind.ZodObject,
				...processCreateParams(params),
			});
		};
		var ZodUnion = class extends ZodType {
			_parse(input) {
				const { ctx } = this._processInputParams(input);
				const options = this._def.options;
				function handleResults(results) {
					for (const result of results) {
						if (result.result.status === "valid") {
							return result.result;
						}
					}
					for (const result of results) {
						if (result.result.status === "dirty") {
							ctx.common.issues.push(...result.ctx.common.issues);
							return result.result;
						}
					}
					const unionErrors = results.map(
						(result) => new ZodError_1.ZodError(result.ctx.common.issues),
					);
					(0, parseUtil_1.addIssueToContext)(ctx, {
						code: ZodError_1.ZodIssueCode.invalid_union,
						unionErrors,
					});
					return parseUtil_1.INVALID;
				}
				if (ctx.common.async) {
					return Promise.all(
						options.map(async (option) => {
							const childCtx = {
								...ctx,
								common: {
									...ctx.common,
									issues: [],
								},
								parent: null,
							};
							return {
								result: await option._parseAsync({
									data: ctx.data,
									path: ctx.path,
									parent: childCtx,
								}),
								ctx: childCtx,
							};
						}),
					).then(handleResults);
				} else {
					let dirty = void 0;
					const issues = [];
					for (const option of options) {
						const childCtx = {
							...ctx,
							common: {
								...ctx.common,
								issues: [],
							},
							parent: null,
						};
						const result = option._parseSync({
							data: ctx.data,
							path: ctx.path,
							parent: childCtx,
						});
						if (result.status === "valid") {
							return result;
						} else if (result.status === "dirty" && !dirty) {
							dirty = { result, ctx: childCtx };
						}
						if (childCtx.common.issues.length) {
							issues.push(childCtx.common.issues);
						}
					}
					if (dirty) {
						ctx.common.issues.push(...dirty.ctx.common.issues);
						return dirty.result;
					}
					const unionErrors = issues.map((issues2) => new ZodError_1.ZodError(issues2));
					(0, parseUtil_1.addIssueToContext)(ctx, {
						code: ZodError_1.ZodIssueCode.invalid_union,
						unionErrors,
					});
					return parseUtil_1.INVALID;
				}
			}
			get options() {
				return this._def.options;
			}
		};
		exports2.ZodUnion = ZodUnion;
		ZodUnion.create = (types, params) => {
			return new ZodUnion({
				options: types,
				typeName: ZodFirstPartyTypeKind.ZodUnion,
				...processCreateParams(params),
			});
		};
		var getDiscriminator = (type) => {
			if (type instanceof ZodLazy) {
				return getDiscriminator(type.schema);
			} else if (type instanceof ZodEffects) {
				return getDiscriminator(type.innerType());
			} else if (type instanceof ZodLiteral) {
				return [type.value];
			} else if (type instanceof ZodEnum) {
				return type.options;
			} else if (type instanceof ZodNativeEnum) {
				return util_1.util.objectValues(type.enum);
			} else if (type instanceof ZodDefault) {
				return getDiscriminator(type._def.innerType);
			} else if (type instanceof ZodUndefined) {
				return [void 0];
			} else if (type instanceof ZodNull) {
				return [null];
			} else if (type instanceof ZodOptional) {
				return [void 0, ...getDiscriminator(type.unwrap())];
			} else if (type instanceof ZodNullable) {
				return [null, ...getDiscriminator(type.unwrap())];
			} else if (type instanceof ZodBranded) {
				return getDiscriminator(type.unwrap());
			} else if (type instanceof ZodReadonly) {
				return getDiscriminator(type.unwrap());
			} else if (type instanceof ZodCatch) {
				return getDiscriminator(type._def.innerType);
			} else {
				return [];
			}
		};
		var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
			_parse(input) {
				const { ctx } = this._processInputParams(input);
				if (ctx.parsedType !== util_1.ZodParsedType.object) {
					(0, parseUtil_1.addIssueToContext)(ctx, {
						code: ZodError_1.ZodIssueCode.invalid_type,
						expected: util_1.ZodParsedType.object,
						received: ctx.parsedType,
					});
					return parseUtil_1.INVALID;
				}
				const discriminator = this.discriminator;
				const discriminatorValue = ctx.data[discriminator];
				const option = this.optionsMap.get(discriminatorValue);
				if (!option) {
					(0, parseUtil_1.addIssueToContext)(ctx, {
						code: ZodError_1.ZodIssueCode.invalid_union_discriminator,
						options: Array.from(this.optionsMap.keys()),
						path: [discriminator],
					});
					return parseUtil_1.INVALID;
				}
				if (ctx.common.async) {
					return option._parseAsync({
						data: ctx.data,
						path: ctx.path,
						parent: ctx,
					});
				} else {
					return option._parseSync({
						data: ctx.data,
						path: ctx.path,
						parent: ctx,
					});
				}
			}
			get discriminator() {
				return this._def.discriminator;
			}
			get options() {
				return this._def.options;
			}
			get optionsMap() {
				return this._def.optionsMap;
			}
			/**
			 * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
			 * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
			 * have a different value for each object in the union.
			 * @param discriminator the name of the discriminator property
			 * @param types an array of object schemas
			 * @param params
			 */
			static create(discriminator, options, params) {
				const optionsMap = /* @__PURE__ */ new Map();
				for (const type of options) {
					const discriminatorValues = getDiscriminator(type.shape[discriminator]);
					if (!discriminatorValues.length) {
						throw new Error(
							`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`,
						);
					}
					for (const value of discriminatorValues) {
						if (optionsMap.has(value)) {
							throw new Error(
								`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`,
							);
						}
						optionsMap.set(value, type);
					}
				}
				return new _ZodDiscriminatedUnion({
					typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
					discriminator,
					options,
					optionsMap,
					...processCreateParams(params),
				});
			}
		};
		exports2.ZodDiscriminatedUnion = ZodDiscriminatedUnion;
		function mergeValues(a, b) {
			const aType = (0, util_1.getParsedType)(a);
			const bType = (0, util_1.getParsedType)(b);
			if (a === b) {
				return { valid: true, data: a };
			} else if (
				aType === util_1.ZodParsedType.object &&
				bType === util_1.ZodParsedType.object
			) {
				const bKeys = util_1.util.objectKeys(b);
				const sharedKeys = util_1.util
					.objectKeys(a)
					.filter((key) => bKeys.indexOf(key) !== -1);
				const newObj = { ...a, ...b };
				for (const key of sharedKeys) {
					const sharedValue = mergeValues(a[key], b[key]);
					if (!sharedValue.valid) {
						return { valid: false };
					}
					newObj[key] = sharedValue.data;
				}
				return { valid: true, data: newObj };
			} else if (
				aType === util_1.ZodParsedType.array &&
				bType === util_1.ZodParsedType.array
			) {
				if (a.length !== b.length) {
					return { valid: false };
				}
				const newArray = [];
				for (let index = 0; index < a.length; index++) {
					const itemA = a[index];
					const itemB = b[index];
					const sharedValue = mergeValues(itemA, itemB);
					if (!sharedValue.valid) {
						return { valid: false };
					}
					newArray.push(sharedValue.data);
				}
				return { valid: true, data: newArray };
			} else if (
				aType === util_1.ZodParsedType.date &&
				bType === util_1.ZodParsedType.date &&
				+a === +b
			) {
				return { valid: true, data: a };
			} else {
				return { valid: false };
			}
		}
		var ZodIntersection = class extends ZodType {
			_parse(input) {
				const { status, ctx } = this._processInputParams(input);
				const handleParsed = (parsedLeft, parsedRight) => {
					if (
						(0, parseUtil_1.isAborted)(parsedLeft) ||
						(0, parseUtil_1.isAborted)(parsedRight)
					) {
						return parseUtil_1.INVALID;
					}
					const merged = mergeValues(parsedLeft.value, parsedRight.value);
					if (!merged.valid) {
						(0, parseUtil_1.addIssueToContext)(ctx, {
							code: ZodError_1.ZodIssueCode.invalid_intersection_types,
						});
						return parseUtil_1.INVALID;
					}
					if (
						(0, parseUtil_1.isDirty)(parsedLeft) ||
						(0, parseUtil_1.isDirty)(parsedRight)
					) {
						status.dirty();
					}
					return { status: status.value, value: merged.data };
				};
				if (ctx.common.async) {
					return Promise.all([
						this._def.left._parseAsync({
							data: ctx.data,
							path: ctx.path,
							parent: ctx,
						}),
						this._def.right._parseAsync({
							data: ctx.data,
							path: ctx.path,
							parent: ctx,
						}),
					]).then(([left, right]) => handleParsed(left, right));
				} else {
					return handleParsed(
						this._def.left._parseSync({
							data: ctx.data,
							path: ctx.path,
							parent: ctx,
						}),
						this._def.right._parseSync({
							data: ctx.data,
							path: ctx.path,
							parent: ctx,
						}),
					);
				}
			}
		};
		exports2.ZodIntersection = ZodIntersection;
		ZodIntersection.create = (left, right, params) => {
			return new ZodIntersection({
				left,
				right,
				typeName: ZodFirstPartyTypeKind.ZodIntersection,
				...processCreateParams(params),
			});
		};
		var ZodTuple = class _ZodTuple extends ZodType {
			_parse(input) {
				const { status, ctx } = this._processInputParams(input);
				if (ctx.parsedType !== util_1.ZodParsedType.array) {
					(0, parseUtil_1.addIssueToContext)(ctx, {
						code: ZodError_1.ZodIssueCode.invalid_type,
						expected: util_1.ZodParsedType.array,
						received: ctx.parsedType,
					});
					return parseUtil_1.INVALID;
				}
				if (ctx.data.length < this._def.items.length) {
					(0, parseUtil_1.addIssueToContext)(ctx, {
						code: ZodError_1.ZodIssueCode.too_small,
						minimum: this._def.items.length,
						inclusive: true,
						exact: false,
						type: "array",
					});
					return parseUtil_1.INVALID;
				}
				const rest = this._def.rest;
				if (!rest && ctx.data.length > this._def.items.length) {
					(0, parseUtil_1.addIssueToContext)(ctx, {
						code: ZodError_1.ZodIssueCode.too_big,
						maximum: this._def.items.length,
						inclusive: true,
						exact: false,
						type: "array",
					});
					status.dirty();
				}
				const items = [...ctx.data]
					.map((item, itemIndex) => {
						const schema = this._def.items[itemIndex] || this._def.rest;
						if (!schema) return null;
						return schema._parse(
							new ParseInputLazyPath(ctx, item, ctx.path, itemIndex),
						);
					})
					.filter((x) => !!x);
				if (ctx.common.async) {
					return Promise.all(items).then((results) => {
						return parseUtil_1.ParseStatus.mergeArray(status, results);
					});
				} else {
					return parseUtil_1.ParseStatus.mergeArray(status, items);
				}
			}
			get items() {
				return this._def.items;
			}
			rest(rest) {
				return new _ZodTuple({
					...this._def,
					rest,
				});
			}
		};
		exports2.ZodTuple = ZodTuple;
		ZodTuple.create = (schemas, params) => {
			if (!Array.isArray(schemas)) {
				throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
			}
			return new ZodTuple({
				items: schemas,
				typeName: ZodFirstPartyTypeKind.ZodTuple,
				rest: null,
				...processCreateParams(params),
			});
		};
		var ZodRecord = class _ZodRecord extends ZodType {
			get keySchema() {
				return this._def.keyType;
			}
			get valueSchema() {
				return this._def.valueType;
			}
			_parse(input) {
				const { status, ctx } = this._processInputParams(input);
				if (ctx.parsedType !== util_1.ZodParsedType.object) {
					(0, parseUtil_1.addIssueToContext)(ctx, {
						code: ZodError_1.ZodIssueCode.invalid_type,
						expected: util_1.ZodParsedType.object,
						received: ctx.parsedType,
					});
					return parseUtil_1.INVALID;
				}
				const pairs = [];
				const keyType = this._def.keyType;
				const valueType = this._def.valueType;
				for (const key in ctx.data) {
					pairs.push({
						key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
						value: valueType._parse(
							new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key),
						),
						alwaysSet: key in ctx.data,
					});
				}
				if (ctx.common.async) {
					return parseUtil_1.ParseStatus.mergeObjectAsync(status, pairs);
				} else {
					return parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
				}
			}
			get element() {
				return this._def.valueType;
			}
			static create(first, second, third) {
				if (second instanceof ZodType) {
					return new _ZodRecord({
						keyType: first,
						valueType: second,
						typeName: ZodFirstPartyTypeKind.ZodRecord,
						...processCreateParams(third),
					});
				}
				return new _ZodRecord({
					keyType: ZodString.create(),
					valueType: first,
					typeName: ZodFirstPartyTypeKind.ZodRecord,
					...processCreateParams(second),
				});
			}
		};
		exports2.ZodRecord = ZodRecord;
		var ZodMap = class extends ZodType {
			get keySchema() {
				return this._def.keyType;
			}
			get valueSchema() {
				return this._def.valueType;
			}
			_parse(input) {
				const { status, ctx } = this._processInputParams(input);
				if (ctx.parsedType !== util_1.ZodParsedType.map) {
					(0, parseUtil_1.addIssueToContext)(ctx, {
						code: ZodError_1.ZodIssueCode.invalid_type,
						expected: util_1.ZodParsedType.map,
						received: ctx.parsedType,
					});
					return parseUtil_1.INVALID;
				}
				const keyType = this._def.keyType;
				const valueType = this._def.valueType;
				const pairs = [...ctx.data.entries()].map(([key, value], index) => {
					return {
						key: keyType._parse(
							new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"]),
						),
						value: valueType._parse(
							new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]),
						),
					};
				});
				if (ctx.common.async) {
					const finalMap = /* @__PURE__ */ new Map();
					return Promise.resolve().then(async () => {
						for (const pair of pairs) {
							const key = await pair.key;
							const value = await pair.value;
							if (key.status === "aborted" || value.status === "aborted") {
								return parseUtil_1.INVALID;
							}
							if (key.status === "dirty" || value.status === "dirty") {
								status.dirty();
							}
							finalMap.set(key.value, value.value);
						}
						return { status: status.value, value: finalMap };
					});
				} else {
					const finalMap = /* @__PURE__ */ new Map();
					for (const pair of pairs) {
						const key = pair.key;
						const value = pair.value;
						if (key.status === "aborted" || value.status === "aborted") {
							return parseUtil_1.INVALID;
						}
						if (key.status === "dirty" || value.status === "dirty") {
							status.dirty();
						}
						finalMap.set(key.value, value.value);
					}
					return { status: status.value, value: finalMap };
				}
			}
		};
		exports2.ZodMap = ZodMap;
		ZodMap.create = (keyType, valueType, params) => {
			return new ZodMap({
				valueType,
				keyType,
				typeName: ZodFirstPartyTypeKind.ZodMap,
				...processCreateParams(params),
			});
		};
		var ZodSet = class _ZodSet extends ZodType {
			_parse(input) {
				const { status, ctx } = this._processInputParams(input);
				if (ctx.parsedType !== util_1.ZodParsedType.set) {
					(0, parseUtil_1.addIssueToContext)(ctx, {
						code: ZodError_1.ZodIssueCode.invalid_type,
						expected: util_1.ZodParsedType.set,
						received: ctx.parsedType,
					});
					return parseUtil_1.INVALID;
				}
				const def = this._def;
				if (def.minSize !== null) {
					if (ctx.data.size < def.minSize.value) {
						(0, parseUtil_1.addIssueToContext)(ctx, {
							code: ZodError_1.ZodIssueCode.too_small,
							minimum: def.minSize.value,
							type: "set",
							inclusive: true,
							exact: false,
							message: def.minSize.message,
						});
						status.dirty();
					}
				}
				if (def.maxSize !== null) {
					if (ctx.data.size > def.maxSize.value) {
						(0, parseUtil_1.addIssueToContext)(ctx, {
							code: ZodError_1.ZodIssueCode.too_big,
							maximum: def.maxSize.value,
							type: "set",
							inclusive: true,
							exact: false,
							message: def.maxSize.message,
						});
						status.dirty();
					}
				}
				const valueType = this._def.valueType;
				function finalizeSet(elements2) {
					const parsedSet = /* @__PURE__ */ new Set();
					for (const element of elements2) {
						if (element.status === "aborted") return parseUtil_1.INVALID;
						if (element.status === "dirty") status.dirty();
						parsedSet.add(element.value);
					}
					return { status: status.value, value: parsedSet };
				}
				const elements = [...ctx.data.values()].map((item, i) =>
					valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)),
				);
				if (ctx.common.async) {
					return Promise.all(elements).then((elements2) => finalizeSet(elements2));
				} else {
					return finalizeSet(elements);
				}
			}
			min(minSize, message) {
				return new _ZodSet({
					...this._def,
					minSize: { value: minSize, message: errorUtil_1.errorUtil.toString(message) },
				});
			}
			max(maxSize, message) {
				return new _ZodSet({
					...this._def,
					maxSize: { value: maxSize, message: errorUtil_1.errorUtil.toString(message) },
				});
			}
			size(size, message) {
				return this.min(size, message).max(size, message);
			}
			nonempty(message) {
				return this.min(1, message);
			}
		};
		exports2.ZodSet = ZodSet;
		ZodSet.create = (valueType, params) => {
			return new ZodSet({
				valueType,
				minSize: null,
				maxSize: null,
				typeName: ZodFirstPartyTypeKind.ZodSet,
				...processCreateParams(params),
			});
		};
		var ZodFunction = class _ZodFunction extends ZodType {
			constructor() {
				super(...arguments);
				this.validate = this.implement;
			}
			_parse(input) {
				const { ctx } = this._processInputParams(input);
				if (ctx.parsedType !== util_1.ZodParsedType.function) {
					(0, parseUtil_1.addIssueToContext)(ctx, {
						code: ZodError_1.ZodIssueCode.invalid_type,
						expected: util_1.ZodParsedType.function,
						received: ctx.parsedType,
					});
					return parseUtil_1.INVALID;
				}
				function makeArgsIssue(args, error) {
					return (0, parseUtil_1.makeIssue)({
						data: args,
						path: ctx.path,
						errorMaps: [
							ctx.common.contextualErrorMap,
							ctx.schemaErrorMap,
							(0, errors_1.getErrorMap)(),
							errors_1.defaultErrorMap,
						].filter((x) => !!x),
						issueData: {
							code: ZodError_1.ZodIssueCode.invalid_arguments,
							argumentsError: error,
						},
					});
				}
				function makeReturnsIssue(returns, error) {
					return (0, parseUtil_1.makeIssue)({
						data: returns,
						path: ctx.path,
						errorMaps: [
							ctx.common.contextualErrorMap,
							ctx.schemaErrorMap,
							(0, errors_1.getErrorMap)(),
							errors_1.defaultErrorMap,
						].filter((x) => !!x),
						issueData: {
							code: ZodError_1.ZodIssueCode.invalid_return_type,
							returnTypeError: error,
						},
					});
				}
				const params = { errorMap: ctx.common.contextualErrorMap };
				const fn = ctx.data;
				if (this._def.returns instanceof ZodPromise) {
					const me = this;
					return (0, parseUtil_1.OK)(async function (...args) {
						const error = new ZodError_1.ZodError([]);
						const parsedArgs = await me._def.args
							.parseAsync(args, params)
							.catch((e) => {
								error.addIssue(makeArgsIssue(args, e));
								throw error;
							});
						const result = await Reflect.apply(fn, this, parsedArgs);
						const parsedReturns = await me._def.returns._def.type
							.parseAsync(result, params)
							.catch((e) => {
								error.addIssue(makeReturnsIssue(result, e));
								throw error;
							});
						return parsedReturns;
					});
				} else {
					const me = this;
					return (0, parseUtil_1.OK)(function (...args) {
						const parsedArgs = me._def.args.safeParse(args, params);
						if (!parsedArgs.success) {
							throw new ZodError_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
						}
						const result = Reflect.apply(fn, this, parsedArgs.data);
						const parsedReturns = me._def.returns.safeParse(result, params);
						if (!parsedReturns.success) {
							throw new ZodError_1.ZodError([
								makeReturnsIssue(result, parsedReturns.error),
							]);
						}
						return parsedReturns.data;
					});
				}
			}
			parameters() {
				return this._def.args;
			}
			returnType() {
				return this._def.returns;
			}
			args(...items) {
				return new _ZodFunction({
					...this._def,
					args: ZodTuple.create(items).rest(ZodUnknown.create()),
				});
			}
			returns(returnType) {
				return new _ZodFunction({
					...this._def,
					returns: returnType,
				});
			}
			implement(func) {
				const validatedFunc = this.parse(func);
				return validatedFunc;
			}
			strictImplement(func) {
				const validatedFunc = this.parse(func);
				return validatedFunc;
			}
			static create(args, returns, params) {
				return new _ZodFunction({
					args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
					returns: returns || ZodUnknown.create(),
					typeName: ZodFirstPartyTypeKind.ZodFunction,
					...processCreateParams(params),
				});
			}
		};
		exports2.ZodFunction = ZodFunction;
		var ZodLazy = class extends ZodType {
			get schema() {
				return this._def.getter();
			}
			_parse(input) {
				const { ctx } = this._processInputParams(input);
				const lazySchema = this._def.getter();
				return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
			}
		};
		exports2.ZodLazy = ZodLazy;
		ZodLazy.create = (getter, params) => {
			return new ZodLazy({
				getter,
				typeName: ZodFirstPartyTypeKind.ZodLazy,
				...processCreateParams(params),
			});
		};
		var ZodLiteral = class extends ZodType {
			_parse(input) {
				if (input.data !== this._def.value) {
					const ctx = this._getOrReturnCtx(input);
					(0, parseUtil_1.addIssueToContext)(ctx, {
						received: ctx.data,
						code: ZodError_1.ZodIssueCode.invalid_literal,
						expected: this._def.value,
					});
					return parseUtil_1.INVALID;
				}
				return { status: "valid", value: input.data };
			}
			get value() {
				return this._def.value;
			}
		};
		exports2.ZodLiteral = ZodLiteral;
		ZodLiteral.create = (value, params) => {
			return new ZodLiteral({
				value,
				typeName: ZodFirstPartyTypeKind.ZodLiteral,
				...processCreateParams(params),
			});
		};
		function createZodEnum(values, params) {
			return new ZodEnum({
				values,
				typeName: ZodFirstPartyTypeKind.ZodEnum,
				...processCreateParams(params),
			});
		}
		var ZodEnum = class _ZodEnum extends ZodType {
			constructor() {
				super(...arguments);
				_ZodEnum_cache.set(this, void 0);
			}
			_parse(input) {
				if (typeof input.data !== "string") {
					const ctx = this._getOrReturnCtx(input);
					const expectedValues = this._def.values;
					(0, parseUtil_1.addIssueToContext)(ctx, {
						expected: util_1.util.joinValues(expectedValues),
						received: ctx.parsedType,
						code: ZodError_1.ZodIssueCode.invalid_type,
					});
					return parseUtil_1.INVALID;
				}
				if (!__classPrivateFieldGet2(this, _ZodEnum_cache, "f")) {
					__classPrivateFieldSet2(this, _ZodEnum_cache, new Set(this._def.values), "f");
				}
				if (!__classPrivateFieldGet2(this, _ZodEnum_cache, "f").has(input.data)) {
					const ctx = this._getOrReturnCtx(input);
					const expectedValues = this._def.values;
					(0, parseUtil_1.addIssueToContext)(ctx, {
						received: ctx.data,
						code: ZodError_1.ZodIssueCode.invalid_enum_value,
						options: expectedValues,
					});
					return parseUtil_1.INVALID;
				}
				return (0, parseUtil_1.OK)(input.data);
			}
			get options() {
				return this._def.values;
			}
			get enum() {
				const enumValues = {};
				for (const val of this._def.values) {
					enumValues[val] = val;
				}
				return enumValues;
			}
			get Values() {
				const enumValues = {};
				for (const val of this._def.values) {
					enumValues[val] = val;
				}
				return enumValues;
			}
			get Enum() {
				const enumValues = {};
				for (const val of this._def.values) {
					enumValues[val] = val;
				}
				return enumValues;
			}
			extract(values, newDef = this._def) {
				return _ZodEnum.create(values, {
					...this._def,
					...newDef,
				});
			}
			exclude(values, newDef = this._def) {
				return _ZodEnum.create(
					this.options.filter((opt) => !values.includes(opt)),
					{
						...this._def,
						...newDef,
					},
				);
			}
		};
		exports2.ZodEnum = ZodEnum;
		_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
		ZodEnum.create = createZodEnum;
		var ZodNativeEnum = class extends ZodType {
			constructor() {
				super(...arguments);
				_ZodNativeEnum_cache.set(this, void 0);
			}
			_parse(input) {
				const nativeEnumValues = util_1.util.getValidEnumValues(this._def.values);
				const ctx = this._getOrReturnCtx(input);
				if (
					ctx.parsedType !== util_1.ZodParsedType.string &&
					ctx.parsedType !== util_1.ZodParsedType.number
				) {
					const expectedValues = util_1.util.objectValues(nativeEnumValues);
					(0, parseUtil_1.addIssueToContext)(ctx, {
						expected: util_1.util.joinValues(expectedValues),
						received: ctx.parsedType,
						code: ZodError_1.ZodIssueCode.invalid_type,
					});
					return parseUtil_1.INVALID;
				}
				if (!__classPrivateFieldGet2(this, _ZodNativeEnum_cache, "f")) {
					__classPrivateFieldSet2(
						this,
						_ZodNativeEnum_cache,
						new Set(util_1.util.getValidEnumValues(this._def.values)),
						"f",
					);
				}
				if (!__classPrivateFieldGet2(this, _ZodNativeEnum_cache, "f").has(input.data)) {
					const expectedValues = util_1.util.objectValues(nativeEnumValues);
					(0, parseUtil_1.addIssueToContext)(ctx, {
						received: ctx.data,
						code: ZodError_1.ZodIssueCode.invalid_enum_value,
						options: expectedValues,
					});
					return parseUtil_1.INVALID;
				}
				return (0, parseUtil_1.OK)(input.data);
			}
			get enum() {
				return this._def.values;
			}
		};
		exports2.ZodNativeEnum = ZodNativeEnum;
		_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
		ZodNativeEnum.create = (values, params) => {
			return new ZodNativeEnum({
				values,
				typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
				...processCreateParams(params),
			});
		};
		var ZodPromise = class extends ZodType {
			unwrap() {
				return this._def.type;
			}
			_parse(input) {
				const { ctx } = this._processInputParams(input);
				if (ctx.parsedType !== util_1.ZodParsedType.promise && ctx.common.async === false) {
					(0, parseUtil_1.addIssueToContext)(ctx, {
						code: ZodError_1.ZodIssueCode.invalid_type,
						expected: util_1.ZodParsedType.promise,
						received: ctx.parsedType,
					});
					return parseUtil_1.INVALID;
				}
				const promisified =
					ctx.parsedType === util_1.ZodParsedType.promise
						? ctx.data
						: Promise.resolve(ctx.data);
				return (0, parseUtil_1.OK)(
					promisified.then((data) => {
						return this._def.type.parseAsync(data, {
							path: ctx.path,
							errorMap: ctx.common.contextualErrorMap,
						});
					}),
				);
			}
		};
		exports2.ZodPromise = ZodPromise;
		ZodPromise.create = (schema, params) => {
			return new ZodPromise({
				type: schema,
				typeName: ZodFirstPartyTypeKind.ZodPromise,
				...processCreateParams(params),
			});
		};
		var ZodEffects = class extends ZodType {
			innerType() {
				return this._def.schema;
			}
			sourceType() {
				return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects
					? this._def.schema.sourceType()
					: this._def.schema;
			}
			_parse(input) {
				const { status, ctx } = this._processInputParams(input);
				const effect = this._def.effect || null;
				const checkCtx = {
					addIssue: (arg) => {
						(0, parseUtil_1.addIssueToContext)(ctx, arg);
						if (arg.fatal) {
							status.abort();
						} else {
							status.dirty();
						}
					},
					get path() {
						return ctx.path;
					},
				};
				checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
				if (effect.type === "preprocess") {
					const processed = effect.transform(ctx.data, checkCtx);
					if (ctx.common.async) {
						return Promise.resolve(processed).then(async (processed2) => {
							if (status.value === "aborted") return parseUtil_1.INVALID;
							const result = await this._def.schema._parseAsync({
								data: processed2,
								path: ctx.path,
								parent: ctx,
							});
							if (result.status === "aborted") return parseUtil_1.INVALID;
							if (result.status === "dirty")
								return (0, parseUtil_1.DIRTY)(result.value);
							if (status.value === "dirty")
								return (0, parseUtil_1.DIRTY)(result.value);
							return result;
						});
					} else {
						if (status.value === "aborted") return parseUtil_1.INVALID;
						const result = this._def.schema._parseSync({
							data: processed,
							path: ctx.path,
							parent: ctx,
						});
						if (result.status === "aborted") return parseUtil_1.INVALID;
						if (result.status === "dirty") return (0, parseUtil_1.DIRTY)(result.value);
						if (status.value === "dirty") return (0, parseUtil_1.DIRTY)(result.value);
						return result;
					}
				}
				if (effect.type === "refinement") {
					const executeRefinement = (acc) => {
						const result = effect.refinement(acc, checkCtx);
						if (ctx.common.async) {
							return Promise.resolve(result);
						}
						if (result instanceof Promise) {
							throw new Error(
								"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.",
							);
						}
						return acc;
					};
					if (ctx.common.async === false) {
						const inner = this._def.schema._parseSync({
							data: ctx.data,
							path: ctx.path,
							parent: ctx,
						});
						if (inner.status === "aborted") return parseUtil_1.INVALID;
						if (inner.status === "dirty") status.dirty();
						executeRefinement(inner.value);
						return { status: status.value, value: inner.value };
					} else {
						return this._def.schema
							._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
							.then((inner) => {
								if (inner.status === "aborted") return parseUtil_1.INVALID;
								if (inner.status === "dirty") status.dirty();
								return executeRefinement(inner.value).then(() => {
									return { status: status.value, value: inner.value };
								});
							});
					}
				}
				if (effect.type === "transform") {
					if (ctx.common.async === false) {
						const base = this._def.schema._parseSync({
							data: ctx.data,
							path: ctx.path,
							parent: ctx,
						});
						if (!(0, parseUtil_1.isValid)(base)) return base;
						const result = effect.transform(base.value, checkCtx);
						if (result instanceof Promise) {
							throw new Error(
								`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`,
							);
						}
						return { status: status.value, value: result };
					} else {
						return this._def.schema
							._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
							.then((base) => {
								if (!(0, parseUtil_1.isValid)(base)) return base;
								return Promise.resolve(effect.transform(base.value, checkCtx)).then(
									(result) => ({ status: status.value, value: result }),
								);
							});
					}
				}
				util_1.util.assertNever(effect);
			}
		};
		exports2.ZodEffects = ZodEffects;
		exports2.ZodTransformer = ZodEffects;
		ZodEffects.create = (schema, effect, params) => {
			return new ZodEffects({
				schema,
				typeName: ZodFirstPartyTypeKind.ZodEffects,
				effect,
				...processCreateParams(params),
			});
		};
		ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
			return new ZodEffects({
				schema,
				effect: { type: "preprocess", transform: preprocess },
				typeName: ZodFirstPartyTypeKind.ZodEffects,
				...processCreateParams(params),
			});
		};
		var ZodOptional = class extends ZodType {
			_parse(input) {
				const parsedType = this._getType(input);
				if (parsedType === util_1.ZodParsedType.undefined) {
					return (0, parseUtil_1.OK)(void 0);
				}
				return this._def.innerType._parse(input);
			}
			unwrap() {
				return this._def.innerType;
			}
		};
		exports2.ZodOptional = ZodOptional;
		ZodOptional.create = (type, params) => {
			return new ZodOptional({
				innerType: type,
				typeName: ZodFirstPartyTypeKind.ZodOptional,
				...processCreateParams(params),
			});
		};
		var ZodNullable = class extends ZodType {
			_parse(input) {
				const parsedType = this._getType(input);
				if (parsedType === util_1.ZodParsedType.null) {
					return (0, parseUtil_1.OK)(null);
				}
				return this._def.innerType._parse(input);
			}
			unwrap() {
				return this._def.innerType;
			}
		};
		exports2.ZodNullable = ZodNullable;
		ZodNullable.create = (type, params) => {
			return new ZodNullable({
				innerType: type,
				typeName: ZodFirstPartyTypeKind.ZodNullable,
				...processCreateParams(params),
			});
		};
		var ZodDefault = class extends ZodType {
			_parse(input) {
				const { ctx } = this._processInputParams(input);
				let data = ctx.data;
				if (ctx.parsedType === util_1.ZodParsedType.undefined) {
					data = this._def.defaultValue();
				}
				return this._def.innerType._parse({
					data,
					path: ctx.path,
					parent: ctx,
				});
			}
			removeDefault() {
				return this._def.innerType;
			}
		};
		exports2.ZodDefault = ZodDefault;
		ZodDefault.create = (type, params) => {
			return new ZodDefault({
				innerType: type,
				typeName: ZodFirstPartyTypeKind.ZodDefault,
				defaultValue:
					typeof params.default === "function" ? params.default : () => params.default,
				...processCreateParams(params),
			});
		};
		var ZodCatch = class extends ZodType {
			_parse(input) {
				const { ctx } = this._processInputParams(input);
				const newCtx = {
					...ctx,
					common: {
						...ctx.common,
						issues: [],
					},
				};
				const result = this._def.innerType._parse({
					data: newCtx.data,
					path: newCtx.path,
					parent: {
						...newCtx,
					},
				});
				if ((0, parseUtil_1.isAsync)(result)) {
					return result.then((result2) => {
						return {
							status: "valid",
							value:
								result2.status === "valid"
									? result2.value
									: this._def.catchValue({
											get error() {
												return new ZodError_1.ZodError(
													newCtx.common.issues,
												);
											},
											input: newCtx.data,
										}),
						};
					});
				} else {
					return {
						status: "valid",
						value:
							result.status === "valid"
								? result.value
								: this._def.catchValue({
										get error() {
											return new ZodError_1.ZodError(newCtx.common.issues);
										},
										input: newCtx.data,
									}),
					};
				}
			}
			removeCatch() {
				return this._def.innerType;
			}
		};
		exports2.ZodCatch = ZodCatch;
		ZodCatch.create = (type, params) => {
			return new ZodCatch({
				innerType: type,
				typeName: ZodFirstPartyTypeKind.ZodCatch,
				catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
				...processCreateParams(params),
			});
		};
		var ZodNaN = class extends ZodType {
			_parse(input) {
				const parsedType = this._getType(input);
				if (parsedType !== util_1.ZodParsedType.nan) {
					const ctx = this._getOrReturnCtx(input);
					(0, parseUtil_1.addIssueToContext)(ctx, {
						code: ZodError_1.ZodIssueCode.invalid_type,
						expected: util_1.ZodParsedType.nan,
						received: ctx.parsedType,
					});
					return parseUtil_1.INVALID;
				}
				return { status: "valid", value: input.data };
			}
		};
		exports2.ZodNaN = ZodNaN;
		ZodNaN.create = (params) => {
			return new ZodNaN({
				typeName: ZodFirstPartyTypeKind.ZodNaN,
				...processCreateParams(params),
			});
		};
		exports2.BRAND = Symbol("zod_brand");
		var ZodBranded = class extends ZodType {
			_parse(input) {
				const { ctx } = this._processInputParams(input);
				const data = ctx.data;
				return this._def.type._parse({
					data,
					path: ctx.path,
					parent: ctx,
				});
			}
			unwrap() {
				return this._def.type;
			}
		};
		exports2.ZodBranded = ZodBranded;
		var ZodPipeline = class _ZodPipeline extends ZodType {
			_parse(input) {
				const { status, ctx } = this._processInputParams(input);
				if (ctx.common.async) {
					const handleAsync = async () => {
						const inResult = await this._def.in._parseAsync({
							data: ctx.data,
							path: ctx.path,
							parent: ctx,
						});
						if (inResult.status === "aborted") return parseUtil_1.INVALID;
						if (inResult.status === "dirty") {
							status.dirty();
							return (0, parseUtil_1.DIRTY)(inResult.value);
						} else {
							return this._def.out._parseAsync({
								data: inResult.value,
								path: ctx.path,
								parent: ctx,
							});
						}
					};
					return handleAsync();
				} else {
					const inResult = this._def.in._parseSync({
						data: ctx.data,
						path: ctx.path,
						parent: ctx,
					});
					if (inResult.status === "aborted") return parseUtil_1.INVALID;
					if (inResult.status === "dirty") {
						status.dirty();
						return {
							status: "dirty",
							value: inResult.value,
						};
					} else {
						return this._def.out._parseSync({
							data: inResult.value,
							path: ctx.path,
							parent: ctx,
						});
					}
				}
			}
			static create(a, b) {
				return new _ZodPipeline({
					in: a,
					out: b,
					typeName: ZodFirstPartyTypeKind.ZodPipeline,
				});
			}
		};
		exports2.ZodPipeline = ZodPipeline;
		var ZodReadonly = class extends ZodType {
			_parse(input) {
				const result = this._def.innerType._parse(input);
				const freeze = (data) => {
					if ((0, parseUtil_1.isValid)(data)) {
						data.value = Object.freeze(data.value);
					}
					return data;
				};
				return (0, parseUtil_1.isAsync)(result)
					? result.then((data) => freeze(data))
					: freeze(result);
			}
			unwrap() {
				return this._def.innerType;
			}
		};
		exports2.ZodReadonly = ZodReadonly;
		ZodReadonly.create = (type, params) => {
			return new ZodReadonly({
				innerType: type,
				typeName: ZodFirstPartyTypeKind.ZodReadonly,
				...processCreateParams(params),
			});
		};
		function custom(check, params = {}, fatal) {
			if (check)
				return ZodAny.create().superRefine((data, ctx) => {
					var _a, _b;
					if (!check(data)) {
						const p =
							typeof params === "function"
								? params(data)
								: typeof params === "string"
									? { message: params }
									: params;
						const _fatal =
							(_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null &&
							_b !== void 0
								? _b
								: true;
						const p2 = typeof p === "string" ? { message: p } : p;
						ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
					}
				});
			return ZodAny.create();
		}
		exports2.custom = custom;
		exports2.late = {
			object: ZodObject.lazycreate,
		};
		var ZodFirstPartyTypeKind;
		(function (ZodFirstPartyTypeKind2) {
			ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
			ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
			ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
			ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
			ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
			ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
			ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
			ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
			ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
			ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
			ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
			ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
			ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
			ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
			ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
			ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
			ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
			ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
			ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
			ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
			ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
			ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
			ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
			ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
			ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
			ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
			ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
			ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
			ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
			ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
			ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
			ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
			ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
			ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
			ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
			ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
		})(
			(ZodFirstPartyTypeKind =
				exports2.ZodFirstPartyTypeKind || (exports2.ZodFirstPartyTypeKind = {})),
		);
		var instanceOfType = (
			cls,
			params = {
				message: `Input not instance of ${cls.name}`,
			},
		) => custom((data) => data instanceof cls, params);
		exports2.instanceof = instanceOfType;
		var stringType = ZodString.create;
		exports2.string = stringType;
		var numberType = ZodNumber.create;
		exports2.number = numberType;
		var nanType = ZodNaN.create;
		exports2.nan = nanType;
		var bigIntType = ZodBigInt.create;
		exports2.bigint = bigIntType;
		var booleanType = ZodBoolean.create;
		exports2.boolean = booleanType;
		var dateType = ZodDate.create;
		exports2.date = dateType;
		var symbolType = ZodSymbol.create;
		exports2.symbol = symbolType;
		var undefinedType = ZodUndefined.create;
		exports2.undefined = undefinedType;
		var nullType = ZodNull.create;
		exports2.null = nullType;
		var anyType = ZodAny.create;
		exports2.any = anyType;
		var unknownType = ZodUnknown.create;
		exports2.unknown = unknownType;
		var neverType = ZodNever.create;
		exports2.never = neverType;
		var voidType = ZodVoid.create;
		exports2.void = voidType;
		var arrayType = ZodArray.create;
		exports2.array = arrayType;
		var objectType = ZodObject.create;
		exports2.object = objectType;
		var strictObjectType = ZodObject.strictCreate;
		exports2.strictObject = strictObjectType;
		var unionType = ZodUnion.create;
		exports2.union = unionType;
		var discriminatedUnionType = ZodDiscriminatedUnion.create;
		exports2.discriminatedUnion = discriminatedUnionType;
		var intersectionType = ZodIntersection.create;
		exports2.intersection = intersectionType;
		var tupleType = ZodTuple.create;
		exports2.tuple = tupleType;
		var recordType = ZodRecord.create;
		exports2.record = recordType;
		var mapType = ZodMap.create;
		exports2.map = mapType;
		var setType = ZodSet.create;
		exports2.set = setType;
		var functionType = ZodFunction.create;
		exports2.function = functionType;
		var lazyType = ZodLazy.create;
		exports2.lazy = lazyType;
		var literalType = ZodLiteral.create;
		exports2.literal = literalType;
		var enumType = ZodEnum.create;
		exports2.enum = enumType;
		var nativeEnumType = ZodNativeEnum.create;
		exports2.nativeEnum = nativeEnumType;
		var promiseType = ZodPromise.create;
		exports2.promise = promiseType;
		var effectsType = ZodEffects.create;
		exports2.effect = effectsType;
		exports2.transformer = effectsType;
		var optionalType = ZodOptional.create;
		exports2.optional = optionalType;
		var nullableType = ZodNullable.create;
		exports2.nullable = nullableType;
		var preprocessType = ZodEffects.createWithPreprocess;
		exports2.preprocess = preprocessType;
		var pipelineType = ZodPipeline.create;
		exports2.pipeline = pipelineType;
		var ostring = () => stringType().optional();
		exports2.ostring = ostring;
		var onumber = () => numberType().optional();
		exports2.onumber = onumber;
		var oboolean = () => booleanType().optional();
		exports2.oboolean = oboolean;
		exports2.coerce = {
			string: (arg) => ZodString.create({ ...arg, coerce: true }),
			number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
			boolean: (arg) =>
				ZodBoolean.create({
					...arg,
					coerce: true,
				}),
			bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
			date: (arg) => ZodDate.create({ ...arg, coerce: true }),
		};
		exports2.NEVER = parseUtil_1.INVALID;
	},
});

// node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/external.js
var require_external = __commonJS({
	"node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/external.js"(exports2) {
		"use strict";
		var __createBinding2 =
			(exports2 && exports2.__createBinding) ||
			(Object.create
				? function (o, m, k, k2) {
						if (k2 === void 0) k2 = k;
						Object.defineProperty(o, k2, {
							enumerable: true,
							get: function () {
								return m[k];
							},
						});
					}
				: function (o, m, k, k2) {
						if (k2 === void 0) k2 = k;
						o[k2] = m[k];
					});
		var __exportStar2 =
			(exports2 && exports2.__exportStar) ||
			function (m, exports3) {
				for (var p in m)
					if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
						__createBinding2(exports3, m, p);
			};
		Object.defineProperty(exports2, "__esModule", { value: true });
		__exportStar2(require_errors3(), exports2);
		__exportStar2(require_parseUtil(), exports2);
		__exportStar2(require_typeAliases(), exports2);
		__exportStar2(require_util9(), exports2);
		__exportStar2(require_types2(), exports2);
		__exportStar2(require_ZodError(), exports2);
	},
});

// node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/index.js
var require_lib = __commonJS({
	"node_modules/.pnpm/zod@3.23.8/node_modules/zod/lib/index.js"(exports2) {
		"use strict";
		var __createBinding2 =
			(exports2 && exports2.__createBinding) ||
			(Object.create
				? function (o, m, k, k2) {
						if (k2 === void 0) k2 = k;
						Object.defineProperty(o, k2, {
							enumerable: true,
							get: function () {
								return m[k];
							},
						});
					}
				: function (o, m, k, k2) {
						if (k2 === void 0) k2 = k;
						o[k2] = m[k];
					});
		var __setModuleDefault2 =
			(exports2 && exports2.__setModuleDefault) ||
			(Object.create
				? function (o, v) {
						Object.defineProperty(o, "default", { enumerable: true, value: v });
					}
				: function (o, v) {
						o["default"] = v;
					});
		var __importStar2 =
			(exports2 && exports2.__importStar) ||
			function (mod) {
				if (mod && mod.__esModule) return mod;
				var result = {};
				if (mod != null) {
					for (var k in mod)
						if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
							__createBinding2(result, mod, k);
				}
				__setModuleDefault2(result, mod);
				return result;
			};
		var __exportStar2 =
			(exports2 && exports2.__exportStar) ||
			function (m, exports3) {
				for (var p in m)
					if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
						__createBinding2(exports3, m, p);
			};
		Object.defineProperty(exports2, "__esModule", { value: true });
		exports2.z = void 0;
		var z = __importStar2(require_external());
		exports2.z = z;
		__exportStar2(require_external(), exports2);
		exports2.default = z;
	},
});

// node_modules/.pnpm/glob-to-regexp@0.4.1/node_modules/glob-to-regexp/index.js
var require_glob_to_regexp = __commonJS({
	"node_modules/.pnpm/glob-to-regexp@0.4.1/node_modules/glob-to-regexp/index.js"(
		exports2,
		module2,
	) {
		"use strict";
		module2.exports = function (glob, opts) {
			if (typeof glob !== "string") {
				throw new TypeError("Expected a string");
			}
			var str = String(glob);
			var reStr = "";
			var extended = opts ? !!opts.extended : false;
			var globstar = opts ? !!opts.globstar : false;
			var inGroup = false;
			var flags = opts && typeof opts.flags === "string" ? opts.flags : "";
			var c;
			for (var i = 0, len = str.length; i < len; i++) {
				c = str[i];
				switch (c) {
					case "/":
					case "$":
					case "^":
					case "+":
					case ".":
					case "(":
					case ")":
					case "=":
					case "!":
					case "|":
						reStr += "\\" + c;
						break;
					case "?":
						if (extended) {
							reStr += ".";
							break;
						}
					case "[":
					case "]":
						if (extended) {
							reStr += c;
							break;
						}
					case "{":
						if (extended) {
							inGroup = true;
							reStr += "(";
							break;
						}
					case "}":
						if (extended) {
							inGroup = false;
							reStr += ")";
							break;
						}
					case ",":
						if (inGroup) {
							reStr += "|";
							break;
						}
						reStr += "\\" + c;
						break;
					case "*":
						var prevChar = str[i - 1];
						var starCount = 1;
						while (str[i + 1] === "*") {
							starCount++;
							i++;
						}
						var nextChar = str[i + 1];
						if (!globstar) {
							reStr += ".*";
						} else {
							var isGlobstar =
								starCount > 1 &&
								(prevChar === "/" || prevChar === void 0) &&
								(nextChar === "/" || nextChar === void 0);
							if (isGlobstar) {
								reStr += "((?:[^/]*(?:/|$))*)";
								i++;
							} else {
								reStr += "([^/]*)";
							}
						}
						break;
					default:
						reStr += c;
				}
			}
			if (!flags || !~flags.indexOf("g")) {
				reStr = "^" + reStr + "$";
			}
			return new RegExp(reStr, flags);
		};
	},
});

// node_modules/.pnpm/acorn@8.14.0/node_modules/acorn/dist/acorn.js
var require_acorn = __commonJS({
	"node_modules/.pnpm/acorn@8.14.0/node_modules/acorn/dist/acorn.js"(exports2, module2) {
		"use strict";
		(function (global2, factory) {
			typeof exports2 === "object" && typeof module2 !== "undefined"
				? factory(exports2)
				: typeof define === "function" && define.amd
					? define(["exports"], factory)
					: ((global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self),
						factory((global2.acorn = {})));
		})(exports2, function (exports3) {
			"use strict";
			var astralIdentifierCodes = [
				509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9,
				9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3,
				46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11,
				83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3,
				6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19,
				13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243,
				14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6,
				2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0,
				2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4,
				14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470,
				0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7,
				3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6,
				2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2,
				9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239,
			];
			var astralIdentifierStartCodes = [
				0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31,
				14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13,
				10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25,
				5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1,
				11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2,
				27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22,
				251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1,
				3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0,
				36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2,
				6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45,
				52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0,
				72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7,
				3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32,
				8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328,
				18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18,
				5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32,
				20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237,
				42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6,
				12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64,
				2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24,
				2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44,
				11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2,
				196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0,
				5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3,
				2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7,
				221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191,
			];
			var nonASCIIidentifierChars =
				"\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
			var nonASCIIidentifierStartChars =
				"\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
			var reservedWords = {
				3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
				5: "class enum extends super const export import",
				6: "enum",
				strict: "implements interface let package private protected public static yield",
				strictBind: "eval arguments",
			};
			var ecma5AndLessKeywords =
				"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
			var keywords$1 = {
				5: ecma5AndLessKeywords,
				"5module": ecma5AndLessKeywords + " export import",
				6: ecma5AndLessKeywords + " const class extends export import super",
			};
			var keywordRelationalOperator = /^in(stanceof)?$/;
			var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
			var nonASCIIidentifier = new RegExp(
				"[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]",
			);
			function isInAstralSet(code, set) {
				var pos = 65536;
				for (var i2 = 0; i2 < set.length; i2 += 2) {
					pos += set[i2];
					if (pos > code) {
						return false;
					}
					pos += set[i2 + 1];
					if (pos >= code) {
						return true;
					}
				}
				return false;
			}
			function isIdentifierStart(code, astral) {
				if (code < 65) {
					return code === 36;
				}
				if (code < 91) {
					return true;
				}
				if (code < 97) {
					return code === 95;
				}
				if (code < 123) {
					return true;
				}
				if (code <= 65535) {
					return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
				}
				if (astral === false) {
					return false;
				}
				return isInAstralSet(code, astralIdentifierStartCodes);
			}
			function isIdentifierChar(code, astral) {
				if (code < 48) {
					return code === 36;
				}
				if (code < 58) {
					return true;
				}
				if (code < 65) {
					return false;
				}
				if (code < 91) {
					return true;
				}
				if (code < 97) {
					return code === 95;
				}
				if (code < 123) {
					return true;
				}
				if (code <= 65535) {
					return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
				}
				if (astral === false) {
					return false;
				}
				return (
					isInAstralSet(code, astralIdentifierStartCodes) ||
					isInAstralSet(code, astralIdentifierCodes)
				);
			}
			var TokenType = function TokenType2(label, conf) {
				if (conf === void 0) conf = {};
				this.label = label;
				this.keyword = conf.keyword;
				this.beforeExpr = !!conf.beforeExpr;
				this.startsExpr = !!conf.startsExpr;
				this.isLoop = !!conf.isLoop;
				this.isAssign = !!conf.isAssign;
				this.prefix = !!conf.prefix;
				this.postfix = !!conf.postfix;
				this.binop = conf.binop || null;
				this.updateContext = null;
			};
			function binop(name, prec) {
				return new TokenType(name, { beforeExpr: true, binop: prec });
			}
			var beforeExpr = { beforeExpr: true },
				startsExpr = { startsExpr: true };
			var keywords = {};
			function kw(name, options) {
				if (options === void 0) options = {};
				options.keyword = name;
				return (keywords[name] = new TokenType(name, options));
			}
			var types$1 = {
				num: new TokenType("num", startsExpr),
				regexp: new TokenType("regexp", startsExpr),
				string: new TokenType("string", startsExpr),
				name: new TokenType("name", startsExpr),
				privateId: new TokenType("privateId", startsExpr),
				eof: new TokenType("eof"),
				// Punctuation token types.
				bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
				bracketR: new TokenType("]"),
				braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
				braceR: new TokenType("}"),
				parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
				parenR: new TokenType(")"),
				comma: new TokenType(",", beforeExpr),
				semi: new TokenType(";", beforeExpr),
				colon: new TokenType(":", beforeExpr),
				dot: new TokenType("."),
				question: new TokenType("?", beforeExpr),
				questionDot: new TokenType("?."),
				arrow: new TokenType("=>", beforeExpr),
				template: new TokenType("template"),
				invalidTemplate: new TokenType("invalidTemplate"),
				ellipsis: new TokenType("...", beforeExpr),
				backQuote: new TokenType("`", startsExpr),
				dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
				// Operators. These carry several kinds of properties to help the
				// parser use them properly (the presence of these properties is
				// what categorizes them as operators).
				//
				// `binop`, when present, specifies that this operator is a binary
				// operator, and will refer to its precedence.
				//
				// `prefix` and `postfix` mark the operator as a prefix or postfix
				// unary operator.
				//
				// `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
				// binary operators with a very low precedence, that should result
				// in AssignmentExpression nodes.
				eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
				assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
				incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
				prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
				logicalOR: binop("||", 1),
				logicalAND: binop("&&", 2),
				bitwiseOR: binop("|", 3),
				bitwiseXOR: binop("^", 4),
				bitwiseAND: binop("&", 5),
				equality: binop("==/!=/===/!==", 6),
				relational: binop("</>/<=/>=", 7),
				bitShift: binop("<</>>/>>>", 8),
				plusMin: new TokenType("+/-", {
					beforeExpr: true,
					binop: 9,
					prefix: true,
					startsExpr: true,
				}),
				modulo: binop("%", 10),
				star: binop("*", 10),
				slash: binop("/", 10),
				starstar: new TokenType("**", { beforeExpr: true }),
				coalesce: binop("??", 1),
				// Keyword token types.
				_break: kw("break"),
				_case: kw("case", beforeExpr),
				_catch: kw("catch"),
				_continue: kw("continue"),
				_debugger: kw("debugger"),
				_default: kw("default", beforeExpr),
				_do: kw("do", { isLoop: true, beforeExpr: true }),
				_else: kw("else", beforeExpr),
				_finally: kw("finally"),
				_for: kw("for", { isLoop: true }),
				_function: kw("function", startsExpr),
				_if: kw("if"),
				_return: kw("return", beforeExpr),
				_switch: kw("switch"),
				_throw: kw("throw", beforeExpr),
				_try: kw("try"),
				_var: kw("var"),
				_const: kw("const"),
				_while: kw("while", { isLoop: true }),
				_with: kw("with"),
				_new: kw("new", { beforeExpr: true, startsExpr: true }),
				_this: kw("this", startsExpr),
				_super: kw("super", startsExpr),
				_class: kw("class", startsExpr),
				_extends: kw("extends", beforeExpr),
				_export: kw("export"),
				_import: kw("import", startsExpr),
				_null: kw("null", startsExpr),
				_true: kw("true", startsExpr),
				_false: kw("false", startsExpr),
				_in: kw("in", { beforeExpr: true, binop: 7 }),
				_instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
				_typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
				_void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
				_delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true }),
			};
			var lineBreak = /\r\n?|\n|\u2028|\u2029/;
			var lineBreakG = new RegExp(lineBreak.source, "g");
			function isNewLine(code) {
				return code === 10 || code === 13 || code === 8232 || code === 8233;
			}
			function nextLineBreak(code, from, end) {
				if (end === void 0) end = code.length;
				for (var i2 = from; i2 < end; i2++) {
					var next = code.charCodeAt(i2);
					if (isNewLine(next)) {
						return i2 < end - 1 && next === 13 && code.charCodeAt(i2 + 1) === 10
							? i2 + 2
							: i2 + 1;
					}
				}
				return -1;
			}
			var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
			var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
			var ref = Object.prototype;
			var hasOwnProperty = ref.hasOwnProperty;
			var toString = ref.toString;
			var hasOwn =
				Object.hasOwn ||
				function (obj, propName) {
					return hasOwnProperty.call(obj, propName);
				};
			var isArray =
				Array.isArray ||
				function (obj) {
					return toString.call(obj) === "[object Array]";
				};
			var regexpCache = /* @__PURE__ */ Object.create(null);
			function wordsRegexp(words) {
				return (
					regexpCache[words] ||
					(regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"))
				);
			}
			function codePointToString(code) {
				if (code <= 65535) {
					return String.fromCharCode(code);
				}
				code -= 65536;
				return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
			}
			var loneSurrogate =
				/(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
			var Position = function Position2(line, col) {
				this.line = line;
				this.column = col;
			};
			Position.prototype.offset = function offset(n) {
				return new Position(this.line, this.column + n);
			};
			var SourceLocation = function SourceLocation2(p, start, end) {
				this.start = start;
				this.end = end;
				if (p.sourceFile !== null) {
					this.source = p.sourceFile;
				}
			};
			function getLineInfo(input, offset) {
				for (var line = 1, cur = 0; ; ) {
					var nextBreak = nextLineBreak(input, cur, offset);
					if (nextBreak < 0) {
						return new Position(line, offset - cur);
					}
					++line;
					cur = nextBreak;
				}
			}
			var defaultOptions = {
				// `ecmaVersion` indicates the ECMAScript version to parse. Must be
				// either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
				// (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
				// (the latest version the library supports). This influences
				// support for strict mode, the set of reserved words, and support
				// for new syntax features.
				ecmaVersion: null,
				// `sourceType` indicates the mode the code should be parsed in.
				// Can be either `"script"` or `"module"`. This influences global
				// strict mode and parsing of `import` and `export` declarations.
				sourceType: "script",
				// `onInsertedSemicolon` can be a callback that will be called when
				// a semicolon is automatically inserted. It will be passed the
				// position of the inserted semicolon as an offset, and if
				// `locations` is enabled, it is given the location as a `{line,
				// column}` object as second argument.
				onInsertedSemicolon: null,
				// `onTrailingComma` is similar to `onInsertedSemicolon`, but for
				// trailing commas.
				onTrailingComma: null,
				// By default, reserved words are only enforced if ecmaVersion >= 5.
				// Set `allowReserved` to a boolean value to explicitly turn this on
				// an off. When this option has the value "never", reserved words
				// and keywords can also not be used as property names.
				allowReserved: null,
				// When enabled, a return at the top level is not considered an
				// error.
				allowReturnOutsideFunction: false,
				// When enabled, import/export statements are not constrained to
				// appearing at the top of the program, and an import.meta expression
				// in a script isn't considered an error.
				allowImportExportEverywhere: false,
				// By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
				// When enabled, await identifiers are allowed to appear at the top-level scope,
				// but they are still not allowed in non-async functions.
				allowAwaitOutsideFunction: null,
				// When enabled, super identifiers are not constrained to
				// appearing in methods and do not raise an error when they appear elsewhere.
				allowSuperOutsideMethod: null,
				// When enabled, hashbang directive in the beginning of file is
				// allowed and treated as a line comment. Enabled by default when
				// `ecmaVersion` >= 2023.
				allowHashBang: false,
				// By default, the parser will verify that private properties are
				// only used in places where they are valid and have been declared.
				// Set this to false to turn such checks off.
				checkPrivateFields: true,
				// When `locations` is on, `loc` properties holding objects with
				// `start` and `end` properties in `{line, column}` form (with
				// line being 1-based and column 0-based) will be attached to the
				// nodes.
				locations: false,
				// A function can be passed as `onToken` option, which will
				// cause Acorn to call that function with object in the same
				// format as tokens returned from `tokenizer().getToken()`. Note
				// that you are not allowed to call the parser from the
				// callbackthat will corrupt its internal state.
				onToken: null,
				// A function can be passed as `onComment` option, which will
				// cause Acorn to call that function with `(block, text, start,
				// end)` parameters whenever a comment is skipped. `block` is a
				// boolean indicating whether this is a block (`/* */`) comment,
				// `text` is the content of the comment, and `start` and `end` are
				// character offsets that denote the start and end of the comment.
				// When the `locations` option is on, two more parameters are
				// passed, the full `{line, column}` locations of the start and
				// end of the comments. Note that you are not allowed to call the
				// parser from the callbackthat will corrupt its internal state.
				// When this option has an array as value, objects representing the
				// comments are pushed to it.
				onComment: null,
				// Nodes have their start and end characters offsets recorded in
				// `start` and `end` properties (directly on the node, rather than
				// the `loc` object, which holds line/column data. To also add a
				// [semi-standardized][range] `range` property holding a `[start,
				// end]` array with the same numbers, set the `ranges` option to
				// `true`.
				//
				// [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
				ranges: false,
				// It is possible to parse multiple files into a single AST by
				// passing the tree produced by parsing the first file as
				// `program` option in subsequent parses. This will add the
				// toplevel forms of the parsed file to the `Program` (top) node
				// of an existing parse tree.
				program: null,
				// When `locations` is on, you can pass this to record the source
				// file in every node's `loc` object.
				sourceFile: null,
				// This value, if given, is stored in every node, whether
				// `locations` is on or off.
				directSourceFile: null,
				// When enabled, parenthesized expressions are represented by
				// (non-standard) ParenthesizedExpression nodes
				preserveParens: false,
			};
			var warnedAboutEcmaVersion = false;
			function getOptions(opts) {
				var options = {};
				for (var opt in defaultOptions) {
					options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
				}
				if (options.ecmaVersion === "latest") {
					options.ecmaVersion = 1e8;
				} else if (options.ecmaVersion == null) {
					if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
						warnedAboutEcmaVersion = true;
						console.warn(
							"Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.",
						);
					}
					options.ecmaVersion = 11;
				} else if (options.ecmaVersion >= 2015) {
					options.ecmaVersion -= 2009;
				}
				if (options.allowReserved == null) {
					options.allowReserved = options.ecmaVersion < 5;
				}
				if (!opts || opts.allowHashBang == null) {
					options.allowHashBang = options.ecmaVersion >= 14;
				}
				if (isArray(options.onToken)) {
					var tokens = options.onToken;
					options.onToken = function (token) {
						return tokens.push(token);
					};
				}
				if (isArray(options.onComment)) {
					options.onComment = pushComment(options, options.onComment);
				}
				return options;
			}
			function pushComment(options, array) {
				return function (block, text, start, end, startLoc, endLoc) {
					var comment = {
						type: block ? "Block" : "Line",
						value: text,
						start,
						end,
					};
					if (options.locations) {
						comment.loc = new SourceLocation(this, startLoc, endLoc);
					}
					if (options.ranges) {
						comment.range = [start, end];
					}
					array.push(comment);
				};
			}
			var SCOPE_TOP = 1,
				SCOPE_FUNCTION = 2,
				SCOPE_ASYNC = 4,
				SCOPE_GENERATOR = 8,
				SCOPE_ARROW = 16,
				SCOPE_SIMPLE_CATCH = 32,
				SCOPE_SUPER = 64,
				SCOPE_DIRECT_SUPER = 128,
				SCOPE_CLASS_STATIC_BLOCK = 256,
				SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
			function functionFlags(async, generator) {
				return (
					SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
				);
			}
			var BIND_NONE = 0,
				BIND_VAR = 1,
				BIND_LEXICAL = 2,
				BIND_FUNCTION = 3,
				BIND_SIMPLE_CATCH = 4,
				BIND_OUTSIDE = 5;
			var Parser = function Parser2(options, input, startPos) {
				this.options = options = getOptions(options);
				this.sourceFile = options.sourceFile;
				this.keywords = wordsRegexp(
					keywords$1[
						options.ecmaVersion >= 6
							? 6
							: options.sourceType === "module"
								? "5module"
								: 5
					],
				);
				var reserved = "";
				if (options.allowReserved !== true) {
					reserved =
						reservedWords[
							options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3
						];
					if (options.sourceType === "module") {
						reserved += " await";
					}
				}
				this.reservedWords = wordsRegexp(reserved);
				var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
				this.reservedWordsStrict = wordsRegexp(reservedStrict);
				this.reservedWordsStrictBind = wordsRegexp(
					reservedStrict + " " + reservedWords.strictBind,
				);
				this.input = String(input);
				this.containsEsc = false;
				if (startPos) {
					this.pos = startPos;
					this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
					this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
				} else {
					this.pos = this.lineStart = 0;
					this.curLine = 1;
				}
				this.type = types$1.eof;
				this.value = null;
				this.start = this.end = this.pos;
				this.startLoc = this.endLoc = this.curPosition();
				this.lastTokEndLoc = this.lastTokStartLoc = null;
				this.lastTokStart = this.lastTokEnd = this.pos;
				this.context = this.initialContext();
				this.exprAllowed = true;
				this.inModule = options.sourceType === "module";
				this.strict = this.inModule || this.strictDirective(this.pos);
				this.potentialArrowAt = -1;
				this.potentialArrowInForAwait = false;
				this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
				this.labels = [];
				this.undefinedExports = /* @__PURE__ */ Object.create(null);
				if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
					this.skipLineComment(2);
				}
				this.scopeStack = [];
				this.enterScope(SCOPE_TOP);
				this.regexpState = null;
				this.privateNameStack = [];
			};
			var prototypeAccessors = {
				inFunction: { configurable: true },
				inGenerator: { configurable: true },
				inAsync: { configurable: true },
				canAwait: { configurable: true },
				allowSuper: { configurable: true },
				allowDirectSuper: { configurable: true },
				treatFunctionsAsVar: { configurable: true },
				allowNewDotTarget: { configurable: true },
				inClassStaticBlock: { configurable: true },
			};
			Parser.prototype.parse = function parse2() {
				var node = this.options.program || this.startNode();
				this.nextToken();
				return this.parseTopLevel(node);
			};
			prototypeAccessors.inFunction.get = function () {
				return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
			};
			prototypeAccessors.inGenerator.get = function () {
				return (
					(this.currentVarScope().flags & SCOPE_GENERATOR) > 0 &&
					!this.currentVarScope().inClassFieldInit
				);
			};
			prototypeAccessors.inAsync.get = function () {
				return (
					(this.currentVarScope().flags & SCOPE_ASYNC) > 0 &&
					!this.currentVarScope().inClassFieldInit
				);
			};
			prototypeAccessors.canAwait.get = function () {
				for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
					var scope = this.scopeStack[i2];
					if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
						return false;
					}
					if (scope.flags & SCOPE_FUNCTION) {
						return (scope.flags & SCOPE_ASYNC) > 0;
					}
				}
				return (
					(this.inModule && this.options.ecmaVersion >= 13) ||
					this.options.allowAwaitOutsideFunction
				);
			};
			prototypeAccessors.allowSuper.get = function () {
				var ref2 = this.currentThisScope();
				var flags = ref2.flags;
				var inClassFieldInit = ref2.inClassFieldInit;
				return (
					(flags & SCOPE_SUPER) > 0 ||
					inClassFieldInit ||
					this.options.allowSuperOutsideMethod
				);
			};
			prototypeAccessors.allowDirectSuper.get = function () {
				return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
			};
			prototypeAccessors.treatFunctionsAsVar.get = function () {
				return this.treatFunctionsAsVarInScope(this.currentScope());
			};
			prototypeAccessors.allowNewDotTarget.get = function () {
				var ref2 = this.currentThisScope();
				var flags = ref2.flags;
				var inClassFieldInit = ref2.inClassFieldInit;
				return (
					(flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit
				);
			};
			prototypeAccessors.inClassStaticBlock.get = function () {
				return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
			};
			Parser.extend = function extend() {
				var plugins = [],
					len = arguments.length;
				while (len--) plugins[len] = arguments[len];
				var cls = this;
				for (var i2 = 0; i2 < plugins.length; i2++) {
					cls = plugins[i2](cls);
				}
				return cls;
			};
			Parser.parse = function parse2(input, options) {
				return new this(options, input).parse();
			};
			Parser.parseExpressionAt = function parseExpressionAt2(input, pos, options) {
				var parser = new this(options, input, pos);
				parser.nextToken();
				return parser.parseExpression();
			};
			Parser.tokenizer = function tokenizer2(input, options) {
				return new this(options, input);
			};
			Object.defineProperties(Parser.prototype, prototypeAccessors);
			var pp$9 = Parser.prototype;
			var literal = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
			pp$9.strictDirective = function (start) {
				if (this.options.ecmaVersion < 5) {
					return false;
				}
				for (;;) {
					skipWhiteSpace.lastIndex = start;
					start += skipWhiteSpace.exec(this.input)[0].length;
					var match = literal.exec(this.input.slice(start));
					if (!match) {
						return false;
					}
					if ((match[1] || match[2]) === "use strict") {
						skipWhiteSpace.lastIndex = start + match[0].length;
						var spaceAfter = skipWhiteSpace.exec(this.input),
							end = spaceAfter.index + spaceAfter[0].length;
						var next = this.input.charAt(end);
						return (
							next === ";" ||
							next === "}" ||
							(lineBreak.test(spaceAfter[0]) &&
								!(
									/[(`.[+\-/*%<>=,?^&]/.test(next) ||
									(next === "!" && this.input.charAt(end + 1) === "=")
								))
						);
					}
					start += match[0].length;
					skipWhiteSpace.lastIndex = start;
					start += skipWhiteSpace.exec(this.input)[0].length;
					if (this.input[start] === ";") {
						start++;
					}
				}
			};
			pp$9.eat = function (type) {
				if (this.type === type) {
					this.next();
					return true;
				} else {
					return false;
				}
			};
			pp$9.isContextual = function (name) {
				return this.type === types$1.name && this.value === name && !this.containsEsc;
			};
			pp$9.eatContextual = function (name) {
				if (!this.isContextual(name)) {
					return false;
				}
				this.next();
				return true;
			};
			pp$9.expectContextual = function (name) {
				if (!this.eatContextual(name)) {
					this.unexpected();
				}
			};
			pp$9.canInsertSemicolon = function () {
				return (
					this.type === types$1.eof ||
					this.type === types$1.braceR ||
					lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
				);
			};
			pp$9.insertSemicolon = function () {
				if (this.canInsertSemicolon()) {
					if (this.options.onInsertedSemicolon) {
						this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
					}
					return true;
				}
			};
			pp$9.semicolon = function () {
				if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
					this.unexpected();
				}
			};
			pp$9.afterTrailingComma = function (tokType, notNext) {
				if (this.type === tokType) {
					if (this.options.onTrailingComma) {
						this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
					}
					if (!notNext) {
						this.next();
					}
					return true;
				}
			};
			pp$9.expect = function (type) {
				this.eat(type) || this.unexpected();
			};
			pp$9.unexpected = function (pos) {
				this.raise(pos != null ? pos : this.start, "Unexpected token");
			};
			var DestructuringErrors = function DestructuringErrors2() {
				this.shorthandAssign =
					this.trailingComma =
					this.parenthesizedAssign =
					this.parenthesizedBind =
					this.doubleProto =
						-1;
			};
			pp$9.checkPatternErrors = function (refDestructuringErrors, isAssign) {
				if (!refDestructuringErrors) {
					return;
				}
				if (refDestructuringErrors.trailingComma > -1) {
					this.raiseRecoverable(
						refDestructuringErrors.trailingComma,
						"Comma is not permitted after the rest element",
					);
				}
				var parens = isAssign
					? refDestructuringErrors.parenthesizedAssign
					: refDestructuringErrors.parenthesizedBind;
				if (parens > -1) {
					this.raiseRecoverable(
						parens,
						isAssign ? "Assigning to rvalue" : "Parenthesized pattern",
					);
				}
			};
			pp$9.checkExpressionErrors = function (refDestructuringErrors, andThrow) {
				if (!refDestructuringErrors) {
					return false;
				}
				var shorthandAssign = refDestructuringErrors.shorthandAssign;
				var doubleProto = refDestructuringErrors.doubleProto;
				if (!andThrow) {
					return shorthandAssign >= 0 || doubleProto >= 0;
				}
				if (shorthandAssign >= 0) {
					this.raise(
						shorthandAssign,
						"Shorthand property assignments are valid only in destructuring patterns",
					);
				}
				if (doubleProto >= 0) {
					this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
				}
			};
			pp$9.checkYieldAwaitInDefaultParams = function () {
				if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
					this.raise(this.yieldPos, "Yield expression cannot be a default value");
				}
				if (this.awaitPos) {
					this.raise(this.awaitPos, "Await expression cannot be a default value");
				}
			};
			pp$9.isSimpleAssignTarget = function (expr) {
				if (expr.type === "ParenthesizedExpression") {
					return this.isSimpleAssignTarget(expr.expression);
				}
				return expr.type === "Identifier" || expr.type === "MemberExpression";
			};
			var pp$8 = Parser.prototype;
			pp$8.parseTopLevel = function (node) {
				var exports4 = /* @__PURE__ */ Object.create(null);
				if (!node.body) {
					node.body = [];
				}
				while (this.type !== types$1.eof) {
					var stmt = this.parseStatement(null, true, exports4);
					node.body.push(stmt);
				}
				if (this.inModule) {
					for (
						var i2 = 0, list2 = Object.keys(this.undefinedExports);
						i2 < list2.length;
						i2 += 1
					) {
						var name = list2[i2];
						this.raiseRecoverable(
							this.undefinedExports[name].start,
							"Export '" + name + "' is not defined",
						);
					}
				}
				this.adaptDirectivePrologue(node.body);
				this.next();
				node.sourceType = this.options.sourceType;
				return this.finishNode(node, "Program");
			};
			var loopLabel = { kind: "loop" },
				switchLabel = { kind: "switch" };
			pp$8.isLet = function (context) {
				if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
					return false;
				}
				skipWhiteSpace.lastIndex = this.pos;
				var skip = skipWhiteSpace.exec(this.input);
				var next = this.pos + skip[0].length,
					nextCh = this.input.charCodeAt(next);
				if (nextCh === 91 || nextCh === 92) {
					return true;
				}
				if (context) {
					return false;
				}
				if (nextCh === 123 || (nextCh > 55295 && nextCh < 56320)) {
					return true;
				}
				if (isIdentifierStart(nextCh, true)) {
					var pos = next + 1;
					while (isIdentifierChar((nextCh = this.input.charCodeAt(pos)), true)) {
						++pos;
					}
					if (nextCh === 92 || (nextCh > 55295 && nextCh < 56320)) {
						return true;
					}
					var ident = this.input.slice(next, pos);
					if (!keywordRelationalOperator.test(ident)) {
						return true;
					}
				}
				return false;
			};
			pp$8.isAsyncFunction = function () {
				if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
					return false;
				}
				skipWhiteSpace.lastIndex = this.pos;
				var skip = skipWhiteSpace.exec(this.input);
				var next = this.pos + skip[0].length,
					after;
				return (
					!lineBreak.test(this.input.slice(this.pos, next)) &&
					this.input.slice(next, next + 8) === "function" &&
					(next + 8 === this.input.length ||
						!(
							isIdentifierChar((after = this.input.charCodeAt(next + 8))) ||
							(after > 55295 && after < 56320)
						))
				);
			};
			pp$8.parseStatement = function (context, topLevel, exports4) {
				var starttype = this.type,
					node = this.startNode(),
					kind;
				if (this.isLet(context)) {
					starttype = types$1._var;
					kind = "let";
				}
				switch (starttype) {
					case types$1._break:
					case types$1._continue:
						return this.parseBreakContinueStatement(node, starttype.keyword);
					case types$1._debugger:
						return this.parseDebuggerStatement(node);
					case types$1._do:
						return this.parseDoStatement(node);
					case types$1._for:
						return this.parseForStatement(node);
					case types$1._function:
						if (
							context &&
							(this.strict || (context !== "if" && context !== "label")) &&
							this.options.ecmaVersion >= 6
						) {
							this.unexpected();
						}
						return this.parseFunctionStatement(node, false, !context);
					case types$1._class:
						if (context) {
							this.unexpected();
						}
						return this.parseClass(node, true);
					case types$1._if:
						return this.parseIfStatement(node);
					case types$1._return:
						return this.parseReturnStatement(node);
					case types$1._switch:
						return this.parseSwitchStatement(node);
					case types$1._throw:
						return this.parseThrowStatement(node);
					case types$1._try:
						return this.parseTryStatement(node);
					case types$1._const:
					case types$1._var:
						kind = kind || this.value;
						if (context && kind !== "var") {
							this.unexpected();
						}
						return this.parseVarStatement(node, kind);
					case types$1._while:
						return this.parseWhileStatement(node);
					case types$1._with:
						return this.parseWithStatement(node);
					case types$1.braceL:
						return this.parseBlock(true, node);
					case types$1.semi:
						return this.parseEmptyStatement(node);
					case types$1._export:
					case types$1._import:
						if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
							skipWhiteSpace.lastIndex = this.pos;
							var skip = skipWhiteSpace.exec(this.input);
							var next = this.pos + skip[0].length,
								nextCh = this.input.charCodeAt(next);
							if (nextCh === 40 || nextCh === 46) {
								return this.parseExpressionStatement(node, this.parseExpression());
							}
						}
						if (!this.options.allowImportExportEverywhere) {
							if (!topLevel) {
								this.raise(
									this.start,
									"'import' and 'export' may only appear at the top level",
								);
							}
							if (!this.inModule) {
								this.raise(
									this.start,
									"'import' and 'export' may appear only with 'sourceType: module'",
								);
							}
						}
						return starttype === types$1._import
							? this.parseImport(node)
							: this.parseExport(node, exports4);
					// If the statement does not start with a statement keyword or a
					// brace, it's an ExpressionStatement or LabeledStatement. We
					// simply start parsing an expression, and afterwards, if the
					// next token is a colon and the expression was a simple
					// Identifier node, we switch to interpreting it as a label.
					default:
						if (this.isAsyncFunction()) {
							if (context) {
								this.unexpected();
							}
							this.next();
							return this.parseFunctionStatement(node, true, !context);
						}
						var maybeName = this.value,
							expr = this.parseExpression();
						if (
							starttype === types$1.name &&
							expr.type === "Identifier" &&
							this.eat(types$1.colon)
						) {
							return this.parseLabeledStatement(node, maybeName, expr, context);
						} else {
							return this.parseExpressionStatement(node, expr);
						}
				}
			};
			pp$8.parseBreakContinueStatement = function (node, keyword) {
				var isBreak = keyword === "break";
				this.next();
				if (this.eat(types$1.semi) || this.insertSemicolon()) {
					node.label = null;
				} else if (this.type !== types$1.name) {
					this.unexpected();
				} else {
					node.label = this.parseIdent();
					this.semicolon();
				}
				var i2 = 0;
				for (; i2 < this.labels.length; ++i2) {
					var lab = this.labels[i2];
					if (node.label == null || lab.name === node.label.name) {
						if (lab.kind != null && (isBreak || lab.kind === "loop")) {
							break;
						}
						if (node.label && isBreak) {
							break;
						}
					}
				}
				if (i2 === this.labels.length) {
					this.raise(node.start, "Unsyntactic " + keyword);
				}
				return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
			};
			pp$8.parseDebuggerStatement = function (node) {
				this.next();
				this.semicolon();
				return this.finishNode(node, "DebuggerStatement");
			};
			pp$8.parseDoStatement = function (node) {
				this.next();
				this.labels.push(loopLabel);
				node.body = this.parseStatement("do");
				this.labels.pop();
				this.expect(types$1._while);
				node.test = this.parseParenExpression();
				if (this.options.ecmaVersion >= 6) {
					this.eat(types$1.semi);
				} else {
					this.semicolon();
				}
				return this.finishNode(node, "DoWhileStatement");
			};
			pp$8.parseForStatement = function (node) {
				this.next();
				var awaitAt =
					this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await")
						? this.lastTokStart
						: -1;
				this.labels.push(loopLabel);
				this.enterScope(0);
				this.expect(types$1.parenL);
				if (this.type === types$1.semi) {
					if (awaitAt > -1) {
						this.unexpected(awaitAt);
					}
					return this.parseFor(node, null);
				}
				var isLet = this.isLet();
				if (this.type === types$1._var || this.type === types$1._const || isLet) {
					var init$1 = this.startNode(),
						kind = isLet ? "let" : this.value;
					this.next();
					this.parseVar(init$1, true, kind);
					this.finishNode(init$1, "VariableDeclaration");
					if (
						(this.type === types$1._in ||
							(this.options.ecmaVersion >= 6 && this.isContextual("of"))) &&
						init$1.declarations.length === 1
					) {
						if (this.options.ecmaVersion >= 9) {
							if (this.type === types$1._in) {
								if (awaitAt > -1) {
									this.unexpected(awaitAt);
								}
							} else {
								node.await = awaitAt > -1;
							}
						}
						return this.parseForIn(node, init$1);
					}
					if (awaitAt > -1) {
						this.unexpected(awaitAt);
					}
					return this.parseFor(node, init$1);
				}
				var startsWithLet = this.isContextual("let"),
					isForOf = false;
				var containsEsc = this.containsEsc;
				var refDestructuringErrors = new DestructuringErrors();
				var initPos = this.start;
				var init =
					awaitAt > -1
						? this.parseExprSubscripts(refDestructuringErrors, "await")
						: this.parseExpression(true, refDestructuringErrors);
				if (
					this.type === types$1._in ||
					(isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))
				) {
					if (awaitAt > -1) {
						if (this.type === types$1._in) {
							this.unexpected(awaitAt);
						}
						node.await = true;
					} else if (isForOf && this.options.ecmaVersion >= 8) {
						if (
							init.start === initPos &&
							!containsEsc &&
							init.type === "Identifier" &&
							init.name === "async"
						) {
							this.unexpected();
						} else if (this.options.ecmaVersion >= 9) {
							node.await = false;
						}
					}
					if (startsWithLet && isForOf) {
						this.raise(
							init.start,
							"The left-hand side of a for-of loop may not start with 'let'.",
						);
					}
					this.toAssignable(init, false, refDestructuringErrors);
					this.checkLValPattern(init);
					return this.parseForIn(node, init);
				} else {
					this.checkExpressionErrors(refDestructuringErrors, true);
				}
				if (awaitAt > -1) {
					this.unexpected(awaitAt);
				}
				return this.parseFor(node, init);
			};
			pp$8.parseFunctionStatement = function (node, isAsync, declarationPosition) {
				this.next();
				return this.parseFunction(
					node,
					FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT),
					false,
					isAsync,
				);
			};
			pp$8.parseIfStatement = function (node) {
				this.next();
				node.test = this.parseParenExpression();
				node.consequent = this.parseStatement("if");
				node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
				return this.finishNode(node, "IfStatement");
			};
			pp$8.parseReturnStatement = function (node) {
				if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
					this.raise(this.start, "'return' outside of function");
				}
				this.next();
				if (this.eat(types$1.semi) || this.insertSemicolon()) {
					node.argument = null;
				} else {
					node.argument = this.parseExpression();
					this.semicolon();
				}
				return this.finishNode(node, "ReturnStatement");
			};
			pp$8.parseSwitchStatement = function (node) {
				this.next();
				node.discriminant = this.parseParenExpression();
				node.cases = [];
				this.expect(types$1.braceL);
				this.labels.push(switchLabel);
				this.enterScope(0);
				var cur;
				for (var sawDefault = false; this.type !== types$1.braceR; ) {
					if (this.type === types$1._case || this.type === types$1._default) {
						var isCase = this.type === types$1._case;
						if (cur) {
							this.finishNode(cur, "SwitchCase");
						}
						node.cases.push((cur = this.startNode()));
						cur.consequent = [];
						this.next();
						if (isCase) {
							cur.test = this.parseExpression();
						} else {
							if (sawDefault) {
								this.raiseRecoverable(
									this.lastTokStart,
									"Multiple default clauses",
								);
							}
							sawDefault = true;
							cur.test = null;
						}
						this.expect(types$1.colon);
					} else {
						if (!cur) {
							this.unexpected();
						}
						cur.consequent.push(this.parseStatement(null));
					}
				}
				this.exitScope();
				if (cur) {
					this.finishNode(cur, "SwitchCase");
				}
				this.next();
				this.labels.pop();
				return this.finishNode(node, "SwitchStatement");
			};
			pp$8.parseThrowStatement = function (node) {
				this.next();
				if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
					this.raise(this.lastTokEnd, "Illegal newline after throw");
				}
				node.argument = this.parseExpression();
				this.semicolon();
				return this.finishNode(node, "ThrowStatement");
			};
			var empty$1 = [];
			pp$8.parseCatchClauseParam = function () {
				var param = this.parseBindingAtom();
				var simple = param.type === "Identifier";
				this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
				this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
				this.expect(types$1.parenR);
				return param;
			};
			pp$8.parseTryStatement = function (node) {
				this.next();
				node.block = this.parseBlock();
				node.handler = null;
				if (this.type === types$1._catch) {
					var clause = this.startNode();
					this.next();
					if (this.eat(types$1.parenL)) {
						clause.param = this.parseCatchClauseParam();
					} else {
						if (this.options.ecmaVersion < 10) {
							this.unexpected();
						}
						clause.param = null;
						this.enterScope(0);
					}
					clause.body = this.parseBlock(false);
					this.exitScope();
					node.handler = this.finishNode(clause, "CatchClause");
				}
				node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
				if (!node.handler && !node.finalizer) {
					this.raise(node.start, "Missing catch or finally clause");
				}
				return this.finishNode(node, "TryStatement");
			};
			pp$8.parseVarStatement = function (node, kind, allowMissingInitializer) {
				this.next();
				this.parseVar(node, false, kind, allowMissingInitializer);
				this.semicolon();
				return this.finishNode(node, "VariableDeclaration");
			};
			pp$8.parseWhileStatement = function (node) {
				this.next();
				node.test = this.parseParenExpression();
				this.labels.push(loopLabel);
				node.body = this.parseStatement("while");
				this.labels.pop();
				return this.finishNode(node, "WhileStatement");
			};
			pp$8.parseWithStatement = function (node) {
				if (this.strict) {
					this.raise(this.start, "'with' in strict mode");
				}
				this.next();
				node.object = this.parseParenExpression();
				node.body = this.parseStatement("with");
				return this.finishNode(node, "WithStatement");
			};
			pp$8.parseEmptyStatement = function (node) {
				this.next();
				return this.finishNode(node, "EmptyStatement");
			};
			pp$8.parseLabeledStatement = function (node, maybeName, expr, context) {
				for (var i$1 = 0, list2 = this.labels; i$1 < list2.length; i$1 += 1) {
					var label = list2[i$1];
					if (label.name === maybeName) {
						this.raise(expr.start, "Label '" + maybeName + "' is already declared");
					}
				}
				var kind = this.type.isLoop
					? "loop"
					: this.type === types$1._switch
						? "switch"
						: null;
				for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
					var label$1 = this.labels[i2];
					if (label$1.statementStart === node.start) {
						label$1.statementStart = this.start;
						label$1.kind = kind;
					} else {
						break;
					}
				}
				this.labels.push({ name: maybeName, kind, statementStart: this.start });
				node.body = this.parseStatement(
					context
						? context.indexOf("label") === -1
							? context + "label"
							: context
						: "label",
				);
				this.labels.pop();
				node.label = expr;
				return this.finishNode(node, "LabeledStatement");
			};
			pp$8.parseExpressionStatement = function (node, expr) {
				node.expression = expr;
				this.semicolon();
				return this.finishNode(node, "ExpressionStatement");
			};
			pp$8.parseBlock = function (createNewLexicalScope, node, exitStrict) {
				if (createNewLexicalScope === void 0) createNewLexicalScope = true;
				if (node === void 0) node = this.startNode();
				node.body = [];
				this.expect(types$1.braceL);
				if (createNewLexicalScope) {
					this.enterScope(0);
				}
				while (this.type !== types$1.braceR) {
					var stmt = this.parseStatement(null);
					node.body.push(stmt);
				}
				if (exitStrict) {
					this.strict = false;
				}
				this.next();
				if (createNewLexicalScope) {
					this.exitScope();
				}
				return this.finishNode(node, "BlockStatement");
			};
			pp$8.parseFor = function (node, init) {
				node.init = init;
				this.expect(types$1.semi);
				node.test = this.type === types$1.semi ? null : this.parseExpression();
				this.expect(types$1.semi);
				node.update = this.type === types$1.parenR ? null : this.parseExpression();
				this.expect(types$1.parenR);
				node.body = this.parseStatement("for");
				this.exitScope();
				this.labels.pop();
				return this.finishNode(node, "ForStatement");
			};
			pp$8.parseForIn = function (node, init) {
				var isForIn = this.type === types$1._in;
				this.next();
				if (
					init.type === "VariableDeclaration" &&
					init.declarations[0].init != null &&
					(!isForIn ||
						this.options.ecmaVersion < 8 ||
						this.strict ||
						init.kind !== "var" ||
						init.declarations[0].id.type !== "Identifier")
				) {
					this.raise(
						init.start,
						(isForIn ? "for-in" : "for-of") +
							" loop variable declaration may not have an initializer",
					);
				}
				node.left = init;
				node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
				this.expect(types$1.parenR);
				node.body = this.parseStatement("for");
				this.exitScope();
				this.labels.pop();
				return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
			};
			pp$8.parseVar = function (node, isFor, kind, allowMissingInitializer) {
				node.declarations = [];
				node.kind = kind;
				for (;;) {
					var decl = this.startNode();
					this.parseVarId(decl, kind);
					if (this.eat(types$1.eq)) {
						decl.init = this.parseMaybeAssign(isFor);
					} else if (
						!allowMissingInitializer &&
						kind === "const" &&
						!(
							this.type === types$1._in ||
							(this.options.ecmaVersion >= 6 && this.isContextual("of"))
						)
					) {
						this.unexpected();
					} else if (
						!allowMissingInitializer &&
						decl.id.type !== "Identifier" &&
						!(isFor && (this.type === types$1._in || this.isContextual("of")))
					) {
						this.raise(
							this.lastTokEnd,
							"Complex binding patterns require an initialization value",
						);
					} else {
						decl.init = null;
					}
					node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
					if (!this.eat(types$1.comma)) {
						break;
					}
				}
				return node;
			};
			pp$8.parseVarId = function (decl, kind) {
				decl.id = this.parseBindingAtom();
				this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
			};
			var FUNC_STATEMENT = 1,
				FUNC_HANGING_STATEMENT = 2,
				FUNC_NULLABLE_ID = 4;
			pp$8.parseFunction = function (node, statement, allowExpressionBody, isAsync, forInit) {
				this.initFunction(node);
				if (this.options.ecmaVersion >= 9 || (this.options.ecmaVersion >= 6 && !isAsync)) {
					if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
						this.unexpected();
					}
					node.generator = this.eat(types$1.star);
				}
				if (this.options.ecmaVersion >= 8) {
					node.async = !!isAsync;
				}
				if (statement & FUNC_STATEMENT) {
					node.id =
						statement & FUNC_NULLABLE_ID && this.type !== types$1.name
							? null
							: this.parseIdent();
					if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
						this.checkLValSimple(
							node.id,
							this.strict || node.generator || node.async
								? this.treatFunctionsAsVar
									? BIND_VAR
									: BIND_LEXICAL
								: BIND_FUNCTION,
						);
					}
				}
				var oldYieldPos = this.yieldPos,
					oldAwaitPos = this.awaitPos,
					oldAwaitIdentPos = this.awaitIdentPos;
				this.yieldPos = 0;
				this.awaitPos = 0;
				this.awaitIdentPos = 0;
				this.enterScope(functionFlags(node.async, node.generator));
				if (!(statement & FUNC_STATEMENT)) {
					node.id = this.type === types$1.name ? this.parseIdent() : null;
				}
				this.parseFunctionParams(node);
				this.parseFunctionBody(node, allowExpressionBody, false, forInit);
				this.yieldPos = oldYieldPos;
				this.awaitPos = oldAwaitPos;
				this.awaitIdentPos = oldAwaitIdentPos;
				return this.finishNode(
					node,
					statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression",
				);
			};
			pp$8.parseFunctionParams = function (node) {
				this.expect(types$1.parenL);
				node.params = this.parseBindingList(
					types$1.parenR,
					false,
					this.options.ecmaVersion >= 8,
				);
				this.checkYieldAwaitInDefaultParams();
			};
			pp$8.parseClass = function (node, isStatement) {
				this.next();
				var oldStrict = this.strict;
				this.strict = true;
				this.parseClassId(node, isStatement);
				this.parseClassSuper(node);
				var privateNameMap = this.enterClassBody();
				var classBody = this.startNode();
				var hadConstructor = false;
				classBody.body = [];
				this.expect(types$1.braceL);
				while (this.type !== types$1.braceR) {
					var element = this.parseClassElement(node.superClass !== null);
					if (element) {
						classBody.body.push(element);
						if (element.type === "MethodDefinition" && element.kind === "constructor") {
							if (hadConstructor) {
								this.raiseRecoverable(
									element.start,
									"Duplicate constructor in the same class",
								);
							}
							hadConstructor = true;
						} else if (
							element.key &&
							element.key.type === "PrivateIdentifier" &&
							isPrivateNameConflicted(privateNameMap, element)
						) {
							this.raiseRecoverable(
								element.key.start,
								"Identifier '#" + element.key.name + "' has already been declared",
							);
						}
					}
				}
				this.strict = oldStrict;
				this.next();
				node.body = this.finishNode(classBody, "ClassBody");
				this.exitClassBody();
				return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
			};
			pp$8.parseClassElement = function (constructorAllowsSuper) {
				if (this.eat(types$1.semi)) {
					return null;
				}
				var ecmaVersion2 = this.options.ecmaVersion;
				var node = this.startNode();
				var keyName = "";
				var isGenerator = false;
				var isAsync = false;
				var kind = "method";
				var isStatic = false;
				if (this.eatContextual("static")) {
					if (ecmaVersion2 >= 13 && this.eat(types$1.braceL)) {
						this.parseClassStaticBlock(node);
						return node;
					}
					if (this.isClassElementNameStart() || this.type === types$1.star) {
						isStatic = true;
					} else {
						keyName = "static";
					}
				}
				node.static = isStatic;
				if (!keyName && ecmaVersion2 >= 8 && this.eatContextual("async")) {
					if (
						(this.isClassElementNameStart() || this.type === types$1.star) &&
						!this.canInsertSemicolon()
					) {
						isAsync = true;
					} else {
						keyName = "async";
					}
				}
				if (!keyName && (ecmaVersion2 >= 9 || !isAsync) && this.eat(types$1.star)) {
					isGenerator = true;
				}
				if (!keyName && !isAsync && !isGenerator) {
					var lastValue = this.value;
					if (this.eatContextual("get") || this.eatContextual("set")) {
						if (this.isClassElementNameStart()) {
							kind = lastValue;
						} else {
							keyName = lastValue;
						}
					}
				}
				if (keyName) {
					node.computed = false;
					node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
					node.key.name = keyName;
					this.finishNode(node.key, "Identifier");
				} else {
					this.parseClassElementName(node);
				}
				if (
					ecmaVersion2 < 13 ||
					this.type === types$1.parenL ||
					kind !== "method" ||
					isGenerator ||
					isAsync
				) {
					var isConstructor = !node.static && checkKeyName(node, "constructor");
					var allowsDirectSuper = isConstructor && constructorAllowsSuper;
					if (isConstructor && kind !== "method") {
						this.raise(node.key.start, "Constructor can't have get/set modifier");
					}
					node.kind = isConstructor ? "constructor" : kind;
					this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
				} else {
					this.parseClassField(node);
				}
				return node;
			};
			pp$8.isClassElementNameStart = function () {
				return (
					this.type === types$1.name ||
					this.type === types$1.privateId ||
					this.type === types$1.num ||
					this.type === types$1.string ||
					this.type === types$1.bracketL ||
					this.type.keyword
				);
			};
			pp$8.parseClassElementName = function (element) {
				if (this.type === types$1.privateId) {
					if (this.value === "constructor") {
						this.raise(
							this.start,
							"Classes can't have an element named '#constructor'",
						);
					}
					element.computed = false;
					element.key = this.parsePrivateIdent();
				} else {
					this.parsePropertyName(element);
				}
			};
			pp$8.parseClassMethod = function (method, isGenerator, isAsync, allowsDirectSuper) {
				var key = method.key;
				if (method.kind === "constructor") {
					if (isGenerator) {
						this.raise(key.start, "Constructor can't be a generator");
					}
					if (isAsync) {
						this.raise(key.start, "Constructor can't be an async method");
					}
				} else if (method.static && checkKeyName(method, "prototype")) {
					this.raise(key.start, "Classes may not have a static property named prototype");
				}
				var value = (method.value = this.parseMethod(
					isGenerator,
					isAsync,
					allowsDirectSuper,
				));
				if (method.kind === "get" && value.params.length !== 0) {
					this.raiseRecoverable(value.start, "getter should have no params");
				}
				if (method.kind === "set" && value.params.length !== 1) {
					this.raiseRecoverable(value.start, "setter should have exactly one param");
				}
				if (method.kind === "set" && value.params[0].type === "RestElement") {
					this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
				}
				return this.finishNode(method, "MethodDefinition");
			};
			pp$8.parseClassField = function (field) {
				if (checkKeyName(field, "constructor")) {
					this.raise(field.key.start, "Classes can't have a field named 'constructor'");
				} else if (field.static && checkKeyName(field, "prototype")) {
					this.raise(
						field.key.start,
						"Classes can't have a static field named 'prototype'",
					);
				}
				if (this.eat(types$1.eq)) {
					var scope = this.currentThisScope();
					var inClassFieldInit = scope.inClassFieldInit;
					scope.inClassFieldInit = true;
					field.value = this.parseMaybeAssign();
					scope.inClassFieldInit = inClassFieldInit;
				} else {
					field.value = null;
				}
				this.semicolon();
				return this.finishNode(field, "PropertyDefinition");
			};
			pp$8.parseClassStaticBlock = function (node) {
				node.body = [];
				var oldLabels = this.labels;
				this.labels = [];
				this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
				while (this.type !== types$1.braceR) {
					var stmt = this.parseStatement(null);
					node.body.push(stmt);
				}
				this.next();
				this.exitScope();
				this.labels = oldLabels;
				return this.finishNode(node, "StaticBlock");
			};
			pp$8.parseClassId = function (node, isStatement) {
				if (this.type === types$1.name) {
					node.id = this.parseIdent();
					if (isStatement) {
						this.checkLValSimple(node.id, BIND_LEXICAL, false);
					}
				} else {
					if (isStatement === true) {
						this.unexpected();
					}
					node.id = null;
				}
			};
			pp$8.parseClassSuper = function (node) {
				node.superClass = this.eat(types$1._extends)
					? this.parseExprSubscripts(null, false)
					: null;
			};
			pp$8.enterClassBody = function () {
				var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
				this.privateNameStack.push(element);
				return element.declared;
			};
			pp$8.exitClassBody = function () {
				var ref2 = this.privateNameStack.pop();
				var declared = ref2.declared;
				var used = ref2.used;
				if (!this.options.checkPrivateFields) {
					return;
				}
				var len = this.privateNameStack.length;
				var parent = len === 0 ? null : this.privateNameStack[len - 1];
				for (var i2 = 0; i2 < used.length; ++i2) {
					var id = used[i2];
					if (!hasOwn(declared, id.name)) {
						if (parent) {
							parent.used.push(id);
						} else {
							this.raiseRecoverable(
								id.start,
								"Private field '#" +
									id.name +
									"' must be declared in an enclosing class",
							);
						}
					}
				}
			};
			function isPrivateNameConflicted(privateNameMap, element) {
				var name = element.key.name;
				var curr = privateNameMap[name];
				var next = "true";
				if (
					element.type === "MethodDefinition" &&
					(element.kind === "get" || element.kind === "set")
				) {
					next = (element.static ? "s" : "i") + element.kind;
				}
				if (
					(curr === "iget" && next === "iset") ||
					(curr === "iset" && next === "iget") ||
					(curr === "sget" && next === "sset") ||
					(curr === "sset" && next === "sget")
				) {
					privateNameMap[name] = "true";
					return false;
				} else if (!curr) {
					privateNameMap[name] = next;
					return false;
				} else {
					return true;
				}
			}
			function checkKeyName(node, name) {
				var computed = node.computed;
				var key = node.key;
				return (
					!computed &&
					((key.type === "Identifier" && key.name === name) ||
						(key.type === "Literal" && key.value === name))
				);
			}
			pp$8.parseExportAllDeclaration = function (node, exports4) {
				if (this.options.ecmaVersion >= 11) {
					if (this.eatContextual("as")) {
						node.exported = this.parseModuleExportName();
						this.checkExport(exports4, node.exported, this.lastTokStart);
					} else {
						node.exported = null;
					}
				}
				this.expectContextual("from");
				if (this.type !== types$1.string) {
					this.unexpected();
				}
				node.source = this.parseExprAtom();
				if (this.options.ecmaVersion >= 16) {
					node.attributes = this.parseWithClause();
				}
				this.semicolon();
				return this.finishNode(node, "ExportAllDeclaration");
			};
			pp$8.parseExport = function (node, exports4) {
				this.next();
				if (this.eat(types$1.star)) {
					return this.parseExportAllDeclaration(node, exports4);
				}
				if (this.eat(types$1._default)) {
					this.checkExport(exports4, "default", this.lastTokStart);
					node.declaration = this.parseExportDefaultDeclaration();
					return this.finishNode(node, "ExportDefaultDeclaration");
				}
				if (this.shouldParseExportStatement()) {
					node.declaration = this.parseExportDeclaration(node);
					if (node.declaration.type === "VariableDeclaration") {
						this.checkVariableExport(exports4, node.declaration.declarations);
					} else {
						this.checkExport(exports4, node.declaration.id, node.declaration.id.start);
					}
					node.specifiers = [];
					node.source = null;
				} else {
					node.declaration = null;
					node.specifiers = this.parseExportSpecifiers(exports4);
					if (this.eatContextual("from")) {
						if (this.type !== types$1.string) {
							this.unexpected();
						}
						node.source = this.parseExprAtom();
						if (this.options.ecmaVersion >= 16) {
							node.attributes = this.parseWithClause();
						}
					} else {
						for (var i2 = 0, list2 = node.specifiers; i2 < list2.length; i2 += 1) {
							var spec = list2[i2];
							this.checkUnreserved(spec.local);
							this.checkLocalExport(spec.local);
							if (spec.local.type === "Literal") {
								this.raise(
									spec.local.start,
									"A string literal cannot be used as an exported binding without `from`.",
								);
							}
						}
						node.source = null;
					}
					this.semicolon();
				}
				return this.finishNode(node, "ExportNamedDeclaration");
			};
			pp$8.parseExportDeclaration = function (node) {
				return this.parseStatement(null);
			};
			pp$8.parseExportDefaultDeclaration = function () {
				var isAsync;
				if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
					var fNode = this.startNode();
					this.next();
					if (isAsync) {
						this.next();
					}
					return this.parseFunction(
						fNode,
						FUNC_STATEMENT | FUNC_NULLABLE_ID,
						false,
						isAsync,
					);
				} else if (this.type === types$1._class) {
					var cNode = this.startNode();
					return this.parseClass(cNode, "nullableID");
				} else {
					var declaration = this.parseMaybeAssign();
					this.semicolon();
					return declaration;
				}
			};
			pp$8.checkExport = function (exports4, name, pos) {
				if (!exports4) {
					return;
				}
				if (typeof name !== "string") {
					name = name.type === "Identifier" ? name.name : name.value;
				}
				if (hasOwn(exports4, name)) {
					this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
				}
				exports4[name] = true;
			};
			pp$8.checkPatternExport = function (exports4, pat) {
				var type = pat.type;
				if (type === "Identifier") {
					this.checkExport(exports4, pat, pat.start);
				} else if (type === "ObjectPattern") {
					for (var i2 = 0, list2 = pat.properties; i2 < list2.length; i2 += 1) {
						var prop = list2[i2];
						this.checkPatternExport(exports4, prop);
					}
				} else if (type === "ArrayPattern") {
					for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
						var elt = list$1[i$1];
						if (elt) {
							this.checkPatternExport(exports4, elt);
						}
					}
				} else if (type === "Property") {
					this.checkPatternExport(exports4, pat.value);
				} else if (type === "AssignmentPattern") {
					this.checkPatternExport(exports4, pat.left);
				} else if (type === "RestElement") {
					this.checkPatternExport(exports4, pat.argument);
				}
			};
			pp$8.checkVariableExport = function (exports4, decls) {
				if (!exports4) {
					return;
				}
				for (var i2 = 0, list2 = decls; i2 < list2.length; i2 += 1) {
					var decl = list2[i2];
					this.checkPatternExport(exports4, decl.id);
				}
			};
			pp$8.shouldParseExportStatement = function () {
				return (
					this.type.keyword === "var" ||
					this.type.keyword === "const" ||
					this.type.keyword === "class" ||
					this.type.keyword === "function" ||
					this.isLet() ||
					this.isAsyncFunction()
				);
			};
			pp$8.parseExportSpecifier = function (exports4) {
				var node = this.startNode();
				node.local = this.parseModuleExportName();
				node.exported = this.eatContextual("as")
					? this.parseModuleExportName()
					: node.local;
				this.checkExport(exports4, node.exported, node.exported.start);
				return this.finishNode(node, "ExportSpecifier");
			};
			pp$8.parseExportSpecifiers = function (exports4) {
				var nodes = [],
					first = true;
				this.expect(types$1.braceL);
				while (!this.eat(types$1.braceR)) {
					if (!first) {
						this.expect(types$1.comma);
						if (this.afterTrailingComma(types$1.braceR)) {
							break;
						}
					} else {
						first = false;
					}
					nodes.push(this.parseExportSpecifier(exports4));
				}
				return nodes;
			};
			pp$8.parseImport = function (node) {
				this.next();
				if (this.type === types$1.string) {
					node.specifiers = empty$1;
					node.source = this.parseExprAtom();
				} else {
					node.specifiers = this.parseImportSpecifiers();
					this.expectContextual("from");
					node.source =
						this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
				}
				if (this.options.ecmaVersion >= 16) {
					node.attributes = this.parseWithClause();
				}
				this.semicolon();
				return this.finishNode(node, "ImportDeclaration");
			};
			pp$8.parseImportSpecifier = function () {
				var node = this.startNode();
				node.imported = this.parseModuleExportName();
				if (this.eatContextual("as")) {
					node.local = this.parseIdent();
				} else {
					this.checkUnreserved(node.imported);
					node.local = node.imported;
				}
				this.checkLValSimple(node.local, BIND_LEXICAL);
				return this.finishNode(node, "ImportSpecifier");
			};
			pp$8.parseImportDefaultSpecifier = function () {
				var node = this.startNode();
				node.local = this.parseIdent();
				this.checkLValSimple(node.local, BIND_LEXICAL);
				return this.finishNode(node, "ImportDefaultSpecifier");
			};
			pp$8.parseImportNamespaceSpecifier = function () {
				var node = this.startNode();
				this.next();
				this.expectContextual("as");
				node.local = this.parseIdent();
				this.checkLValSimple(node.local, BIND_LEXICAL);
				return this.finishNode(node, "ImportNamespaceSpecifier");
			};
			pp$8.parseImportSpecifiers = function () {
				var nodes = [],
					first = true;
				if (this.type === types$1.name) {
					nodes.push(this.parseImportDefaultSpecifier());
					if (!this.eat(types$1.comma)) {
						return nodes;
					}
				}
				if (this.type === types$1.star) {
					nodes.push(this.parseImportNamespaceSpecifier());
					return nodes;
				}
				this.expect(types$1.braceL);
				while (!this.eat(types$1.braceR)) {
					if (!first) {
						this.expect(types$1.comma);
						if (this.afterTrailingComma(types$1.braceR)) {
							break;
						}
					} else {
						first = false;
					}
					nodes.push(this.parseImportSpecifier());
				}
				return nodes;
			};
			pp$8.parseWithClause = function () {
				var nodes = [];
				if (!this.eat(types$1._with)) {
					return nodes;
				}
				this.expect(types$1.braceL);
				var attributeKeys = {};
				var first = true;
				while (!this.eat(types$1.braceR)) {
					if (!first) {
						this.expect(types$1.comma);
						if (this.afterTrailingComma(types$1.braceR)) {
							break;
						}
					} else {
						first = false;
					}
					var attr = this.parseImportAttribute();
					var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
					if (hasOwn(attributeKeys, keyName)) {
						this.raiseRecoverable(
							attr.key.start,
							"Duplicate attribute key '" + keyName + "'",
						);
					}
					attributeKeys[keyName] = true;
					nodes.push(attr);
				}
				return nodes;
			};
			pp$8.parseImportAttribute = function () {
				var node = this.startNode();
				node.key =
					this.type === types$1.string
						? this.parseExprAtom()
						: this.parseIdent(this.options.allowReserved !== "never");
				this.expect(types$1.colon);
				if (this.type !== types$1.string) {
					this.unexpected();
				}
				node.value = this.parseExprAtom();
				return this.finishNode(node, "ImportAttribute");
			};
			pp$8.parseModuleExportName = function () {
				if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
					var stringLiteral = this.parseLiteral(this.value);
					if (loneSurrogate.test(stringLiteral.value)) {
						this.raise(
							stringLiteral.start,
							"An export name cannot include a lone surrogate.",
						);
					}
					return stringLiteral;
				}
				return this.parseIdent(true);
			};
			pp$8.adaptDirectivePrologue = function (statements) {
				for (
					var i2 = 0;
					i2 < statements.length && this.isDirectiveCandidate(statements[i2]);
					++i2
				) {
					statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
				}
			};
			pp$8.isDirectiveCandidate = function (statement) {
				return (
					this.options.ecmaVersion >= 5 &&
					statement.type === "ExpressionStatement" &&
					statement.expression.type === "Literal" &&
					typeof statement.expression.value === "string" && // Reject parenthesized strings.
					(this.input[statement.start] === '"' || this.input[statement.start] === "'")
				);
			};
			var pp$7 = Parser.prototype;
			pp$7.toAssignable = function (node, isBinding, refDestructuringErrors) {
				if (this.options.ecmaVersion >= 6 && node) {
					switch (node.type) {
						case "Identifier":
							if (this.inAsync && node.name === "await") {
								this.raise(
									node.start,
									"Cannot use 'await' as identifier inside an async function",
								);
							}
							break;
						case "ObjectPattern":
						case "ArrayPattern":
						case "AssignmentPattern":
						case "RestElement":
							break;
						case "ObjectExpression":
							node.type = "ObjectPattern";
							if (refDestructuringErrors) {
								this.checkPatternErrors(refDestructuringErrors, true);
							}
							for (var i2 = 0, list2 = node.properties; i2 < list2.length; i2 += 1) {
								var prop = list2[i2];
								this.toAssignable(prop, isBinding);
								if (
									prop.type === "RestElement" &&
									(prop.argument.type === "ArrayPattern" ||
										prop.argument.type === "ObjectPattern")
								) {
									this.raise(prop.argument.start, "Unexpected token");
								}
							}
							break;
						case "Property":
							if (node.kind !== "init") {
								this.raise(
									node.key.start,
									"Object pattern can't contain getter or setter",
								);
							}
							this.toAssignable(node.value, isBinding);
							break;
						case "ArrayExpression":
							node.type = "ArrayPattern";
							if (refDestructuringErrors) {
								this.checkPatternErrors(refDestructuringErrors, true);
							}
							this.toAssignableList(node.elements, isBinding);
							break;
						case "SpreadElement":
							node.type = "RestElement";
							this.toAssignable(node.argument, isBinding);
							if (node.argument.type === "AssignmentPattern") {
								this.raise(
									node.argument.start,
									"Rest elements cannot have a default value",
								);
							}
							break;
						case "AssignmentExpression":
							if (node.operator !== "=") {
								this.raise(
									node.left.end,
									"Only '=' operator can be used for specifying default value.",
								);
							}
							node.type = "AssignmentPattern";
							delete node.operator;
							this.toAssignable(node.left, isBinding);
							break;
						case "ParenthesizedExpression":
							this.toAssignable(node.expression, isBinding, refDestructuringErrors);
							break;
						case "ChainExpression":
							this.raiseRecoverable(
								node.start,
								"Optional chaining cannot appear in left-hand side",
							);
							break;
						case "MemberExpression":
							if (!isBinding) {
								break;
							}
						default:
							this.raise(node.start, "Assigning to rvalue");
					}
				} else if (refDestructuringErrors) {
					this.checkPatternErrors(refDestructuringErrors, true);
				}
				return node;
			};
			pp$7.toAssignableList = function (exprList, isBinding) {
				var end = exprList.length;
				for (var i2 = 0; i2 < end; i2++) {
					var elt = exprList[i2];
					if (elt) {
						this.toAssignable(elt, isBinding);
					}
				}
				if (end) {
					var last = exprList[end - 1];
					if (
						this.options.ecmaVersion === 6 &&
						isBinding &&
						last &&
						last.type === "RestElement" &&
						last.argument.type !== "Identifier"
					) {
						this.unexpected(last.argument.start);
					}
				}
				return exprList;
			};
			pp$7.parseSpread = function (refDestructuringErrors) {
				var node = this.startNode();
				this.next();
				node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
				return this.finishNode(node, "SpreadElement");
			};
			pp$7.parseRestBinding = function () {
				var node = this.startNode();
				this.next();
				if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
					this.unexpected();
				}
				node.argument = this.parseBindingAtom();
				return this.finishNode(node, "RestElement");
			};
			pp$7.parseBindingAtom = function () {
				if (this.options.ecmaVersion >= 6) {
					switch (this.type) {
						case types$1.bracketL:
							var node = this.startNode();
							this.next();
							node.elements = this.parseBindingList(types$1.bracketR, true, true);
							return this.finishNode(node, "ArrayPattern");
						case types$1.braceL:
							return this.parseObj(true);
					}
				}
				return this.parseIdent();
			};
			pp$7.parseBindingList = function (
				close,
				allowEmpty,
				allowTrailingComma,
				allowModifiers,
			) {
				var elts = [],
					first = true;
				while (!this.eat(close)) {
					if (first) {
						first = false;
					} else {
						this.expect(types$1.comma);
					}
					if (allowEmpty && this.type === types$1.comma) {
						elts.push(null);
					} else if (allowTrailingComma && this.afterTrailingComma(close)) {
						break;
					} else if (this.type === types$1.ellipsis) {
						var rest = this.parseRestBinding();
						this.parseBindingListItem(rest);
						elts.push(rest);
						if (this.type === types$1.comma) {
							this.raiseRecoverable(
								this.start,
								"Comma is not permitted after the rest element",
							);
						}
						this.expect(close);
						break;
					} else {
						elts.push(this.parseAssignableListItem(allowModifiers));
					}
				}
				return elts;
			};
			pp$7.parseAssignableListItem = function (allowModifiers) {
				var elem = this.parseMaybeDefault(this.start, this.startLoc);
				this.parseBindingListItem(elem);
				return elem;
			};
			pp$7.parseBindingListItem = function (param) {
				return param;
			};
			pp$7.parseMaybeDefault = function (startPos, startLoc, left) {
				left = left || this.parseBindingAtom();
				if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
					return left;
				}
				var node = this.startNodeAt(startPos, startLoc);
				node.left = left;
				node.right = this.parseMaybeAssign();
				return this.finishNode(node, "AssignmentPattern");
			};
			pp$7.checkLValSimple = function (expr, bindingType, checkClashes) {
				if (bindingType === void 0) bindingType = BIND_NONE;
				var isBind = bindingType !== BIND_NONE;
				switch (expr.type) {
					case "Identifier":
						if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
							this.raiseRecoverable(
								expr.start,
								(isBind ? "Binding " : "Assigning to ") +
									expr.name +
									" in strict mode",
							);
						}
						if (isBind) {
							if (bindingType === BIND_LEXICAL && expr.name === "let") {
								this.raiseRecoverable(
									expr.start,
									"let is disallowed as a lexically bound name",
								);
							}
							if (checkClashes) {
								if (hasOwn(checkClashes, expr.name)) {
									this.raiseRecoverable(expr.start, "Argument name clash");
								}
								checkClashes[expr.name] = true;
							}
							if (bindingType !== BIND_OUTSIDE) {
								this.declareName(expr.name, bindingType, expr.start);
							}
						}
						break;
					case "ChainExpression":
						this.raiseRecoverable(
							expr.start,
							"Optional chaining cannot appear in left-hand side",
						);
						break;
					case "MemberExpression":
						if (isBind) {
							this.raiseRecoverable(expr.start, "Binding member expression");
						}
						break;
					case "ParenthesizedExpression":
						if (isBind) {
							this.raiseRecoverable(expr.start, "Binding parenthesized expression");
						}
						return this.checkLValSimple(expr.expression, bindingType, checkClashes);
					default:
						this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
				}
			};
			pp$7.checkLValPattern = function (expr, bindingType, checkClashes) {
				if (bindingType === void 0) bindingType = BIND_NONE;
				switch (expr.type) {
					case "ObjectPattern":
						for (var i2 = 0, list2 = expr.properties; i2 < list2.length; i2 += 1) {
							var prop = list2[i2];
							this.checkLValInnerPattern(prop, bindingType, checkClashes);
						}
						break;
					case "ArrayPattern":
						for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
							var elem = list$1[i$1];
							if (elem) {
								this.checkLValInnerPattern(elem, bindingType, checkClashes);
							}
						}
						break;
					default:
						this.checkLValSimple(expr, bindingType, checkClashes);
				}
			};
			pp$7.checkLValInnerPattern = function (expr, bindingType, checkClashes) {
				if (bindingType === void 0) bindingType = BIND_NONE;
				switch (expr.type) {
					case "Property":
						this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
						break;
					case "AssignmentPattern":
						this.checkLValPattern(expr.left, bindingType, checkClashes);
						break;
					case "RestElement":
						this.checkLValPattern(expr.argument, bindingType, checkClashes);
						break;
					default:
						this.checkLValPattern(expr, bindingType, checkClashes);
				}
			};
			var TokContext = function TokContext2(
				token,
				isExpr,
				preserveSpace,
				override,
				generator,
			) {
				this.token = token;
				this.isExpr = !!isExpr;
				this.preserveSpace = !!preserveSpace;
				this.override = override;
				this.generator = !!generator;
			};
			var types = {
				b_stat: new TokContext("{", false),
				b_expr: new TokContext("{", true),
				b_tmpl: new TokContext("${", false),
				p_stat: new TokContext("(", false),
				p_expr: new TokContext("(", true),
				q_tmpl: new TokContext("`", true, true, function (p) {
					return p.tryReadTemplateToken();
				}),
				f_stat: new TokContext("function", false),
				f_expr: new TokContext("function", true),
				f_expr_gen: new TokContext("function", true, false, null, true),
				f_gen: new TokContext("function", false, false, null, true),
			};
			var pp$6 = Parser.prototype;
			pp$6.initialContext = function () {
				return [types.b_stat];
			};
			pp$6.curContext = function () {
				return this.context[this.context.length - 1];
			};
			pp$6.braceIsBlock = function (prevType) {
				var parent = this.curContext();
				if (parent === types.f_expr || parent === types.f_stat) {
					return true;
				}
				if (
					prevType === types$1.colon &&
					(parent === types.b_stat || parent === types.b_expr)
				) {
					return !parent.isExpr;
				}
				if (
					prevType === types$1._return ||
					(prevType === types$1.name && this.exprAllowed)
				) {
					return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
				}
				if (
					prevType === types$1._else ||
					prevType === types$1.semi ||
					prevType === types$1.eof ||
					prevType === types$1.parenR ||
					prevType === types$1.arrow
				) {
					return true;
				}
				if (prevType === types$1.braceL) {
					return parent === types.b_stat;
				}
				if (
					prevType === types$1._var ||
					prevType === types$1._const ||
					prevType === types$1.name
				) {
					return false;
				}
				return !this.exprAllowed;
			};
			pp$6.inGeneratorContext = function () {
				for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
					var context = this.context[i2];
					if (context.token === "function") {
						return context.generator;
					}
				}
				return false;
			};
			pp$6.updateContext = function (prevType) {
				var update,
					type = this.type;
				if (type.keyword && prevType === types$1.dot) {
					this.exprAllowed = false;
				} else if ((update = type.updateContext)) {
					update.call(this, prevType);
				} else {
					this.exprAllowed = type.beforeExpr;
				}
			};
			pp$6.overrideContext = function (tokenCtx) {
				if (this.curContext() !== tokenCtx) {
					this.context[this.context.length - 1] = tokenCtx;
				}
			};
			types$1.parenR.updateContext = types$1.braceR.updateContext = function () {
				if (this.context.length === 1) {
					this.exprAllowed = true;
					return;
				}
				var out = this.context.pop();
				if (out === types.b_stat && this.curContext().token === "function") {
					out = this.context.pop();
				}
				this.exprAllowed = !out.isExpr;
			};
			types$1.braceL.updateContext = function (prevType) {
				this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
				this.exprAllowed = true;
			};
			types$1.dollarBraceL.updateContext = function () {
				this.context.push(types.b_tmpl);
				this.exprAllowed = true;
			};
			types$1.parenL.updateContext = function (prevType) {
				var statementParens =
					prevType === types$1._if ||
					prevType === types$1._for ||
					prevType === types$1._with ||
					prevType === types$1._while;
				this.context.push(statementParens ? types.p_stat : types.p_expr);
				this.exprAllowed = true;
			};
			types$1.incDec.updateContext = function () {};
			types$1._function.updateContext = types$1._class.updateContext = function (prevType) {
				if (
					prevType.beforeExpr &&
					prevType !== types$1._else &&
					!(prevType === types$1.semi && this.curContext() !== types.p_stat) &&
					!(
						prevType === types$1._return &&
						lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
					) &&
					!(
						(prevType === types$1.colon || prevType === types$1.braceL) &&
						this.curContext() === types.b_stat
					)
				) {
					this.context.push(types.f_expr);
				} else {
					this.context.push(types.f_stat);
				}
				this.exprAllowed = false;
			};
			types$1.colon.updateContext = function () {
				if (this.curContext().token === "function") {
					this.context.pop();
				}
				this.exprAllowed = true;
			};
			types$1.backQuote.updateContext = function () {
				if (this.curContext() === types.q_tmpl) {
					this.context.pop();
				} else {
					this.context.push(types.q_tmpl);
				}
				this.exprAllowed = false;
			};
			types$1.star.updateContext = function (prevType) {
				if (prevType === types$1._function) {
					var index = this.context.length - 1;
					if (this.context[index] === types.f_expr) {
						this.context[index] = types.f_expr_gen;
					} else {
						this.context[index] = types.f_gen;
					}
				}
				this.exprAllowed = true;
			};
			types$1.name.updateContext = function (prevType) {
				var allowed = false;
				if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
					if (
						(this.value === "of" && !this.exprAllowed) ||
						(this.value === "yield" && this.inGeneratorContext())
					) {
						allowed = true;
					}
				}
				this.exprAllowed = allowed;
			};
			var pp$5 = Parser.prototype;
			pp$5.checkPropClash = function (prop, propHash, refDestructuringErrors) {
				if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
					return;
				}
				if (
					this.options.ecmaVersion >= 6 &&
					(prop.computed || prop.method || prop.shorthand)
				) {
					return;
				}
				var key = prop.key;
				var name;
				switch (key.type) {
					case "Identifier":
						name = key.name;
						break;
					case "Literal":
						name = String(key.value);
						break;
					default:
						return;
				}
				var kind = prop.kind;
				if (this.options.ecmaVersion >= 6) {
					if (name === "__proto__" && kind === "init") {
						if (propHash.proto) {
							if (refDestructuringErrors) {
								if (refDestructuringErrors.doubleProto < 0) {
									refDestructuringErrors.doubleProto = key.start;
								}
							} else {
								this.raiseRecoverable(
									key.start,
									"Redefinition of __proto__ property",
								);
							}
						}
						propHash.proto = true;
					}
					return;
				}
				name = "$" + name;
				var other = propHash[name];
				if (other) {
					var redefinition;
					if (kind === "init") {
						redefinition = (this.strict && other.init) || other.get || other.set;
					} else {
						redefinition = other.init || other[kind];
					}
					if (redefinition) {
						this.raiseRecoverable(key.start, "Redefinition of property");
					}
				} else {
					other = propHash[name] = {
						init: false,
						get: false,
						set: false,
					};
				}
				other[kind] = true;
			};
			pp$5.parseExpression = function (forInit, refDestructuringErrors) {
				var startPos = this.start,
					startLoc = this.startLoc;
				var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
				if (this.type === types$1.comma) {
					var node = this.startNodeAt(startPos, startLoc);
					node.expressions = [expr];
					while (this.eat(types$1.comma)) {
						node.expressions.push(
							this.parseMaybeAssign(forInit, refDestructuringErrors),
						);
					}
					return this.finishNode(node, "SequenceExpression");
				}
				return expr;
			};
			pp$5.parseMaybeAssign = function (forInit, refDestructuringErrors, afterLeftParse) {
				if (this.isContextual("yield")) {
					if (this.inGenerator) {
						return this.parseYield(forInit);
					} else {
						this.exprAllowed = false;
					}
				}
				var ownDestructuringErrors = false,
					oldParenAssign = -1,
					oldTrailingComma = -1,
					oldDoubleProto = -1;
				if (refDestructuringErrors) {
					oldParenAssign = refDestructuringErrors.parenthesizedAssign;
					oldTrailingComma = refDestructuringErrors.trailingComma;
					oldDoubleProto = refDestructuringErrors.doubleProto;
					refDestructuringErrors.parenthesizedAssign =
						refDestructuringErrors.trailingComma = -1;
				} else {
					refDestructuringErrors = new DestructuringErrors();
					ownDestructuringErrors = true;
				}
				var startPos = this.start,
					startLoc = this.startLoc;
				if (this.type === types$1.parenL || this.type === types$1.name) {
					this.potentialArrowAt = this.start;
					this.potentialArrowInForAwait = forInit === "await";
				}
				var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
				if (afterLeftParse) {
					left = afterLeftParse.call(this, left, startPos, startLoc);
				}
				if (this.type.isAssign) {
					var node = this.startNodeAt(startPos, startLoc);
					node.operator = this.value;
					if (this.type === types$1.eq) {
						left = this.toAssignable(left, false, refDestructuringErrors);
					}
					if (!ownDestructuringErrors) {
						refDestructuringErrors.parenthesizedAssign =
							refDestructuringErrors.trailingComma =
							refDestructuringErrors.doubleProto =
								-1;
					}
					if (refDestructuringErrors.shorthandAssign >= left.start) {
						refDestructuringErrors.shorthandAssign = -1;
					}
					if (this.type === types$1.eq) {
						this.checkLValPattern(left);
					} else {
						this.checkLValSimple(left);
					}
					node.left = left;
					this.next();
					node.right = this.parseMaybeAssign(forInit);
					if (oldDoubleProto > -1) {
						refDestructuringErrors.doubleProto = oldDoubleProto;
					}
					return this.finishNode(node, "AssignmentExpression");
				} else {
					if (ownDestructuringErrors) {
						this.checkExpressionErrors(refDestructuringErrors, true);
					}
				}
				if (oldParenAssign > -1) {
					refDestructuringErrors.parenthesizedAssign = oldParenAssign;
				}
				if (oldTrailingComma > -1) {
					refDestructuringErrors.trailingComma = oldTrailingComma;
				}
				return left;
			};
			pp$5.parseMaybeConditional = function (forInit, refDestructuringErrors) {
				var startPos = this.start,
					startLoc = this.startLoc;
				var expr = this.parseExprOps(forInit, refDestructuringErrors);
				if (this.checkExpressionErrors(refDestructuringErrors)) {
					return expr;
				}
				if (this.eat(types$1.question)) {
					var node = this.startNodeAt(startPos, startLoc);
					node.test = expr;
					node.consequent = this.parseMaybeAssign();
					this.expect(types$1.colon);
					node.alternate = this.parseMaybeAssign(forInit);
					return this.finishNode(node, "ConditionalExpression");
				}
				return expr;
			};
			pp$5.parseExprOps = function (forInit, refDestructuringErrors) {
				var startPos = this.start,
					startLoc = this.startLoc;
				var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
				if (this.checkExpressionErrors(refDestructuringErrors)) {
					return expr;
				}
				return expr.start === startPos && expr.type === "ArrowFunctionExpression"
					? expr
					: this.parseExprOp(expr, startPos, startLoc, -1, forInit);
			};
			pp$5.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, forInit) {
				var prec = this.type.binop;
				if (prec != null && (!forInit || this.type !== types$1._in)) {
					if (prec > minPrec) {
						var logical =
							this.type === types$1.logicalOR || this.type === types$1.logicalAND;
						var coalesce = this.type === types$1.coalesce;
						if (coalesce) {
							prec = types$1.logicalAND.binop;
						}
						var op = this.value;
						this.next();
						var startPos = this.start,
							startLoc = this.startLoc;
						var right = this.parseExprOp(
							this.parseMaybeUnary(null, false, false, forInit),
							startPos,
							startLoc,
							prec,
							forInit,
						);
						var node = this.buildBinary(
							leftStartPos,
							leftStartLoc,
							left,
							right,
							op,
							logical || coalesce,
						);
						if (
							(logical && this.type === types$1.coalesce) ||
							(coalesce &&
								(this.type === types$1.logicalOR ||
									this.type === types$1.logicalAND))
						) {
							this.raiseRecoverable(
								this.start,
								"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses",
							);
						}
						return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
					}
				}
				return left;
			};
			pp$5.buildBinary = function (startPos, startLoc, left, right, op, logical) {
				if (right.type === "PrivateIdentifier") {
					this.raise(
						right.start,
						"Private identifier can only be left side of binary expression",
					);
				}
				var node = this.startNodeAt(startPos, startLoc);
				node.left = left;
				node.operator = op;
				node.right = right;
				return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
			};
			pp$5.parseMaybeUnary = function (refDestructuringErrors, sawUnary, incDec, forInit) {
				var startPos = this.start,
					startLoc = this.startLoc,
					expr;
				if (this.isContextual("await") && this.canAwait) {
					expr = this.parseAwait(forInit);
					sawUnary = true;
				} else if (this.type.prefix) {
					var node = this.startNode(),
						update = this.type === types$1.incDec;
					node.operator = this.value;
					node.prefix = true;
					this.next();
					node.argument = this.parseMaybeUnary(null, true, update, forInit);
					this.checkExpressionErrors(refDestructuringErrors, true);
					if (update) {
						this.checkLValSimple(node.argument);
					} else if (
						this.strict &&
						node.operator === "delete" &&
						isLocalVariableAccess(node.argument)
					) {
						this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
					} else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
						this.raiseRecoverable(node.start, "Private fields can not be deleted");
					} else {
						sawUnary = true;
					}
					expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
				} else if (!sawUnary && this.type === types$1.privateId) {
					if (
						(forInit || this.privateNameStack.length === 0) &&
						this.options.checkPrivateFields
					) {
						this.unexpected();
					}
					expr = this.parsePrivateIdent();
					if (this.type !== types$1._in) {
						this.unexpected();
					}
				} else {
					expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
					if (this.checkExpressionErrors(refDestructuringErrors)) {
						return expr;
					}
					while (this.type.postfix && !this.canInsertSemicolon()) {
						var node$1 = this.startNodeAt(startPos, startLoc);
						node$1.operator = this.value;
						node$1.prefix = false;
						node$1.argument = expr;
						this.checkLValSimple(expr);
						this.next();
						expr = this.finishNode(node$1, "UpdateExpression");
					}
				}
				if (!incDec && this.eat(types$1.starstar)) {
					if (sawUnary) {
						this.unexpected(this.lastTokStart);
					} else {
						return this.buildBinary(
							startPos,
							startLoc,
							expr,
							this.parseMaybeUnary(null, false, false, forInit),
							"**",
							false,
						);
					}
				} else {
					return expr;
				}
			};
			function isLocalVariableAccess(node) {
				return (
					node.type === "Identifier" ||
					(node.type === "ParenthesizedExpression" &&
						isLocalVariableAccess(node.expression))
				);
			}
			function isPrivateFieldAccess(node) {
				return (
					(node.type === "MemberExpression" &&
						node.property.type === "PrivateIdentifier") ||
					(node.type === "ChainExpression" && isPrivateFieldAccess(node.expression)) ||
					(node.type === "ParenthesizedExpression" &&
						isPrivateFieldAccess(node.expression))
				);
			}
			pp$5.parseExprSubscripts = function (refDestructuringErrors, forInit) {
				var startPos = this.start,
					startLoc = this.startLoc;
				var expr = this.parseExprAtom(refDestructuringErrors, forInit);
				if (
					expr.type === "ArrowFunctionExpression" &&
					this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")"
				) {
					return expr;
				}
				var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
				if (refDestructuringErrors && result.type === "MemberExpression") {
					if (refDestructuringErrors.parenthesizedAssign >= result.start) {
						refDestructuringErrors.parenthesizedAssign = -1;
					}
					if (refDestructuringErrors.parenthesizedBind >= result.start) {
						refDestructuringErrors.parenthesizedBind = -1;
					}
					if (refDestructuringErrors.trailingComma >= result.start) {
						refDestructuringErrors.trailingComma = -1;
					}
				}
				return result;
			};
			pp$5.parseSubscripts = function (base, startPos, startLoc, noCalls, forInit) {
				var maybeAsyncArrow =
					this.options.ecmaVersion >= 8 &&
					base.type === "Identifier" &&
					base.name === "async" &&
					this.lastTokEnd === base.end &&
					!this.canInsertSemicolon() &&
					base.end - base.start === 5 &&
					this.potentialArrowAt === base.start;
				var optionalChained = false;
				while (true) {
					var element = this.parseSubscript(
						base,
						startPos,
						startLoc,
						noCalls,
						maybeAsyncArrow,
						optionalChained,
						forInit,
					);
					if (element.optional) {
						optionalChained = true;
					}
					if (element === base || element.type === "ArrowFunctionExpression") {
						if (optionalChained) {
							var chainNode = this.startNodeAt(startPos, startLoc);
							chainNode.expression = element;
							element = this.finishNode(chainNode, "ChainExpression");
						}
						return element;
					}
					base = element;
				}
			};
			pp$5.shouldParseAsyncArrow = function () {
				return !this.canInsertSemicolon() && this.eat(types$1.arrow);
			};
			pp$5.parseSubscriptAsyncArrow = function (startPos, startLoc, exprList, forInit) {
				return this.parseArrowExpression(
					this.startNodeAt(startPos, startLoc),
					exprList,
					true,
					forInit,
				);
			};
			pp$5.parseSubscript = function (
				base,
				startPos,
				startLoc,
				noCalls,
				maybeAsyncArrow,
				optionalChained,
				forInit,
			) {
				var optionalSupported = this.options.ecmaVersion >= 11;
				var optional = optionalSupported && this.eat(types$1.questionDot);
				if (noCalls && optional) {
					this.raise(
						this.lastTokStart,
						"Optional chaining cannot appear in the callee of new expressions",
					);
				}
				var computed = this.eat(types$1.bracketL);
				if (
					computed ||
					(optional && this.type !== types$1.parenL && this.type !== types$1.backQuote) ||
					this.eat(types$1.dot)
				) {
					var node = this.startNodeAt(startPos, startLoc);
					node.object = base;
					if (computed) {
						node.property = this.parseExpression();
						this.expect(types$1.bracketR);
					} else if (this.type === types$1.privateId && base.type !== "Super") {
						node.property = this.parsePrivateIdent();
					} else {
						node.property = this.parseIdent(this.options.allowReserved !== "never");
					}
					node.computed = !!computed;
					if (optionalSupported) {
						node.optional = optional;
					}
					base = this.finishNode(node, "MemberExpression");
				} else if (!noCalls && this.eat(types$1.parenL)) {
					var refDestructuringErrors = new DestructuringErrors(),
						oldYieldPos = this.yieldPos,
						oldAwaitPos = this.awaitPos,
						oldAwaitIdentPos = this.awaitIdentPos;
					this.yieldPos = 0;
					this.awaitPos = 0;
					this.awaitIdentPos = 0;
					var exprList = this.parseExprList(
						types$1.parenR,
						this.options.ecmaVersion >= 8,
						false,
						refDestructuringErrors,
					);
					if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
						this.checkPatternErrors(refDestructuringErrors, false);
						this.checkYieldAwaitInDefaultParams();
						if (this.awaitIdentPos > 0) {
							this.raise(
								this.awaitIdentPos,
								"Cannot use 'await' as identifier inside an async function",
							);
						}
						this.yieldPos = oldYieldPos;
						this.awaitPos = oldAwaitPos;
						this.awaitIdentPos = oldAwaitIdentPos;
						return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
					}
					this.checkExpressionErrors(refDestructuringErrors, true);
					this.yieldPos = oldYieldPos || this.yieldPos;
					this.awaitPos = oldAwaitPos || this.awaitPos;
					this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
					var node$1 = this.startNodeAt(startPos, startLoc);
					node$1.callee = base;
					node$1.arguments = exprList;
					if (optionalSupported) {
						node$1.optional = optional;
					}
					base = this.finishNode(node$1, "CallExpression");
				} else if (this.type === types$1.backQuote) {
					if (optional || optionalChained) {
						this.raise(
							this.start,
							"Optional chaining cannot appear in the tag of tagged template expressions",
						);
					}
					var node$2 = this.startNodeAt(startPos, startLoc);
					node$2.tag = base;
					node$2.quasi = this.parseTemplate({ isTagged: true });
					base = this.finishNode(node$2, "TaggedTemplateExpression");
				}
				return base;
			};
			pp$5.parseExprAtom = function (refDestructuringErrors, forInit, forNew) {
				if (this.type === types$1.slash) {
					this.readRegexp();
				}
				var node,
					canBeArrow = this.potentialArrowAt === this.start;
				switch (this.type) {
					case types$1._super:
						if (!this.allowSuper) {
							this.raise(this.start, "'super' keyword outside a method");
						}
						node = this.startNode();
						this.next();
						if (this.type === types$1.parenL && !this.allowDirectSuper) {
							this.raise(
								node.start,
								"super() call outside constructor of a subclass",
							);
						}
						if (
							this.type !== types$1.dot &&
							this.type !== types$1.bracketL &&
							this.type !== types$1.parenL
						) {
							this.unexpected();
						}
						return this.finishNode(node, "Super");
					case types$1._this:
						node = this.startNode();
						this.next();
						return this.finishNode(node, "ThisExpression");
					case types$1.name:
						var startPos = this.start,
							startLoc = this.startLoc,
							containsEsc = this.containsEsc;
						var id = this.parseIdent(false);
						if (
							this.options.ecmaVersion >= 8 &&
							!containsEsc &&
							id.name === "async" &&
							!this.canInsertSemicolon() &&
							this.eat(types$1._function)
						) {
							this.overrideContext(types.f_expr);
							return this.parseFunction(
								this.startNodeAt(startPos, startLoc),
								0,
								false,
								true,
								forInit,
							);
						}
						if (canBeArrow && !this.canInsertSemicolon()) {
							if (this.eat(types$1.arrow)) {
								return this.parseArrowExpression(
									this.startNodeAt(startPos, startLoc),
									[id],
									false,
									forInit,
								);
							}
							if (
								this.options.ecmaVersion >= 8 &&
								id.name === "async" &&
								this.type === types$1.name &&
								!containsEsc &&
								(!this.potentialArrowInForAwait ||
									this.value !== "of" ||
									this.containsEsc)
							) {
								id = this.parseIdent(false);
								if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
									this.unexpected();
								}
								return this.parseArrowExpression(
									this.startNodeAt(startPos, startLoc),
									[id],
									true,
									forInit,
								);
							}
						}
						return id;
					case types$1.regexp:
						var value = this.value;
						node = this.parseLiteral(value.value);
						node.regex = { pattern: value.pattern, flags: value.flags };
						return node;
					case types$1.num:
					case types$1.string:
						return this.parseLiteral(this.value);
					case types$1._null:
					case types$1._true:
					case types$1._false:
						node = this.startNode();
						node.value =
							this.type === types$1._null ? null : this.type === types$1._true;
						node.raw = this.type.keyword;
						this.next();
						return this.finishNode(node, "Literal");
					case types$1.parenL:
						var start = this.start,
							expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
						if (refDestructuringErrors) {
							if (
								refDestructuringErrors.parenthesizedAssign < 0 &&
								!this.isSimpleAssignTarget(expr)
							) {
								refDestructuringErrors.parenthesizedAssign = start;
							}
							if (refDestructuringErrors.parenthesizedBind < 0) {
								refDestructuringErrors.parenthesizedBind = start;
							}
						}
						return expr;
					case types$1.bracketL:
						node = this.startNode();
						this.next();
						node.elements = this.parseExprList(
							types$1.bracketR,
							true,
							true,
							refDestructuringErrors,
						);
						return this.finishNode(node, "ArrayExpression");
					case types$1.braceL:
						this.overrideContext(types.b_expr);
						return this.parseObj(false, refDestructuringErrors);
					case types$1._function:
						node = this.startNode();
						this.next();
						return this.parseFunction(node, 0);
					case types$1._class:
						return this.parseClass(this.startNode(), false);
					case types$1._new:
						return this.parseNew();
					case types$1.backQuote:
						return this.parseTemplate();
					case types$1._import:
						if (this.options.ecmaVersion >= 11) {
							return this.parseExprImport(forNew);
						} else {
							return this.unexpected();
						}
					default:
						return this.parseExprAtomDefault();
				}
			};
			pp$5.parseExprAtomDefault = function () {
				this.unexpected();
			};
			pp$5.parseExprImport = function (forNew) {
				var node = this.startNode();
				if (this.containsEsc) {
					this.raiseRecoverable(this.start, "Escape sequence in keyword import");
				}
				this.next();
				if (this.type === types$1.parenL && !forNew) {
					return this.parseDynamicImport(node);
				} else if (this.type === types$1.dot) {
					var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
					meta.name = "import";
					node.meta = this.finishNode(meta, "Identifier");
					return this.parseImportMeta(node);
				} else {
					this.unexpected();
				}
			};
			pp$5.parseDynamicImport = function (node) {
				this.next();
				node.source = this.parseMaybeAssign();
				if (this.options.ecmaVersion >= 16) {
					if (!this.eat(types$1.parenR)) {
						this.expect(types$1.comma);
						if (!this.afterTrailingComma(types$1.parenR)) {
							node.options = this.parseMaybeAssign();
							if (!this.eat(types$1.parenR)) {
								this.expect(types$1.comma);
								if (!this.afterTrailingComma(types$1.parenR)) {
									this.unexpected();
								}
							}
						} else {
							node.options = null;
						}
					} else {
						node.options = null;
					}
				} else {
					if (!this.eat(types$1.parenR)) {
						var errorPos = this.start;
						if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
							this.raiseRecoverable(
								errorPos,
								"Trailing comma is not allowed in import()",
							);
						} else {
							this.unexpected(errorPos);
						}
					}
				}
				return this.finishNode(node, "ImportExpression");
			};
			pp$5.parseImportMeta = function (node) {
				this.next();
				var containsEsc = this.containsEsc;
				node.property = this.parseIdent(true);
				if (node.property.name !== "meta") {
					this.raiseRecoverable(
						node.property.start,
						"The only valid meta property for import is 'import.meta'",
					);
				}
				if (containsEsc) {
					this.raiseRecoverable(
						node.start,
						"'import.meta' must not contain escaped characters",
					);
				}
				if (
					this.options.sourceType !== "module" &&
					!this.options.allowImportExportEverywhere
				) {
					this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
				}
				return this.finishNode(node, "MetaProperty");
			};
			pp$5.parseLiteral = function (value) {
				var node = this.startNode();
				node.value = value;
				node.raw = this.input.slice(this.start, this.end);
				if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
					node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
				}
				this.next();
				return this.finishNode(node, "Literal");
			};
			pp$5.parseParenExpression = function () {
				this.expect(types$1.parenL);
				var val = this.parseExpression();
				this.expect(types$1.parenR);
				return val;
			};
			pp$5.shouldParseArrow = function (exprList) {
				return !this.canInsertSemicolon();
			};
			pp$5.parseParenAndDistinguishExpression = function (canBeArrow, forInit) {
				var startPos = this.start,
					startLoc = this.startLoc,
					val,
					allowTrailingComma = this.options.ecmaVersion >= 8;
				if (this.options.ecmaVersion >= 6) {
					this.next();
					var innerStartPos = this.start,
						innerStartLoc = this.startLoc;
					var exprList = [],
						first = true,
						lastIsComma = false;
					var refDestructuringErrors = new DestructuringErrors(),
						oldYieldPos = this.yieldPos,
						oldAwaitPos = this.awaitPos,
						spreadStart;
					this.yieldPos = 0;
					this.awaitPos = 0;
					while (this.type !== types$1.parenR) {
						first ? (first = false) : this.expect(types$1.comma);
						if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
							lastIsComma = true;
							break;
						} else if (this.type === types$1.ellipsis) {
							spreadStart = this.start;
							exprList.push(this.parseParenItem(this.parseRestBinding()));
							if (this.type === types$1.comma) {
								this.raiseRecoverable(
									this.start,
									"Comma is not permitted after the rest element",
								);
							}
							break;
						} else {
							exprList.push(
								this.parseMaybeAssign(
									false,
									refDestructuringErrors,
									this.parseParenItem,
								),
							);
						}
					}
					var innerEndPos = this.lastTokEnd,
						innerEndLoc = this.lastTokEndLoc;
					this.expect(types$1.parenR);
					if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
						this.checkPatternErrors(refDestructuringErrors, false);
						this.checkYieldAwaitInDefaultParams();
						this.yieldPos = oldYieldPos;
						this.awaitPos = oldAwaitPos;
						return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
					}
					if (!exprList.length || lastIsComma) {
						this.unexpected(this.lastTokStart);
					}
					if (spreadStart) {
						this.unexpected(spreadStart);
					}
					this.checkExpressionErrors(refDestructuringErrors, true);
					this.yieldPos = oldYieldPos || this.yieldPos;
					this.awaitPos = oldAwaitPos || this.awaitPos;
					if (exprList.length > 1) {
						val = this.startNodeAt(innerStartPos, innerStartLoc);
						val.expressions = exprList;
						this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
					} else {
						val = exprList[0];
					}
				} else {
					val = this.parseParenExpression();
				}
				if (this.options.preserveParens) {
					var par = this.startNodeAt(startPos, startLoc);
					par.expression = val;
					return this.finishNode(par, "ParenthesizedExpression");
				} else {
					return val;
				}
			};
			pp$5.parseParenItem = function (item) {
				return item;
			};
			pp$5.parseParenArrowList = function (startPos, startLoc, exprList, forInit) {
				return this.parseArrowExpression(
					this.startNodeAt(startPos, startLoc),
					exprList,
					false,
					forInit,
				);
			};
			var empty = [];
			pp$5.parseNew = function () {
				if (this.containsEsc) {
					this.raiseRecoverable(this.start, "Escape sequence in keyword new");
				}
				var node = this.startNode();
				this.next();
				if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
					var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
					meta.name = "new";
					node.meta = this.finishNode(meta, "Identifier");
					this.next();
					var containsEsc = this.containsEsc;
					node.property = this.parseIdent(true);
					if (node.property.name !== "target") {
						this.raiseRecoverable(
							node.property.start,
							"The only valid meta property for new is 'new.target'",
						);
					}
					if (containsEsc) {
						this.raiseRecoverable(
							node.start,
							"'new.target' must not contain escaped characters",
						);
					}
					if (!this.allowNewDotTarget) {
						this.raiseRecoverable(
							node.start,
							"'new.target' can only be used in functions and class static block",
						);
					}
					return this.finishNode(node, "MetaProperty");
				}
				var startPos = this.start,
					startLoc = this.startLoc;
				node.callee = this.parseSubscripts(
					this.parseExprAtom(null, false, true),
					startPos,
					startLoc,
					true,
					false,
				);
				if (this.eat(types$1.parenL)) {
					node.arguments = this.parseExprList(
						types$1.parenR,
						this.options.ecmaVersion >= 8,
						false,
					);
				} else {
					node.arguments = empty;
				}
				return this.finishNode(node, "NewExpression");
			};
			pp$5.parseTemplateElement = function (ref2) {
				var isTagged = ref2.isTagged;
				var elem = this.startNode();
				if (this.type === types$1.invalidTemplate) {
					if (!isTagged) {
						this.raiseRecoverable(
							this.start,
							"Bad escape sequence in untagged template literal",
						);
					}
					elem.value = {
						raw: this.value.replace(/\r\n?/g, "\n"),
						cooked: null,
					};
				} else {
					elem.value = {
						raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
						cooked: this.value,
					};
				}
				this.next();
				elem.tail = this.type === types$1.backQuote;
				return this.finishNode(elem, "TemplateElement");
			};
			pp$5.parseTemplate = function (ref2) {
				if (ref2 === void 0) ref2 = {};
				var isTagged = ref2.isTagged;
				if (isTagged === void 0) isTagged = false;
				var node = this.startNode();
				this.next();
				node.expressions = [];
				var curElt = this.parseTemplateElement({ isTagged });
				node.quasis = [curElt];
				while (!curElt.tail) {
					if (this.type === types$1.eof) {
						this.raise(this.pos, "Unterminated template literal");
					}
					this.expect(types$1.dollarBraceL);
					node.expressions.push(this.parseExpression());
					this.expect(types$1.braceR);
					node.quasis.push((curElt = this.parseTemplateElement({ isTagged })));
				}
				this.next();
				return this.finishNode(node, "TemplateLiteral");
			};
			pp$5.isAsyncProp = function (prop) {
				return (
					!prop.computed &&
					prop.key.type === "Identifier" &&
					prop.key.name === "async" &&
					(this.type === types$1.name ||
						this.type === types$1.num ||
						this.type === types$1.string ||
						this.type === types$1.bracketL ||
						this.type.keyword ||
						(this.options.ecmaVersion >= 9 && this.type === types$1.star)) &&
					!lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
				);
			};
			pp$5.parseObj = function (isPattern, refDestructuringErrors) {
				var node = this.startNode(),
					first = true,
					propHash = {};
				node.properties = [];
				this.next();
				while (!this.eat(types$1.braceR)) {
					if (!first) {
						this.expect(types$1.comma);
						if (
							this.options.ecmaVersion >= 5 &&
							this.afterTrailingComma(types$1.braceR)
						) {
							break;
						}
					} else {
						first = false;
					}
					var prop = this.parseProperty(isPattern, refDestructuringErrors);
					if (!isPattern) {
						this.checkPropClash(prop, propHash, refDestructuringErrors);
					}
					node.properties.push(prop);
				}
				return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
			};
			pp$5.parseProperty = function (isPattern, refDestructuringErrors) {
				var prop = this.startNode(),
					isGenerator,
					isAsync,
					startPos,
					startLoc;
				if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
					if (isPattern) {
						prop.argument = this.parseIdent(false);
						if (this.type === types$1.comma) {
							this.raiseRecoverable(
								this.start,
								"Comma is not permitted after the rest element",
							);
						}
						return this.finishNode(prop, "RestElement");
					}
					prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
					if (
						this.type === types$1.comma &&
						refDestructuringErrors &&
						refDestructuringErrors.trailingComma < 0
					) {
						refDestructuringErrors.trailingComma = this.start;
					}
					return this.finishNode(prop, "SpreadElement");
				}
				if (this.options.ecmaVersion >= 6) {
					prop.method = false;
					prop.shorthand = false;
					if (isPattern || refDestructuringErrors) {
						startPos = this.start;
						startLoc = this.startLoc;
					}
					if (!isPattern) {
						isGenerator = this.eat(types$1.star);
					}
				}
				var containsEsc = this.containsEsc;
				this.parsePropertyName(prop);
				if (
					!isPattern &&
					!containsEsc &&
					this.options.ecmaVersion >= 8 &&
					!isGenerator &&
					this.isAsyncProp(prop)
				) {
					isAsync = true;
					isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
					this.parsePropertyName(prop);
				} else {
					isAsync = false;
				}
				this.parsePropertyValue(
					prop,
					isPattern,
					isGenerator,
					isAsync,
					startPos,
					startLoc,
					refDestructuringErrors,
					containsEsc,
				);
				return this.finishNode(prop, "Property");
			};
			pp$5.parseGetterSetter = function (prop) {
				prop.kind = prop.key.name;
				this.parsePropertyName(prop);
				prop.value = this.parseMethod(false);
				var paramCount = prop.kind === "get" ? 0 : 1;
				if (prop.value.params.length !== paramCount) {
					var start = prop.value.start;
					if (prop.kind === "get") {
						this.raiseRecoverable(start, "getter should have no params");
					} else {
						this.raiseRecoverable(start, "setter should have exactly one param");
					}
				} else {
					if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
						this.raiseRecoverable(
							prop.value.params[0].start,
							"Setter cannot use rest params",
						);
					}
				}
			};
			pp$5.parsePropertyValue = function (
				prop,
				isPattern,
				isGenerator,
				isAsync,
				startPos,
				startLoc,
				refDestructuringErrors,
				containsEsc,
			) {
				if ((isGenerator || isAsync) && this.type === types$1.colon) {
					this.unexpected();
				}
				if (this.eat(types$1.colon)) {
					prop.value = isPattern
						? this.parseMaybeDefault(this.start, this.startLoc)
						: this.parseMaybeAssign(false, refDestructuringErrors);
					prop.kind = "init";
				} else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
					if (isPattern) {
						this.unexpected();
					}
					prop.kind = "init";
					prop.method = true;
					prop.value = this.parseMethod(isGenerator, isAsync);
				} else if (
					!isPattern &&
					!containsEsc &&
					this.options.ecmaVersion >= 5 &&
					!prop.computed &&
					prop.key.type === "Identifier" &&
					(prop.key.name === "get" || prop.key.name === "set") &&
					this.type !== types$1.comma &&
					this.type !== types$1.braceR &&
					this.type !== types$1.eq
				) {
					if (isGenerator || isAsync) {
						this.unexpected();
					}
					this.parseGetterSetter(prop);
				} else if (
					this.options.ecmaVersion >= 6 &&
					!prop.computed &&
					prop.key.type === "Identifier"
				) {
					if (isGenerator || isAsync) {
						this.unexpected();
					}
					this.checkUnreserved(prop.key);
					if (prop.key.name === "await" && !this.awaitIdentPos) {
						this.awaitIdentPos = startPos;
					}
					prop.kind = "init";
					if (isPattern) {
						prop.value = this.parseMaybeDefault(
							startPos,
							startLoc,
							this.copyNode(prop.key),
						);
					} else if (this.type === types$1.eq && refDestructuringErrors) {
						if (refDestructuringErrors.shorthandAssign < 0) {
							refDestructuringErrors.shorthandAssign = this.start;
						}
						prop.value = this.parseMaybeDefault(
							startPos,
							startLoc,
							this.copyNode(prop.key),
						);
					} else {
						prop.value = this.copyNode(prop.key);
					}
					prop.shorthand = true;
				} else {
					this.unexpected();
				}
			};
			pp$5.parsePropertyName = function (prop) {
				if (this.options.ecmaVersion >= 6) {
					if (this.eat(types$1.bracketL)) {
						prop.computed = true;
						prop.key = this.parseMaybeAssign();
						this.expect(types$1.bracketR);
						return prop.key;
					} else {
						prop.computed = false;
					}
				}
				return (prop.key =
					this.type === types$1.num || this.type === types$1.string
						? this.parseExprAtom()
						: this.parseIdent(this.options.allowReserved !== "never"));
			};
			pp$5.initFunction = function (node) {
				node.id = null;
				if (this.options.ecmaVersion >= 6) {
					node.generator = node.expression = false;
				}
				if (this.options.ecmaVersion >= 8) {
					node.async = false;
				}
			};
			pp$5.parseMethod = function (isGenerator, isAsync, allowDirectSuper) {
				var node = this.startNode(),
					oldYieldPos = this.yieldPos,
					oldAwaitPos = this.awaitPos,
					oldAwaitIdentPos = this.awaitIdentPos;
				this.initFunction(node);
				if (this.options.ecmaVersion >= 6) {
					node.generator = isGenerator;
				}
				if (this.options.ecmaVersion >= 8) {
					node.async = !!isAsync;
				}
				this.yieldPos = 0;
				this.awaitPos = 0;
				this.awaitIdentPos = 0;
				this.enterScope(
					functionFlags(isAsync, node.generator) |
						SCOPE_SUPER |
						(allowDirectSuper ? SCOPE_DIRECT_SUPER : 0),
				);
				this.expect(types$1.parenL);
				node.params = this.parseBindingList(
					types$1.parenR,
					false,
					this.options.ecmaVersion >= 8,
				);
				this.checkYieldAwaitInDefaultParams();
				this.parseFunctionBody(node, false, true, false);
				this.yieldPos = oldYieldPos;
				this.awaitPos = oldAwaitPos;
				this.awaitIdentPos = oldAwaitIdentPos;
				return this.finishNode(node, "FunctionExpression");
			};
			pp$5.parseArrowExpression = function (node, params, isAsync, forInit) {
				var oldYieldPos = this.yieldPos,
					oldAwaitPos = this.awaitPos,
					oldAwaitIdentPos = this.awaitIdentPos;
				this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
				this.initFunction(node);
				if (this.options.ecmaVersion >= 8) {
					node.async = !!isAsync;
				}
				this.yieldPos = 0;
				this.awaitPos = 0;
				this.awaitIdentPos = 0;
				node.params = this.toAssignableList(params, true);
				this.parseFunctionBody(node, true, false, forInit);
				this.yieldPos = oldYieldPos;
				this.awaitPos = oldAwaitPos;
				this.awaitIdentPos = oldAwaitIdentPos;
				return this.finishNode(node, "ArrowFunctionExpression");
			};
			pp$5.parseFunctionBody = function (node, isArrowFunction, isMethod, forInit) {
				var isExpression = isArrowFunction && this.type !== types$1.braceL;
				var oldStrict = this.strict,
					useStrict = false;
				if (isExpression) {
					node.body = this.parseMaybeAssign(forInit);
					node.expression = true;
					this.checkParams(node, false);
				} else {
					var nonSimple =
						this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
					if (!oldStrict || nonSimple) {
						useStrict = this.strictDirective(this.end);
						if (useStrict && nonSimple) {
							this.raiseRecoverable(
								node.start,
								"Illegal 'use strict' directive in function with non-simple parameter list",
							);
						}
					}
					var oldLabels = this.labels;
					this.labels = [];
					if (useStrict) {
						this.strict = true;
					}
					this.checkParams(
						node,
						!oldStrict &&
							!useStrict &&
							!isArrowFunction &&
							!isMethod &&
							this.isSimpleParamList(node.params),
					);
					if (this.strict && node.id) {
						this.checkLValSimple(node.id, BIND_OUTSIDE);
					}
					node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
					node.expression = false;
					this.adaptDirectivePrologue(node.body.body);
					this.labels = oldLabels;
				}
				this.exitScope();
			};
			pp$5.isSimpleParamList = function (params) {
				for (var i2 = 0, list2 = params; i2 < list2.length; i2 += 1) {
					var param = list2[i2];
					if (param.type !== "Identifier") {
						return false;
					}
				}
				return true;
			};
			pp$5.checkParams = function (node, allowDuplicates) {
				var nameHash = /* @__PURE__ */ Object.create(null);
				for (var i2 = 0, list2 = node.params; i2 < list2.length; i2 += 1) {
					var param = list2[i2];
					this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
				}
			};
			pp$5.parseExprList = function (
				close,
				allowTrailingComma,
				allowEmpty,
				refDestructuringErrors,
			) {
				var elts = [],
					first = true;
				while (!this.eat(close)) {
					if (!first) {
						this.expect(types$1.comma);
						if (allowTrailingComma && this.afterTrailingComma(close)) {
							break;
						}
					} else {
						first = false;
					}
					var elt = void 0;
					if (allowEmpty && this.type === types$1.comma) {
						elt = null;
					} else if (this.type === types$1.ellipsis) {
						elt = this.parseSpread(refDestructuringErrors);
						if (
							refDestructuringErrors &&
							this.type === types$1.comma &&
							refDestructuringErrors.trailingComma < 0
						) {
							refDestructuringErrors.trailingComma = this.start;
						}
					} else {
						elt = this.parseMaybeAssign(false, refDestructuringErrors);
					}
					elts.push(elt);
				}
				return elts;
			};
			pp$5.checkUnreserved = function (ref2) {
				var start = ref2.start;
				var end = ref2.end;
				var name = ref2.name;
				if (this.inGenerator && name === "yield") {
					this.raiseRecoverable(
						start,
						"Cannot use 'yield' as identifier inside a generator",
					);
				}
				if (this.inAsync && name === "await") {
					this.raiseRecoverable(
						start,
						"Cannot use 'await' as identifier inside an async function",
					);
				}
				if (this.currentThisScope().inClassFieldInit && name === "arguments") {
					this.raiseRecoverable(
						start,
						"Cannot use 'arguments' in class field initializer",
					);
				}
				if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
					this.raise(
						start,
						"Cannot use " + name + " in class static initialization block",
					);
				}
				if (this.keywords.test(name)) {
					this.raise(start, "Unexpected keyword '" + name + "'");
				}
				if (
					this.options.ecmaVersion < 6 &&
					this.input.slice(start, end).indexOf("\\") !== -1
				) {
					return;
				}
				var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
				if (re.test(name)) {
					if (!this.inAsync && name === "await") {
						this.raiseRecoverable(
							start,
							"Cannot use keyword 'await' outside an async function",
						);
					}
					this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
				}
			};
			pp$5.parseIdent = function (liberal) {
				var node = this.parseIdentNode();
				this.next(!!liberal);
				this.finishNode(node, "Identifier");
				if (!liberal) {
					this.checkUnreserved(node);
					if (node.name === "await" && !this.awaitIdentPos) {
						this.awaitIdentPos = node.start;
					}
				}
				return node;
			};
			pp$5.parseIdentNode = function () {
				var node = this.startNode();
				if (this.type === types$1.name) {
					node.name = this.value;
				} else if (this.type.keyword) {
					node.name = this.type.keyword;
					if (
						(node.name === "class" || node.name === "function") &&
						(this.lastTokEnd !== this.lastTokStart + 1 ||
							this.input.charCodeAt(this.lastTokStart) !== 46)
					) {
						this.context.pop();
					}
					this.type = types$1.name;
				} else {
					this.unexpected();
				}
				return node;
			};
			pp$5.parsePrivateIdent = function () {
				var node = this.startNode();
				if (this.type === types$1.privateId) {
					node.name = this.value;
				} else {
					this.unexpected();
				}
				this.next();
				this.finishNode(node, "PrivateIdentifier");
				if (this.options.checkPrivateFields) {
					if (this.privateNameStack.length === 0) {
						this.raise(
							node.start,
							"Private field '#" +
								node.name +
								"' must be declared in an enclosing class",
						);
					} else {
						this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
					}
				}
				return node;
			};
			pp$5.parseYield = function (forInit) {
				if (!this.yieldPos) {
					this.yieldPos = this.start;
				}
				var node = this.startNode();
				this.next();
				if (
					this.type === types$1.semi ||
					this.canInsertSemicolon() ||
					(this.type !== types$1.star && !this.type.startsExpr)
				) {
					node.delegate = false;
					node.argument = null;
				} else {
					node.delegate = this.eat(types$1.star);
					node.argument = this.parseMaybeAssign(forInit);
				}
				return this.finishNode(node, "YieldExpression");
			};
			pp$5.parseAwait = function (forInit) {
				if (!this.awaitPos) {
					this.awaitPos = this.start;
				}
				var node = this.startNode();
				this.next();
				node.argument = this.parseMaybeUnary(null, true, false, forInit);
				return this.finishNode(node, "AwaitExpression");
			};
			var pp$4 = Parser.prototype;
			pp$4.raise = function (pos, message) {
				var loc = getLineInfo(this.input, pos);
				message += " (" + loc.line + ":" + loc.column + ")";
				var err = new SyntaxError(message);
				err.pos = pos;
				err.loc = loc;
				err.raisedAt = this.pos;
				throw err;
			};
			pp$4.raiseRecoverable = pp$4.raise;
			pp$4.curPosition = function () {
				if (this.options.locations) {
					return new Position(this.curLine, this.pos - this.lineStart);
				}
			};
			var pp$3 = Parser.prototype;
			var Scope = function Scope2(flags) {
				this.flags = flags;
				this.var = [];
				this.lexical = [];
				this.functions = [];
				this.inClassFieldInit = false;
			};
			pp$3.enterScope = function (flags) {
				this.scopeStack.push(new Scope(flags));
			};
			pp$3.exitScope = function () {
				this.scopeStack.pop();
			};
			pp$3.treatFunctionsAsVarInScope = function (scope) {
				return scope.flags & SCOPE_FUNCTION || (!this.inModule && scope.flags & SCOPE_TOP);
			};
			pp$3.declareName = function (name, bindingType, pos) {
				var redeclared = false;
				if (bindingType === BIND_LEXICAL) {
					var scope = this.currentScope();
					redeclared =
						scope.lexical.indexOf(name) > -1 ||
						scope.functions.indexOf(name) > -1 ||
						scope.var.indexOf(name) > -1;
					scope.lexical.push(name);
					if (this.inModule && scope.flags & SCOPE_TOP) {
						delete this.undefinedExports[name];
					}
				} else if (bindingType === BIND_SIMPLE_CATCH) {
					var scope$1 = this.currentScope();
					scope$1.lexical.push(name);
				} else if (bindingType === BIND_FUNCTION) {
					var scope$2 = this.currentScope();
					if (this.treatFunctionsAsVar) {
						redeclared = scope$2.lexical.indexOf(name) > -1;
					} else {
						redeclared =
							scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
					}
					scope$2.functions.push(name);
				} else {
					for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
						var scope$3 = this.scopeStack[i2];
						if (
							(scope$3.lexical.indexOf(name) > -1 &&
								!(
									scope$3.flags & SCOPE_SIMPLE_CATCH &&
									scope$3.lexical[0] === name
								)) ||
							(!this.treatFunctionsAsVarInScope(scope$3) &&
								scope$3.functions.indexOf(name) > -1)
						) {
							redeclared = true;
							break;
						}
						scope$3.var.push(name);
						if (this.inModule && scope$3.flags & SCOPE_TOP) {
							delete this.undefinedExports[name];
						}
						if (scope$3.flags & SCOPE_VAR) {
							break;
						}
					}
				}
				if (redeclared) {
					this.raiseRecoverable(
						pos,
						"Identifier '" + name + "' has already been declared",
					);
				}
			};
			pp$3.checkLocalExport = function (id) {
				if (
					this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
					this.scopeStack[0].var.indexOf(id.name) === -1
				) {
					this.undefinedExports[id.name] = id;
				}
			};
			pp$3.currentScope = function () {
				return this.scopeStack[this.scopeStack.length - 1];
			};
			pp$3.currentVarScope = function () {
				for (var i2 = this.scopeStack.length - 1; ; i2--) {
					var scope = this.scopeStack[i2];
					if (scope.flags & SCOPE_VAR) {
						return scope;
					}
				}
			};
			pp$3.currentThisScope = function () {
				for (var i2 = this.scopeStack.length - 1; ; i2--) {
					var scope = this.scopeStack[i2];
					if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
						return scope;
					}
				}
			};
			var Node = function Node2(parser, pos, loc) {
				this.type = "";
				this.start = pos;
				this.end = 0;
				if (parser.options.locations) {
					this.loc = new SourceLocation(parser, loc);
				}
				if (parser.options.directSourceFile) {
					this.sourceFile = parser.options.directSourceFile;
				}
				if (parser.options.ranges) {
					this.range = [pos, 0];
				}
			};
			var pp$2 = Parser.prototype;
			pp$2.startNode = function () {
				return new Node(this, this.start, this.startLoc);
			};
			pp$2.startNodeAt = function (pos, loc) {
				return new Node(this, pos, loc);
			};
			function finishNodeAt(node, type, pos, loc) {
				node.type = type;
				node.end = pos;
				if (this.options.locations) {
					node.loc.end = loc;
				}
				if (this.options.ranges) {
					node.range[1] = pos;
				}
				return node;
			}
			pp$2.finishNode = function (node, type) {
				return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
			};
			pp$2.finishNodeAt = function (node, type, pos, loc) {
				return finishNodeAt.call(this, node, type, pos, loc);
			};
			pp$2.copyNode = function (node) {
				var newNode = new Node(this, node.start, this.startLoc);
				for (var prop in node) {
					newNode[prop] = node[prop];
				}
				return newNode;
			};
			var scriptValuesAddedInUnicode =
				"Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
			var ecma9BinaryProperties =
				"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
			var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
			var ecma11BinaryProperties = ecma10BinaryProperties;
			var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
			var ecma13BinaryProperties = ecma12BinaryProperties;
			var ecma14BinaryProperties = ecma13BinaryProperties;
			var unicodeBinaryProperties = {
				9: ecma9BinaryProperties,
				10: ecma10BinaryProperties,
				11: ecma11BinaryProperties,
				12: ecma12BinaryProperties,
				13: ecma13BinaryProperties,
				14: ecma14BinaryProperties,
			};
			var ecma14BinaryPropertiesOfStrings =
				"Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
			var unicodeBinaryPropertiesOfStrings = {
				9: "",
				10: "",
				11: "",
				12: "",
				13: "",
				14: ecma14BinaryPropertiesOfStrings,
			};
			var unicodeGeneralCategoryValues =
				"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
			var ecma9ScriptValues =
				"Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
			var ecma10ScriptValues =
				ecma9ScriptValues +
				" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
			var ecma11ScriptValues =
				ecma10ScriptValues +
				" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
			var ecma12ScriptValues =
				ecma11ScriptValues +
				" Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
			var ecma13ScriptValues =
				ecma12ScriptValues +
				" Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
			var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
			var unicodeScriptValues = {
				9: ecma9ScriptValues,
				10: ecma10ScriptValues,
				11: ecma11ScriptValues,
				12: ecma12ScriptValues,
				13: ecma13ScriptValues,
				14: ecma14ScriptValues,
			};
			var data = {};
			function buildUnicodeData(ecmaVersion2) {
				var d = (data[ecmaVersion2] = {
					binary: wordsRegexp(
						unicodeBinaryProperties[ecmaVersion2] + " " + unicodeGeneralCategoryValues,
					),
					binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion2]),
					nonBinary: {
						General_Category: wordsRegexp(unicodeGeneralCategoryValues),
						Script: wordsRegexp(unicodeScriptValues[ecmaVersion2]),
					},
				});
				d.nonBinary.Script_Extensions = d.nonBinary.Script;
				d.nonBinary.gc = d.nonBinary.General_Category;
				d.nonBinary.sc = d.nonBinary.Script;
				d.nonBinary.scx = d.nonBinary.Script_Extensions;
			}
			for (var i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {
				var ecmaVersion = list[i];
				buildUnicodeData(ecmaVersion);
			}
			var pp$1 = Parser.prototype;
			var BranchID = function BranchID2(parent, base) {
				this.parent = parent;
				this.base = base || this;
			};
			BranchID.prototype.separatedFrom = function separatedFrom(alt) {
				for (var self2 = this; self2; self2 = self2.parent) {
					for (var other = alt; other; other = other.parent) {
						if (self2.base === other.base && self2 !== other) {
							return true;
						}
					}
				}
				return false;
			};
			BranchID.prototype.sibling = function sibling() {
				return new BranchID(this.parent, this.base);
			};
			var RegExpValidationState = function RegExpValidationState2(parser) {
				this.parser = parser;
				this.validFlags =
					"gim" +
					(parser.options.ecmaVersion >= 6 ? "uy" : "") +
					(parser.options.ecmaVersion >= 9 ? "s" : "") +
					(parser.options.ecmaVersion >= 13 ? "d" : "") +
					(parser.options.ecmaVersion >= 15 ? "v" : "");
				this.unicodeProperties =
					data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
				this.source = "";
				this.flags = "";
				this.start = 0;
				this.switchU = false;
				this.switchV = false;
				this.switchN = false;
				this.pos = 0;
				this.lastIntValue = 0;
				this.lastStringValue = "";
				this.lastAssertionIsQuantifiable = false;
				this.numCapturingParens = 0;
				this.maxBackReference = 0;
				this.groupNames = /* @__PURE__ */ Object.create(null);
				this.backReferenceNames = [];
				this.branchID = null;
			};
			RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
				var unicodeSets = flags.indexOf("v") !== -1;
				var unicode = flags.indexOf("u") !== -1;
				this.start = start | 0;
				this.source = pattern + "";
				this.flags = flags;
				if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
					this.switchU = true;
					this.switchV = true;
					this.switchN = true;
				} else {
					this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
					this.switchV = false;
					this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
				}
			};
			RegExpValidationState.prototype.raise = function raise(message) {
				this.parser.raiseRecoverable(
					this.start,
					"Invalid regular expression: /" + this.source + "/: " + message,
				);
			};
			RegExpValidationState.prototype.at = function at(i2, forceU) {
				if (forceU === void 0) forceU = false;
				var s = this.source;
				var l = s.length;
				if (i2 >= l) {
					return -1;
				}
				var c = s.charCodeAt(i2);
				if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l) {
					return c;
				}
				var next = s.charCodeAt(i2 + 1);
				return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
			};
			RegExpValidationState.prototype.nextIndex = function nextIndex(i2, forceU) {
				if (forceU === void 0) forceU = false;
				var s = this.source;
				var l = s.length;
				if (i2 >= l) {
					return l;
				}
				var c = s.charCodeAt(i2),
					next;
				if (
					!(forceU || this.switchU) ||
					c <= 55295 ||
					c >= 57344 ||
					i2 + 1 >= l ||
					(next = s.charCodeAt(i2 + 1)) < 56320 ||
					next > 57343
				) {
					return i2 + 1;
				}
				return i2 + 2;
			};
			RegExpValidationState.prototype.current = function current(forceU) {
				if (forceU === void 0) forceU = false;
				return this.at(this.pos, forceU);
			};
			RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
				if (forceU === void 0) forceU = false;
				return this.at(this.nextIndex(this.pos, forceU), forceU);
			};
			RegExpValidationState.prototype.advance = function advance(forceU) {
				if (forceU === void 0) forceU = false;
				this.pos = this.nextIndex(this.pos, forceU);
			};
			RegExpValidationState.prototype.eat = function eat(ch, forceU) {
				if (forceU === void 0) forceU = false;
				if (this.current(forceU) === ch) {
					this.advance(forceU);
					return true;
				}
				return false;
			};
			RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
				if (forceU === void 0) forceU = false;
				var pos = this.pos;
				for (var i2 = 0, list2 = chs; i2 < list2.length; i2 += 1) {
					var ch = list2[i2];
					var current = this.at(pos, forceU);
					if (current === -1 || current !== ch) {
						return false;
					}
					pos = this.nextIndex(pos, forceU);
				}
				this.pos = pos;
				return true;
			};
			pp$1.validateRegExpFlags = function (state) {
				var validFlags = state.validFlags;
				var flags = state.flags;
				var u = false;
				var v = false;
				for (var i2 = 0; i2 < flags.length; i2++) {
					var flag = flags.charAt(i2);
					if (validFlags.indexOf(flag) === -1) {
						this.raise(state.start, "Invalid regular expression flag");
					}
					if (flags.indexOf(flag, i2 + 1) > -1) {
						this.raise(state.start, "Duplicate regular expression flag");
					}
					if (flag === "u") {
						u = true;
					}
					if (flag === "v") {
						v = true;
					}
				}
				if (this.options.ecmaVersion >= 15 && u && v) {
					this.raise(state.start, "Invalid regular expression flag");
				}
			};
			function hasProp(obj) {
				for (var _ in obj) {
					return true;
				}
				return false;
			}
			pp$1.validateRegExpPattern = function (state) {
				this.regexp_pattern(state);
				if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
					state.switchN = true;
					this.regexp_pattern(state);
				}
			};
			pp$1.regexp_pattern = function (state) {
				state.pos = 0;
				state.lastIntValue = 0;
				state.lastStringValue = "";
				state.lastAssertionIsQuantifiable = false;
				state.numCapturingParens = 0;
				state.maxBackReference = 0;
				state.groupNames = /* @__PURE__ */ Object.create(null);
				state.backReferenceNames.length = 0;
				state.branchID = null;
				this.regexp_disjunction(state);
				if (state.pos !== state.source.length) {
					if (
						state.eat(
							41,
							/* ) */
						)
					) {
						state.raise("Unmatched ')'");
					}
					if (
						state.eat(
							93,
							/* ] */
						) ||
						state.eat(
							125,
							/* } */
						)
					) {
						state.raise("Lone quantifier brackets");
					}
				}
				if (state.maxBackReference > state.numCapturingParens) {
					state.raise("Invalid escape");
				}
				for (var i2 = 0, list2 = state.backReferenceNames; i2 < list2.length; i2 += 1) {
					var name = list2[i2];
					if (!state.groupNames[name]) {
						state.raise("Invalid named capture referenced");
					}
				}
			};
			pp$1.regexp_disjunction = function (state) {
				var trackDisjunction = this.options.ecmaVersion >= 16;
				if (trackDisjunction) {
					state.branchID = new BranchID(state.branchID, null);
				}
				this.regexp_alternative(state);
				while (
					state.eat(
						124,
						/* | */
					)
				) {
					if (trackDisjunction) {
						state.branchID = state.branchID.sibling();
					}
					this.regexp_alternative(state);
				}
				if (trackDisjunction) {
					state.branchID = state.branchID.parent;
				}
				if (this.regexp_eatQuantifier(state, true)) {
					state.raise("Nothing to repeat");
				}
				if (
					state.eat(
						123,
						/* { */
					)
				) {
					state.raise("Lone quantifier brackets");
				}
			};
			pp$1.regexp_alternative = function (state) {
				while (state.pos < state.source.length && this.regexp_eatTerm(state)) {}
			};
			pp$1.regexp_eatTerm = function (state) {
				if (this.regexp_eatAssertion(state)) {
					if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
						if (state.switchU) {
							state.raise("Invalid quantifier");
						}
					}
					return true;
				}
				if (
					state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)
				) {
					this.regexp_eatQuantifier(state);
					return true;
				}
				return false;
			};
			pp$1.regexp_eatAssertion = function (state) {
				var start = state.pos;
				state.lastAssertionIsQuantifiable = false;
				if (
					state.eat(
						94,
						/* ^ */
					) ||
					state.eat(
						36,
						/* $ */
					)
				) {
					return true;
				}
				if (
					state.eat(
						92,
						/* \ */
					)
				) {
					if (
						state.eat(
							66,
							/* B */
						) ||
						state.eat(
							98,
							/* b */
						)
					) {
						return true;
					}
					state.pos = start;
				}
				if (
					state.eat(
						40,
						/* ( */
					) &&
					state.eat(
						63,
						/* ? */
					)
				) {
					var lookbehind = false;
					if (this.options.ecmaVersion >= 9) {
						lookbehind = state.eat(
							60,
							/* < */
						);
					}
					if (
						state.eat(
							61,
							/* = */
						) ||
						state.eat(
							33,
							/* ! */
						)
					) {
						this.regexp_disjunction(state);
						if (
							!state.eat(
								41,
								/* ) */
							)
						) {
							state.raise("Unterminated group");
						}
						state.lastAssertionIsQuantifiable = !lookbehind;
						return true;
					}
				}
				state.pos = start;
				return false;
			};
			pp$1.regexp_eatQuantifier = function (state, noError) {
				if (noError === void 0) noError = false;
				if (this.regexp_eatQuantifierPrefix(state, noError)) {
					state.eat(
						63,
						/* ? */
					);
					return true;
				}
				return false;
			};
			pp$1.regexp_eatQuantifierPrefix = function (state, noError) {
				return (
					state.eat(
						42,
						/* * */
					) ||
					state.eat(
						43,
						/* + */
					) ||
					state.eat(
						63,
						/* ? */
					) ||
					this.regexp_eatBracedQuantifier(state, noError)
				);
			};
			pp$1.regexp_eatBracedQuantifier = function (state, noError) {
				var start = state.pos;
				if (
					state.eat(
						123,
						/* { */
					)
				) {
					var min = 0,
						max = -1;
					if (this.regexp_eatDecimalDigits(state)) {
						min = state.lastIntValue;
						if (
							state.eat(
								44,
								/* , */
							) &&
							this.regexp_eatDecimalDigits(state)
						) {
							max = state.lastIntValue;
						}
						if (
							state.eat(
								125,
								/* } */
							)
						) {
							if (max !== -1 && max < min && !noError) {
								state.raise("numbers out of order in {} quantifier");
							}
							return true;
						}
					}
					if (state.switchU && !noError) {
						state.raise("Incomplete quantifier");
					}
					state.pos = start;
				}
				return false;
			};
			pp$1.regexp_eatAtom = function (state) {
				return (
					this.regexp_eatPatternCharacters(state) ||
					state.eat(
						46,
						/* . */
					) ||
					this.regexp_eatReverseSolidusAtomEscape(state) ||
					this.regexp_eatCharacterClass(state) ||
					this.regexp_eatUncapturingGroup(state) ||
					this.regexp_eatCapturingGroup(state)
				);
			};
			pp$1.regexp_eatReverseSolidusAtomEscape = function (state) {
				var start = state.pos;
				if (
					state.eat(
						92,
						/* \ */
					)
				) {
					if (this.regexp_eatAtomEscape(state)) {
						return true;
					}
					state.pos = start;
				}
				return false;
			};
			pp$1.regexp_eatUncapturingGroup = function (state) {
				var start = state.pos;
				if (
					state.eat(
						40,
						/* ( */
					)
				) {
					if (
						state.eat(
							63,
							/* ? */
						)
					) {
						if (this.options.ecmaVersion >= 16) {
							var addModifiers = this.regexp_eatModifiers(state);
							var hasHyphen = state.eat(
								45,
								/* - */
							);
							if (addModifiers || hasHyphen) {
								for (var i2 = 0; i2 < addModifiers.length; i2++) {
									var modifier = addModifiers.charAt(i2);
									if (addModifiers.indexOf(modifier, i2 + 1) > -1) {
										state.raise("Duplicate regular expression modifiers");
									}
								}
								if (hasHyphen) {
									var removeModifiers = this.regexp_eatModifiers(state);
									if (
										!addModifiers &&
										!removeModifiers &&
										state.current() === 58
									) {
										state.raise("Invalid regular expression modifiers");
									}
									for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {
										var modifier$1 = removeModifiers.charAt(i$1);
										if (
											removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 ||
											addModifiers.indexOf(modifier$1) > -1
										) {
											state.raise("Duplicate regular expression modifiers");
										}
									}
								}
							}
						}
						if (
							state.eat(
								58,
								/* : */
							)
						) {
							this.regexp_disjunction(state);
							if (
								state.eat(
									41,
									/* ) */
								)
							) {
								return true;
							}
							state.raise("Unterminated group");
						}
					}
					state.pos = start;
				}
				return false;
			};
			pp$1.regexp_eatCapturingGroup = function (state) {
				if (
					state.eat(
						40,
						/* ( */
					)
				) {
					if (this.options.ecmaVersion >= 9) {
						this.regexp_groupSpecifier(state);
					} else if (state.current() === 63) {
						state.raise("Invalid group");
					}
					this.regexp_disjunction(state);
					if (
						state.eat(
							41,
							/* ) */
						)
					) {
						state.numCapturingParens += 1;
						return true;
					}
					state.raise("Unterminated group");
				}
				return false;
			};
			pp$1.regexp_eatModifiers = function (state) {
				var modifiers = "";
				var ch = 0;
				while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
					modifiers += codePointToString(ch);
					state.advance();
				}
				return modifiers;
			};
			function isRegularExpressionModifier(ch) {
				return ch === 105 || ch === 109 || ch === 115;
			}
			pp$1.regexp_eatExtendedAtom = function (state) {
				return (
					state.eat(
						46,
						/* . */
					) ||
					this.regexp_eatReverseSolidusAtomEscape(state) ||
					this.regexp_eatCharacterClass(state) ||
					this.regexp_eatUncapturingGroup(state) ||
					this.regexp_eatCapturingGroup(state) ||
					this.regexp_eatInvalidBracedQuantifier(state) ||
					this.regexp_eatExtendedPatternCharacter(state)
				);
			};
			pp$1.regexp_eatInvalidBracedQuantifier = function (state) {
				if (this.regexp_eatBracedQuantifier(state, true)) {
					state.raise("Nothing to repeat");
				}
				return false;
			};
			pp$1.regexp_eatSyntaxCharacter = function (state) {
				var ch = state.current();
				if (isSyntaxCharacter(ch)) {
					state.lastIntValue = ch;
					state.advance();
					return true;
				}
				return false;
			};
			function isSyntaxCharacter(ch) {
				return (
					ch === 36 ||
					(ch >= 40 && ch <= 43) ||
					ch === 46 ||
					ch === 63 ||
					(ch >= 91 && ch <= 94) ||
					(ch >= 123 && ch <= 125)
				);
			}
			pp$1.regexp_eatPatternCharacters = function (state) {
				var start = state.pos;
				var ch = 0;
				while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
					state.advance();
				}
				return state.pos !== start;
			};
			pp$1.regexp_eatExtendedPatternCharacter = function (state) {
				var ch = state.current();
				if (
					ch !== -1 &&
					ch !== 36 &&
					!(ch >= 40 && ch <= 43) &&
					ch !== 46 &&
					ch !== 63 &&
					ch !== 91 &&
					ch !== 94 &&
					ch !== 124
				) {
					state.advance();
					return true;
				}
				return false;
			};
			pp$1.regexp_groupSpecifier = function (state) {
				if (
					state.eat(
						63,
						/* ? */
					)
				) {
					if (!this.regexp_eatGroupName(state)) {
						state.raise("Invalid group");
					}
					var trackDisjunction = this.options.ecmaVersion >= 16;
					var known = state.groupNames[state.lastStringValue];
					if (known) {
						if (trackDisjunction) {
							for (var i2 = 0, list2 = known; i2 < list2.length; i2 += 1) {
								var altID = list2[i2];
								if (!altID.separatedFrom(state.branchID)) {
									state.raise("Duplicate capture group name");
								}
							}
						} else {
							state.raise("Duplicate capture group name");
						}
					}
					if (trackDisjunction) {
						(known || (state.groupNames[state.lastStringValue] = [])).push(
							state.branchID,
						);
					} else {
						state.groupNames[state.lastStringValue] = true;
					}
				}
			};
			pp$1.regexp_eatGroupName = function (state) {
				state.lastStringValue = "";
				if (
					state.eat(
						60,
						/* < */
					)
				) {
					if (
						this.regexp_eatRegExpIdentifierName(state) &&
						state.eat(
							62,
							/* > */
						)
					) {
						return true;
					}
					state.raise("Invalid capture group name");
				}
				return false;
			};
			pp$1.regexp_eatRegExpIdentifierName = function (state) {
				state.lastStringValue = "";
				if (this.regexp_eatRegExpIdentifierStart(state)) {
					state.lastStringValue += codePointToString(state.lastIntValue);
					while (this.regexp_eatRegExpIdentifierPart(state)) {
						state.lastStringValue += codePointToString(state.lastIntValue);
					}
					return true;
				}
				return false;
			};
			pp$1.regexp_eatRegExpIdentifierStart = function (state) {
				var start = state.pos;
				var forceU = this.options.ecmaVersion >= 11;
				var ch = state.current(forceU);
				state.advance(forceU);
				if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
					ch = state.lastIntValue;
				}
				if (isRegExpIdentifierStart(ch)) {
					state.lastIntValue = ch;
					return true;
				}
				state.pos = start;
				return false;
			};
			function isRegExpIdentifierStart(ch) {
				return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
			}
			pp$1.regexp_eatRegExpIdentifierPart = function (state) {
				var start = state.pos;
				var forceU = this.options.ecmaVersion >= 11;
				var ch = state.current(forceU);
				state.advance(forceU);
				if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
					ch = state.lastIntValue;
				}
				if (isRegExpIdentifierPart(ch)) {
					state.lastIntValue = ch;
					return true;
				}
				state.pos = start;
				return false;
			};
			function isRegExpIdentifierPart(ch) {
				return (
					isIdentifierChar(ch, true) ||
					ch === 36 ||
					ch === 95 ||
					ch === 8204 ||
					ch === 8205
				);
			}
			pp$1.regexp_eatAtomEscape = function (state) {
				if (
					this.regexp_eatBackReference(state) ||
					this.regexp_eatCharacterClassEscape(state) ||
					this.regexp_eatCharacterEscape(state) ||
					(state.switchN && this.regexp_eatKGroupName(state))
				) {
					return true;
				}
				if (state.switchU) {
					if (state.current() === 99) {
						state.raise("Invalid unicode escape");
					}
					state.raise("Invalid escape");
				}
				return false;
			};
			pp$1.regexp_eatBackReference = function (state) {
				var start = state.pos;
				if (this.regexp_eatDecimalEscape(state)) {
					var n = state.lastIntValue;
					if (state.switchU) {
						if (n > state.maxBackReference) {
							state.maxBackReference = n;
						}
						return true;
					}
					if (n <= state.numCapturingParens) {
						return true;
					}
					state.pos = start;
				}
				return false;
			};
			pp$1.regexp_eatKGroupName = function (state) {
				if (
					state.eat(
						107,
						/* k */
					)
				) {
					if (this.regexp_eatGroupName(state)) {
						state.backReferenceNames.push(state.lastStringValue);
						return true;
					}
					state.raise("Invalid named reference");
				}
				return false;
			};
			pp$1.regexp_eatCharacterEscape = function (state) {
				return (
					this.regexp_eatControlEscape(state) ||
					this.regexp_eatCControlLetter(state) ||
					this.regexp_eatZero(state) ||
					this.regexp_eatHexEscapeSequence(state) ||
					this.regexp_eatRegExpUnicodeEscapeSequence(state, false) ||
					(!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
					this.regexp_eatIdentityEscape(state)
				);
			};
			pp$1.regexp_eatCControlLetter = function (state) {
				var start = state.pos;
				if (
					state.eat(
						99,
						/* c */
					)
				) {
					if (this.regexp_eatControlLetter(state)) {
						return true;
					}
					state.pos = start;
				}
				return false;
			};
			pp$1.regexp_eatZero = function (state) {
				if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
					state.lastIntValue = 0;
					state.advance();
					return true;
				}
				return false;
			};
			pp$1.regexp_eatControlEscape = function (state) {
				var ch = state.current();
				if (ch === 116) {
					state.lastIntValue = 9;
					state.advance();
					return true;
				}
				if (ch === 110) {
					state.lastIntValue = 10;
					state.advance();
					return true;
				}
				if (ch === 118) {
					state.lastIntValue = 11;
					state.advance();
					return true;
				}
				if (ch === 102) {
					state.lastIntValue = 12;
					state.advance();
					return true;
				}
				if (ch === 114) {
					state.lastIntValue = 13;
					state.advance();
					return true;
				}
				return false;
			};
			pp$1.regexp_eatControlLetter = function (state) {
				var ch = state.current();
				if (isControlLetter(ch)) {
					state.lastIntValue = ch % 32;
					state.advance();
					return true;
				}
				return false;
			};
			function isControlLetter(ch) {
				return (ch >= 65 && ch <= 90) || (ch >= 97 && ch <= 122);
			}
			pp$1.regexp_eatRegExpUnicodeEscapeSequence = function (state, forceU) {
				if (forceU === void 0) forceU = false;
				var start = state.pos;
				var switchU = forceU || state.switchU;
				if (
					state.eat(
						117,
						/* u */
					)
				) {
					if (this.regexp_eatFixedHexDigits(state, 4)) {
						var lead = state.lastIntValue;
						if (switchU && lead >= 55296 && lead <= 56319) {
							var leadSurrogateEnd = state.pos;
							if (
								state.eat(
									92,
									/* \ */
								) &&
								state.eat(
									117,
									/* u */
								) &&
								this.regexp_eatFixedHexDigits(state, 4)
							) {
								var trail = state.lastIntValue;
								if (trail >= 56320 && trail <= 57343) {
									state.lastIntValue =
										(lead - 55296) * 1024 + (trail - 56320) + 65536;
									return true;
								}
							}
							state.pos = leadSurrogateEnd;
							state.lastIntValue = lead;
						}
						return true;
					}
					if (
						switchU &&
						state.eat(
							123,
							/* { */
						) &&
						this.regexp_eatHexDigits(state) &&
						state.eat(
							125,
							/* } */
						) &&
						isValidUnicode(state.lastIntValue)
					) {
						return true;
					}
					if (switchU) {
						state.raise("Invalid unicode escape");
					}
					state.pos = start;
				}
				return false;
			};
			function isValidUnicode(ch) {
				return ch >= 0 && ch <= 1114111;
			}
			pp$1.regexp_eatIdentityEscape = function (state) {
				if (state.switchU) {
					if (this.regexp_eatSyntaxCharacter(state)) {
						return true;
					}
					if (
						state.eat(
							47,
							/* / */
						)
					) {
						state.lastIntValue = 47;
						return true;
					}
					return false;
				}
				var ch = state.current();
				if (ch !== 99 && (!state.switchN || ch !== 107)) {
					state.lastIntValue = ch;
					state.advance();
					return true;
				}
				return false;
			};
			pp$1.regexp_eatDecimalEscape = function (state) {
				state.lastIntValue = 0;
				var ch = state.current();
				if (ch >= 49 && ch <= 57) {
					do {
						state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
						state.advance();
					} while ((ch = state.current()) >= 48 && ch <= 57);
					return true;
				}
				return false;
			};
			var CharSetNone = 0;
			var CharSetOk = 1;
			var CharSetString = 2;
			pp$1.regexp_eatCharacterClassEscape = function (state) {
				var ch = state.current();
				if (isCharacterClassEscape(ch)) {
					state.lastIntValue = -1;
					state.advance();
					return CharSetOk;
				}
				var negate = false;
				if (
					state.switchU &&
					this.options.ecmaVersion >= 9 &&
					((negate = ch === 80) || ch === 112)
				) {
					state.lastIntValue = -1;
					state.advance();
					var result;
					if (
						state.eat(
							123,
							/* { */
						) &&
						(result = this.regexp_eatUnicodePropertyValueExpression(state)) &&
						state.eat(
							125,
							/* } */
						)
					) {
						if (negate && result === CharSetString) {
							state.raise("Invalid property name");
						}
						return result;
					}
					state.raise("Invalid property name");
				}
				return CharSetNone;
			};
			function isCharacterClassEscape(ch) {
				return (
					ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87
				);
			}
			pp$1.regexp_eatUnicodePropertyValueExpression = function (state) {
				var start = state.pos;
				if (
					this.regexp_eatUnicodePropertyName(state) &&
					state.eat(
						61,
						/* = */
					)
				) {
					var name = state.lastStringValue;
					if (this.regexp_eatUnicodePropertyValue(state)) {
						var value = state.lastStringValue;
						this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
						return CharSetOk;
					}
				}
				state.pos = start;
				if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
					var nameOrValue = state.lastStringValue;
					return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
				}
				return CharSetNone;
			};
			pp$1.regexp_validateUnicodePropertyNameAndValue = function (state, name, value) {
				if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
					state.raise("Invalid property name");
				}
				if (!state.unicodeProperties.nonBinary[name].test(value)) {
					state.raise("Invalid property value");
				}
			};
			pp$1.regexp_validateUnicodePropertyNameOrValue = function (state, nameOrValue) {
				if (state.unicodeProperties.binary.test(nameOrValue)) {
					return CharSetOk;
				}
				if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
					return CharSetString;
				}
				state.raise("Invalid property name");
			};
			pp$1.regexp_eatUnicodePropertyName = function (state) {
				var ch = 0;
				state.lastStringValue = "";
				while (isUnicodePropertyNameCharacter((ch = state.current()))) {
					state.lastStringValue += codePointToString(ch);
					state.advance();
				}
				return state.lastStringValue !== "";
			};
			function isUnicodePropertyNameCharacter(ch) {
				return isControlLetter(ch) || ch === 95;
			}
			pp$1.regexp_eatUnicodePropertyValue = function (state) {
				var ch = 0;
				state.lastStringValue = "";
				while (isUnicodePropertyValueCharacter((ch = state.current()))) {
					state.lastStringValue += codePointToString(ch);
					state.advance();
				}
				return state.lastStringValue !== "";
			};
			function isUnicodePropertyValueCharacter(ch) {
				return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
			}
			pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function (state) {
				return this.regexp_eatUnicodePropertyValue(state);
			};
			pp$1.regexp_eatCharacterClass = function (state) {
				if (
					state.eat(
						91,
						/* [ */
					)
				) {
					var negate = state.eat(
						94,
						/* ^ */
					);
					var result = this.regexp_classContents(state);
					if (
						!state.eat(
							93,
							/* ] */
						)
					) {
						state.raise("Unterminated character class");
					}
					if (negate && result === CharSetString) {
						state.raise("Negated character class may contain strings");
					}
					return true;
				}
				return false;
			};
			pp$1.regexp_classContents = function (state) {
				if (state.current() === 93) {
					return CharSetOk;
				}
				if (state.switchV) {
					return this.regexp_classSetExpression(state);
				}
				this.regexp_nonEmptyClassRanges(state);
				return CharSetOk;
			};
			pp$1.regexp_nonEmptyClassRanges = function (state) {
				while (this.regexp_eatClassAtom(state)) {
					var left = state.lastIntValue;
					if (
						state.eat(
							45,
							/* - */
						) &&
						this.regexp_eatClassAtom(state)
					) {
						var right = state.lastIntValue;
						if (state.switchU && (left === -1 || right === -1)) {
							state.raise("Invalid character class");
						}
						if (left !== -1 && right !== -1 && left > right) {
							state.raise("Range out of order in character class");
						}
					}
				}
			};
			pp$1.regexp_eatClassAtom = function (state) {
				var start = state.pos;
				if (
					state.eat(
						92,
						/* \ */
					)
				) {
					if (this.regexp_eatClassEscape(state)) {
						return true;
					}
					if (state.switchU) {
						var ch$1 = state.current();
						if (ch$1 === 99 || isOctalDigit(ch$1)) {
							state.raise("Invalid class escape");
						}
						state.raise("Invalid escape");
					}
					state.pos = start;
				}
				var ch = state.current();
				if (ch !== 93) {
					state.lastIntValue = ch;
					state.advance();
					return true;
				}
				return false;
			};
			pp$1.regexp_eatClassEscape = function (state) {
				var start = state.pos;
				if (
					state.eat(
						98,
						/* b */
					)
				) {
					state.lastIntValue = 8;
					return true;
				}
				if (
					state.switchU &&
					state.eat(
						45,
						/* - */
					)
				) {
					state.lastIntValue = 45;
					return true;
				}
				if (
					!state.switchU &&
					state.eat(
						99,
						/* c */
					)
				) {
					if (this.regexp_eatClassControlLetter(state)) {
						return true;
					}
					state.pos = start;
				}
				return (
					this.regexp_eatCharacterClassEscape(state) ||
					this.regexp_eatCharacterEscape(state)
				);
			};
			pp$1.regexp_classSetExpression = function (state) {
				var result = CharSetOk,
					subResult;
				if (this.regexp_eatClassSetRange(state));
				else if ((subResult = this.regexp_eatClassSetOperand(state))) {
					if (subResult === CharSetString) {
						result = CharSetString;
					}
					var start = state.pos;
					while (
						state.eatChars(
							[38, 38],
							/* && */
						)
					) {
						if (
							state.current() !== 38 &&
							(subResult = this.regexp_eatClassSetOperand(state))
						) {
							if (subResult !== CharSetString) {
								result = CharSetOk;
							}
							continue;
						}
						state.raise("Invalid character in character class");
					}
					if (start !== state.pos) {
						return result;
					}
					while (
						state.eatChars(
							[45, 45],
							/* -- */
						)
					) {
						if (this.regexp_eatClassSetOperand(state)) {
							continue;
						}
						state.raise("Invalid character in character class");
					}
					if (start !== state.pos) {
						return result;
					}
				} else {
					state.raise("Invalid character in character class");
				}
				for (;;) {
					if (this.regexp_eatClassSetRange(state)) {
						continue;
					}
					subResult = this.regexp_eatClassSetOperand(state);
					if (!subResult) {
						return result;
					}
					if (subResult === CharSetString) {
						result = CharSetString;
					}
				}
			};
			pp$1.regexp_eatClassSetRange = function (state) {
				var start = state.pos;
				if (this.regexp_eatClassSetCharacter(state)) {
					var left = state.lastIntValue;
					if (
						state.eat(
							45,
							/* - */
						) &&
						this.regexp_eatClassSetCharacter(state)
					) {
						var right = state.lastIntValue;
						if (left !== -1 && right !== -1 && left > right) {
							state.raise("Range out of order in character class");
						}
						return true;
					}
					state.pos = start;
				}
				return false;
			};
			pp$1.regexp_eatClassSetOperand = function (state) {
				if (this.regexp_eatClassSetCharacter(state)) {
					return CharSetOk;
				}
				return (
					this.regexp_eatClassStringDisjunction(state) ||
					this.regexp_eatNestedClass(state)
				);
			};
			pp$1.regexp_eatNestedClass = function (state) {
				var start = state.pos;
				if (
					state.eat(
						91,
						/* [ */
					)
				) {
					var negate = state.eat(
						94,
						/* ^ */
					);
					var result = this.regexp_classContents(state);
					if (
						state.eat(
							93,
							/* ] */
						)
					) {
						if (negate && result === CharSetString) {
							state.raise("Negated character class may contain strings");
						}
						return result;
					}
					state.pos = start;
				}
				if (
					state.eat(
						92,
						/* \ */
					)
				) {
					var result$1 = this.regexp_eatCharacterClassEscape(state);
					if (result$1) {
						return result$1;
					}
					state.pos = start;
				}
				return null;
			};
			pp$1.regexp_eatClassStringDisjunction = function (state) {
				var start = state.pos;
				if (
					state.eatChars(
						[92, 113],
						/* \q */
					)
				) {
					if (
						state.eat(
							123,
							/* { */
						)
					) {
						var result = this.regexp_classStringDisjunctionContents(state);
						if (
							state.eat(
								125,
								/* } */
							)
						) {
							return result;
						}
					} else {
						state.raise("Invalid escape");
					}
					state.pos = start;
				}
				return null;
			};
			pp$1.regexp_classStringDisjunctionContents = function (state) {
				var result = this.regexp_classString(state);
				while (
					state.eat(
						124,
						/* | */
					)
				) {
					if (this.regexp_classString(state) === CharSetString) {
						result = CharSetString;
					}
				}
				return result;
			};
			pp$1.regexp_classString = function (state) {
				var count = 0;
				while (this.regexp_eatClassSetCharacter(state)) {
					count++;
				}
				return count === 1 ? CharSetOk : CharSetString;
			};
			pp$1.regexp_eatClassSetCharacter = function (state) {
				var start = state.pos;
				if (
					state.eat(
						92,
						/* \ */
					)
				) {
					if (
						this.regexp_eatCharacterEscape(state) ||
						this.regexp_eatClassSetReservedPunctuator(state)
					) {
						return true;
					}
					if (
						state.eat(
							98,
							/* b */
						)
					) {
						state.lastIntValue = 8;
						return true;
					}
					state.pos = start;
					return false;
				}
				var ch = state.current();
				if (
					ch < 0 ||
					(ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch))
				) {
					return false;
				}
				if (isClassSetSyntaxCharacter(ch)) {
					return false;
				}
				state.advance();
				state.lastIntValue = ch;
				return true;
			};
			function isClassSetReservedDoublePunctuatorCharacter(ch) {
				return (
					ch === 33 ||
					(ch >= 35 && ch <= 38) ||
					(ch >= 42 && ch <= 44) ||
					ch === 46 ||
					(ch >= 58 && ch <= 64) ||
					ch === 94 ||
					ch === 96 ||
					ch === 126
				);
			}
			function isClassSetSyntaxCharacter(ch) {
				return (
					ch === 40 ||
					ch === 41 ||
					ch === 45 ||
					ch === 47 ||
					(ch >= 91 && ch <= 93) ||
					(ch >= 123 && ch <= 125)
				);
			}
			pp$1.regexp_eatClassSetReservedPunctuator = function (state) {
				var ch = state.current();
				if (isClassSetReservedPunctuator(ch)) {
					state.lastIntValue = ch;
					state.advance();
					return true;
				}
				return false;
			};
			function isClassSetReservedPunctuator(ch) {
				return (
					ch === 33 ||
					ch === 35 ||
					ch === 37 ||
					ch === 38 ||
					ch === 44 ||
					ch === 45 ||
					(ch >= 58 && ch <= 62) ||
					ch === 64 ||
					ch === 96 ||
					ch === 126
				);
			}
			pp$1.regexp_eatClassControlLetter = function (state) {
				var ch = state.current();
				if (isDecimalDigit(ch) || ch === 95) {
					state.lastIntValue = ch % 32;
					state.advance();
					return true;
				}
				return false;
			};
			pp$1.regexp_eatHexEscapeSequence = function (state) {
				var start = state.pos;
				if (
					state.eat(
						120,
						/* x */
					)
				) {
					if (this.regexp_eatFixedHexDigits(state, 2)) {
						return true;
					}
					if (state.switchU) {
						state.raise("Invalid escape");
					}
					state.pos = start;
				}
				return false;
			};
			pp$1.regexp_eatDecimalDigits = function (state) {
				var start = state.pos;
				var ch = 0;
				state.lastIntValue = 0;
				while (isDecimalDigit((ch = state.current()))) {
					state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
					state.advance();
				}
				return state.pos !== start;
			};
			function isDecimalDigit(ch) {
				return ch >= 48 && ch <= 57;
			}
			pp$1.regexp_eatHexDigits = function (state) {
				var start = state.pos;
				var ch = 0;
				state.lastIntValue = 0;
				while (isHexDigit((ch = state.current()))) {
					state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
					state.advance();
				}
				return state.pos !== start;
			};
			function isHexDigit(ch) {
				return (ch >= 48 && ch <= 57) || (ch >= 65 && ch <= 70) || (ch >= 97 && ch <= 102);
			}
			function hexToInt(ch) {
				if (ch >= 65 && ch <= 70) {
					return 10 + (ch - 65);
				}
				if (ch >= 97 && ch <= 102) {
					return 10 + (ch - 97);
				}
				return ch - 48;
			}
			pp$1.regexp_eatLegacyOctalEscapeSequence = function (state) {
				if (this.regexp_eatOctalDigit(state)) {
					var n1 = state.lastIntValue;
					if (this.regexp_eatOctalDigit(state)) {
						var n2 = state.lastIntValue;
						if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
							state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
						} else {
							state.lastIntValue = n1 * 8 + n2;
						}
					} else {
						state.lastIntValue = n1;
					}
					return true;
				}
				return false;
			};
			pp$1.regexp_eatOctalDigit = function (state) {
				var ch = state.current();
				if (isOctalDigit(ch)) {
					state.lastIntValue = ch - 48;
					state.advance();
					return true;
				}
				state.lastIntValue = 0;
				return false;
			};
			function isOctalDigit(ch) {
				return ch >= 48 && ch <= 55;
			}
			pp$1.regexp_eatFixedHexDigits = function (state, length) {
				var start = state.pos;
				state.lastIntValue = 0;
				for (var i2 = 0; i2 < length; ++i2) {
					var ch = state.current();
					if (!isHexDigit(ch)) {
						state.pos = start;
						return false;
					}
					state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
					state.advance();
				}
				return true;
			};
			var Token = function Token2(p) {
				this.type = p.type;
				this.value = p.value;
				this.start = p.start;
				this.end = p.end;
				if (p.options.locations) {
					this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
				}
				if (p.options.ranges) {
					this.range = [p.start, p.end];
				}
			};
			var pp = Parser.prototype;
			pp.next = function (ignoreEscapeSequenceInKeyword) {
				if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
					this.raiseRecoverable(
						this.start,
						"Escape sequence in keyword " + this.type.keyword,
					);
				}
				if (this.options.onToken) {
					this.options.onToken(new Token(this));
				}
				this.lastTokEnd = this.end;
				this.lastTokStart = this.start;
				this.lastTokEndLoc = this.endLoc;
				this.lastTokStartLoc = this.startLoc;
				this.nextToken();
			};
			pp.getToken = function () {
				this.next();
				return new Token(this);
			};
			if (typeof Symbol !== "undefined") {
				pp[Symbol.iterator] = function () {
					var this$1$1 = this;
					return {
						next: function () {
							var token = this$1$1.getToken();
							return {
								done: token.type === types$1.eof,
								value: token,
							};
						},
					};
				};
			}
			pp.nextToken = function () {
				var curContext = this.curContext();
				if (!curContext || !curContext.preserveSpace) {
					this.skipSpace();
				}
				this.start = this.pos;
				if (this.options.locations) {
					this.startLoc = this.curPosition();
				}
				if (this.pos >= this.input.length) {
					return this.finishToken(types$1.eof);
				}
				if (curContext.override) {
					return curContext.override(this);
				} else {
					this.readToken(this.fullCharCodeAtPos());
				}
			};
			pp.readToken = function (code) {
				if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
					return this.readWord();
				}
				return this.getTokenFromCode(code);
			};
			pp.fullCharCodeAtPos = function () {
				var code = this.input.charCodeAt(this.pos);
				if (code <= 55295 || code >= 56320) {
					return code;
				}
				var next = this.input.charCodeAt(this.pos + 1);
				return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
			};
			pp.skipBlockComment = function () {
				var startLoc = this.options.onComment && this.curPosition();
				var start = this.pos,
					end = this.input.indexOf("*/", (this.pos += 2));
				if (end === -1) {
					this.raise(this.pos - 2, "Unterminated comment");
				}
				this.pos = end + 2;
				if (this.options.locations) {
					for (
						var nextBreak = void 0, pos = start;
						(nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1;

					) {
						++this.curLine;
						pos = this.lineStart = nextBreak;
					}
				}
				if (this.options.onComment) {
					this.options.onComment(
						true,
						this.input.slice(start + 2, end),
						start,
						this.pos,
						startLoc,
						this.curPosition(),
					);
				}
			};
			pp.skipLineComment = function (startSkip) {
				var start = this.pos;
				var startLoc = this.options.onComment && this.curPosition();
				var ch = this.input.charCodeAt((this.pos += startSkip));
				while (this.pos < this.input.length && !isNewLine(ch)) {
					ch = this.input.charCodeAt(++this.pos);
				}
				if (this.options.onComment) {
					this.options.onComment(
						false,
						this.input.slice(start + startSkip, this.pos),
						start,
						this.pos,
						startLoc,
						this.curPosition(),
					);
				}
			};
			pp.skipSpace = function () {
				loop: while (this.pos < this.input.length) {
					var ch = this.input.charCodeAt(this.pos);
					switch (ch) {
						case 32:
						case 160:
							++this.pos;
							break;
						case 13:
							if (this.input.charCodeAt(this.pos + 1) === 10) {
								++this.pos;
							}
						case 10:
						case 8232:
						case 8233:
							++this.pos;
							if (this.options.locations) {
								++this.curLine;
								this.lineStart = this.pos;
							}
							break;
						case 47:
							switch (this.input.charCodeAt(this.pos + 1)) {
								case 42:
									this.skipBlockComment();
									break;
								case 47:
									this.skipLineComment(2);
									break;
								default:
									break loop;
							}
							break;
						default:
							if (
								(ch > 8 && ch < 14) ||
								(ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch)))
							) {
								++this.pos;
							} else {
								break loop;
							}
					}
				}
			};
			pp.finishToken = function (type, val) {
				this.end = this.pos;
				if (this.options.locations) {
					this.endLoc = this.curPosition();
				}
				var prevType = this.type;
				this.type = type;
				this.value = val;
				this.updateContext(prevType);
			};
			pp.readToken_dot = function () {
				var next = this.input.charCodeAt(this.pos + 1);
				if (next >= 48 && next <= 57) {
					return this.readNumber(true);
				}
				var next2 = this.input.charCodeAt(this.pos + 2);
				if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
					this.pos += 3;
					return this.finishToken(types$1.ellipsis);
				} else {
					++this.pos;
					return this.finishToken(types$1.dot);
				}
			};
			pp.readToken_slash = function () {
				var next = this.input.charCodeAt(this.pos + 1);
				if (this.exprAllowed) {
					++this.pos;
					return this.readRegexp();
				}
				if (next === 61) {
					return this.finishOp(types$1.assign, 2);
				}
				return this.finishOp(types$1.slash, 1);
			};
			pp.readToken_mult_modulo_exp = function (code) {
				var next = this.input.charCodeAt(this.pos + 1);
				var size = 1;
				var tokentype = code === 42 ? types$1.star : types$1.modulo;
				if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
					++size;
					tokentype = types$1.starstar;
					next = this.input.charCodeAt(this.pos + 2);
				}
				if (next === 61) {
					return this.finishOp(types$1.assign, size + 1);
				}
				return this.finishOp(tokentype, size);
			};
			pp.readToken_pipe_amp = function (code) {
				var next = this.input.charCodeAt(this.pos + 1);
				if (next === code) {
					if (this.options.ecmaVersion >= 12) {
						var next2 = this.input.charCodeAt(this.pos + 2);
						if (next2 === 61) {
							return this.finishOp(types$1.assign, 3);
						}
					}
					return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
				}
				if (next === 61) {
					return this.finishOp(types$1.assign, 2);
				}
				return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
			};
			pp.readToken_caret = function () {
				var next = this.input.charCodeAt(this.pos + 1);
				if (next === 61) {
					return this.finishOp(types$1.assign, 2);
				}
				return this.finishOp(types$1.bitwiseXOR, 1);
			};
			pp.readToken_plus_min = function (code) {
				var next = this.input.charCodeAt(this.pos + 1);
				if (next === code) {
					if (
						next === 45 &&
						!this.inModule &&
						this.input.charCodeAt(this.pos + 2) === 62 &&
						(this.lastTokEnd === 0 ||
							lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))
					) {
						this.skipLineComment(3);
						this.skipSpace();
						return this.nextToken();
					}
					return this.finishOp(types$1.incDec, 2);
				}
				if (next === 61) {
					return this.finishOp(types$1.assign, 2);
				}
				return this.finishOp(types$1.plusMin, 1);
			};
			pp.readToken_lt_gt = function (code) {
				var next = this.input.charCodeAt(this.pos + 1);
				var size = 1;
				if (next === code) {
					size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
					if (this.input.charCodeAt(this.pos + size) === 61) {
						return this.finishOp(types$1.assign, size + 1);
					}
					return this.finishOp(types$1.bitShift, size);
				}
				if (
					next === 33 &&
					code === 60 &&
					!this.inModule &&
					this.input.charCodeAt(this.pos + 2) === 45 &&
					this.input.charCodeAt(this.pos + 3) === 45
				) {
					this.skipLineComment(4);
					this.skipSpace();
					return this.nextToken();
				}
				if (next === 61) {
					size = 2;
				}
				return this.finishOp(types$1.relational, size);
			};
			pp.readToken_eq_excl = function (code) {
				var next = this.input.charCodeAt(this.pos + 1);
				if (next === 61) {
					return this.finishOp(
						types$1.equality,
						this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2,
					);
				}
				if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
					this.pos += 2;
					return this.finishToken(types$1.arrow);
				}
				return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
			};
			pp.readToken_question = function () {
				var ecmaVersion2 = this.options.ecmaVersion;
				if (ecmaVersion2 >= 11) {
					var next = this.input.charCodeAt(this.pos + 1);
					if (next === 46) {
						var next2 = this.input.charCodeAt(this.pos + 2);
						if (next2 < 48 || next2 > 57) {
							return this.finishOp(types$1.questionDot, 2);
						}
					}
					if (next === 63) {
						if (ecmaVersion2 >= 12) {
							var next2$1 = this.input.charCodeAt(this.pos + 2);
							if (next2$1 === 61) {
								return this.finishOp(types$1.assign, 3);
							}
						}
						return this.finishOp(types$1.coalesce, 2);
					}
				}
				return this.finishOp(types$1.question, 1);
			};
			pp.readToken_numberSign = function () {
				var ecmaVersion2 = this.options.ecmaVersion;
				var code = 35;
				if (ecmaVersion2 >= 13) {
					++this.pos;
					code = this.fullCharCodeAtPos();
					if (isIdentifierStart(code, true) || code === 92) {
						return this.finishToken(types$1.privateId, this.readWord1());
					}
				}
				this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
			};
			pp.getTokenFromCode = function (code) {
				switch (code) {
					// The interpretation of a dot depends on whether it is followed
					// by a digit or another two dots.
					case 46:
						return this.readToken_dot();
					// Punctuation tokens.
					case 40:
						++this.pos;
						return this.finishToken(types$1.parenL);
					case 41:
						++this.pos;
						return this.finishToken(types$1.parenR);
					case 59:
						++this.pos;
						return this.finishToken(types$1.semi);
					case 44:
						++this.pos;
						return this.finishToken(types$1.comma);
					case 91:
						++this.pos;
						return this.finishToken(types$1.bracketL);
					case 93:
						++this.pos;
						return this.finishToken(types$1.bracketR);
					case 123:
						++this.pos;
						return this.finishToken(types$1.braceL);
					case 125:
						++this.pos;
						return this.finishToken(types$1.braceR);
					case 58:
						++this.pos;
						return this.finishToken(types$1.colon);
					case 96:
						if (this.options.ecmaVersion < 6) {
							break;
						}
						++this.pos;
						return this.finishToken(types$1.backQuote);
					case 48:
						var next = this.input.charCodeAt(this.pos + 1);
						if (next === 120 || next === 88) {
							return this.readRadixNumber(16);
						}
						if (this.options.ecmaVersion >= 6) {
							if (next === 111 || next === 79) {
								return this.readRadixNumber(8);
							}
							if (next === 98 || next === 66) {
								return this.readRadixNumber(2);
							}
						}
					// Anything else beginning with a digit is an integer, octal
					// number, or float.
					case 49:
					case 50:
					case 51:
					case 52:
					case 53:
					case 54:
					case 55:
					case 56:
					case 57:
						return this.readNumber(false);
					// Quotes produce strings.
					case 34:
					case 39:
						return this.readString(code);
					// Operators are parsed inline in tiny state machines. '=' (61) is
					// often referred to. `finishOp` simply skips the amount of
					// characters it is given as second argument, and returns a token
					// of the type given by its first argument.
					case 47:
						return this.readToken_slash();
					case 37:
					case 42:
						return this.readToken_mult_modulo_exp(code);
					case 124:
					case 38:
						return this.readToken_pipe_amp(code);
					case 94:
						return this.readToken_caret();
					case 43:
					case 45:
						return this.readToken_plus_min(code);
					case 60:
					case 62:
						return this.readToken_lt_gt(code);
					case 61:
					case 33:
						return this.readToken_eq_excl(code);
					case 63:
						return this.readToken_question();
					case 126:
						return this.finishOp(types$1.prefix, 1);
					case 35:
						return this.readToken_numberSign();
				}
				this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
			};
			pp.finishOp = function (type, size) {
				var str = this.input.slice(this.pos, this.pos + size);
				this.pos += size;
				return this.finishToken(type, str);
			};
			pp.readRegexp = function () {
				var escaped,
					inClass,
					start = this.pos;
				for (;;) {
					if (this.pos >= this.input.length) {
						this.raise(start, "Unterminated regular expression");
					}
					var ch = this.input.charAt(this.pos);
					if (lineBreak.test(ch)) {
						this.raise(start, "Unterminated regular expression");
					}
					if (!escaped) {
						if (ch === "[") {
							inClass = true;
						} else if (ch === "]" && inClass) {
							inClass = false;
						} else if (ch === "/" && !inClass) {
							break;
						}
						escaped = ch === "\\";
					} else {
						escaped = false;
					}
					++this.pos;
				}
				var pattern = this.input.slice(start, this.pos);
				++this.pos;
				var flagsStart = this.pos;
				var flags = this.readWord1();
				if (this.containsEsc) {
					this.unexpected(flagsStart);
				}
				var state =
					this.regexpState || (this.regexpState = new RegExpValidationState(this));
				state.reset(start, pattern, flags);
				this.validateRegExpFlags(state);
				this.validateRegExpPattern(state);
				var value = null;
				try {
					value = new RegExp(pattern, flags);
				} catch (e) {}
				return this.finishToken(types$1.regexp, { pattern, flags, value });
			};
			pp.readInt = function (radix, len, maybeLegacyOctalNumericLiteral) {
				var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
				var isLegacyOctalNumericLiteral =
					maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
				var start = this.pos,
					total = 0,
					lastCode = 0;
				for (var i2 = 0, e = len == null ? Infinity : len; i2 < e; ++i2, ++this.pos) {
					var code = this.input.charCodeAt(this.pos),
						val = void 0;
					if (allowSeparators && code === 95) {
						if (isLegacyOctalNumericLiteral) {
							this.raiseRecoverable(
								this.pos,
								"Numeric separator is not allowed in legacy octal numeric literals",
							);
						}
						if (lastCode === 95) {
							this.raiseRecoverable(
								this.pos,
								"Numeric separator must be exactly one underscore",
							);
						}
						if (i2 === 0) {
							this.raiseRecoverable(
								this.pos,
								"Numeric separator is not allowed at the first of digits",
							);
						}
						lastCode = code;
						continue;
					}
					if (code >= 97) {
						val = code - 97 + 10;
					} else if (code >= 65) {
						val = code - 65 + 10;
					} else if (code >= 48 && code <= 57) {
						val = code - 48;
					} else {
						val = Infinity;
					}
					if (val >= radix) {
						break;
					}
					lastCode = code;
					total = total * radix + val;
				}
				if (allowSeparators && lastCode === 95) {
					this.raiseRecoverable(
						this.pos - 1,
						"Numeric separator is not allowed at the last of digits",
					);
				}
				if (this.pos === start || (len != null && this.pos - start !== len)) {
					return null;
				}
				return total;
			};
			function stringToNumber(str, isLegacyOctalNumericLiteral) {
				if (isLegacyOctalNumericLiteral) {
					return parseInt(str, 8);
				}
				return parseFloat(str.replace(/_/g, ""));
			}
			function stringToBigInt(str) {
				if (typeof BigInt !== "function") {
					return null;
				}
				return BigInt(str.replace(/_/g, ""));
			}
			pp.readRadixNumber = function (radix) {
				var start = this.pos;
				this.pos += 2;
				var val = this.readInt(radix);
				if (val == null) {
					this.raise(this.start + 2, "Expected number in radix " + radix);
				}
				if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
					val = stringToBigInt(this.input.slice(start, this.pos));
					++this.pos;
				} else if (isIdentifierStart(this.fullCharCodeAtPos())) {
					this.raise(this.pos, "Identifier directly after number");
				}
				return this.finishToken(types$1.num, val);
			};
			pp.readNumber = function (startsWithDot) {
				var start = this.pos;
				if (!startsWithDot && this.readInt(10, void 0, true) === null) {
					this.raise(start, "Invalid number");
				}
				var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
				if (octal && this.strict) {
					this.raise(start, "Invalid number");
				}
				var next = this.input.charCodeAt(this.pos);
				if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
					var val$1 = stringToBigInt(this.input.slice(start, this.pos));
					++this.pos;
					if (isIdentifierStart(this.fullCharCodeAtPos())) {
						this.raise(this.pos, "Identifier directly after number");
					}
					return this.finishToken(types$1.num, val$1);
				}
				if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
					octal = false;
				}
				if (next === 46 && !octal) {
					++this.pos;
					this.readInt(10);
					next = this.input.charCodeAt(this.pos);
				}
				if ((next === 69 || next === 101) && !octal) {
					next = this.input.charCodeAt(++this.pos);
					if (next === 43 || next === 45) {
						++this.pos;
					}
					if (this.readInt(10) === null) {
						this.raise(start, "Invalid number");
					}
				}
				if (isIdentifierStart(this.fullCharCodeAtPos())) {
					this.raise(this.pos, "Identifier directly after number");
				}
				var val = stringToNumber(this.input.slice(start, this.pos), octal);
				return this.finishToken(types$1.num, val);
			};
			pp.readCodePoint = function () {
				var ch = this.input.charCodeAt(this.pos),
					code;
				if (ch === 123) {
					if (this.options.ecmaVersion < 6) {
						this.unexpected();
					}
					var codePos = ++this.pos;
					code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
					++this.pos;
					if (code > 1114111) {
						this.invalidStringToken(codePos, "Code point out of bounds");
					}
				} else {
					code = this.readHexChar(4);
				}
				return code;
			};
			pp.readString = function (quote) {
				var out = "",
					chunkStart = ++this.pos;
				for (;;) {
					if (this.pos >= this.input.length) {
						this.raise(this.start, "Unterminated string constant");
					}
					var ch = this.input.charCodeAt(this.pos);
					if (ch === quote) {
						break;
					}
					if (ch === 92) {
						out += this.input.slice(chunkStart, this.pos);
						out += this.readEscapedChar(false);
						chunkStart = this.pos;
					} else if (ch === 8232 || ch === 8233) {
						if (this.options.ecmaVersion < 10) {
							this.raise(this.start, "Unterminated string constant");
						}
						++this.pos;
						if (this.options.locations) {
							this.curLine++;
							this.lineStart = this.pos;
						}
					} else {
						if (isNewLine(ch)) {
							this.raise(this.start, "Unterminated string constant");
						}
						++this.pos;
					}
				}
				out += this.input.slice(chunkStart, this.pos++);
				return this.finishToken(types$1.string, out);
			};
			var INVALID_TEMPLATE_ESCAPE_ERROR = {};
			pp.tryReadTemplateToken = function () {
				this.inTemplateElement = true;
				try {
					this.readTmplToken();
				} catch (err) {
					if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
						this.readInvalidTemplateToken();
					} else {
						throw err;
					}
				}
				this.inTemplateElement = false;
			};
			pp.invalidStringToken = function (position, message) {
				if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
					throw INVALID_TEMPLATE_ESCAPE_ERROR;
				} else {
					this.raise(position, message);
				}
			};
			pp.readTmplToken = function () {
				var out = "",
					chunkStart = this.pos;
				for (;;) {
					if (this.pos >= this.input.length) {
						this.raise(this.start, "Unterminated template");
					}
					var ch = this.input.charCodeAt(this.pos);
					if (ch === 96 || (ch === 36 && this.input.charCodeAt(this.pos + 1) === 123)) {
						if (
							this.pos === this.start &&
							(this.type === types$1.template ||
								this.type === types$1.invalidTemplate)
						) {
							if (ch === 36) {
								this.pos += 2;
								return this.finishToken(types$1.dollarBraceL);
							} else {
								++this.pos;
								return this.finishToken(types$1.backQuote);
							}
						}
						out += this.input.slice(chunkStart, this.pos);
						return this.finishToken(types$1.template, out);
					}
					if (ch === 92) {
						out += this.input.slice(chunkStart, this.pos);
						out += this.readEscapedChar(true);
						chunkStart = this.pos;
					} else if (isNewLine(ch)) {
						out += this.input.slice(chunkStart, this.pos);
						++this.pos;
						switch (ch) {
							case 13:
								if (this.input.charCodeAt(this.pos) === 10) {
									++this.pos;
								}
							case 10:
								out += "\n";
								break;
							default:
								out += String.fromCharCode(ch);
								break;
						}
						if (this.options.locations) {
							++this.curLine;
							this.lineStart = this.pos;
						}
						chunkStart = this.pos;
					} else {
						++this.pos;
					}
				}
			};
			pp.readInvalidTemplateToken = function () {
				for (; this.pos < this.input.length; this.pos++) {
					switch (this.input[this.pos]) {
						case "\\":
							++this.pos;
							break;
						case "$":
							if (this.input[this.pos + 1] !== "{") {
								break;
							}
						// fall through
						case "`":
							return this.finishToken(
								types$1.invalidTemplate,
								this.input.slice(this.start, this.pos),
							);
						case "\r":
							if (this.input[this.pos + 1] === "\n") {
								++this.pos;
							}
						// fall through
						case "\n":
						case "\u2028":
						case "\u2029":
							++this.curLine;
							this.lineStart = this.pos + 1;
							break;
					}
				}
				this.raise(this.start, "Unterminated template");
			};
			pp.readEscapedChar = function (inTemplate) {
				var ch = this.input.charCodeAt(++this.pos);
				++this.pos;
				switch (ch) {
					case 110:
						return "\n";
					// 'n' -> '\n'
					case 114:
						return "\r";
					// 'r' -> '\r'
					case 120:
						return String.fromCharCode(this.readHexChar(2));
					// 'x'
					case 117:
						return codePointToString(this.readCodePoint());
					// 'u'
					case 116:
						return "	";
					// 't' -> '\t'
					case 98:
						return "\b";
					// 'b' -> '\b'
					case 118:
						return "\v";
					// 'v' -> '\u000b'
					case 102:
						return "\f";
					// 'f' -> '\f'
					case 13:
						if (this.input.charCodeAt(this.pos) === 10) {
							++this.pos;
						}
					// '\r\n'
					case 10:
						if (this.options.locations) {
							this.lineStart = this.pos;
							++this.curLine;
						}
						return "";
					case 56:
					case 57:
						if (this.strict) {
							this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
						}
						if (inTemplate) {
							var codePos = this.pos - 1;
							this.invalidStringToken(
								codePos,
								"Invalid escape sequence in template string",
							);
						}
					default:
						if (ch >= 48 && ch <= 55) {
							var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
							var octal = parseInt(octalStr, 8);
							if (octal > 255) {
								octalStr = octalStr.slice(0, -1);
								octal = parseInt(octalStr, 8);
							}
							this.pos += octalStr.length - 1;
							ch = this.input.charCodeAt(this.pos);
							if (
								(octalStr !== "0" || ch === 56 || ch === 57) &&
								(this.strict || inTemplate)
							) {
								this.invalidStringToken(
									this.pos - 1 - octalStr.length,
									inTemplate
										? "Octal literal in template string"
										: "Octal literal in strict mode",
								);
							}
							return String.fromCharCode(octal);
						}
						if (isNewLine(ch)) {
							if (this.options.locations) {
								this.lineStart = this.pos;
								++this.curLine;
							}
							return "";
						}
						return String.fromCharCode(ch);
				}
			};
			pp.readHexChar = function (len) {
				var codePos = this.pos;
				var n = this.readInt(16, len);
				if (n === null) {
					this.invalidStringToken(codePos, "Bad character escape sequence");
				}
				return n;
			};
			pp.readWord1 = function () {
				this.containsEsc = false;
				var word = "",
					first = true,
					chunkStart = this.pos;
				var astral = this.options.ecmaVersion >= 6;
				while (this.pos < this.input.length) {
					var ch = this.fullCharCodeAtPos();
					if (isIdentifierChar(ch, astral)) {
						this.pos += ch <= 65535 ? 1 : 2;
					} else if (ch === 92) {
						this.containsEsc = true;
						word += this.input.slice(chunkStart, this.pos);
						var escStart = this.pos;
						if (this.input.charCodeAt(++this.pos) !== 117) {
							this.invalidStringToken(
								this.pos,
								"Expecting Unicode escape sequence \\uXXXX",
							);
						}
						++this.pos;
						var esc = this.readCodePoint();
						if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
							this.invalidStringToken(escStart, "Invalid Unicode escape");
						}
						word += codePointToString(esc);
						chunkStart = this.pos;
					} else {
						break;
					}
					first = false;
				}
				return word + this.input.slice(chunkStart, this.pos);
			};
			pp.readWord = function () {
				var word = this.readWord1();
				var type = types$1.name;
				if (this.keywords.test(word)) {
					type = keywords[word];
				}
				return this.finishToken(type, word);
			};
			var version = "8.14.0";
			Parser.acorn = {
				Parser,
				version,
				defaultOptions,
				Position,
				SourceLocation,
				getLineInfo,
				Node,
				TokenType,
				tokTypes: types$1,
				keywordTypes: keywords,
				TokContext,
				tokContexts: types,
				isIdentifierChar,
				isIdentifierStart,
				Token,
				isNewLine,
				lineBreak,
				lineBreakG,
				nonASCIIwhitespace,
			};
			function parse(input, options) {
				return Parser.parse(input, options);
			}
			function parseExpressionAt(input, pos, options) {
				return Parser.parseExpressionAt(input, pos, options);
			}
			function tokenizer(input, options) {
				return Parser.tokenizer(input, options);
			}
			exports3.Node = Node;
			exports3.Parser = Parser;
			exports3.Position = Position;
			exports3.SourceLocation = SourceLocation;
			exports3.TokContext = TokContext;
			exports3.Token = Token;
			exports3.TokenType = TokenType;
			exports3.defaultOptions = defaultOptions;
			exports3.getLineInfo = getLineInfo;
			exports3.isIdentifierChar = isIdentifierChar;
			exports3.isIdentifierStart = isIdentifierStart;
			exports3.isNewLine = isNewLine;
			exports3.keywordTypes = keywords;
			exports3.lineBreak = lineBreak;
			exports3.lineBreakG = lineBreakG;
			exports3.nonASCIIwhitespace = nonASCIIwhitespace;
			exports3.parse = parse;
			exports3.parseExpressionAt = parseExpressionAt;
			exports3.tokContexts = types;
			exports3.tokTypes = types$1;
			exports3.tokenizer = tokenizer;
			exports3.version = version;
		});
	},
});

// node_modules/.pnpm/acorn-walk@8.3.4/node_modules/acorn-walk/dist/walk.js
var require_walk = __commonJS({
	"node_modules/.pnpm/acorn-walk@8.3.4/node_modules/acorn-walk/dist/walk.js"(exports2, module2) {
		"use strict";
		(function (global2, factory) {
			typeof exports2 === "object" && typeof module2 !== "undefined"
				? factory(exports2)
				: typeof define === "function" && define.amd
					? define(["exports"], factory)
					: ((global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self),
						factory(
							((global2.acorn = global2.acorn || {}), (global2.acorn.walk = {})),
						));
		})(exports2, function (exports3) {
			"use strict";
			function simple(node, visitors, baseVisitor, state, override) {
				if (!baseVisitor) {
					baseVisitor = base;
				}
				(function c(node2, st, override2) {
					var type = override2 || node2.type;
					baseVisitor[type](node2, st, c);
					if (visitors[type]) {
						visitors[type](node2, st);
					}
				})(node, state, override);
			}
			function ancestor(node, visitors, baseVisitor, state, override) {
				var ancestors = [];
				if (!baseVisitor) {
					baseVisitor = base;
				}
				(function c(node2, st, override2) {
					var type = override2 || node2.type;
					var isNew = node2 !== ancestors[ancestors.length - 1];
					if (isNew) {
						ancestors.push(node2);
					}
					baseVisitor[type](node2, st, c);
					if (visitors[type]) {
						visitors[type](node2, st || ancestors, ancestors);
					}
					if (isNew) {
						ancestors.pop();
					}
				})(node, state, override);
			}
			function recursive(node, state, funcs, baseVisitor, override) {
				var visitor = funcs ? make(funcs, baseVisitor || void 0) : baseVisitor;
				(function c(node2, st, override2) {
					visitor[override2 || node2.type](node2, st, c);
				})(node, state, override);
			}
			function makeTest(test) {
				if (typeof test === "string") {
					return function (type) {
						return type === test;
					};
				} else if (!test) {
					return function () {
						return true;
					};
				} else {
					return test;
				}
			}
			var Found = function Found2(node, state) {
				this.node = node;
				this.state = state;
			};
			function full(node, callback, baseVisitor, state, override) {
				if (!baseVisitor) {
					baseVisitor = base;
				}
				var last;
				(function c(node2, st, override2) {
					var type = override2 || node2.type;
					baseVisitor[type](node2, st, c);
					if (last !== node2) {
						callback(node2, st, type);
						last = node2;
					}
				})(node, state, override);
			}
			function fullAncestor(node, callback, baseVisitor, state) {
				if (!baseVisitor) {
					baseVisitor = base;
				}
				var ancestors = [],
					last;
				(function c(node2, st, override) {
					var type = override || node2.type;
					var isNew = node2 !== ancestors[ancestors.length - 1];
					if (isNew) {
						ancestors.push(node2);
					}
					baseVisitor[type](node2, st, c);
					if (last !== node2) {
						callback(node2, st || ancestors, ancestors, type);
						last = node2;
					}
					if (isNew) {
						ancestors.pop();
					}
				})(node, state);
			}
			function findNodeAt(node, start, end, test, baseVisitor, state) {
				if (!baseVisitor) {
					baseVisitor = base;
				}
				test = makeTest(test);
				try {
					(function c(node2, st, override) {
						var type = override || node2.type;
						if (
							(start == null || node2.start <= start) &&
							(end == null || node2.end >= end)
						) {
							baseVisitor[type](node2, st, c);
						}
						if (
							(start == null || node2.start === start) &&
							(end == null || node2.end === end) &&
							test(type, node2)
						) {
							throw new Found(node2, st);
						}
					})(node, state);
				} catch (e) {
					if (e instanceof Found) {
						return e;
					}
					throw e;
				}
			}
			function findNodeAround(node, pos, test, baseVisitor, state) {
				test = makeTest(test);
				if (!baseVisitor) {
					baseVisitor = base;
				}
				try {
					(function c(node2, st, override) {
						var type = override || node2.type;
						if (node2.start > pos || node2.end < pos) {
							return;
						}
						baseVisitor[type](node2, st, c);
						if (test(type, node2)) {
							throw new Found(node2, st);
						}
					})(node, state);
				} catch (e) {
					if (e instanceof Found) {
						return e;
					}
					throw e;
				}
			}
			function findNodeAfter(node, pos, test, baseVisitor, state) {
				test = makeTest(test);
				if (!baseVisitor) {
					baseVisitor = base;
				}
				try {
					(function c(node2, st, override) {
						if (node2.end < pos) {
							return;
						}
						var type = override || node2.type;
						if (node2.start >= pos && test(type, node2)) {
							throw new Found(node2, st);
						}
						baseVisitor[type](node2, st, c);
					})(node, state);
				} catch (e) {
					if (e instanceof Found) {
						return e;
					}
					throw e;
				}
			}
			function findNodeBefore(node, pos, test, baseVisitor, state) {
				test = makeTest(test);
				if (!baseVisitor) {
					baseVisitor = base;
				}
				var max;
				(function c(node2, st, override) {
					if (node2.start > pos) {
						return;
					}
					var type = override || node2.type;
					if (
						node2.end <= pos &&
						(!max || max.node.end < node2.end) &&
						test(type, node2)
					) {
						max = new Found(node2, st);
					}
					baseVisitor[type](node2, st, c);
				})(node, state);
				return max;
			}
			function make(funcs, baseVisitor) {
				var visitor = Object.create(baseVisitor || base);
				for (var type in funcs) {
					visitor[type] = funcs[type];
				}
				return visitor;
			}
			function skipThrough(node, st, c) {
				c(node, st);
			}
			function ignore(_node, _st, _c) {}
			var base = {};
			base.Program =
				base.BlockStatement =
				base.StaticBlock =
					function (node, st, c) {
						for (var i = 0, list = node.body; i < list.length; i += 1) {
							var stmt = list[i];
							c(stmt, st, "Statement");
						}
					};
			base.Statement = skipThrough;
			base.EmptyStatement = ignore;
			base.ExpressionStatement =
				base.ParenthesizedExpression =
				base.ChainExpression =
					function (node, st, c) {
						return c(node.expression, st, "Expression");
					};
			base.IfStatement = function (node, st, c) {
				c(node.test, st, "Expression");
				c(node.consequent, st, "Statement");
				if (node.alternate) {
					c(node.alternate, st, "Statement");
				}
			};
			base.LabeledStatement = function (node, st, c) {
				return c(node.body, st, "Statement");
			};
			base.BreakStatement = base.ContinueStatement = ignore;
			base.WithStatement = function (node, st, c) {
				c(node.object, st, "Expression");
				c(node.body, st, "Statement");
			};
			base.SwitchStatement = function (node, st, c) {
				c(node.discriminant, st, "Expression");
				for (var i = 0, list = node.cases; i < list.length; i += 1) {
					var cs = list[i];
					c(cs, st);
				}
			};
			base.SwitchCase = function (node, st, c) {
				if (node.test) {
					c(node.test, st, "Expression");
				}
				for (var i = 0, list = node.consequent; i < list.length; i += 1) {
					var cons = list[i];
					c(cons, st, "Statement");
				}
			};
			base.ReturnStatement =
				base.YieldExpression =
				base.AwaitExpression =
					function (node, st, c) {
						if (node.argument) {
							c(node.argument, st, "Expression");
						}
					};
			base.ThrowStatement = base.SpreadElement = function (node, st, c) {
				return c(node.argument, st, "Expression");
			};
			base.TryStatement = function (node, st, c) {
				c(node.block, st, "Statement");
				if (node.handler) {
					c(node.handler, st);
				}
				if (node.finalizer) {
					c(node.finalizer, st, "Statement");
				}
			};
			base.CatchClause = function (node, st, c) {
				if (node.param) {
					c(node.param, st, "Pattern");
				}
				c(node.body, st, "Statement");
			};
			base.WhileStatement = base.DoWhileStatement = function (node, st, c) {
				c(node.test, st, "Expression");
				c(node.body, st, "Statement");
			};
			base.ForStatement = function (node, st, c) {
				if (node.init) {
					c(node.init, st, "ForInit");
				}
				if (node.test) {
					c(node.test, st, "Expression");
				}
				if (node.update) {
					c(node.update, st, "Expression");
				}
				c(node.body, st, "Statement");
			};
			base.ForInStatement = base.ForOfStatement = function (node, st, c) {
				c(node.left, st, "ForInit");
				c(node.right, st, "Expression");
				c(node.body, st, "Statement");
			};
			base.ForInit = function (node, st, c) {
				if (node.type === "VariableDeclaration") {
					c(node, st);
				} else {
					c(node, st, "Expression");
				}
			};
			base.DebuggerStatement = ignore;
			base.FunctionDeclaration = function (node, st, c) {
				return c(node, st, "Function");
			};
			base.VariableDeclaration = function (node, st, c) {
				for (var i = 0, list = node.declarations; i < list.length; i += 1) {
					var decl = list[i];
					c(decl, st);
				}
			};
			base.VariableDeclarator = function (node, st, c) {
				c(node.id, st, "Pattern");
				if (node.init) {
					c(node.init, st, "Expression");
				}
			};
			base.Function = function (node, st, c) {
				if (node.id) {
					c(node.id, st, "Pattern");
				}
				for (var i = 0, list = node.params; i < list.length; i += 1) {
					var param = list[i];
					c(param, st, "Pattern");
				}
				c(node.body, st, node.expression ? "Expression" : "Statement");
			};
			base.Pattern = function (node, st, c) {
				if (node.type === "Identifier") {
					c(node, st, "VariablePattern");
				} else if (node.type === "MemberExpression") {
					c(node, st, "MemberPattern");
				} else {
					c(node, st);
				}
			};
			base.VariablePattern = ignore;
			base.MemberPattern = skipThrough;
			base.RestElement = function (node, st, c) {
				return c(node.argument, st, "Pattern");
			};
			base.ArrayPattern = function (node, st, c) {
				for (var i = 0, list = node.elements; i < list.length; i += 1) {
					var elt = list[i];
					if (elt) {
						c(elt, st, "Pattern");
					}
				}
			};
			base.ObjectPattern = function (node, st, c) {
				for (var i = 0, list = node.properties; i < list.length; i += 1) {
					var prop = list[i];
					if (prop.type === "Property") {
						if (prop.computed) {
							c(prop.key, st, "Expression");
						}
						c(prop.value, st, "Pattern");
					} else if (prop.type === "RestElement") {
						c(prop.argument, st, "Pattern");
					}
				}
			};
			base.Expression = skipThrough;
			base.ThisExpression = base.Super = base.MetaProperty = ignore;
			base.ArrayExpression = function (node, st, c) {
				for (var i = 0, list = node.elements; i < list.length; i += 1) {
					var elt = list[i];
					if (elt) {
						c(elt, st, "Expression");
					}
				}
			};
			base.ObjectExpression = function (node, st, c) {
				for (var i = 0, list = node.properties; i < list.length; i += 1) {
					var prop = list[i];
					c(prop, st);
				}
			};
			base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
			base.SequenceExpression = function (node, st, c) {
				for (var i = 0, list = node.expressions; i < list.length; i += 1) {
					var expr = list[i];
					c(expr, st, "Expression");
				}
			};
			base.TemplateLiteral = function (node, st, c) {
				for (var i = 0, list = node.quasis; i < list.length; i += 1) {
					var quasi = list[i];
					c(quasi, st);
				}
				for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1) {
					var expr = list$1[i$1];
					c(expr, st, "Expression");
				}
			};
			base.TemplateElement = ignore;
			base.UnaryExpression = base.UpdateExpression = function (node, st, c) {
				c(node.argument, st, "Expression");
			};
			base.BinaryExpression = base.LogicalExpression = function (node, st, c) {
				c(node.left, st, "Expression");
				c(node.right, st, "Expression");
			};
			base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {
				c(node.left, st, "Pattern");
				c(node.right, st, "Expression");
			};
			base.ConditionalExpression = function (node, st, c) {
				c(node.test, st, "Expression");
				c(node.consequent, st, "Expression");
				c(node.alternate, st, "Expression");
			};
			base.NewExpression = base.CallExpression = function (node, st, c) {
				c(node.callee, st, "Expression");
				if (node.arguments) {
					for (var i = 0, list = node.arguments; i < list.length; i += 1) {
						var arg = list[i];
						c(arg, st, "Expression");
					}
				}
			};
			base.MemberExpression = function (node, st, c) {
				c(node.object, st, "Expression");
				if (node.computed) {
					c(node.property, st, "Expression");
				}
			};
			base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {
				if (node.declaration) {
					c(
						node.declaration,
						st,
						node.type === "ExportNamedDeclaration" || node.declaration.id
							? "Statement"
							: "Expression",
					);
				}
				if (node.source) {
					c(node.source, st, "Expression");
				}
			};
			base.ExportAllDeclaration = function (node, st, c) {
				if (node.exported) {
					c(node.exported, st);
				}
				c(node.source, st, "Expression");
			};
			base.ImportDeclaration = function (node, st, c) {
				for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
					var spec = list[i];
					c(spec, st);
				}
				c(node.source, st, "Expression");
			};
			base.ImportExpression = function (node, st, c) {
				c(node.source, st, "Expression");
			};
			base.ImportSpecifier =
				base.ImportDefaultSpecifier =
				base.ImportNamespaceSpecifier =
				base.Identifier =
				base.PrivateIdentifier =
				base.Literal =
					ignore;
			base.TaggedTemplateExpression = function (node, st, c) {
				c(node.tag, st, "Expression");
				c(node.quasi, st, "Expression");
			};
			base.ClassDeclaration = base.ClassExpression = function (node, st, c) {
				return c(node, st, "Class");
			};
			base.Class = function (node, st, c) {
				if (node.id) {
					c(node.id, st, "Pattern");
				}
				if (node.superClass) {
					c(node.superClass, st, "Expression");
				}
				c(node.body, st);
			};
			base.ClassBody = function (node, st, c) {
				for (var i = 0, list = node.body; i < list.length; i += 1) {
					var elt = list[i];
					c(elt, st);
				}
			};
			base.MethodDefinition =
				base.PropertyDefinition =
				base.Property =
					function (node, st, c) {
						if (node.computed) {
							c(node.key, st, "Expression");
						}
						if (node.value) {
							c(node.value, st, "Expression");
						}
					};
			exports3.ancestor = ancestor;
			exports3.base = base;
			exports3.findNodeAfter = findNodeAfter;
			exports3.findNodeAround = findNodeAround;
			exports3.findNodeAt = findNodeAt;
			exports3.findNodeBefore = findNodeBefore;
			exports3.full = full;
			exports3.fullAncestor = fullAncestor;
			exports3.make = make;
			exports3.recursive = recursive;
			exports3.simple = simple;
		});
	},
});

// node_modules/.pnpm/cookie@0.7.2/node_modules/cookie/index.js
var require_cookie = __commonJS({
	"node_modules/.pnpm/cookie@0.7.2/node_modules/cookie/index.js"(exports2) {
		"use strict";
		exports2.parse = parse;
		exports2.serialize = serialize;
		var __toString = Object.prototype.toString;
		var __hasOwnProperty = Object.prototype.hasOwnProperty;
		var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
		var cookieValueRegExp =
			/^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;
		var domainValueRegExp =
			/^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
		var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
		function parse(str, opt) {
			if (typeof str !== "string") {
				throw new TypeError("argument str must be a string");
			}
			var obj = {};
			var len = str.length;
			if (len < 2) return obj;
			var dec = (opt && opt.decode) || decode;
			var index = 0;
			var eqIdx = 0;
			var endIdx = 0;
			do {
				eqIdx = str.indexOf("=", index);
				if (eqIdx === -1) break;
				endIdx = str.indexOf(";", index);
				if (endIdx === -1) {
					endIdx = len;
				} else if (eqIdx > endIdx) {
					index = str.lastIndexOf(";", eqIdx - 1) + 1;
					continue;
				}
				var keyStartIdx = startIndex(str, index, eqIdx);
				var keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
				var key = str.slice(keyStartIdx, keyEndIdx);
				if (!__hasOwnProperty.call(obj, key)) {
					var valStartIdx = startIndex(str, eqIdx + 1, endIdx);
					var valEndIdx = endIndex(str, endIdx, valStartIdx);
					if (
						str.charCodeAt(valStartIdx) === 34 &&
						str.charCodeAt(valEndIdx - 1) === 34
					) {
						valStartIdx++;
						valEndIdx--;
					}
					var val = str.slice(valStartIdx, valEndIdx);
					obj[key] = tryDecode(val, dec);
				}
				index = endIdx + 1;
			} while (index < len);
			return obj;
		}
		function startIndex(str, index, max) {
			do {
				var code = str.charCodeAt(index);
				if (code !== 32 && code !== 9) return index;
			} while (++index < max);
			return max;
		}
		function endIndex(str, index, min) {
			while (index > min) {
				var code = str.charCodeAt(--index);
				if (code !== 32 && code !== 9) return index + 1;
			}
			return min;
		}
		function serialize(name, val, opt) {
			var enc = (opt && opt.encode) || encodeURIComponent;
			if (typeof enc !== "function") {
				throw new TypeError("option encode is invalid");
			}
			if (!cookieNameRegExp.test(name)) {
				throw new TypeError("argument name is invalid");
			}
			var value = enc(val);
			if (!cookieValueRegExp.test(value)) {
				throw new TypeError("argument val is invalid");
			}
			var str = name + "=" + value;
			if (!opt) return str;
			if (null != opt.maxAge) {
				var maxAge = Math.floor(opt.maxAge);
				if (!isFinite(maxAge)) {
					throw new TypeError("option maxAge is invalid");
				}
				str += "; Max-Age=" + maxAge;
			}
			if (opt.domain) {
				if (!domainValueRegExp.test(opt.domain)) {
					throw new TypeError("option domain is invalid");
				}
				str += "; Domain=" + opt.domain;
			}
			if (opt.path) {
				if (!pathValueRegExp.test(opt.path)) {
					throw new TypeError("option path is invalid");
				}
				str += "; Path=" + opt.path;
			}
			if (opt.expires) {
				var expires = opt.expires;
				if (!isDate(expires) || isNaN(expires.valueOf())) {
					throw new TypeError("option expires is invalid");
				}
				str += "; Expires=" + expires.toUTCString();
			}
			if (opt.httpOnly) {
				str += "; HttpOnly";
			}
			if (opt.secure) {
				str += "; Secure";
			}
			if (opt.partitioned) {
				str += "; Partitioned";
			}
			if (opt.priority) {
				var priority =
					typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
				switch (priority) {
					case "low":
						str += "; Priority=Low";
						break;
					case "medium":
						str += "; Priority=Medium";
						break;
					case "high":
						str += "; Priority=High";
						break;
					default:
						throw new TypeError("option priority is invalid");
				}
			}
			if (opt.sameSite) {
				var sameSite =
					typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
				switch (sameSite) {
					case true:
						str += "; SameSite=Strict";
						break;
					case "lax":
						str += "; SameSite=Lax";
						break;
					case "strict":
						str += "; SameSite=Strict";
						break;
					case "none":
						str += "; SameSite=None";
						break;
					default:
						throw new TypeError("option sameSite is invalid");
				}
			}
			return str;
		}
		function decode(str) {
			return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
		}
		function isDate(val) {
			return __toString.call(val) === "[object Date]";
		}
		function tryDecode(str, decode2) {
			try {
				return decode2(str);
			} catch (e) {
				return str;
			}
		}
	},
});

// node_modules/.pnpm/mustache@4.2.0/node_modules/mustache/mustache.js
var require_mustache = __commonJS({
	"node_modules/.pnpm/mustache@4.2.0/node_modules/mustache/mustache.js"(exports2, module2) {
		"use strict";
		(function (global2, factory) {
			typeof exports2 === "object" && typeof module2 !== "undefined"
				? (module2.exports = factory())
				: typeof define === "function" && define.amd
					? define(factory)
					: ((global2 = global2 || self), (global2.Mustache = factory()));
		})(exports2, function () {
			"use strict";
			var objectToString = Object.prototype.toString;
			var isArray =
				Array.isArray ||
				function isArrayPolyfill(object) {
					return objectToString.call(object) === "[object Array]";
				};
			function isFunction(object) {
				return typeof object === "function";
			}
			function typeStr(obj) {
				return isArray(obj) ? "array" : typeof obj;
			}
			function escapeRegExp(string) {
				return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
			}
			function hasProperty(obj, propName) {
				return obj != null && typeof obj === "object" && propName in obj;
			}
			function primitiveHasOwnProperty(primitive, propName) {
				return (
					primitive != null &&
					typeof primitive !== "object" &&
					primitive.hasOwnProperty &&
					primitive.hasOwnProperty(propName)
				);
			}
			var regExpTest = RegExp.prototype.test;
			function testRegExp(re, string) {
				return regExpTest.call(re, string);
			}
			var nonSpaceRe = /\S/;
			function isWhitespace(string) {
				return !testRegExp(nonSpaceRe, string);
			}
			var entityMap = {
				"&": "&amp;",
				"<": "&lt;",
				">": "&gt;",
				'"': "&quot;",
				"'": "&#39;",
				"/": "&#x2F;",
				"`": "&#x60;",
				"=": "&#x3D;",
			};
			function escapeHtml(string) {
				return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
					return entityMap[s];
				});
			}
			var whiteRe = /\s*/;
			var spaceRe = /\s+/;
			var equalsRe = /\s*=/;
			var curlyRe = /\s*\}/;
			var tagRe = /#|\^|\/|>|\{|&|=|!/;
			function parseTemplate(template, tags) {
				if (!template) return [];
				var lineHasNonSpace = false;
				var sections = [];
				var tokens = [];
				var spaces = [];
				var hasTag = false;
				var nonSpace = false;
				var indentation = "";
				var tagIndex = 0;
				function stripSpace() {
					if (hasTag && !nonSpace) {
						while (spaces.length) delete tokens[spaces.pop()];
					} else {
						spaces = [];
					}
					hasTag = false;
					nonSpace = false;
				}
				var openingTagRe, closingTagRe, closingCurlyRe;
				function compileTags(tagsToCompile) {
					if (typeof tagsToCompile === "string")
						tagsToCompile = tagsToCompile.split(spaceRe, 2);
					if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
						throw new Error("Invalid tags: " + tagsToCompile);
					openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + "\\s*");
					closingTagRe = new RegExp("\\s*" + escapeRegExp(tagsToCompile[1]));
					closingCurlyRe = new RegExp("\\s*" + escapeRegExp("}" + tagsToCompile[1]));
				}
				compileTags(tags || mustache.tags);
				var scanner = new Scanner(template);
				var start, type, value, chr, token, openSection;
				while (!scanner.eos()) {
					start = scanner.pos;
					value = scanner.scanUntil(openingTagRe);
					if (value) {
						for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
							chr = value.charAt(i);
							if (isWhitespace(chr)) {
								spaces.push(tokens.length);
								indentation += chr;
							} else {
								nonSpace = true;
								lineHasNonSpace = true;
								indentation += " ";
							}
							tokens.push(["text", chr, start, start + 1]);
							start += 1;
							if (chr === "\n") {
								stripSpace();
								indentation = "";
								tagIndex = 0;
								lineHasNonSpace = false;
							}
						}
					}
					if (!scanner.scan(openingTagRe)) break;
					hasTag = true;
					type = scanner.scan(tagRe) || "name";
					scanner.scan(whiteRe);
					if (type === "=") {
						value = scanner.scanUntil(equalsRe);
						scanner.scan(equalsRe);
						scanner.scanUntil(closingTagRe);
					} else if (type === "{") {
						value = scanner.scanUntil(closingCurlyRe);
						scanner.scan(curlyRe);
						scanner.scanUntil(closingTagRe);
						type = "&";
					} else {
						value = scanner.scanUntil(closingTagRe);
					}
					if (!scanner.scan(closingTagRe))
						throw new Error("Unclosed tag at " + scanner.pos);
					if (type == ">") {
						token = [
							type,
							value,
							start,
							scanner.pos,
							indentation,
							tagIndex,
							lineHasNonSpace,
						];
					} else {
						token = [type, value, start, scanner.pos];
					}
					tagIndex++;
					tokens.push(token);
					if (type === "#" || type === "^") {
						sections.push(token);
					} else if (type === "/") {
						openSection = sections.pop();
						if (!openSection)
							throw new Error('Unopened section "' + value + '" at ' + start);
						if (openSection[1] !== value)
							throw new Error(
								'Unclosed section "' + openSection[1] + '" at ' + start,
							);
					} else if (type === "name" || type === "{" || type === "&") {
						nonSpace = true;
					} else if (type === "=") {
						compileTags(value);
					}
				}
				stripSpace();
				openSection = sections.pop();
				if (openSection)
					throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
				return nestTokens(squashTokens(tokens));
			}
			function squashTokens(tokens) {
				var squashedTokens = [];
				var token, lastToken;
				for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
					token = tokens[i];
					if (token) {
						if (token[0] === "text" && lastToken && lastToken[0] === "text") {
							lastToken[1] += token[1];
							lastToken[3] = token[3];
						} else {
							squashedTokens.push(token);
							lastToken = token;
						}
					}
				}
				return squashedTokens;
			}
			function nestTokens(tokens) {
				var nestedTokens = [];
				var collector = nestedTokens;
				var sections = [];
				var token, section;
				for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
					token = tokens[i];
					switch (token[0]) {
						case "#":
						case "^":
							collector.push(token);
							sections.push(token);
							collector = token[4] = [];
							break;
						case "/":
							section = sections.pop();
							section[5] = token[2];
							collector =
								sections.length > 0
									? sections[sections.length - 1][4]
									: nestedTokens;
							break;
						default:
							collector.push(token);
					}
				}
				return nestedTokens;
			}
			function Scanner(string) {
				this.string = string;
				this.tail = string;
				this.pos = 0;
			}
			Scanner.prototype.eos = function eos() {
				return this.tail === "";
			};
			Scanner.prototype.scan = function scan(re) {
				var match = this.tail.match(re);
				if (!match || match.index !== 0) return "";
				var string = match[0];
				this.tail = this.tail.substring(string.length);
				this.pos += string.length;
				return string;
			};
			Scanner.prototype.scanUntil = function scanUntil(re) {
				var index = this.tail.search(re),
					match;
				switch (index) {
					case -1:
						match = this.tail;
						this.tail = "";
						break;
					case 0:
						match = "";
						break;
					default:
						match = this.tail.substring(0, index);
						this.tail = this.tail.substring(index);
				}
				this.pos += match.length;
				return match;
			};
			function Context(view, parentContext) {
				this.view = view;
				this.cache = { ".": this.view };
				this.parent = parentContext;
			}
			Context.prototype.push = function push(view) {
				return new Context(view, this);
			};
			Context.prototype.lookup = function lookup(name) {
				var cache = this.cache;
				var value;
				if (cache.hasOwnProperty(name)) {
					value = cache[name];
				} else {
					var context = this,
						intermediateValue,
						names,
						index,
						lookupHit = false;
					while (context) {
						if (name.indexOf(".") > 0) {
							intermediateValue = context.view;
							names = name.split(".");
							index = 0;
							while (intermediateValue != null && index < names.length) {
								if (index === names.length - 1)
									lookupHit =
										hasProperty(intermediateValue, names[index]) ||
										primitiveHasOwnProperty(intermediateValue, names[index]);
								intermediateValue = intermediateValue[names[index++]];
							}
						} else {
							intermediateValue = context.view[name];
							lookupHit = hasProperty(context.view, name);
						}
						if (lookupHit) {
							value = intermediateValue;
							break;
						}
						context = context.parent;
					}
					cache[name] = value;
				}
				if (isFunction(value)) value = value.call(this.view);
				return value;
			};
			function Writer() {
				this.templateCache = {
					_cache: {},
					set: function set(key, value) {
						this._cache[key] = value;
					},
					get: function get(key) {
						return this._cache[key];
					},
					clear: function clear() {
						this._cache = {};
					},
				};
			}
			Writer.prototype.clearCache = function clearCache() {
				if (typeof this.templateCache !== "undefined") {
					this.templateCache.clear();
				}
			};
			Writer.prototype.parse = function parse(template, tags) {
				var cache = this.templateCache;
				var cacheKey = template + ":" + (tags || mustache.tags).join(":");
				var isCacheEnabled = typeof cache !== "undefined";
				var tokens = isCacheEnabled ? cache.get(cacheKey) : void 0;
				if (tokens == void 0) {
					tokens = parseTemplate(template, tags);
					isCacheEnabled && cache.set(cacheKey, tokens);
				}
				return tokens;
			};
			Writer.prototype.render = function render(template, view, partials, config) {
				var tags = this.getConfigTags(config);
				var tokens = this.parse(template, tags);
				var context = view instanceof Context ? view : new Context(view, void 0);
				return this.renderTokens(tokens, context, partials, template, config);
			};
			Writer.prototype.renderTokens = function renderTokens(
				tokens,
				context,
				partials,
				originalTemplate,
				config,
			) {
				var buffer = "";
				var token, symbol, value;
				for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
					value = void 0;
					token = tokens[i];
					symbol = token[0];
					if (symbol === "#")
						value = this.renderSection(
							token,
							context,
							partials,
							originalTemplate,
							config,
						);
					else if (symbol === "^")
						value = this.renderInverted(
							token,
							context,
							partials,
							originalTemplate,
							config,
						);
					else if (symbol === ">")
						value = this.renderPartial(token, context, partials, config);
					else if (symbol === "&") value = this.unescapedValue(token, context);
					else if (symbol === "name") value = this.escapedValue(token, context, config);
					else if (symbol === "text") value = this.rawValue(token);
					if (value !== void 0) buffer += value;
				}
				return buffer;
			};
			Writer.prototype.renderSection = function renderSection(
				token,
				context,
				partials,
				originalTemplate,
				config,
			) {
				var self2 = this;
				var buffer = "";
				var value = context.lookup(token[1]);
				function subRender(template) {
					return self2.render(template, context, partials, config);
				}
				if (!value) return;
				if (isArray(value)) {
					for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
						buffer += this.renderTokens(
							token[4],
							context.push(value[j]),
							partials,
							originalTemplate,
							config,
						);
					}
				} else if (
					typeof value === "object" ||
					typeof value === "string" ||
					typeof value === "number"
				) {
					buffer += this.renderTokens(
						token[4],
						context.push(value),
						partials,
						originalTemplate,
						config,
					);
				} else if (isFunction(value)) {
					if (typeof originalTemplate !== "string")
						throw new Error(
							"Cannot use higher-order sections without the original template",
						);
					value = value.call(
						context.view,
						originalTemplate.slice(token[3], token[5]),
						subRender,
					);
					if (value != null) buffer += value;
				} else {
					buffer += this.renderTokens(
						token[4],
						context,
						partials,
						originalTemplate,
						config,
					);
				}
				return buffer;
			};
			Writer.prototype.renderInverted = function renderInverted(
				token,
				context,
				partials,
				originalTemplate,
				config,
			) {
				var value = context.lookup(token[1]);
				if (!value || (isArray(value) && value.length === 0))
					return this.renderTokens(token[4], context, partials, originalTemplate, config);
			};
			Writer.prototype.indentPartial = function indentPartial(
				partial,
				indentation,
				lineHasNonSpace,
			) {
				var filteredIndentation = indentation.replace(/[^ \t]/g, "");
				var partialByNl = partial.split("\n");
				for (var i = 0; i < partialByNl.length; i++) {
					if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
						partialByNl[i] = filteredIndentation + partialByNl[i];
					}
				}
				return partialByNl.join("\n");
			};
			Writer.prototype.renderPartial = function renderPartial(
				token,
				context,
				partials,
				config,
			) {
				if (!partials) return;
				var tags = this.getConfigTags(config);
				var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
				if (value != null) {
					var lineHasNonSpace = token[6];
					var tagIndex = token[5];
					var indentation = token[4];
					var indentedValue = value;
					if (tagIndex == 0 && indentation) {
						indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
					}
					var tokens = this.parse(indentedValue, tags);
					return this.renderTokens(tokens, context, partials, indentedValue, config);
				}
			};
			Writer.prototype.unescapedValue = function unescapedValue(token, context) {
				var value = context.lookup(token[1]);
				if (value != null) return value;
			};
			Writer.prototype.escapedValue = function escapedValue(token, context, config) {
				var escape = this.getConfigEscape(config) || mustache.escape;
				var value = context.lookup(token[1]);
				if (value != null)
					return typeof value === "number" && escape === mustache.escape
						? String(value)
						: escape(value);
			};
			Writer.prototype.rawValue = function rawValue(token) {
				return token[1];
			};
			Writer.prototype.getConfigTags = function getConfigTags(config) {
				if (isArray(config)) {
					return config;
				} else if (config && typeof config === "object") {
					return config.tags;
				} else {
					return void 0;
				}
			};
			Writer.prototype.getConfigEscape = function getConfigEscape(config) {
				if (config && typeof config === "object" && !isArray(config)) {
					return config.escape;
				} else {
					return void 0;
				}
			};
			var mustache = {
				name: "mustache.js",
				version: "4.2.0",
				tags: ["{{", "}}"],
				clearCache: void 0,
				escape: void 0,
				parse: void 0,
				render: void 0,
				Scanner: void 0,
				Context: void 0,
				Writer: void 0,
				/**
				 * Allows a user to override the default caching strategy, by providing an
				 * object with set, get and clear methods. This can also be used to disable
				 * the cache by setting it to the literal `undefined`.
				 */
				set templateCache(cache) {
					defaultWriter.templateCache = cache;
				},
				/**
				 * Gets the default or overridden caching object from the default writer.
				 */
				get templateCache() {
					return defaultWriter.templateCache;
				},
			};
			var defaultWriter = new Writer();
			mustache.clearCache = function clearCache() {
				return defaultWriter.clearCache();
			};
			mustache.parse = function parse(template, tags) {
				return defaultWriter.parse(template, tags);
			};
			mustache.render = function render(template, view, partials, config) {
				if (typeof template !== "string") {
					throw new TypeError(
						'Invalid template! Template should be a "string" but "' +
							typeStr(template) +
							'" was given as the first argument for mustache#render(template, view, partials)',
					);
				}
				return defaultWriter.render(template, view, partials, config);
			};
			mustache.escape = escapeHtml;
			mustache.Scanner = Scanner;
			mustache.Context = Context;
			mustache.Writer = Writer;
			return mustache;
		});
	},
});

// node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
	"node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64.js"(exports2) {
		"use strict";
		var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(
			"",
		);
		exports2.encode = function (number) {
			if (0 <= number && number < intToCharMap.length) {
				return intToCharMap[number];
			}
			throw new TypeError("Must be between 0 and 63: " + number);
		};
		exports2.decode = function (charCode) {
			var bigA = 65;
			var bigZ = 90;
			var littleA = 97;
			var littleZ = 122;
			var zero = 48;
			var nine = 57;
			var plus = 43;
			var slash = 47;
			var littleOffset = 26;
			var numberOffset = 52;
			if (bigA <= charCode && charCode <= bigZ) {
				return charCode - bigA;
			}
			if (littleA <= charCode && charCode <= littleZ) {
				return charCode - littleA + littleOffset;
			}
			if (zero <= charCode && charCode <= nine) {
				return charCode - zero + numberOffset;
			}
			if (charCode == plus) {
				return 62;
			}
			if (charCode == slash) {
				return 63;
			}
			return -1;
		};
	},
});

// node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
	"node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64-vlq.js"(exports2) {
		"use strict";
		var base64 = require_base64();
		var VLQ_BASE_SHIFT = 5;
		var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
		var VLQ_BASE_MASK = VLQ_BASE - 1;
		var VLQ_CONTINUATION_BIT = VLQ_BASE;
		function toVLQSigned(aValue) {
			return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
		}
		function fromVLQSigned(aValue) {
			var isNegative = (aValue & 1) === 1;
			var shifted = aValue >> 1;
			return isNegative ? -shifted : shifted;
		}
		exports2.encode = function base64VLQ_encode(aValue) {
			var encoded = "";
			var digit;
			var vlq = toVLQSigned(aValue);
			do {
				digit = vlq & VLQ_BASE_MASK;
				vlq >>>= VLQ_BASE_SHIFT;
				if (vlq > 0) {
					digit |= VLQ_CONTINUATION_BIT;
				}
				encoded += base64.encode(digit);
			} while (vlq > 0);
			return encoded;
		};
		exports2.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
			var strLen = aStr.length;
			var result = 0;
			var shift = 0;
			var continuation, digit;
			do {
				if (aIndex >= strLen) {
					throw new Error("Expected more digits in base 64 VLQ value.");
				}
				digit = base64.decode(aStr.charCodeAt(aIndex++));
				if (digit === -1) {
					throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
				}
				continuation = !!(digit & VLQ_CONTINUATION_BIT);
				digit &= VLQ_BASE_MASK;
				result = result + (digit << shift);
				shift += VLQ_BASE_SHIFT;
			} while (continuation);
			aOutParam.value = fromVLQSigned(result);
			aOutParam.rest = aIndex;
		};
	},
});

// node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/util.js
var require_util10 = __commonJS({
	"node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/util.js"(exports2) {
		"use strict";
		function getArg(aArgs, aName, aDefaultValue) {
			if (aName in aArgs) {
				return aArgs[aName];
			} else if (arguments.length === 3) {
				return aDefaultValue;
			} else {
				throw new Error('"' + aName + '" is a required argument.');
			}
		}
		exports2.getArg = getArg;
		var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
		var dataUrlRegexp = /^data:.+\,.+$/;
		function urlParse(aUrl) {
			var match = aUrl.match(urlRegexp);
			if (!match) {
				return null;
			}
			return {
				scheme: match[1],
				auth: match[2],
				host: match[3],
				port: match[4],
				path: match[5],
			};
		}
		exports2.urlParse = urlParse;
		function urlGenerate(aParsedUrl) {
			var url = "";
			if (aParsedUrl.scheme) {
				url += aParsedUrl.scheme + ":";
			}
			url += "//";
			if (aParsedUrl.auth) {
				url += aParsedUrl.auth + "@";
			}
			if (aParsedUrl.host) {
				url += aParsedUrl.host;
			}
			if (aParsedUrl.port) {
				url += ":" + aParsedUrl.port;
			}
			if (aParsedUrl.path) {
				url += aParsedUrl.path;
			}
			return url;
		}
		exports2.urlGenerate = urlGenerate;
		function normalize(aPath) {
			var path = aPath;
			var url = urlParse(aPath);
			if (url) {
				if (!url.path) {
					return aPath;
				}
				path = url.path;
			}
			var isAbsolute = exports2.isAbsolute(path);
			var parts = path.split(/\/+/);
			for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
				part = parts[i];
				if (part === ".") {
					parts.splice(i, 1);
				} else if (part === "..") {
					up++;
				} else if (up > 0) {
					if (part === "") {
						parts.splice(i + 1, up);
						up = 0;
					} else {
						parts.splice(i, 2);
						up--;
					}
				}
			}
			path = parts.join("/");
			if (path === "") {
				path = isAbsolute ? "/" : ".";
			}
			if (url) {
				url.path = path;
				return urlGenerate(url);
			}
			return path;
		}
		exports2.normalize = normalize;
		function join(aRoot, aPath) {
			if (aRoot === "") {
				aRoot = ".";
			}
			if (aPath === "") {
				aPath = ".";
			}
			var aPathUrl = urlParse(aPath);
			var aRootUrl = urlParse(aRoot);
			if (aRootUrl) {
				aRoot = aRootUrl.path || "/";
			}
			if (aPathUrl && !aPathUrl.scheme) {
				if (aRootUrl) {
					aPathUrl.scheme = aRootUrl.scheme;
				}
				return urlGenerate(aPathUrl);
			}
			if (aPathUrl || aPath.match(dataUrlRegexp)) {
				return aPath;
			}
			if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
				aRootUrl.host = aPath;
				return urlGenerate(aRootUrl);
			}
			var joined =
				aPath.charAt(0) === "/"
					? aPath
					: normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
			if (aRootUrl) {
				aRootUrl.path = joined;
				return urlGenerate(aRootUrl);
			}
			return joined;
		}
		exports2.join = join;
		exports2.isAbsolute = function (aPath) {
			return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
		};
		function relative(aRoot, aPath) {
			if (aRoot === "") {
				aRoot = ".";
			}
			aRoot = aRoot.replace(/\/$/, "");
			var level = 0;
			while (aPath.indexOf(aRoot + "/") !== 0) {
				var index = aRoot.lastIndexOf("/");
				if (index < 0) {
					return aPath;
				}
				aRoot = aRoot.slice(0, index);
				if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
					return aPath;
				}
				++level;
			}
			return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
		}
		exports2.relative = relative;
		var supportsNullProto = (function () {
			var obj = /* @__PURE__ */ Object.create(null);
			return !("__proto__" in obj);
		})();
		function identity(s) {
			return s;
		}
		function toSetString(aStr) {
			if (isProtoString(aStr)) {
				return "$" + aStr;
			}
			return aStr;
		}
		exports2.toSetString = supportsNullProto ? identity : toSetString;
		function fromSetString(aStr) {
			if (isProtoString(aStr)) {
				return aStr.slice(1);
			}
			return aStr;
		}
		exports2.fromSetString = supportsNullProto ? identity : fromSetString;
		function isProtoString(s) {
			if (!s) {
				return false;
			}
			var length = s.length;
			if (length < 9) {
				return false;
			}
			if (
				s.charCodeAt(length - 1) !== 95 ||
				s.charCodeAt(length - 2) !== 95 ||
				s.charCodeAt(length - 3) !== 111 ||
				s.charCodeAt(length - 4) !== 116 ||
				s.charCodeAt(length - 5) !== 111 ||
				s.charCodeAt(length - 6) !== 114 ||
				s.charCodeAt(length - 7) !== 112 ||
				s.charCodeAt(length - 8) !== 95 ||
				s.charCodeAt(length - 9) !== 95
			) {
				return false;
			}
			for (var i = length - 10; i >= 0; i--) {
				if (s.charCodeAt(i) !== 36) {
					return false;
				}
			}
			return true;
		}
		function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
			var cmp = strcmp(mappingA.source, mappingB.source);
			if (cmp !== 0) {
				return cmp;
			}
			cmp = mappingA.originalLine - mappingB.originalLine;
			if (cmp !== 0) {
				return cmp;
			}
			cmp = mappingA.originalColumn - mappingB.originalColumn;
			if (cmp !== 0 || onlyCompareOriginal) {
				return cmp;
			}
			cmp = mappingA.generatedColumn - mappingB.generatedColumn;
			if (cmp !== 0) {
				return cmp;
			}
			cmp = mappingA.generatedLine - mappingB.generatedLine;
			if (cmp !== 0) {
				return cmp;
			}
			return strcmp(mappingA.name, mappingB.name);
		}
		exports2.compareByOriginalPositions = compareByOriginalPositions;
		function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
			var cmp = mappingA.generatedLine - mappingB.generatedLine;
			if (cmp !== 0) {
				return cmp;
			}
			cmp = mappingA.generatedColumn - mappingB.generatedColumn;
			if (cmp !== 0 || onlyCompareGenerated) {
				return cmp;
			}
			cmp = strcmp(mappingA.source, mappingB.source);
			if (cmp !== 0) {
				return cmp;
			}
			cmp = mappingA.originalLine - mappingB.originalLine;
			if (cmp !== 0) {
				return cmp;
			}
			cmp = mappingA.originalColumn - mappingB.originalColumn;
			if (cmp !== 0) {
				return cmp;
			}
			return strcmp(mappingA.name, mappingB.name);
		}
		exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
		function strcmp(aStr1, aStr2) {
			if (aStr1 === aStr2) {
				return 0;
			}
			if (aStr1 === null) {
				return 1;
			}
			if (aStr2 === null) {
				return -1;
			}
			if (aStr1 > aStr2) {
				return 1;
			}
			return -1;
		}
		function compareByGeneratedPositionsInflated(mappingA, mappingB) {
			var cmp = mappingA.generatedLine - mappingB.generatedLine;
			if (cmp !== 0) {
				return cmp;
			}
			cmp = mappingA.generatedColumn - mappingB.generatedColumn;
			if (cmp !== 0) {
				return cmp;
			}
			cmp = strcmp(mappingA.source, mappingB.source);
			if (cmp !== 0) {
				return cmp;
			}
			cmp = mappingA.originalLine - mappingB.originalLine;
			if (cmp !== 0) {
				return cmp;
			}
			cmp = mappingA.originalColumn - mappingB.originalColumn;
			if (cmp !== 0) {
				return cmp;
			}
			return strcmp(mappingA.name, mappingB.name);
		}
		exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
		function parseSourceMapInput(str) {
			return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
		}
		exports2.parseSourceMapInput = parseSourceMapInput;
		function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
			sourceURL = sourceURL || "";
			if (sourceRoot) {
				if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
					sourceRoot += "/";
				}
				sourceURL = sourceRoot + sourceURL;
			}
			if (sourceMapURL) {
				var parsed = urlParse(sourceMapURL);
				if (!parsed) {
					throw new Error("sourceMapURL could not be parsed");
				}
				if (parsed.path) {
					var index = parsed.path.lastIndexOf("/");
					if (index >= 0) {
						parsed.path = parsed.path.substring(0, index + 1);
					}
				}
				sourceURL = join(urlGenerate(parsed), sourceURL);
			}
			return normalize(sourceURL);
		}
		exports2.computeSourceURL = computeSourceURL;
	},
});

// node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
	"node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/array-set.js"(exports2) {
		"use strict";
		var util = require_util10();
		var has = Object.prototype.hasOwnProperty;
		var hasNativeMap = typeof Map !== "undefined";
		function ArraySet() {
			this._array = [];
			this._set = hasNativeMap
				? /* @__PURE__ */ new Map()
				: /* @__PURE__ */ Object.create(null);
		}
		ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
			var set = new ArraySet();
			for (var i = 0, len = aArray.length; i < len; i++) {
				set.add(aArray[i], aAllowDuplicates);
			}
			return set;
		};
		ArraySet.prototype.size = function ArraySet_size() {
			return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
		};
		ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
			var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
			var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
			var idx = this._array.length;
			if (!isDuplicate || aAllowDuplicates) {
				this._array.push(aStr);
			}
			if (!isDuplicate) {
				if (hasNativeMap) {
					this._set.set(aStr, idx);
				} else {
					this._set[sStr] = idx;
				}
			}
		};
		ArraySet.prototype.has = function ArraySet_has(aStr) {
			if (hasNativeMap) {
				return this._set.has(aStr);
			} else {
				var sStr = util.toSetString(aStr);
				return has.call(this._set, sStr);
			}
		};
		ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
			if (hasNativeMap) {
				var idx = this._set.get(aStr);
				if (idx >= 0) {
					return idx;
				}
			} else {
				var sStr = util.toSetString(aStr);
				if (has.call(this._set, sStr)) {
					return this._set[sStr];
				}
			}
			throw new Error('"' + aStr + '" is not in the set.');
		};
		ArraySet.prototype.at = function ArraySet_at(aIdx) {
			if (aIdx >= 0 && aIdx < this._array.length) {
				return this._array[aIdx];
			}
			throw new Error("No element indexed by " + aIdx);
		};
		ArraySet.prototype.toArray = function ArraySet_toArray() {
			return this._array.slice();
		};
		exports2.ArraySet = ArraySet;
	},
});

// node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
	"node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/mapping-list.js"(exports2) {
		"use strict";
		var util = require_util10();
		function generatedPositionAfter(mappingA, mappingB) {
			var lineA = mappingA.generatedLine;
			var lineB = mappingB.generatedLine;
			var columnA = mappingA.generatedColumn;
			var columnB = mappingB.generatedColumn;
			return (
				lineB > lineA ||
				(lineB == lineA && columnB >= columnA) ||
				util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0
			);
		}
		function MappingList() {
			this._array = [];
			this._sorted = true;
			this._last = { generatedLine: -1, generatedColumn: 0 };
		}
		MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
			this._array.forEach(aCallback, aThisArg);
		};
		MappingList.prototype.add = function MappingList_add(aMapping) {
			if (generatedPositionAfter(this._last, aMapping)) {
				this._last = aMapping;
				this._array.push(aMapping);
			} else {
				this._sorted = false;
				this._array.push(aMapping);
			}
		};
		MappingList.prototype.toArray = function MappingList_toArray() {
			if (!this._sorted) {
				this._array.sort(util.compareByGeneratedPositionsInflated);
				this._sorted = true;
			}
			return this._array;
		};
		exports2.MappingList = MappingList;
	},
});

// node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
	"node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-generator.js"(
		exports2,
	) {
		"use strict";
		var base64VLQ = require_base64_vlq();
		var util = require_util10();
		var ArraySet = require_array_set().ArraySet;
		var MappingList = require_mapping_list().MappingList;
		function SourceMapGenerator(aArgs) {
			if (!aArgs) {
				aArgs = {};
			}
			this._file = util.getArg(aArgs, "file", null);
			this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
			this._skipValidation = util.getArg(aArgs, "skipValidation", false);
			this._sources = new ArraySet();
			this._names = new ArraySet();
			this._mappings = new MappingList();
			this._sourcesContents = null;
		}
		SourceMapGenerator.prototype._version = 3;
		SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(
			aSourceMapConsumer,
		) {
			var sourceRoot = aSourceMapConsumer.sourceRoot;
			var generator = new SourceMapGenerator({
				file: aSourceMapConsumer.file,
				sourceRoot,
			});
			aSourceMapConsumer.eachMapping(function (mapping) {
				var newMapping = {
					generated: {
						line: mapping.generatedLine,
						column: mapping.generatedColumn,
					},
				};
				if (mapping.source != null) {
					newMapping.source = mapping.source;
					if (sourceRoot != null) {
						newMapping.source = util.relative(sourceRoot, newMapping.source);
					}
					newMapping.original = {
						line: mapping.originalLine,
						column: mapping.originalColumn,
					};
					if (mapping.name != null) {
						newMapping.name = mapping.name;
					}
				}
				generator.addMapping(newMapping);
			});
			aSourceMapConsumer.sources.forEach(function (sourceFile) {
				var sourceRelative = sourceFile;
				if (sourceRoot !== null) {
					sourceRelative = util.relative(sourceRoot, sourceFile);
				}
				if (!generator._sources.has(sourceRelative)) {
					generator._sources.add(sourceRelative);
				}
				var content = aSourceMapConsumer.sourceContentFor(sourceFile);
				if (content != null) {
					generator.setSourceContent(sourceFile, content);
				}
			});
			return generator;
		};
		SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
			var generated = util.getArg(aArgs, "generated");
			var original = util.getArg(aArgs, "original", null);
			var source = util.getArg(aArgs, "source", null);
			var name = util.getArg(aArgs, "name", null);
			if (!this._skipValidation) {
				this._validateMapping(generated, original, source, name);
			}
			if (source != null) {
				source = String(source);
				if (!this._sources.has(source)) {
					this._sources.add(source);
				}
			}
			if (name != null) {
				name = String(name);
				if (!this._names.has(name)) {
					this._names.add(name);
				}
			}
			this._mappings.add({
				generatedLine: generated.line,
				generatedColumn: generated.column,
				originalLine: original != null && original.line,
				originalColumn: original != null && original.column,
				source,
				name,
			});
		};
		SourceMapGenerator.prototype.setSourceContent =
			function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
				var source = aSourceFile;
				if (this._sourceRoot != null) {
					source = util.relative(this._sourceRoot, source);
				}
				if (aSourceContent != null) {
					if (!this._sourcesContents) {
						this._sourcesContents = /* @__PURE__ */ Object.create(null);
					}
					this._sourcesContents[util.toSetString(source)] = aSourceContent;
				} else if (this._sourcesContents) {
					delete this._sourcesContents[util.toSetString(source)];
					if (Object.keys(this._sourcesContents).length === 0) {
						this._sourcesContents = null;
					}
				}
			};
		SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(
			aSourceMapConsumer,
			aSourceFile,
			aSourceMapPath,
		) {
			var sourceFile = aSourceFile;
			if (aSourceFile == null) {
				if (aSourceMapConsumer.file == null) {
					throw new Error(
						`SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`,
					);
				}
				sourceFile = aSourceMapConsumer.file;
			}
			var sourceRoot = this._sourceRoot;
			if (sourceRoot != null) {
				sourceFile = util.relative(sourceRoot, sourceFile);
			}
			var newSources = new ArraySet();
			var newNames = new ArraySet();
			this._mappings.unsortedForEach(function (mapping) {
				if (mapping.source === sourceFile && mapping.originalLine != null) {
					var original = aSourceMapConsumer.originalPositionFor({
						line: mapping.originalLine,
						column: mapping.originalColumn,
					});
					if (original.source != null) {
						mapping.source = original.source;
						if (aSourceMapPath != null) {
							mapping.source = util.join(aSourceMapPath, mapping.source);
						}
						if (sourceRoot != null) {
							mapping.source = util.relative(sourceRoot, mapping.source);
						}
						mapping.originalLine = original.line;
						mapping.originalColumn = original.column;
						if (original.name != null) {
							mapping.name = original.name;
						}
					}
				}
				var source = mapping.source;
				if (source != null && !newSources.has(source)) {
					newSources.add(source);
				}
				var name = mapping.name;
				if (name != null && !newNames.has(name)) {
					newNames.add(name);
				}
			}, this);
			this._sources = newSources;
			this._names = newNames;
			aSourceMapConsumer.sources.forEach(function (sourceFile2) {
				var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
				if (content != null) {
					if (aSourceMapPath != null) {
						sourceFile2 = util.join(aSourceMapPath, sourceFile2);
					}
					if (sourceRoot != null) {
						sourceFile2 = util.relative(sourceRoot, sourceFile2);
					}
					this.setSourceContent(sourceFile2, content);
				}
			}, this);
		};
		SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(
			aGenerated,
			aOriginal,
			aSource,
			aName,
		) {
			if (
				aOriginal &&
				typeof aOriginal.line !== "number" &&
				typeof aOriginal.column !== "number"
			) {
				throw new Error(
					"original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.",
				);
			}
			if (
				aGenerated &&
				"line" in aGenerated &&
				"column" in aGenerated &&
				aGenerated.line > 0 &&
				aGenerated.column >= 0 &&
				!aOriginal &&
				!aSource &&
				!aName
			) {
				return;
			} else if (
				aGenerated &&
				"line" in aGenerated &&
				"column" in aGenerated &&
				aOriginal &&
				"line" in aOriginal &&
				"column" in aOriginal &&
				aGenerated.line > 0 &&
				aGenerated.column >= 0 &&
				aOriginal.line > 0 &&
				aOriginal.column >= 0 &&
				aSource
			) {
				return;
			} else {
				throw new Error(
					"Invalid mapping: " +
						JSON.stringify({
							generated: aGenerated,
							source: aSource,
							original: aOriginal,
							name: aName,
						}),
				);
			}
		};
		SourceMapGenerator.prototype._serializeMappings =
			function SourceMapGenerator_serializeMappings() {
				var previousGeneratedColumn = 0;
				var previousGeneratedLine = 1;
				var previousOriginalColumn = 0;
				var previousOriginalLine = 0;
				var previousName = 0;
				var previousSource = 0;
				var result = "";
				var next;
				var mapping;
				var nameIdx;
				var sourceIdx;
				var mappings = this._mappings.toArray();
				for (var i = 0, len = mappings.length; i < len; i++) {
					mapping = mappings[i];
					next = "";
					if (mapping.generatedLine !== previousGeneratedLine) {
						previousGeneratedColumn = 0;
						while (mapping.generatedLine !== previousGeneratedLine) {
							next += ";";
							previousGeneratedLine++;
						}
					} else {
						if (i > 0) {
							if (
								!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])
							) {
								continue;
							}
							next += ",";
						}
					}
					next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
					previousGeneratedColumn = mapping.generatedColumn;
					if (mapping.source != null) {
						sourceIdx = this._sources.indexOf(mapping.source);
						next += base64VLQ.encode(sourceIdx - previousSource);
						previousSource = sourceIdx;
						next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
						previousOriginalLine = mapping.originalLine - 1;
						next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
						previousOriginalColumn = mapping.originalColumn;
						if (mapping.name != null) {
							nameIdx = this._names.indexOf(mapping.name);
							next += base64VLQ.encode(nameIdx - previousName);
							previousName = nameIdx;
						}
					}
					result += next;
				}
				return result;
			};
		SourceMapGenerator.prototype._generateSourcesContent =
			function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
				return aSources.map(function (source) {
					if (!this._sourcesContents) {
						return null;
					}
					if (aSourceRoot != null) {
						source = util.relative(aSourceRoot, source);
					}
					var key = util.toSetString(source);
					return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
						? this._sourcesContents[key]
						: null;
				}, this);
			};
		SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
			var map = {
				version: this._version,
				sources: this._sources.toArray(),
				names: this._names.toArray(),
				mappings: this._serializeMappings(),
			};
			if (this._file != null) {
				map.file = this._file;
			}
			if (this._sourceRoot != null) {
				map.sourceRoot = this._sourceRoot;
			}
			if (this._sourcesContents) {
				map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
			}
			return map;
		};
		SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
			return JSON.stringify(this.toJSON());
		};
		exports2.SourceMapGenerator = SourceMapGenerator;
	},
});

// node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
	"node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/binary-search.js"(exports2) {
		"use strict";
		exports2.GREATEST_LOWER_BOUND = 1;
		exports2.LEAST_UPPER_BOUND = 2;
		function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
			var mid = Math.floor((aHigh - aLow) / 2) + aLow;
			var cmp = aCompare(aNeedle, aHaystack[mid], true);
			if (cmp === 0) {
				return mid;
			} else if (cmp > 0) {
				if (aHigh - mid > 1) {
					return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
				}
				if (aBias == exports2.LEAST_UPPER_BOUND) {
					return aHigh < aHaystack.length ? aHigh : -1;
				} else {
					return mid;
				}
			} else {
				if (mid - aLow > 1) {
					return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
				}
				if (aBias == exports2.LEAST_UPPER_BOUND) {
					return mid;
				} else {
					return aLow < 0 ? -1 : aLow;
				}
			}
		}
		exports2.search = function search(aNeedle, aHaystack, aCompare, aBias) {
			if (aHaystack.length === 0) {
				return -1;
			}
			var index = recursiveSearch(
				-1,
				aHaystack.length,
				aNeedle,
				aHaystack,
				aCompare,
				aBias || exports2.GREATEST_LOWER_BOUND,
			);
			if (index < 0) {
				return -1;
			}
			while (index - 1 >= 0) {
				if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
					break;
				}
				--index;
			}
			return index;
		};
	},
});

// node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS({
	"node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/quick-sort.js"(exports2) {
		"use strict";
		function swap(ary, x, y) {
			var temp = ary[x];
			ary[x] = ary[y];
			ary[y] = temp;
		}
		function randomIntInRange(low, high) {
			return Math.round(low + Math.random() * (high - low));
		}
		function doQuickSort(ary, comparator, p, r) {
			if (p < r) {
				var pivotIndex = randomIntInRange(p, r);
				var i = p - 1;
				swap(ary, pivotIndex, r);
				var pivot = ary[r];
				for (var j = p; j < r; j++) {
					if (comparator(ary[j], pivot) <= 0) {
						i += 1;
						swap(ary, i, j);
					}
				}
				swap(ary, i + 1, j);
				var q = i + 1;
				doQuickSort(ary, comparator, p, q - 1);
				doQuickSort(ary, comparator, q + 1, r);
			}
		}
		exports2.quickSort = function (ary, comparator) {
			doQuickSort(ary, comparator, 0, ary.length - 1);
		};
	},
});

// node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
	"node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-consumer.js"(
		exports2,
	) {
		"use strict";
		var util = require_util10();
		var binarySearch = require_binary_search();
		var ArraySet = require_array_set().ArraySet;
		var base64VLQ = require_base64_vlq();
		var quickSort = require_quick_sort().quickSort;
		function SourceMapConsumer(aSourceMap, aSourceMapURL) {
			var sourceMap = aSourceMap;
			if (typeof aSourceMap === "string") {
				sourceMap = util.parseSourceMapInput(aSourceMap);
			}
			return sourceMap.sections != null
				? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
				: new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
		}
		SourceMapConsumer.fromSourceMap = function (aSourceMap, aSourceMapURL) {
			return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
		};
		SourceMapConsumer.prototype._version = 3;
		SourceMapConsumer.prototype.__generatedMappings = null;
		Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
			configurable: true,
			enumerable: true,
			get: function () {
				if (!this.__generatedMappings) {
					this._parseMappings(this._mappings, this.sourceRoot);
				}
				return this.__generatedMappings;
			},
		});
		SourceMapConsumer.prototype.__originalMappings = null;
		Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
			configurable: true,
			enumerable: true,
			get: function () {
				if (!this.__originalMappings) {
					this._parseMappings(this._mappings, this.sourceRoot);
				}
				return this.__originalMappings;
			},
		});
		SourceMapConsumer.prototype._charIsMappingSeparator =
			function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
				var c = aStr.charAt(index);
				return c === ";" || c === ",";
			};
		SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(
			aStr,
			aSourceRoot,
		) {
			throw new Error("Subclasses must implement _parseMappings");
		};
		SourceMapConsumer.GENERATED_ORDER = 1;
		SourceMapConsumer.ORIGINAL_ORDER = 2;
		SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
		SourceMapConsumer.LEAST_UPPER_BOUND = 2;
		SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(
			aCallback,
			aContext,
			aOrder,
		) {
			var context = aContext || null;
			var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
			var mappings;
			switch (order) {
				case SourceMapConsumer.GENERATED_ORDER:
					mappings = this._generatedMappings;
					break;
				case SourceMapConsumer.ORIGINAL_ORDER:
					mappings = this._originalMappings;
					break;
				default:
					throw new Error("Unknown order of iteration.");
			}
			var sourceRoot = this.sourceRoot;
			mappings
				.map(function (mapping) {
					var source = mapping.source === null ? null : this._sources.at(mapping.source);
					source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
					return {
						source,
						generatedLine: mapping.generatedLine,
						generatedColumn: mapping.generatedColumn,
						originalLine: mapping.originalLine,
						originalColumn: mapping.originalColumn,
						name: mapping.name === null ? null : this._names.at(mapping.name),
					};
				}, this)
				.forEach(aCallback, context);
		};
		SourceMapConsumer.prototype.allGeneratedPositionsFor =
			function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
				var line = util.getArg(aArgs, "line");
				var needle = {
					source: util.getArg(aArgs, "source"),
					originalLine: line,
					originalColumn: util.getArg(aArgs, "column", 0),
				};
				needle.source = this._findSourceIndex(needle.source);
				if (needle.source < 0) {
					return [];
				}
				var mappings = [];
				var index = this._findMapping(
					needle,
					this._originalMappings,
					"originalLine",
					"originalColumn",
					util.compareByOriginalPositions,
					binarySearch.LEAST_UPPER_BOUND,
				);
				if (index >= 0) {
					var mapping = this._originalMappings[index];
					if (aArgs.column === void 0) {
						var originalLine = mapping.originalLine;
						while (mapping && mapping.originalLine === originalLine) {
							mappings.push({
								line: util.getArg(mapping, "generatedLine", null),
								column: util.getArg(mapping, "generatedColumn", null),
								lastColumn: util.getArg(mapping, "lastGeneratedColumn", null),
							});
							mapping = this._originalMappings[++index];
						}
					} else {
						var originalColumn = mapping.originalColumn;
						while (
							mapping &&
							mapping.originalLine === line &&
							mapping.originalColumn == originalColumn
						) {
							mappings.push({
								line: util.getArg(mapping, "generatedLine", null),
								column: util.getArg(mapping, "generatedColumn", null),
								lastColumn: util.getArg(mapping, "lastGeneratedColumn", null),
							});
							mapping = this._originalMappings[++index];
						}
					}
				}
				return mappings;
			};
		exports2.SourceMapConsumer = SourceMapConsumer;
		function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
			var sourceMap = aSourceMap;
			if (typeof aSourceMap === "string") {
				sourceMap = util.parseSourceMapInput(aSourceMap);
			}
			var version = util.getArg(sourceMap, "version");
			var sources = util.getArg(sourceMap, "sources");
			var names = util.getArg(sourceMap, "names", []);
			var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
			var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
			var mappings = util.getArg(sourceMap, "mappings");
			var file = util.getArg(sourceMap, "file", null);
			if (version != this._version) {
				throw new Error("Unsupported version: " + version);
			}
			if (sourceRoot) {
				sourceRoot = util.normalize(sourceRoot);
			}
			sources = sources
				.map(String)
				.map(util.normalize)
				.map(function (source) {
					return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
						? util.relative(sourceRoot, source)
						: source;
				});
			this._names = ArraySet.fromArray(names.map(String), true);
			this._sources = ArraySet.fromArray(sources, true);
			this._absoluteSources = this._sources.toArray().map(function (s) {
				return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
			});
			this.sourceRoot = sourceRoot;
			this.sourcesContent = sourcesContent;
			this._mappings = mappings;
			this._sourceMapURL = aSourceMapURL;
			this.file = file;
		}
		BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
		BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
		BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {
			var relativeSource = aSource;
			if (this.sourceRoot != null) {
				relativeSource = util.relative(this.sourceRoot, relativeSource);
			}
			if (this._sources.has(relativeSource)) {
				return this._sources.indexOf(relativeSource);
			}
			var i;
			for (i = 0; i < this._absoluteSources.length; ++i) {
				if (this._absoluteSources[i] == aSource) {
					return i;
				}
			}
			return -1;
		};
		BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(
			aSourceMap,
			aSourceMapURL,
		) {
			var smc = Object.create(BasicSourceMapConsumer.prototype);
			var names = (smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true));
			var sources = (smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true));
			smc.sourceRoot = aSourceMap._sourceRoot;
			smc.sourcesContent = aSourceMap._generateSourcesContent(
				smc._sources.toArray(),
				smc.sourceRoot,
			);
			smc.file = aSourceMap._file;
			smc._sourceMapURL = aSourceMapURL;
			smc._absoluteSources = smc._sources.toArray().map(function (s) {
				return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
			});
			var generatedMappings = aSourceMap._mappings.toArray().slice();
			var destGeneratedMappings = (smc.__generatedMappings = []);
			var destOriginalMappings = (smc.__originalMappings = []);
			for (var i = 0, length = generatedMappings.length; i < length; i++) {
				var srcMapping = generatedMappings[i];
				var destMapping = new Mapping();
				destMapping.generatedLine = srcMapping.generatedLine;
				destMapping.generatedColumn = srcMapping.generatedColumn;
				if (srcMapping.source) {
					destMapping.source = sources.indexOf(srcMapping.source);
					destMapping.originalLine = srcMapping.originalLine;
					destMapping.originalColumn = srcMapping.originalColumn;
					if (srcMapping.name) {
						destMapping.name = names.indexOf(srcMapping.name);
					}
					destOriginalMappings.push(destMapping);
				}
				destGeneratedMappings.push(destMapping);
			}
			quickSort(smc.__originalMappings, util.compareByOriginalPositions);
			return smc;
		};
		BasicSourceMapConsumer.prototype._version = 3;
		Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
			get: function () {
				return this._absoluteSources.slice();
			},
		});
		function Mapping() {
			this.generatedLine = 0;
			this.generatedColumn = 0;
			this.source = null;
			this.originalLine = null;
			this.originalColumn = null;
			this.name = null;
		}
		BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(
			aStr,
			aSourceRoot,
		) {
			var generatedLine = 1;
			var previousGeneratedColumn = 0;
			var previousOriginalLine = 0;
			var previousOriginalColumn = 0;
			var previousSource = 0;
			var previousName = 0;
			var length = aStr.length;
			var index = 0;
			var cachedSegments = {};
			var temp = {};
			var originalMappings = [];
			var generatedMappings = [];
			var mapping, str, segment, end, value;
			while (index < length) {
				if (aStr.charAt(index) === ";") {
					generatedLine++;
					index++;
					previousGeneratedColumn = 0;
				} else if (aStr.charAt(index) === ",") {
					index++;
				} else {
					mapping = new Mapping();
					mapping.generatedLine = generatedLine;
					for (end = index; end < length; end++) {
						if (this._charIsMappingSeparator(aStr, end)) {
							break;
						}
					}
					str = aStr.slice(index, end);
					segment = cachedSegments[str];
					if (segment) {
						index += str.length;
					} else {
						segment = [];
						while (index < end) {
							base64VLQ.decode(aStr, index, temp);
							value = temp.value;
							index = temp.rest;
							segment.push(value);
						}
						if (segment.length === 2) {
							throw new Error("Found a source, but no line and column");
						}
						if (segment.length === 3) {
							throw new Error("Found a source and line, but no column");
						}
						cachedSegments[str] = segment;
					}
					mapping.generatedColumn = previousGeneratedColumn + segment[0];
					previousGeneratedColumn = mapping.generatedColumn;
					if (segment.length > 1) {
						mapping.source = previousSource + segment[1];
						previousSource += segment[1];
						mapping.originalLine = previousOriginalLine + segment[2];
						previousOriginalLine = mapping.originalLine;
						mapping.originalLine += 1;
						mapping.originalColumn = previousOriginalColumn + segment[3];
						previousOriginalColumn = mapping.originalColumn;
						if (segment.length > 4) {
							mapping.name = previousName + segment[4];
							previousName += segment[4];
						}
					}
					generatedMappings.push(mapping);
					if (typeof mapping.originalLine === "number") {
						originalMappings.push(mapping);
					}
				}
			}
			quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
			this.__generatedMappings = generatedMappings;
			quickSort(originalMappings, util.compareByOriginalPositions);
			this.__originalMappings = originalMappings;
		};
		BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(
			aNeedle,
			aMappings,
			aLineName,
			aColumnName,
			aComparator,
			aBias,
		) {
			if (aNeedle[aLineName] <= 0) {
				throw new TypeError(
					"Line must be greater than or equal to 1, got " + aNeedle[aLineName],
				);
			}
			if (aNeedle[aColumnName] < 0) {
				throw new TypeError(
					"Column must be greater than or equal to 0, got " + aNeedle[aColumnName],
				);
			}
			return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
		};
		BasicSourceMapConsumer.prototype.computeColumnSpans =
			function SourceMapConsumer_computeColumnSpans() {
				for (var index = 0; index < this._generatedMappings.length; ++index) {
					var mapping = this._generatedMappings[index];
					if (index + 1 < this._generatedMappings.length) {
						var nextMapping = this._generatedMappings[index + 1];
						if (mapping.generatedLine === nextMapping.generatedLine) {
							mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
							continue;
						}
					}
					mapping.lastGeneratedColumn = Infinity;
				}
			};
		BasicSourceMapConsumer.prototype.originalPositionFor =
			function SourceMapConsumer_originalPositionFor(aArgs) {
				var needle = {
					generatedLine: util.getArg(aArgs, "line"),
					generatedColumn: util.getArg(aArgs, "column"),
				};
				var index = this._findMapping(
					needle,
					this._generatedMappings,
					"generatedLine",
					"generatedColumn",
					util.compareByGeneratedPositionsDeflated,
					util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND),
				);
				if (index >= 0) {
					var mapping = this._generatedMappings[index];
					if (mapping.generatedLine === needle.generatedLine) {
						var source = util.getArg(mapping, "source", null);
						if (source !== null) {
							source = this._sources.at(source);
							source = util.computeSourceURL(
								this.sourceRoot,
								source,
								this._sourceMapURL,
							);
						}
						var name = util.getArg(mapping, "name", null);
						if (name !== null) {
							name = this._names.at(name);
						}
						return {
							source,
							line: util.getArg(mapping, "originalLine", null),
							column: util.getArg(mapping, "originalColumn", null),
							name,
						};
					}
				}
				return {
					source: null,
					line: null,
					column: null,
					name: null,
				};
			};
		BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
			function BasicSourceMapConsumer_hasContentsOfAllSources() {
				if (!this.sourcesContent) {
					return false;
				}
				return (
					this.sourcesContent.length >= this._sources.size() &&
					!this.sourcesContent.some(function (sc) {
						return sc == null;
					})
				);
			};
		BasicSourceMapConsumer.prototype.sourceContentFor =
			function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
				if (!this.sourcesContent) {
					return null;
				}
				var index = this._findSourceIndex(aSource);
				if (index >= 0) {
					return this.sourcesContent[index];
				}
				var relativeSource = aSource;
				if (this.sourceRoot != null) {
					relativeSource = util.relative(this.sourceRoot, relativeSource);
				}
				var url;
				if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
					var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
					if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
						return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
					}
					if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
						return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
					}
				}
				if (nullOnMissing) {
					return null;
				} else {
					throw new Error('"' + relativeSource + '" is not in the SourceMap.');
				}
			};
		BasicSourceMapConsumer.prototype.generatedPositionFor =
			function SourceMapConsumer_generatedPositionFor(aArgs) {
				var source = util.getArg(aArgs, "source");
				source = this._findSourceIndex(source);
				if (source < 0) {
					return {
						line: null,
						column: null,
						lastColumn: null,
					};
				}
				var needle = {
					source,
					originalLine: util.getArg(aArgs, "line"),
					originalColumn: util.getArg(aArgs, "column"),
				};
				var index = this._findMapping(
					needle,
					this._originalMappings,
					"originalLine",
					"originalColumn",
					util.compareByOriginalPositions,
					util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND),
				);
				if (index >= 0) {
					var mapping = this._originalMappings[index];
					if (mapping.source === needle.source) {
						return {
							line: util.getArg(mapping, "generatedLine", null),
							column: util.getArg(mapping, "generatedColumn", null),
							lastColumn: util.getArg(mapping, "lastGeneratedColumn", null),
						};
					}
				}
				return {
					line: null,
					column: null,
					lastColumn: null,
				};
			};
		exports2.BasicSourceMapConsumer = BasicSourceMapConsumer;
		function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
			var sourceMap = aSourceMap;
			if (typeof aSourceMap === "string") {
				sourceMap = util.parseSourceMapInput(aSourceMap);
			}
			var version = util.getArg(sourceMap, "version");
			var sections = util.getArg(sourceMap, "sections");
			if (version != this._version) {
				throw new Error("Unsupported version: " + version);
			}
			this._sources = new ArraySet();
			this._names = new ArraySet();
			var lastOffset = {
				line: -1,
				column: 0,
			};
			this._sections = sections.map(function (s) {
				if (s.url) {
					throw new Error("Support for url field in sections not implemented.");
				}
				var offset = util.getArg(s, "offset");
				var offsetLine = util.getArg(offset, "line");
				var offsetColumn = util.getArg(offset, "column");
				if (
					offsetLine < lastOffset.line ||
					(offsetLine === lastOffset.line && offsetColumn < lastOffset.column)
				) {
					throw new Error("Section offsets must be ordered and non-overlapping.");
				}
				lastOffset = offset;
				return {
					generatedOffset: {
						// The offset fields are 0-based, but we use 1-based indices when
						// encoding/decoding from VLQ.
						generatedLine: offsetLine + 1,
						generatedColumn: offsetColumn + 1,
					},
					consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL),
				};
			});
		}
		IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
		IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
		IndexedSourceMapConsumer.prototype._version = 3;
		Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
			get: function () {
				var sources = [];
				for (var i = 0; i < this._sections.length; i++) {
					for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
						sources.push(this._sections[i].consumer.sources[j]);
					}
				}
				return sources;
			},
		});
		IndexedSourceMapConsumer.prototype.originalPositionFor =
			function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
				var needle = {
					generatedLine: util.getArg(aArgs, "line"),
					generatedColumn: util.getArg(aArgs, "column"),
				};
				var sectionIndex = binarySearch.search(
					needle,
					this._sections,
					function (needle2, section2) {
						var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
						if (cmp) {
							return cmp;
						}
						return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
					},
				);
				var section = this._sections[sectionIndex];
				if (!section) {
					return {
						source: null,
						line: null,
						column: null,
						name: null,
					};
				}
				return section.consumer.originalPositionFor({
					line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
					column:
						needle.generatedColumn -
						(section.generatedOffset.generatedLine === needle.generatedLine
							? section.generatedOffset.generatedColumn - 1
							: 0),
					bias: aArgs.bias,
				});
			};
		IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
			function IndexedSourceMapConsumer_hasContentsOfAllSources() {
				return this._sections.every(function (s) {
					return s.consumer.hasContentsOfAllSources();
				});
			};
		IndexedSourceMapConsumer.prototype.sourceContentFor =
			function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
				for (var i = 0; i < this._sections.length; i++) {
					var section = this._sections[i];
					var content = section.consumer.sourceContentFor(aSource, true);
					if (content) {
						return content;
					}
				}
				if (nullOnMissing) {
					return null;
				} else {
					throw new Error('"' + aSource + '" is not in the SourceMap.');
				}
			};
		IndexedSourceMapConsumer.prototype.generatedPositionFor =
			function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
				for (var i = 0; i < this._sections.length; i++) {
					var section = this._sections[i];
					if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
						continue;
					}
					var generatedPosition = section.consumer.generatedPositionFor(aArgs);
					if (generatedPosition) {
						var ret = {
							line:
								generatedPosition.line +
								(section.generatedOffset.generatedLine - 1),
							column:
								generatedPosition.column +
								(section.generatedOffset.generatedLine === generatedPosition.line
									? section.generatedOffset.generatedColumn - 1
									: 0),
						};
						return ret;
					}
				}
				return {
					line: null,
					column: null,
				};
			};
		IndexedSourceMapConsumer.prototype._parseMappings =
			function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
				this.__generatedMappings = [];
				this.__originalMappings = [];
				for (var i = 0; i < this._sections.length; i++) {
					var section = this._sections[i];
					var sectionMappings = section.consumer._generatedMappings;
					for (var j = 0; j < sectionMappings.length; j++) {
						var mapping = sectionMappings[j];
						var source = section.consumer._sources.at(mapping.source);
						source = util.computeSourceURL(
							section.consumer.sourceRoot,
							source,
							this._sourceMapURL,
						);
						this._sources.add(source);
						source = this._sources.indexOf(source);
						var name = null;
						if (mapping.name) {
							name = section.consumer._names.at(mapping.name);
							this._names.add(name);
							name = this._names.indexOf(name);
						}
						var adjustedMapping = {
							source,
							generatedLine:
								mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
							generatedColumn:
								mapping.generatedColumn +
								(section.generatedOffset.generatedLine === mapping.generatedLine
									? section.generatedOffset.generatedColumn - 1
									: 0),
							originalLine: mapping.originalLine,
							originalColumn: mapping.originalColumn,
							name,
						};
						this.__generatedMappings.push(adjustedMapping);
						if (typeof adjustedMapping.originalLine === "number") {
							this.__originalMappings.push(adjustedMapping);
						}
					}
				}
				quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
				quickSort(this.__originalMappings, util.compareByOriginalPositions);
			};
		exports2.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
	},
});

// node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
	"node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-node.js"(exports2) {
		"use strict";
		var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
		var util = require_util10();
		var REGEX_NEWLINE = /(\r?\n)/;
		var NEWLINE_CODE = 10;
		var isSourceNode = "$$$isSourceNode$$$";
		function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
			this.children = [];
			this.sourceContents = {};
			this.line = aLine == null ? null : aLine;
			this.column = aColumn == null ? null : aColumn;
			this.source = aSource == null ? null : aSource;
			this.name = aName == null ? null : aName;
			this[isSourceNode] = true;
			if (aChunks != null) this.add(aChunks);
		}
		SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(
			aGeneratedCode,
			aSourceMapConsumer,
			aRelativePath,
		) {
			var node = new SourceNode();
			var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
			var remainingLinesIndex = 0;
			var shiftNextLine = function () {
				var lineContents = getNextLine();
				var newLine = getNextLine() || "";
				return lineContents + newLine;
				function getNextLine() {
					return remainingLinesIndex < remainingLines.length
						? remainingLines[remainingLinesIndex++]
						: void 0;
				}
			};
			var lastGeneratedLine = 1,
				lastGeneratedColumn = 0;
			var lastMapping = null;
			aSourceMapConsumer.eachMapping(function (mapping) {
				if (lastMapping !== null) {
					if (lastGeneratedLine < mapping.generatedLine) {
						addMappingWithCode(lastMapping, shiftNextLine());
						lastGeneratedLine++;
						lastGeneratedColumn = 0;
					} else {
						var nextLine = remainingLines[remainingLinesIndex] || "";
						var code = nextLine.substr(
							0,
							mapping.generatedColumn - lastGeneratedColumn,
						);
						remainingLines[remainingLinesIndex] = nextLine.substr(
							mapping.generatedColumn - lastGeneratedColumn,
						);
						lastGeneratedColumn = mapping.generatedColumn;
						addMappingWithCode(lastMapping, code);
						lastMapping = mapping;
						return;
					}
				}
				while (lastGeneratedLine < mapping.generatedLine) {
					node.add(shiftNextLine());
					lastGeneratedLine++;
				}
				if (lastGeneratedColumn < mapping.generatedColumn) {
					var nextLine = remainingLines[remainingLinesIndex] || "";
					node.add(nextLine.substr(0, mapping.generatedColumn));
					remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
					lastGeneratedColumn = mapping.generatedColumn;
				}
				lastMapping = mapping;
			}, this);
			if (remainingLinesIndex < remainingLines.length) {
				if (lastMapping) {
					addMappingWithCode(lastMapping, shiftNextLine());
				}
				node.add(remainingLines.splice(remainingLinesIndex).join(""));
			}
			aSourceMapConsumer.sources.forEach(function (sourceFile) {
				var content = aSourceMapConsumer.sourceContentFor(sourceFile);
				if (content != null) {
					if (aRelativePath != null) {
						sourceFile = util.join(aRelativePath, sourceFile);
					}
					node.setSourceContent(sourceFile, content);
				}
			});
			return node;
			function addMappingWithCode(mapping, code) {
				if (mapping === null || mapping.source === void 0) {
					node.add(code);
				} else {
					var source = aRelativePath
						? util.join(aRelativePath, mapping.source)
						: mapping.source;
					node.add(
						new SourceNode(
							mapping.originalLine,
							mapping.originalColumn,
							source,
							code,
							mapping.name,
						),
					);
				}
			}
		};
		SourceNode.prototype.add = function SourceNode_add(aChunk) {
			if (Array.isArray(aChunk)) {
				aChunk.forEach(function (chunk) {
					this.add(chunk);
				}, this);
			} else if (aChunk[isSourceNode] || typeof aChunk === "string") {
				if (aChunk) {
					this.children.push(aChunk);
				}
			} else {
				throw new TypeError(
					"Expected a SourceNode, string, or an array of SourceNodes and strings. Got " +
						aChunk,
				);
			}
			return this;
		};
		SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
			if (Array.isArray(aChunk)) {
				for (var i = aChunk.length - 1; i >= 0; i--) {
					this.prepend(aChunk[i]);
				}
			} else if (aChunk[isSourceNode] || typeof aChunk === "string") {
				this.children.unshift(aChunk);
			} else {
				throw new TypeError(
					"Expected a SourceNode, string, or an array of SourceNodes and strings. Got " +
						aChunk,
				);
			}
			return this;
		};
		SourceNode.prototype.walk = function SourceNode_walk(aFn) {
			var chunk;
			for (var i = 0, len = this.children.length; i < len; i++) {
				chunk = this.children[i];
				if (chunk[isSourceNode]) {
					chunk.walk(aFn);
				} else {
					if (chunk !== "") {
						aFn(chunk, {
							source: this.source,
							line: this.line,
							column: this.column,
							name: this.name,
						});
					}
				}
			}
		};
		SourceNode.prototype.join = function SourceNode_join(aSep) {
			var newChildren;
			var i;
			var len = this.children.length;
			if (len > 0) {
				newChildren = [];
				for (i = 0; i < len - 1; i++) {
					newChildren.push(this.children[i]);
					newChildren.push(aSep);
				}
				newChildren.push(this.children[i]);
				this.children = newChildren;
			}
			return this;
		};
		SourceNode.prototype.replaceRight = function SourceNode_replaceRight(
			aPattern,
			aReplacement,
		) {
			var lastChild = this.children[this.children.length - 1];
			if (lastChild[isSourceNode]) {
				lastChild.replaceRight(aPattern, aReplacement);
			} else if (typeof lastChild === "string") {
				this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
			} else {
				this.children.push("".replace(aPattern, aReplacement));
			}
			return this;
		};
		SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(
			aSourceFile,
			aSourceContent,
		) {
			this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
		};
		SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
			for (var i = 0, len = this.children.length; i < len; i++) {
				if (this.children[i][isSourceNode]) {
					this.children[i].walkSourceContents(aFn);
				}
			}
			var sources = Object.keys(this.sourceContents);
			for (var i = 0, len = sources.length; i < len; i++) {
				aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
			}
		};
		SourceNode.prototype.toString = function SourceNode_toString() {
			var str = "";
			this.walk(function (chunk) {
				str += chunk;
			});
			return str;
		};
		SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(
			aArgs,
		) {
			var generated = {
				code: "",
				line: 1,
				column: 0,
			};
			var map = new SourceMapGenerator(aArgs);
			var sourceMappingActive = false;
			var lastOriginalSource = null;
			var lastOriginalLine = null;
			var lastOriginalColumn = null;
			var lastOriginalName = null;
			this.walk(function (chunk, original) {
				generated.code += chunk;
				if (
					original.source !== null &&
					original.line !== null &&
					original.column !== null
				) {
					if (
						lastOriginalSource !== original.source ||
						lastOriginalLine !== original.line ||
						lastOriginalColumn !== original.column ||
						lastOriginalName !== original.name
					) {
						map.addMapping({
							source: original.source,
							original: {
								line: original.line,
								column: original.column,
							},
							generated: {
								line: generated.line,
								column: generated.column,
							},
							name: original.name,
						});
					}
					lastOriginalSource = original.source;
					lastOriginalLine = original.line;
					lastOriginalColumn = original.column;
					lastOriginalName = original.name;
					sourceMappingActive = true;
				} else if (sourceMappingActive) {
					map.addMapping({
						generated: {
							line: generated.line,
							column: generated.column,
						},
					});
					lastOriginalSource = null;
					sourceMappingActive = false;
				}
				for (var idx = 0, length = chunk.length; idx < length; idx++) {
					if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
						generated.line++;
						generated.column = 0;
						if (idx + 1 === length) {
							lastOriginalSource = null;
							sourceMappingActive = false;
						} else if (sourceMappingActive) {
							map.addMapping({
								source: original.source,
								original: {
									line: original.line,
									column: original.column,
								},
								generated: {
									line: generated.line,
									column: generated.column,
								},
								name: original.name,
							});
						}
					} else {
						generated.column++;
					}
				}
			});
			this.walkSourceContents(function (sourceFile, sourceContent) {
				map.setSourceContent(sourceFile, sourceContent);
			});
			return { code: generated.code, map };
		};
		exports2.SourceNode = SourceNode;
	},
});

// node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/source-map.js
var require_source_map = __commonJS({
	"node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/source-map.js"(exports2) {
		"use strict";
		exports2.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
		exports2.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
		exports2.SourceNode = require_source_node().SourceNode;
	},
});

// node_modules/.pnpm/get-source@2.0.12/node_modules/get-source/impl/SyncPromise.js
var require_SyncPromise = __commonJS({
	"node_modules/.pnpm/get-source@2.0.12/node_modules/get-source/impl/SyncPromise.js"(
		exports2,
		module2,
	) {
		"use strict";
		module2.exports = class SyncPromise {
			constructor(fn) {
				try {
					fn(
						(x) => {
							this.setValue(x, false);
						},
						// resolve
						(x) => {
							this.setValue(x, true);
						},
						// reject
					);
				} catch (e) {
					this.setValue(e, true);
				}
			}
			setValue(x, rejected) {
				this.val = x instanceof SyncPromise ? x.val : x;
				this.rejected = rejected || (x instanceof SyncPromise ? x.rejected : false);
			}
			static valueFrom(x) {
				if (x instanceof SyncPromise) {
					if (x.rejected) throw x.val;
					else return x.val;
				} else {
					return x;
				}
			}
			then(fn) {
				try {
					if (!this.rejected) return SyncPromise.resolve(fn(this.val));
				} catch (e) {
					return SyncPromise.reject(e);
				}
				return this;
			}
			catch(fn) {
				try {
					if (this.rejected) return SyncPromise.resolve(fn(this.val));
				} catch (e) {
					return SyncPromise.reject(e);
				}
				return this;
			}
			static resolve(x) {
				return new SyncPromise((resolve) => {
					resolve(x);
				});
			}
			static reject(x) {
				return new SyncPromise((_, reject) => {
					reject(x);
				});
			}
		};
	},
});

// node_modules/.pnpm/get-source@2.0.12/node_modules/get-source/impl/path.js
var require_path = __commonJS({
	"node_modules/.pnpm/get-source@2.0.12/node_modules/get-source/impl/path.js"(exports2, module2) {
		"use strict";
		var isBrowser =
			typeof window !== "undefined" && window.window === window && window.navigator;
		var cwd = isBrowser ? window.location.href : process.cwd();
		var urlRegexp = new RegExp(
			"^((https|http)://)?[a-z0-9A-Z]{3}.[a-z0-9A-Z][a-z0-9A-Z]{0,61}?[a-z0-9A-Z].com|net|cn|cc (:s[0-9]{1-4})?/$",
		);
		var path = (module2.exports = {
			concat(a, b) {
				const a_endsWithSlash = a[a.length - 1] === "/",
					b_startsWithSlash = b[0] === "/";
				return (
					a +
					(a_endsWithSlash || b_startsWithSlash ? "" : "/") +
					(a_endsWithSlash && b_startsWithSlash ? b.substring(1) : b)
				);
			},
			resolve(x) {
				if (path.isAbsolute(x)) {
					return path.normalize(x);
				}
				return path.normalize(path.concat(cwd, x));
			},
			normalize(x) {
				let output = [],
					skip = 0;
				x.split("/")
					.reverse()
					.filter((x2) => x2 !== ".")
					.forEach((x2) => {
						if (x2 === "..") {
							skip++;
						} else if (skip === 0) {
							output.push(x2);
						} else {
							skip--;
						}
					});
				const result = output.reverse().join("/");
				return (
					(isBrowser && result[0] === "/"
						? result[1] === "/"
							? window.location.protocol
							: window.location.origin
						: "") + result
				);
			},
			isData: (x) => x.indexOf("data:") === 0,
			isURL: (x) => urlRegexp.test(x),
			isAbsolute: (x) => x[0] === "/" || /^[^\/]*:/.test(x),
			relativeToFile(a, b) {
				return path.isData(a) || path.isAbsolute(b)
					? path.normalize(b)
					: path.normalize(path.concat(a.split("/").slice(0, -1).join("/"), b));
			},
		});
	},
});

// node_modules/.pnpm/data-uri-to-buffer@2.0.2/node_modules/data-uri-to-buffer/index.js
var require_data_uri_to_buffer = __commonJS({
	"node_modules/.pnpm/data-uri-to-buffer@2.0.2/node_modules/data-uri-to-buffer/index.js"(
		exports2,
		module2,
	) {
		"use strict";
		module2.exports = dataUriToBuffer;
		function dataUriToBuffer(uri) {
			if (!/^data\:/i.test(uri)) {
				throw new TypeError(
					'`uri` does not appear to be a Data URI (must begin with "data:")',
				);
			}
			uri = uri.replace(/\r?\n/g, "");
			var firstComma = uri.indexOf(",");
			if (-1 === firstComma || firstComma <= 4) {
				throw new TypeError("malformed data: URI");
			}
			var meta = uri.substring(5, firstComma).split(";");
			var type = meta[0] || "text/plain";
			var typeFull = type;
			var base64 = false;
			var charset = "";
			for (var i = 1; i < meta.length; i++) {
				if ("base64" == meta[i]) {
					base64 = true;
				} else {
					typeFull += ";" + meta[i];
					if (0 == meta[i].indexOf("charset=")) {
						charset = meta[i].substring(8);
					}
				}
			}
			if (!meta[0] && !charset.length) {
				typeFull += ";charset=US-ASCII";
				charset = "US-ASCII";
			}
			var data = unescape(uri.substring(firstComma + 1));
			var encoding = base64 ? "base64" : "ascii";
			var buffer = Buffer.from ? Buffer.from(data, encoding) : new Buffer(data, encoding);
			buffer.type = type;
			buffer.typeFull = typeFull;
			buffer.charset = charset;
			return buffer;
		}
	},
});

// node_modules/.pnpm/get-source@2.0.12/node_modules/get-source/get-source.js
var require_get_source = __commonJS({
	"node_modules/.pnpm/get-source@2.0.12/node_modules/get-source/get-source.js"(
		exports2,
		module2,
	) {
		"use strict";
		var { assign } = Object;
		var isBrowser =
			typeof window !== "undefined" && window.window === window && window.navigator;
		var SourceMapConsumer = require_source_map().SourceMapConsumer;
		var SyncPromise = require_SyncPromise();
		var path = require_path();
		var dataURIToBuffer = require_data_uri_to_buffer();
		var nodeRequire = isBrowser ? null : module2.require;
		var memoize = (f) => {
			const m = (x) => (x in m.cache ? m.cache[x] : (m.cache[x] = f(x)));
			m.forgetEverything = () => {
				m.cache = /* @__PURE__ */ Object.create(null);
			};
			m.cache = /* @__PURE__ */ Object.create(null);
			return m;
		};
		function impl(fetchFile, sync) {
			const PromiseImpl = sync ? SyncPromise : Promise;
			const SourceFileMemoized = memoize((path2) => SourceFile(path2, fetchFile(path2)));
			function SourceFile(srcPath, text) {
				if (text === void 0) return SourceFileMemoized(path.resolve(srcPath));
				return PromiseImpl.resolve(text).then((text2) => {
					let file;
					let lines;
					let resolver;
					let _resolve = (loc) =>
						(resolver = resolver || SourceMapResolverFromFetchedFile(file))(loc);
					return (file = {
						path: srcPath,
						text: text2,
						get lines() {
							return (lines = lines || text2.split("\n"));
						},
						resolve(loc) {
							const result = _resolve(loc);
							if (sync) {
								try {
									return SyncPromise.valueFrom(result);
								} catch (e) {
									return assign({}, loc, { error: e });
								}
							} else {
								return Promise.resolve(result);
							}
						},
						_resolve,
					});
				});
			}
			function SourceMapResolverFromFetchedFile(file) {
				const re = /\u0023 sourceMappingURL=(.+)\n?/g;
				let lastMatch = void 0;
				while (true) {
					const match = re.exec(file.text);
					if (match) lastMatch = match;
					else break;
				}
				const url = lastMatch && lastMatch[1];
				const defaultResolver = (loc) =>
					assign({}, loc, {
						sourceFile: file,
						sourceLine: file.lines[loc.line - 1] || "",
					});
				return url ? SourceMapResolver(file.path, url, defaultResolver) : defaultResolver;
			}
			function SourceMapResolver(originalFilePath, sourceMapPath, fallbackResolve) {
				const srcFile = sourceMapPath.startsWith("data:")
					? SourceFile(originalFilePath, dataURIToBuffer(sourceMapPath).toString())
					: SourceFile(path.relativeToFile(originalFilePath, sourceMapPath));
				const parsedMap = srcFile.then((f) => SourceMapConsumer(JSON.parse(f.text)));
				const sourceFor = memoize(function sourceFor2(filePath) {
					return srcFile.then((f) => {
						const fullPath = path.relativeToFile(f.path, filePath);
						return parsedMap.then((x) =>
							SourceFile(
								fullPath,
								x.sourceContentFor(
									filePath,
									true,
									/* return null on missing */
								) || void 0,
							),
						);
					});
				});
				return (loc) =>
					parsedMap
						.then((x) => {
							const originalLoc = x.originalPositionFor(loc);
							return originalLoc.source
								? sourceFor(originalLoc.source).then((x2) =>
										x2._resolve(
											assign({}, loc, {
												line: originalLoc.line,
												column: originalLoc.column + 1,
												name: originalLoc.name,
											}),
										),
									)
								: fallbackResolve(loc);
						})
						.catch((e) => assign(fallbackResolve(loc), { sourceMapError: e }));
			}
			return assign(
				function getSource(path2) {
					const file = SourceFile(path2);
					if (sync) {
						try {
							return SyncPromise.valueFrom(file);
						} catch (e) {
							const noFile = {
								path: path2,
								text: "",
								lines: [],
								error: e,
								resolve(loc) {
									return assign({}, loc, {
										error: e,
										sourceLine: "",
										sourceFile: noFile,
									});
								},
							};
							return noFile;
						}
					}
					return file;
				},
				{
					resetCache: () => SourceFileMemoized.forgetEverything(),
					getCache: () => SourceFileMemoized.cache,
				},
			);
		}
		module2.exports = impl(function fetchFileSync(path2) {
			return new SyncPromise((resolve) => {
				if (isBrowser) {
					let xhr = new XMLHttpRequest();
					xhr.open(
						"GET",
						path2,
						false,
						/* SYNCHRONOUS XHR FTW :) */
					);
					xhr.send(null);
					resolve(xhr.responseText);
				} else {
					resolve(nodeRequire("fs").readFileSync(path2, { encoding: "utf8" }));
				}
			});
		}, true);
		module2.exports.async = impl(function fetchFileAsync(path2) {
			return new Promise((resolve, reject) => {
				if (isBrowser) {
					let xhr = new XMLHttpRequest();
					xhr.open("GET", path2);
					xhr.onreadystatechange = (event) => {
						if (xhr.readyState === 4) {
							if (xhr.status === 200) {
								resolve(xhr.responseText);
							} else {
								reject(new Error(xhr.statusText));
							}
						}
					};
					xhr.send(null);
				} else {
					nodeRequire("fs").readFile(path2, { encoding: "utf8" }, (e, x) => {
						e ? reject(e) : resolve(x);
					});
				}
			});
		});
	},
});

// node_modules/.pnpm/stacktracey@2.1.8/node_modules/stacktracey/impl/partition.js
var require_partition = __commonJS({
	"node_modules/.pnpm/stacktracey@2.1.8/node_modules/stacktracey/impl/partition.js"(
		exports2,
		module2,
	) {
		"use strict";
		module2.exports = (arr_, pred) => {
			const arr = arr_ || [],
				spans = [];
			let span = {
				label: void 0,
				items: [arr.first],
			};
			arr.forEach((x) => {
				const label = pred(x);
				if (span.label !== label && span.items.length) {
					spans.push((span = { label, items: [x] }));
				} else {
					span.items.push(x);
				}
			});
			return spans;
		};
	},
});

// node_modules/.pnpm/printable-characters@1.0.42/node_modules/printable-characters/build/printable-characters.js
var require_printable_characters = __commonJS({
	"node_modules/.pnpm/printable-characters@1.0.42/node_modules/printable-characters/build/printable-characters.js"(
		exports2,
		module2,
	) {
		"use strict";
		var _slicedToArray = /* @__PURE__ */ (function () {
			function sliceIterator(arr, i) {
				var _arr = [];
				var _n = true;
				var _d = false;
				var _e = void 0;
				try {
					for (
						var _i = arr[Symbol.iterator](), _s;
						!(_n = (_s = _i.next()).done);
						_n = true
					) {
						_arr.push(_s.value);
						if (i && _arr.length === i) break;
					}
				} catch (err) {
					_d = true;
					_e = err;
				} finally {
					try {
						if (!_n && _i["return"]) _i["return"]();
					} finally {
						if (_d) throw _e;
					}
				}
				return _arr;
			}
			return function (arr, i) {
				if (Array.isArray(arr)) {
					return arr;
				} else if (Symbol.iterator in Object(arr)) {
					return sliceIterator(arr, i);
				} else {
					throw new TypeError("Invalid attempt to destructure non-iterable instance");
				}
			};
		})();
		var ansiEscapeCode =
			"[\x1B\x9B][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]";
		var zeroWidthCharacterExceptNewline =
			"\0-\b\v-\x1B\x9B\xAD\u200B\u2028\u2029\uFEFF\uFE00-\uFE0F";
		var zeroWidthCharacter = "\n" + zeroWidthCharacterExceptNewline;
		var zeroWidthCharactersExceptNewline = new RegExp(
			"(?:" + ansiEscapeCode + ")|[" + zeroWidthCharacterExceptNewline + "]",
			"g",
		);
		var zeroWidthCharacters = new RegExp(
			"(?:" + ansiEscapeCode + ")|[" + zeroWidthCharacter + "]",
			"g",
		);
		var partition = new RegExp(
			"((?:" +
				ansiEscapeCode +
				")|[	" +
				zeroWidthCharacter +
				"])?([^	" +
				zeroWidthCharacter +
				"]*)",
			"g",
		);
		module2.exports = {
			zeroWidthCharacters,
			ansiEscapeCodes: new RegExp(ansiEscapeCode, "g"),
			strlen: (s) => Array.from(s.replace(zeroWidthCharacters, "")).length,
			// Array.from solves the emoji problem as described here: http://blog.jonnew.com/posts/poo-dot-length-equals-two
			isBlank: (s) => s.replace(zeroWidthCharacters, "").replace(/\s/g, "").length === 0,
			blank: (s) =>
				Array.from(s.replace(zeroWidthCharactersExceptNewline, ""))
					.map((x) => (x === "	" || x === "\n" ? x : " "))
					.join(""),
			partition(s) {
				for (
					var m, spans = [];
					partition.lastIndex !== s.length && (m = partition.exec(s));

				) {
					spans.push([m[1] || "", m[2]]);
				}
				partition.lastIndex = 0;
				return spans;
			},
			first(s, n) {
				let result = "",
					length = 0;
				for (const _ref of module2.exports.partition(s)) {
					var _ref2 = _slicedToArray(_ref, 2);
					const nonPrintable = _ref2[0];
					const printable = _ref2[1];
					const text = Array.from(printable).slice(0, n - length);
					result += nonPrintable + text.join("");
					length += text.length;
				}
				return result;
			},
		};
	},
});

// node_modules/.pnpm/as-table@1.0.55/node_modules/as-table/build/as-table.js
var require_as_table = __commonJS({
	"node_modules/.pnpm/as-table@1.0.55/node_modules/as-table/build/as-table.js"(
		exports2,
		module2,
	) {
		"use strict";
		function _toConsumableArray(arr) {
			if (Array.isArray(arr)) {
				for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
				return arr2;
			} else {
				return Array.from(arr);
			}
		}
		var O = Object;
		var _require = require_printable_characters();
		var first = _require.first;
		var strlen = _require.strlen;
		var limit = (s, n) => first(s, n - 1) + "\u2026";
		var asColumns = (rows, cfg_) => {
			const zip = (arrs, f) =>
					arrs
						.reduce(
							(a, b) =>
								b.map((b2, i) => [].concat(_toConsumableArray(a[i] || []), [b2])),
							[],
						)
						.map((args) => f.apply(void 0, _toConsumableArray(args))),
				cells = rows.map((r) => r.map((c) => c.replace(/\n/g, "\\n"))),
				cellWidths = cells.map((r) => r.map(strlen)),
				maxWidths = zip(cellWidths, Math.max),
				cfg = O.assign(
					{
						delimiter: "  ",
						minColumnWidths: maxWidths.map((x) => 0),
						maxTotalWidth: 0,
					},
					cfg_,
				),
				delimiterLength = strlen(cfg.delimiter),
				totalWidth = maxWidths.reduce((a, b) => a + b, 0),
				relativeWidths = maxWidths.map((w) => w / totalWidth),
				maxTotalWidth = cfg.maxTotalWidth - delimiterLength * (maxWidths.length - 1),
				excessWidth = Math.max(0, totalWidth - maxTotalWidth),
				computedWidths = zip(
					[cfg.minColumnWidths, maxWidths, relativeWidths],
					(min, max, relative) => Math.max(min, Math.floor(max - excessWidth * relative)),
				),
				restCellWidths = cellWidths.map((widths) =>
					zip([computedWidths, widths], (a, b) => a - b),
				);
			return zip([cells, restCellWidths], (a, b) =>
				zip([a, b], (str, w) =>
					w >= 0
						? cfg.right
							? " ".repeat(w) + str
							: str + " ".repeat(w)
						: limit(str, strlen(str) + w),
				).join(cfg.delimiter),
			);
		};
		var asTable = (cfg) =>
			O.assign(
				(arr) => {
					var _ref;
					if (arr[0] && Array.isArray(arr[0])) {
						return asColumns(
							arr.map((r) => r.map((c, i) => (c === void 0 ? "" : cfg.print(c, i)))),
							cfg,
						).join("\n");
					}
					const colNames = [].concat(
							_toConsumableArray(
								new Set(
									(_ref = []).concat.apply(
										_ref,
										_toConsumableArray(arr.map(O.keys)),
									),
								),
							),
						),
						columns = [colNames.map(cfg.title)].concat(
							_toConsumableArray(
								arr.map((o) =>
									colNames.map((key) =>
										o[key] === void 0 ? "" : cfg.print(o[key], key),
									),
								),
							),
						),
						lines = asColumns(columns, cfg);
					return (
						cfg.dash
							? [lines[0], cfg.dash.repeat(strlen(lines[0]))].concat(
									_toConsumableArray(lines.slice(1)),
								)
							: lines
					).join("\n");
				},
				cfg,
				{
					configure: (newConfig) => asTable(O.assign({}, cfg, newConfig)),
				},
			);
		module2.exports = asTable({
			maxTotalWidth: Number.MAX_SAFE_INTEGER,
			print: String,
			title: String,
			dash: "-",
			right: false,
		});
	},
});

// node_modules/.pnpm/stacktracey@2.1.8/node_modules/stacktracey/stacktracey.js
var require_stacktracey = __commonJS({
	"node_modules/.pnpm/stacktracey@2.1.8/node_modules/stacktracey/stacktracey.js"(
		exports2,
		module2,
	) {
		"use strict";
		var O = Object;
		var isBrowser =
			typeof window !== "undefined" && window.window === window && window.navigator;
		var nodeRequire = isBrowser ? null : module2.require;
		var lastOf = (x) => x[x.length - 1];
		var getSource = require_get_source();
		var partition = require_partition();
		var asTable = require_as_table();
		var nixSlashes = (x) => x.replace(/\\/g, "/");
		var pathRoot = isBrowser ? window.location.href : nixSlashes(process.cwd()) + "/";
		var StackTracey = class _StackTracey {
			constructor(input, offset) {
				const originalInput = input,
					isParseableSyntaxError = input && input instanceof SyntaxError && !isBrowser;
				if (!input) {
					input = new Error();
					offset = offset === void 0 ? 1 : offset;
				}
				if (input instanceof Error) {
					input = input.stack || "";
				}
				if (typeof input === "string") {
					input = this.rawParse(input)
						.slice(offset)
						.map((x) => this.extractEntryMetadata(x));
				}
				if (Array.isArray(input)) {
					if (isParseableSyntaxError) {
						const rawLines = nodeRequire("util").inspect(originalInput).split("\n"),
							fileLine = rawLines[0].split(":"),
							line = fileLine.pop(),
							file = fileLine.join(":");
						if (file) {
							input.unshift({
								file: nixSlashes(file),
								line,
								column: (rawLines[2] || "").indexOf("^") + 1,
								sourceLine: rawLines[1],
								callee: "(syntax error)",
								syntaxError: true,
							});
						}
					}
					this.items = input;
				} else {
					this.items = [];
				}
			}
			extractEntryMetadata(e) {
				const decomposedPath = this.decomposePath(e.file || "");
				const fileRelative = decomposedPath[0];
				const externalDomain = decomposedPath[1];
				return O.assign(e, {
					calleeShort: e.calleeShort || lastOf((e.callee || "").split(".")),
					fileRelative,
					fileShort: this.shortenPath(fileRelative),
					fileName: lastOf((e.file || "").split("/")),
					thirdParty: this.isThirdParty(fileRelative, externalDomain) && !e.index,
					externalDomain,
				});
			}
			shortenPath(relativePath) {
				return relativePath
					.replace(/^node_modules\//, "")
					.replace(/^webpack\/bootstrap\//, "")
					.replace(/^__parcel_source_root\//, "");
			}
			decomposePath(fullPath) {
				let result = fullPath;
				if (isBrowser) result = result.replace(pathRoot, "");
				const externalDomainMatch = result.match(/^(http|https)\:\/\/?([^\/]+)\/(.*)/);
				const externalDomain = externalDomainMatch ? externalDomainMatch[2] : void 0;
				result = externalDomainMatch ? externalDomainMatch[3] : result;
				if (!isBrowser) result = nodeRequire("path").relative(pathRoot, result);
				return [
					nixSlashes(result).replace(/^.*\:\/\/?\/?/, ""),
					// cut webpack:/// and webpack:/ things
					externalDomain,
				];
			}
			isThirdParty(relativePath, externalDomain) {
				return (
					externalDomain ||
					relativePath[0] === "~" || // webpack-specific heuristic
					relativePath[0] === "/" || // external source
					relativePath.indexOf("node_modules") === 0 ||
					relativePath.indexOf("webpack/bootstrap") === 0
				);
			}
			rawParse(str) {
				const lines = (str || "").split("\n");
				const entries = lines.map((line) => {
					line = line.trim();
					let callee,
						fileLineColumn = [],
						native,
						planA,
						planB;
					if (
						(planA = line.match(/at (.+) \(eval at .+ \((.+)\), .+\)/)) || // eval calls
						(planA = line.match(/at (.+) \((.+)\)/)) ||
						(line.slice(0, 3) !== "at " && (planA = line.match(/(.*)@(.*)/)))
					) {
						callee = planA[1];
						native = planA[2] === "native";
						fileLineColumn = (
							planA[2].match(/(.*):(\d+):(\d+)/) ||
							planA[2].match(/(.*):(\d+)/) ||
							[]
						).slice(1);
					} else if ((planB = line.match(/^(at\s+)*(.+):(\d+):(\d+)/))) {
						fileLineColumn = planB.slice(2);
					} else {
						return void 0;
					}
					if (callee && !fileLineColumn[0]) {
						const type = callee.split(".")[0];
						if (type === "Array") {
							native = true;
						}
					}
					return {
						beforeParse: line,
						callee: callee || "",
						index: isBrowser && fileLineColumn[0] === window.location.href,
						native: native || false,
						file: nixSlashes(fileLineColumn[0] || ""),
						line: parseInt(fileLineColumn[1] || "", 10) || void 0,
						column: parseInt(fileLineColumn[2] || "", 10) || void 0,
					};
				});
				return entries.filter((x) => x !== void 0);
			}
			withSourceAt(i) {
				return this.items[i] && this.withSource(this.items[i]);
			}
			withSourceAsyncAt(i) {
				return this.items[i] && this.withSourceAsync(this.items[i]);
			}
			withSource(loc) {
				if (this.shouldSkipResolving(loc)) {
					return loc;
				} else {
					let resolved = getSource(loc.file || "").resolve(loc);
					if (!resolved.sourceFile) {
						return loc;
					}
					return this.withSourceResolved(loc, resolved);
				}
			}
			withSourceAsync(loc) {
				if (this.shouldSkipResolving(loc)) {
					return Promise.resolve(loc);
				} else {
					return getSource
						.async(loc.file || "")
						.then((x) => x.resolve(loc))
						.then((resolved) => this.withSourceResolved(loc, resolved))
						.catch((e) => this.withSourceResolved(loc, { error: e, sourceLine: "" }));
				}
			}
			shouldSkipResolving(loc) {
				return loc.sourceFile || loc.error || (loc.file && loc.file.indexOf("<") >= 0);
			}
			withSourceResolved(loc, resolved) {
				if (resolved.sourceFile && !resolved.sourceFile.error) {
					resolved.file = nixSlashes(resolved.sourceFile.path);
					resolved = this.extractEntryMetadata(resolved);
				}
				if (resolved.sourceLine.includes("// @hide")) {
					resolved.sourceLine = resolved.sourceLine.replace("// @hide", "");
					resolved.hide = true;
				}
				if (
					resolved.sourceLine.includes("__webpack_require__") || // webpack-specific heuristics
					resolved.sourceLine.includes("/******/ ({")
				) {
					resolved.thirdParty = true;
				}
				return O.assign({ sourceLine: "" }, loc, resolved);
			}
			withSources() {
				return this.map((x) => this.withSource(x));
			}
			withSourcesAsync() {
				return Promise.all(this.items.map((x) => this.withSourceAsync(x))).then(
					(items) => new _StackTracey(items),
				);
			}
			mergeRepeatedLines() {
				return new _StackTracey(
					partition(this.items, (e) => e.file + e.line).map((group) => {
						return group.items.slice(1).reduce(
							(memo, entry) => {
								memo.callee =
									(memo.callee || "<anonymous>") +
									" \u2192 " +
									(entry.callee || "<anonymous>");
								memo.calleeShort =
									(memo.calleeShort || "<anonymous>") +
									" \u2192 " +
									(entry.calleeShort || "<anonymous>");
								return memo;
							},
							O.assign({}, group.items[0]),
						);
					}),
				);
			}
			clean() {
				const s = this.withSources().mergeRepeatedLines();
				return s.filter(s.isClean.bind(s));
			}
			cleanAsync() {
				return this.withSourcesAsync().then((s) => {
					s = s.mergeRepeatedLines();
					return s.filter(s.isClean.bind(s));
				});
			}
			isClean(entry, index) {
				return index === 0 || !(entry.thirdParty || entry.hide || entry.native);
			}
			at(i) {
				return O.assign(
					{
						beforeParse: "",
						callee: "<???>",
						index: false,
						native: false,
						file: "<???>",
						line: 0,
						column: 0,
					},
					this.items[i],
				);
			}
			asTable(opts) {
				const maxColumnWidths = (opts && opts.maxColumnWidths) || this.maxColumnWidths();
				const trimEnd = (s, n) => s && (s.length > n ? s.slice(0, n - 1) + "\u2026" : s);
				const trimStart = (s, n) => s && (s.length > n ? "\u2026" + s.slice(-(n - 1)) : s);
				const trimmed = this.map((e) => [
					"at " + trimEnd(e.calleeShort, maxColumnWidths.callee),
					trimStart(
						(e.fileShort && e.fileShort + ":" + e.line) || "",
						maxColumnWidths.file,
					),
					trimEnd((e.sourceLine || "").trim() || "", maxColumnWidths.sourceLine),
				]);
				return asTable(trimmed.items);
			}
			maxColumnWidths() {
				return {
					callee: 30,
					file: 60,
					sourceLine: 80,
				};
			}
			static resetCache() {
				getSource.resetCache();
				getSource.async.resetCache();
			}
			static locationsEqual(a, b) {
				return a.file === b.file && a.line === b.line && a.column === b.column;
			}
		};
		["map", "filter", "slice", "concat"].forEach((method) => {
			StackTracey.prototype[method] = function () {
				return new StackTracey(this.items[method].apply(this.items, arguments));
			};
		});
		module2.exports = StackTracey;
	},
});

// node_modules/.pnpm/youch@3.3.4/node_modules/youch/src/Youch.js
var require_Youch = __commonJS({
	"node_modules/.pnpm/youch@3.3.4/node_modules/youch/src/Youch.js"(exports2, module2) {
		"use strict";
		var fs3 = require("fs");
		var path = require("path");
		var cookie = require_cookie();
		var Mustache = require_mustache();
		var { fileURLToPath } = require("url");
		var StackTracey = require_stacktracey();
		var VIEW_PATH = "./error.compiled.mustache";
		var viewTemplate = fs3.readFileSync(path.join(__dirname, VIEW_PATH), "utf-8");
		var Youch = class {
			constructor(error, request, options = {}) {
				this.options = options;
				this.options.postLines = options.postLines || 5;
				this.options.preLines = options.preLines || 5;
				this._filterHeaders = ["cookie", "connection"];
				this.error = error;
				this.request = request;
				this.links = [];
				this.showAllFrames = false;
			}
			/**
			 * Returns the source code for a given file. It unable to
			 * read file it resolves the promise with a null.
			 *
			 * @param  {Object} frame
			 * @return {Promise}
			 */
			_getFrameSource(frame) {
				let path2 = frame.file
					.replace(/dist\/webpack:\//g, "")
					.replace(/dist\\webpack:\\/g, "");
				try {
					path2 = path2.startsWith("file:") ? fileURLToPath(path2) : path2;
				} catch {}
				return new Promise((resolve) => {
					fs3.readFile(path2, "utf-8", (error, contents) => {
						if (error) {
							resolve(null);
							return;
						}
						const lines = contents.split(/\r?\n/);
						const lineNumber = frame.line;
						resolve({
							pre: lines.slice(
								Math.max(0, lineNumber - (this.options.preLines + 1)),
								lineNumber - 1,
							),
							line: lines[lineNumber - 1],
							post: lines.slice(lineNumber, lineNumber + this.options.postLines),
						});
					});
				});
			}
			/**
			 * Parses the error stack and returns serialized
			 * frames out of it.
			 *
			 * @return {Object}
			 */
			_parseError() {
				return new Promise((resolve, reject) => {
					const stack = new StackTracey(this.error);
					Promise.all(
						stack.items.map(async (frame) => {
							if (this._isNode(frame)) {
								return Promise.resolve(frame);
							}
							return this._getFrameSource(frame).then((context) => {
								frame.context = context;
								return frame;
							});
						}),
					)
						.then(resolve)
						.catch(reject);
				});
			}
			/**
			 * Returns the context with code for a given
			 * frame.
			 *
			 * @param  {Object}
			 * @return {Object}
			 */
			_getContext(frame) {
				if (!frame.context) {
					return {};
				}
				return {
					start: frame.line - (frame.context.pre || []).length,
					pre: frame.context.pre.join("\n"),
					line: frame.context.line,
					post: frame.context.post.join("\n"),
				};
			}
			/**
			 * Returns classes to be used inside HTML when
			 * displaying the frames list.
			 *
			 * @param  {Object}
			 * @param  {Number}
			 *
			 * @return {String}
			 */
			_getDisplayClasses(frame) {
				const classes = [];
				if (!frame.isApp) {
					classes.push("native-frame");
				}
				return classes;
			}
			/**
			 * Compiles the view using HTML
			 *
			 * @param  {String}
			 * @param  {Object}
			 *
			 * @return {String}
			 */
			_compileView(view, data) {
				return Mustache.render(view, data);
			}
			/**
			 * Serializes frame to a usable error object.
			 *
			 * @param  {Object}
			 *
			 * @return {Object}
			 */
			_serializeFrame(frame) {
				return {
					file: frame.fileRelative,
					filePath: frame.file.startsWith("file:")
						? fileURLToPath(frame.file).replaceAll("\\", "/")
						: frame.file,
					line: frame.line,
					callee: frame.callee,
					calleeShort: frame.calleeShort,
					column: frame.column,
					context: this._getContext(frame),
					isModule: frame.thirdParty,
					isNative: frame.native,
					isApp: this._isApp(frame),
				};
			}
			/**
			 * Returns whether frame belongs to nodejs
			 * or not.
			 *
			 * @return {Boolean} [description]
			 */
			_isNode(frame) {
				if (frame.native) {
					return true;
				}
				const filename = frame.file || "";
				if (filename.startsWith("node:")) {
					return true;
				}
				return false;
			}
			/**
			 * Returns whether code belongs to the app
			 * or not.
			 *
			 * @return {Boolean} [description]
			 */
			_isApp(frame) {
				return !this._isNode(frame) && !this._isNodeModule(frame);
			}
			/**
			 * Returns whether frame belongs to a node_module or
			 * not
			 *
			 * @method _isNodeModule
			 *
			 * @param  {Object}      frame
			 *
			 * @return {Boolean}
			 *
			 * @private
			 */
			_isNodeModule(frame) {
				return (frame.file || "").indexOf("node_modules/") > -1;
			}
			/**
			 * Serializes stack to Mustache friendly object to
			 * be used within the view. Optionally can pass
			 * a callback to customize the frames output.
			 *
			 * @param  {Object}
			 * @param  {Function} [callback]
			 *
			 * @return {Object}
			 */
			_serializeData(stack, callback) {
				callback = callback || this._serializeFrame.bind(this);
				return {
					message: this.error.message,
					help: this.error.help,
					cause: this.error.cause,
					name: this.error.name,
					status: this.error.status,
					frames:
						stack instanceof Array === true
							? stack.filter((frame) => frame.file).map(callback)
							: [],
				};
			}
			/**
			 * Returns a serialized object with important
			 * information.
			 *
			 * @return {Object}
			 */
			_serializeRequest() {
				const headers = [];
				const cookies = [];
				if (this.request.headers) {
					Object.keys(this.request.headers).forEach((key) => {
						if (this._filterHeaders.indexOf(key) > -1) {
							return;
						}
						headers.push({
							key: key.toUpperCase(),
							value: this.request.headers[key],
						});
					});
					if (this.request.headers.cookie) {
						const parsedCookies = cookie.parse(this.request.headers.cookie || "");
						Object.keys(parsedCookies).forEach((key) => {
							cookies.push({ key, value: parsedCookies[key] });
						});
					}
				}
				return {
					url: this.request.url,
					httpVersion: this.request.httpVersion,
					method: this.request.method,
					connection: this.request.headers ? this.request.headers.connection : null,
					headers,
					cookies,
				};
			}
			/**
			 * Stores the link `callback` which
			 * will be processed when rendering
			 * the HTML view.
			 *
			 * @param {Function} callback
			 *
			 * @returns {Object}
			 */
			addLink(callback) {
				if (typeof callback === "function") {
					this.links.push(callback);
					return this;
				}
				throw new Error('Pass a callback function to "addLink"');
			}
			/**
			 * Toggle the state of showing all frames by default
			 */
			toggleShowAllFrames() {
				this.showAllFrames = !this.showAllFrames;
				return this;
			}
			/**
			 * Returns error stack as JSON.
			 *
			 * @return {Promise}
			 */
			toJSON() {
				return new Promise((resolve, reject) => {
					this._parseError()
						.then((stack) => {
							resolve({
								error: this._serializeData(stack),
							});
						})
						.catch(reject);
				});
			}
			/**
			 * Returns HTML representation of the error stack
			 * by parsing the stack into frames and getting
			 * important info out of it.
			 *
			 * @return {Promise}
			 */
			toHTML(templateState) {
				return new Promise((resolve, reject) => {
					this._parseError()
						.then((stack) => {
							let foundActiveFrame = false;
							const data = this._serializeData(stack, (frame, index) => {
								const serializedFrame = this._serializeFrame(frame);
								const classes = this._getDisplayClasses(serializedFrame);
								if (
									!foundActiveFrame &&
									(serializedFrame.isApp || index + 1 === stack.length)
								) {
									classes.push("active");
									foundActiveFrame = true;
								}
								serializedFrame.classes = classes.join(" ");
								return serializedFrame;
							});
							if (templateState) {
								Object.assign(data, templateState);
							}
							if (this.request) {
								data.request = this._serializeRequest();
							}
							data.links = this.links.map((renderLink) => renderLink(data));
							data.loadFA = !!data.links.find((link) => link.includes("fa-"));
							data.showAllFrames = this.showAllFrames;
							return resolve(this._compileView(viewTemplate, data));
						})
						.catch(reject);
				});
			}
		};
		module2.exports = Youch;
	},
});

// node_modules/.pnpm/miniflare@3.20241106.0/node_modules/miniflare/dist/src/index.js
var require_src3 = __commonJS({
	"node_modules/.pnpm/miniflare@3.20241106.0/node_modules/miniflare/dist/src/index.js"(
		exports2,
		module2,
	) {
		"use strict";
		var __create2 = Object.create;
		var __defProp2 = Object.defineProperty;
		var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
		var __getOwnPropNames2 = Object.getOwnPropertyNames;
		var __getProtoOf2 = Object.getPrototypeOf;
		var __hasOwnProp2 = Object.prototype.hasOwnProperty;
		var __defNormalProp = (obj, key, value) =>
			key in obj
				? __defProp2(obj, key, {
						enumerable: true,
						configurable: true,
						writable: true,
						value,
					})
				: (obj[key] = value);
		var __commonJS2 = (cb, mod) =>
			function __require() {
				return (
					mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod),
					mod.exports
				);
			};
		var __export2 = (target, all) => {
			for (var name in all) __defProp2(target, name, { get: all[name], enumerable: true });
		};
		var __copyProps2 = (to, from, except, desc) => {
			if ((from && typeof from === "object") || typeof from === "function") {
				for (let key of __getOwnPropNames2(from))
					if (!__hasOwnProp2.call(to, key) && key !== except)
						__defProp2(to, key, {
							get: () => from[key],
							enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable,
						});
			}
			return to;
		};
		var __toESM2 = (mod, isNodeMode, target) => (
			(target = mod != null ? __create2(__getProtoOf2(mod)) : {}),
			__copyProps2(
				// If the importer is in node compatibility mode or this is not an ESM
				// file that has been converted to a CommonJS file using a Babel-
				// compatible transform (i.e. "__esModule" has not been set), then set
				// "default" to the CommonJS "module.exports" for node compatibility.
				isNodeMode || !mod || !mod.__esModule
					? __defProp2(target, "default", { value: mod, enumerable: true })
					: target,
				mod,
			)
		);
		var __toCommonJS2 = (mod) =>
			__copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
		var __publicField = (obj, key, value) => {
			__defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
			return value;
		};
		var __accessCheck = (obj, member, msg) => {
			if (!member.has(obj)) throw TypeError("Cannot " + msg);
		};
		var __privateGet = (obj, member, getter) => {
			__accessCheck(obj, member, "read from private field");
			return getter ? getter.call(obj) : member.get(obj);
		};
		var __privateAdd = (obj, member, value) => {
			if (member.has(obj))
				throw TypeError("Cannot add the same private member more than once");
			member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
		};
		var __privateSet = (obj, member, value, setter) => {
			__accessCheck(obj, member, "write to private field");
			setter ? setter.call(obj, value) : member.set(obj, value);
			return value;
		};
		var __privateMethod = (obj, member, method) => {
			__accessCheck(obj, member, "access private method");
			return method;
		};
		var require_Mime = __commonJS2({
			"../../node_modules/.pnpm/mime@3.0.0/node_modules/mime/Mime.js"(exports3, module22) {
				"use strict";
				function Mime() {
					this._types = /* @__PURE__ */ Object.create(null);
					this._extensions = /* @__PURE__ */ Object.create(null);
					for (let i = 0; i < arguments.length; i++) {
						this.define(arguments[i]);
					}
					this.define = this.define.bind(this);
					this.getType = this.getType.bind(this);
					this.getExtension = this.getExtension.bind(this);
				}
				Mime.prototype.define = function (typeMap, force) {
					for (let type in typeMap) {
						let extensions = typeMap[type].map(function (t) {
							return t.toLowerCase();
						});
						type = type.toLowerCase();
						for (let i = 0; i < extensions.length; i++) {
							const ext = extensions[i];
							if (ext[0] === "*") {
								continue;
							}
							if (!force && ext in this._types) {
								throw new Error(
									'Attempt to change mapping for "' +
										ext +
										'" extension from "' +
										this._types[ext] +
										'" to "' +
										type +
										'". Pass `force=true` to allow this, otherwise remove "' +
										ext +
										'" from the list of extensions for "' +
										type +
										'".',
								);
							}
							this._types[ext] = type;
						}
						if (force || !this._extensions[type]) {
							const ext = extensions[0];
							this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
						}
					}
				};
				Mime.prototype.getType = function (path28) {
					path28 = String(path28);
					let last = path28.replace(/^.*[/\\]/, "").toLowerCase();
					let ext = last.replace(/^.*\./, "").toLowerCase();
					let hasPath = last.length < path28.length;
					let hasDot = ext.length < last.length - 1;
					return ((hasDot || !hasPath) && this._types[ext]) || null;
				};
				Mime.prototype.getExtension = function (type) {
					type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
					return (type && this._extensions[type.toLowerCase()]) || null;
				};
				module22.exports = Mime;
			},
		});
		var require_standard = __commonJS2({
			"../../node_modules/.pnpm/mime@3.0.0/node_modules/mime/types/standard.js"(
				exports3,
				module22,
			) {
				module22.exports = {
					"application/andrew-inset": ["ez"],
					"application/applixware": ["aw"],
					"application/atom+xml": ["atom"],
					"application/atomcat+xml": ["atomcat"],
					"application/atomdeleted+xml": ["atomdeleted"],
					"application/atomsvc+xml": ["atomsvc"],
					"application/atsc-dwd+xml": ["dwd"],
					"application/atsc-held+xml": ["held"],
					"application/atsc-rsat+xml": ["rsat"],
					"application/bdoc": ["bdoc"],
					"application/calendar+xml": ["xcs"],
					"application/ccxml+xml": ["ccxml"],
					"application/cdfx+xml": ["cdfx"],
					"application/cdmi-capability": ["cdmia"],
					"application/cdmi-container": ["cdmic"],
					"application/cdmi-domain": ["cdmid"],
					"application/cdmi-object": ["cdmio"],
					"application/cdmi-queue": ["cdmiq"],
					"application/cu-seeme": ["cu"],
					"application/dash+xml": ["mpd"],
					"application/davmount+xml": ["davmount"],
					"application/docbook+xml": ["dbk"],
					"application/dssc+der": ["dssc"],
					"application/dssc+xml": ["xdssc"],
					"application/ecmascript": ["es", "ecma"],
					"application/emma+xml": ["emma"],
					"application/emotionml+xml": ["emotionml"],
					"application/epub+zip": ["epub"],
					"application/exi": ["exi"],
					"application/express": ["exp"],
					"application/fdt+xml": ["fdt"],
					"application/font-tdpfr": ["pfr"],
					"application/geo+json": ["geojson"],
					"application/gml+xml": ["gml"],
					"application/gpx+xml": ["gpx"],
					"application/gxf": ["gxf"],
					"application/gzip": ["gz"],
					"application/hjson": ["hjson"],
					"application/hyperstudio": ["stk"],
					"application/inkml+xml": ["ink", "inkml"],
					"application/ipfix": ["ipfix"],
					"application/its+xml": ["its"],
					"application/java-archive": ["jar", "war", "ear"],
					"application/java-serialized-object": ["ser"],
					"application/java-vm": ["class"],
					"application/javascript": ["js", "mjs"],
					"application/json": ["json", "map"],
					"application/json5": ["json5"],
					"application/jsonml+json": ["jsonml"],
					"application/ld+json": ["jsonld"],
					"application/lgr+xml": ["lgr"],
					"application/lost+xml": ["lostxml"],
					"application/mac-binhex40": ["hqx"],
					"application/mac-compactpro": ["cpt"],
					"application/mads+xml": ["mads"],
					"application/manifest+json": ["webmanifest"],
					"application/marc": ["mrc"],
					"application/marcxml+xml": ["mrcx"],
					"application/mathematica": ["ma", "nb", "mb"],
					"application/mathml+xml": ["mathml"],
					"application/mbox": ["mbox"],
					"application/mediaservercontrol+xml": ["mscml"],
					"application/metalink+xml": ["metalink"],
					"application/metalink4+xml": ["meta4"],
					"application/mets+xml": ["mets"],
					"application/mmt-aei+xml": ["maei"],
					"application/mmt-usd+xml": ["musd"],
					"application/mods+xml": ["mods"],
					"application/mp21": ["m21", "mp21"],
					"application/mp4": ["mp4s", "m4p"],
					"application/msword": ["doc", "dot"],
					"application/mxf": ["mxf"],
					"application/n-quads": ["nq"],
					"application/n-triples": ["nt"],
					"application/node": ["cjs"],
					"application/octet-stream": [
						"bin",
						"dms",
						"lrf",
						"mar",
						"so",
						"dist",
						"distz",
						"pkg",
						"bpk",
						"dump",
						"elc",
						"deploy",
						"exe",
						"dll",
						"deb",
						"dmg",
						"iso",
						"img",
						"msi",
						"msp",
						"msm",
						"buffer",
					],
					"application/oda": ["oda"],
					"application/oebps-package+xml": ["opf"],
					"application/ogg": ["ogx"],
					"application/omdoc+xml": ["omdoc"],
					"application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"],
					"application/oxps": ["oxps"],
					"application/p2p-overlay+xml": ["relo"],
					"application/patch-ops-error+xml": ["xer"],
					"application/pdf": ["pdf"],
					"application/pgp-encrypted": ["pgp"],
					"application/pgp-signature": ["asc", "sig"],
					"application/pics-rules": ["prf"],
					"application/pkcs10": ["p10"],
					"application/pkcs7-mime": ["p7m", "p7c"],
					"application/pkcs7-signature": ["p7s"],
					"application/pkcs8": ["p8"],
					"application/pkix-attr-cert": ["ac"],
					"application/pkix-cert": ["cer"],
					"application/pkix-crl": ["crl"],
					"application/pkix-pkipath": ["pkipath"],
					"application/pkixcmp": ["pki"],
					"application/pls+xml": ["pls"],
					"application/postscript": ["ai", "eps", "ps"],
					"application/provenance+xml": ["provx"],
					"application/pskc+xml": ["pskcxml"],
					"application/raml+yaml": ["raml"],
					"application/rdf+xml": ["rdf", "owl"],
					"application/reginfo+xml": ["rif"],
					"application/relax-ng-compact-syntax": ["rnc"],
					"application/resource-lists+xml": ["rl"],
					"application/resource-lists-diff+xml": ["rld"],
					"application/rls-services+xml": ["rs"],
					"application/route-apd+xml": ["rapd"],
					"application/route-s-tsid+xml": ["sls"],
					"application/route-usd+xml": ["rusd"],
					"application/rpki-ghostbusters": ["gbr"],
					"application/rpki-manifest": ["mft"],
					"application/rpki-roa": ["roa"],
					"application/rsd+xml": ["rsd"],
					"application/rss+xml": ["rss"],
					"application/rtf": ["rtf"],
					"application/sbml+xml": ["sbml"],
					"application/scvp-cv-request": ["scq"],
					"application/scvp-cv-response": ["scs"],
					"application/scvp-vp-request": ["spq"],
					"application/scvp-vp-response": ["spp"],
					"application/sdp": ["sdp"],
					"application/senml+xml": ["senmlx"],
					"application/sensml+xml": ["sensmlx"],
					"application/set-payment-initiation": ["setpay"],
					"application/set-registration-initiation": ["setreg"],
					"application/shf+xml": ["shf"],
					"application/sieve": ["siv", "sieve"],
					"application/smil+xml": ["smi", "smil"],
					"application/sparql-query": ["rq"],
					"application/sparql-results+xml": ["srx"],
					"application/srgs": ["gram"],
					"application/srgs+xml": ["grxml"],
					"application/sru+xml": ["sru"],
					"application/ssdl+xml": ["ssdl"],
					"application/ssml+xml": ["ssml"],
					"application/swid+xml": ["swidtag"],
					"application/tei+xml": ["tei", "teicorpus"],
					"application/thraud+xml": ["tfi"],
					"application/timestamped-data": ["tsd"],
					"application/toml": ["toml"],
					"application/trig": ["trig"],
					"application/ttml+xml": ["ttml"],
					"application/ubjson": ["ubj"],
					"application/urc-ressheet+xml": ["rsheet"],
					"application/urc-targetdesc+xml": ["td"],
					"application/voicexml+xml": ["vxml"],
					"application/wasm": ["wasm"],
					"application/widget": ["wgt"],
					"application/winhlp": ["hlp"],
					"application/wsdl+xml": ["wsdl"],
					"application/wspolicy+xml": ["wspolicy"],
					"application/xaml+xml": ["xaml"],
					"application/xcap-att+xml": ["xav"],
					"application/xcap-caps+xml": ["xca"],
					"application/xcap-diff+xml": ["xdf"],
					"application/xcap-el+xml": ["xel"],
					"application/xcap-ns+xml": ["xns"],
					"application/xenc+xml": ["xenc"],
					"application/xhtml+xml": ["xhtml", "xht"],
					"application/xliff+xml": ["xlf"],
					"application/xml": ["xml", "xsl", "xsd", "rng"],
					"application/xml-dtd": ["dtd"],
					"application/xop+xml": ["xop"],
					"application/xproc+xml": ["xpl"],
					"application/xslt+xml": ["*xsl", "xslt"],
					"application/xspf+xml": ["xspf"],
					"application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"],
					"application/yang": ["yang"],
					"application/yin+xml": ["yin"],
					"application/zip": ["zip"],
					"audio/3gpp": ["*3gpp"],
					"audio/adpcm": ["adp"],
					"audio/amr": ["amr"],
					"audio/basic": ["au", "snd"],
					"audio/midi": ["mid", "midi", "kar", "rmi"],
					"audio/mobile-xmf": ["mxmf"],
					"audio/mp3": ["*mp3"],
					"audio/mp4": ["m4a", "mp4a"],
					"audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
					"audio/ogg": ["oga", "ogg", "spx", "opus"],
					"audio/s3m": ["s3m"],
					"audio/silk": ["sil"],
					"audio/wav": ["wav"],
					"audio/wave": ["*wav"],
					"audio/webm": ["weba"],
					"audio/xm": ["xm"],
					"font/collection": ["ttc"],
					"font/otf": ["otf"],
					"font/ttf": ["ttf"],
					"font/woff": ["woff"],
					"font/woff2": ["woff2"],
					"image/aces": ["exr"],
					"image/apng": ["apng"],
					"image/avif": ["avif"],
					"image/bmp": ["bmp"],
					"image/cgm": ["cgm"],
					"image/dicom-rle": ["drle"],
					"image/emf": ["emf"],
					"image/fits": ["fits"],
					"image/g3fax": ["g3"],
					"image/gif": ["gif"],
					"image/heic": ["heic"],
					"image/heic-sequence": ["heics"],
					"image/heif": ["heif"],
					"image/heif-sequence": ["heifs"],
					"image/hej2k": ["hej2"],
					"image/hsj2": ["hsj2"],
					"image/ief": ["ief"],
					"image/jls": ["jls"],
					"image/jp2": ["jp2", "jpg2"],
					"image/jpeg": ["jpeg", "jpg", "jpe"],
					"image/jph": ["jph"],
					"image/jphc": ["jhc"],
					"image/jpm": ["jpm"],
					"image/jpx": ["jpx", "jpf"],
					"image/jxr": ["jxr"],
					"image/jxra": ["jxra"],
					"image/jxrs": ["jxrs"],
					"image/jxs": ["jxs"],
					"image/jxsc": ["jxsc"],
					"image/jxsi": ["jxsi"],
					"image/jxss": ["jxss"],
					"image/ktx": ["ktx"],
					"image/ktx2": ["ktx2"],
					"image/png": ["png"],
					"image/sgi": ["sgi"],
					"image/svg+xml": ["svg", "svgz"],
					"image/t38": ["t38"],
					"image/tiff": ["tif", "tiff"],
					"image/tiff-fx": ["tfx"],
					"image/webp": ["webp"],
					"image/wmf": ["wmf"],
					"message/disposition-notification": ["disposition-notification"],
					"message/global": ["u8msg"],
					"message/global-delivery-status": ["u8dsn"],
					"message/global-disposition-notification": ["u8mdn"],
					"message/global-headers": ["u8hdr"],
					"message/rfc822": ["eml", "mime"],
					"model/3mf": ["3mf"],
					"model/gltf+json": ["gltf"],
					"model/gltf-binary": ["glb"],
					"model/iges": ["igs", "iges"],
					"model/mesh": ["msh", "mesh", "silo"],
					"model/mtl": ["mtl"],
					"model/obj": ["obj"],
					"model/step+xml": ["stpx"],
					"model/step+zip": ["stpz"],
					"model/step-xml+zip": ["stpxz"],
					"model/stl": ["stl"],
					"model/vrml": ["wrl", "vrml"],
					"model/x3d+binary": ["*x3db", "x3dbz"],
					"model/x3d+fastinfoset": ["x3db"],
					"model/x3d+vrml": ["*x3dv", "x3dvz"],
					"model/x3d+xml": ["x3d", "x3dz"],
					"model/x3d-vrml": ["x3dv"],
					"text/cache-manifest": ["appcache", "manifest"],
					"text/calendar": ["ics", "ifb"],
					"text/coffeescript": ["coffee", "litcoffee"],
					"text/css": ["css"],
					"text/csv": ["csv"],
					"text/html": ["html", "htm", "shtml"],
					"text/jade": ["jade"],
					"text/jsx": ["jsx"],
					"text/less": ["less"],
					"text/markdown": ["markdown", "md"],
					"text/mathml": ["mml"],
					"text/mdx": ["mdx"],
					"text/n3": ["n3"],
					"text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
					"text/richtext": ["rtx"],
					"text/rtf": ["*rtf"],
					"text/sgml": ["sgml", "sgm"],
					"text/shex": ["shex"],
					"text/slim": ["slim", "slm"],
					"text/spdx": ["spdx"],
					"text/stylus": ["stylus", "styl"],
					"text/tab-separated-values": ["tsv"],
					"text/troff": ["t", "tr", "roff", "man", "me", "ms"],
					"text/turtle": ["ttl"],
					"text/uri-list": ["uri", "uris", "urls"],
					"text/vcard": ["vcard"],
					"text/vtt": ["vtt"],
					"text/xml": ["*xml"],
					"text/yaml": ["yaml", "yml"],
					"video/3gpp": ["3gp", "3gpp"],
					"video/3gpp2": ["3g2"],
					"video/h261": ["h261"],
					"video/h263": ["h263"],
					"video/h264": ["h264"],
					"video/iso.segment": ["m4s"],
					"video/jpeg": ["jpgv"],
					"video/jpm": ["*jpm", "jpgm"],
					"video/mj2": ["mj2", "mjp2"],
					"video/mp2t": ["ts"],
					"video/mp4": ["mp4", "mp4v", "mpg4"],
					"video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"],
					"video/ogg": ["ogv"],
					"video/quicktime": ["qt", "mov"],
					"video/webm": ["webm"],
				};
			},
		});
		var require_other = __commonJS2({
			"../../node_modules/.pnpm/mime@3.0.0/node_modules/mime/types/other.js"(
				exports3,
				module22,
			) {
				module22.exports = {
					"application/prs.cww": ["cww"],
					"application/vnd.1000minds.decision-model+xml": ["1km"],
					"application/vnd.3gpp.pic-bw-large": ["plb"],
					"application/vnd.3gpp.pic-bw-small": ["psb"],
					"application/vnd.3gpp.pic-bw-var": ["pvb"],
					"application/vnd.3gpp2.tcap": ["tcap"],
					"application/vnd.3m.post-it-notes": ["pwn"],
					"application/vnd.accpac.simply.aso": ["aso"],
					"application/vnd.accpac.simply.imp": ["imp"],
					"application/vnd.acucobol": ["acu"],
					"application/vnd.acucorp": ["atc", "acutc"],
					"application/vnd.adobe.air-application-installer-package+zip": ["air"],
					"application/vnd.adobe.formscentral.fcdt": ["fcdt"],
					"application/vnd.adobe.fxp": ["fxp", "fxpl"],
					"application/vnd.adobe.xdp+xml": ["xdp"],
					"application/vnd.adobe.xfdf": ["xfdf"],
					"application/vnd.ahead.space": ["ahead"],
					"application/vnd.airzip.filesecure.azf": ["azf"],
					"application/vnd.airzip.filesecure.azs": ["azs"],
					"application/vnd.amazon.ebook": ["azw"],
					"application/vnd.americandynamics.acc": ["acc"],
					"application/vnd.amiga.ami": ["ami"],
					"application/vnd.android.package-archive": ["apk"],
					"application/vnd.anser-web-certificate-issue-initiation": ["cii"],
					"application/vnd.anser-web-funds-transfer-initiation": ["fti"],
					"application/vnd.antix.game-component": ["atx"],
					"application/vnd.apple.installer+xml": ["mpkg"],
					"application/vnd.apple.keynote": ["key"],
					"application/vnd.apple.mpegurl": ["m3u8"],
					"application/vnd.apple.numbers": ["numbers"],
					"application/vnd.apple.pages": ["pages"],
					"application/vnd.apple.pkpass": ["pkpass"],
					"application/vnd.aristanetworks.swi": ["swi"],
					"application/vnd.astraea-software.iota": ["iota"],
					"application/vnd.audiograph": ["aep"],
					"application/vnd.balsamiq.bmml+xml": ["bmml"],
					"application/vnd.blueice.multipass": ["mpm"],
					"application/vnd.bmi": ["bmi"],
					"application/vnd.businessobjects": ["rep"],
					"application/vnd.chemdraw+xml": ["cdxml"],
					"application/vnd.chipnuts.karaoke-mmd": ["mmd"],
					"application/vnd.cinderella": ["cdy"],
					"application/vnd.citationstyles.style+xml": ["csl"],
					"application/vnd.claymore": ["cla"],
					"application/vnd.cloanto.rp9": ["rp9"],
					"application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"],
					"application/vnd.cluetrust.cartomobile-config": ["c11amc"],
					"application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"],
					"application/vnd.commonspace": ["csp"],
					"application/vnd.contact.cmsg": ["cdbcmsg"],
					"application/vnd.cosmocaller": ["cmc"],
					"application/vnd.crick.clicker": ["clkx"],
					"application/vnd.crick.clicker.keyboard": ["clkk"],
					"application/vnd.crick.clicker.palette": ["clkp"],
					"application/vnd.crick.clicker.template": ["clkt"],
					"application/vnd.crick.clicker.wordbank": ["clkw"],
					"application/vnd.criticaltools.wbs+xml": ["wbs"],
					"application/vnd.ctc-posml": ["pml"],
					"application/vnd.cups-ppd": ["ppd"],
					"application/vnd.curl.car": ["car"],
					"application/vnd.curl.pcurl": ["pcurl"],
					"application/vnd.dart": ["dart"],
					"application/vnd.data-vision.rdz": ["rdz"],
					"application/vnd.dbf": ["dbf"],
					"application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"],
					"application/vnd.dece.ttml+xml": ["uvt", "uvvt"],
					"application/vnd.dece.unspecified": ["uvx", "uvvx"],
					"application/vnd.dece.zip": ["uvz", "uvvz"],
					"application/vnd.denovo.fcselayout-link": ["fe_launch"],
					"application/vnd.dna": ["dna"],
					"application/vnd.dolby.mlp": ["mlp"],
					"application/vnd.dpgraph": ["dpg"],
					"application/vnd.dreamfactory": ["dfac"],
					"application/vnd.ds-keypoint": ["kpxx"],
					"application/vnd.dvb.ait": ["ait"],
					"application/vnd.dvb.service": ["svc"],
					"application/vnd.dynageo": ["geo"],
					"application/vnd.ecowin.chart": ["mag"],
					"application/vnd.enliven": ["nml"],
					"application/vnd.epson.esf": ["esf"],
					"application/vnd.epson.msf": ["msf"],
					"application/vnd.epson.quickanime": ["qam"],
					"application/vnd.epson.salt": ["slt"],
					"application/vnd.epson.ssf": ["ssf"],
					"application/vnd.eszigno3+xml": ["es3", "et3"],
					"application/vnd.ezpix-album": ["ez2"],
					"application/vnd.ezpix-package": ["ez3"],
					"application/vnd.fdf": ["fdf"],
					"application/vnd.fdsn.mseed": ["mseed"],
					"application/vnd.fdsn.seed": ["seed", "dataless"],
					"application/vnd.flographit": ["gph"],
					"application/vnd.fluxtime.clip": ["ftc"],
					"application/vnd.framemaker": ["fm", "frame", "maker", "book"],
					"application/vnd.frogans.fnc": ["fnc"],
					"application/vnd.frogans.ltf": ["ltf"],
					"application/vnd.fsc.weblaunch": ["fsc"],
					"application/vnd.fujitsu.oasys": ["oas"],
					"application/vnd.fujitsu.oasys2": ["oa2"],
					"application/vnd.fujitsu.oasys3": ["oa3"],
					"application/vnd.fujitsu.oasysgp": ["fg5"],
					"application/vnd.fujitsu.oasysprs": ["bh2"],
					"application/vnd.fujixerox.ddd": ["ddd"],
					"application/vnd.fujixerox.docuworks": ["xdw"],
					"application/vnd.fujixerox.docuworks.binder": ["xbd"],
					"application/vnd.fuzzysheet": ["fzs"],
					"application/vnd.genomatix.tuxedo": ["txd"],
					"application/vnd.geogebra.file": ["ggb"],
					"application/vnd.geogebra.tool": ["ggt"],
					"application/vnd.geometry-explorer": ["gex", "gre"],
					"application/vnd.geonext": ["gxt"],
					"application/vnd.geoplan": ["g2w"],
					"application/vnd.geospace": ["g3w"],
					"application/vnd.gmx": ["gmx"],
					"application/vnd.google-apps.document": ["gdoc"],
					"application/vnd.google-apps.presentation": ["gslides"],
					"application/vnd.google-apps.spreadsheet": ["gsheet"],
					"application/vnd.google-earth.kml+xml": ["kml"],
					"application/vnd.google-earth.kmz": ["kmz"],
					"application/vnd.grafeq": ["gqf", "gqs"],
					"application/vnd.groove-account": ["gac"],
					"application/vnd.groove-help": ["ghf"],
					"application/vnd.groove-identity-message": ["gim"],
					"application/vnd.groove-injector": ["grv"],
					"application/vnd.groove-tool-message": ["gtm"],
					"application/vnd.groove-tool-template": ["tpl"],
					"application/vnd.groove-vcard": ["vcg"],
					"application/vnd.hal+xml": ["hal"],
					"application/vnd.handheld-entertainment+xml": ["zmm"],
					"application/vnd.hbci": ["hbci"],
					"application/vnd.hhe.lesson-player": ["les"],
					"application/vnd.hp-hpgl": ["hpgl"],
					"application/vnd.hp-hpid": ["hpid"],
					"application/vnd.hp-hps": ["hps"],
					"application/vnd.hp-jlyt": ["jlt"],
					"application/vnd.hp-pcl": ["pcl"],
					"application/vnd.hp-pclxl": ["pclxl"],
					"application/vnd.hydrostatix.sof-data": ["sfd-hdstx"],
					"application/vnd.ibm.minipay": ["mpy"],
					"application/vnd.ibm.modcap": ["afp", "listafp", "list3820"],
					"application/vnd.ibm.rights-management": ["irm"],
					"application/vnd.ibm.secure-container": ["sc"],
					"application/vnd.iccprofile": ["icc", "icm"],
					"application/vnd.igloader": ["igl"],
					"application/vnd.immervision-ivp": ["ivp"],
					"application/vnd.immervision-ivu": ["ivu"],
					"application/vnd.insors.igm": ["igm"],
					"application/vnd.intercon.formnet": ["xpw", "xpx"],
					"application/vnd.intergeo": ["i2g"],
					"application/vnd.intu.qbo": ["qbo"],
					"application/vnd.intu.qfx": ["qfx"],
					"application/vnd.ipunplugged.rcprofile": ["rcprofile"],
					"application/vnd.irepository.package+xml": ["irp"],
					"application/vnd.is-xpr": ["xpr"],
					"application/vnd.isac.fcs": ["fcs"],
					"application/vnd.jam": ["jam"],
					"application/vnd.jcp.javame.midlet-rms": ["rms"],
					"application/vnd.jisp": ["jisp"],
					"application/vnd.joost.joda-archive": ["joda"],
					"application/vnd.kahootz": ["ktz", "ktr"],
					"application/vnd.kde.karbon": ["karbon"],
					"application/vnd.kde.kchart": ["chrt"],
					"application/vnd.kde.kformula": ["kfo"],
					"application/vnd.kde.kivio": ["flw"],
					"application/vnd.kde.kontour": ["kon"],
					"application/vnd.kde.kpresenter": ["kpr", "kpt"],
					"application/vnd.kde.kspread": ["ksp"],
					"application/vnd.kde.kword": ["kwd", "kwt"],
					"application/vnd.kenameaapp": ["htke"],
					"application/vnd.kidspiration": ["kia"],
					"application/vnd.kinar": ["kne", "knp"],
					"application/vnd.koan": ["skp", "skd", "skt", "skm"],
					"application/vnd.kodak-descriptor": ["sse"],
					"application/vnd.las.las+xml": ["lasxml"],
					"application/vnd.llamagraphics.life-balance.desktop": ["lbd"],
					"application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"],
					"application/vnd.lotus-1-2-3": ["123"],
					"application/vnd.lotus-approach": ["apr"],
					"application/vnd.lotus-freelance": ["pre"],
					"application/vnd.lotus-notes": ["nsf"],
					"application/vnd.lotus-organizer": ["org"],
					"application/vnd.lotus-screencam": ["scm"],
					"application/vnd.lotus-wordpro": ["lwp"],
					"application/vnd.macports.portpkg": ["portpkg"],
					"application/vnd.mapbox-vector-tile": ["mvt"],
					"application/vnd.mcd": ["mcd"],
					"application/vnd.medcalcdata": ["mc1"],
					"application/vnd.mediastation.cdkey": ["cdkey"],
					"application/vnd.mfer": ["mwf"],
					"application/vnd.mfmp": ["mfm"],
					"application/vnd.micrografx.flo": ["flo"],
					"application/vnd.micrografx.igx": ["igx"],
					"application/vnd.mif": ["mif"],
					"application/vnd.mobius.daf": ["daf"],
					"application/vnd.mobius.dis": ["dis"],
					"application/vnd.mobius.mbk": ["mbk"],
					"application/vnd.mobius.mqy": ["mqy"],
					"application/vnd.mobius.msl": ["msl"],
					"application/vnd.mobius.plc": ["plc"],
					"application/vnd.mobius.txf": ["txf"],
					"application/vnd.mophun.application": ["mpn"],
					"application/vnd.mophun.certificate": ["mpc"],
					"application/vnd.mozilla.xul+xml": ["xul"],
					"application/vnd.ms-artgalry": ["cil"],
					"application/vnd.ms-cab-compressed": ["cab"],
					"application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"],
					"application/vnd.ms-excel.addin.macroenabled.12": ["xlam"],
					"application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"],
					"application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"],
					"application/vnd.ms-excel.template.macroenabled.12": ["xltm"],
					"application/vnd.ms-fontobject": ["eot"],
					"application/vnd.ms-htmlhelp": ["chm"],
					"application/vnd.ms-ims": ["ims"],
					"application/vnd.ms-lrm": ["lrm"],
					"application/vnd.ms-officetheme": ["thmx"],
					"application/vnd.ms-outlook": ["msg"],
					"application/vnd.ms-pki.seccat": ["cat"],
					"application/vnd.ms-pki.stl": ["*stl"],
					"application/vnd.ms-powerpoint": ["ppt", "pps", "pot"],
					"application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"],
					"application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"],
					"application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"],
					"application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"],
					"application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"],
					"application/vnd.ms-project": ["mpp", "mpt"],
					"application/vnd.ms-word.document.macroenabled.12": ["docm"],
					"application/vnd.ms-word.template.macroenabled.12": ["dotm"],
					"application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"],
					"application/vnd.ms-wpl": ["wpl"],
					"application/vnd.ms-xpsdocument": ["xps"],
					"application/vnd.mseq": ["mseq"],
					"application/vnd.musician": ["mus"],
					"application/vnd.muvee.style": ["msty"],
					"application/vnd.mynfc": ["taglet"],
					"application/vnd.neurolanguage.nlu": ["nlu"],
					"application/vnd.nitf": ["ntf", "nitf"],
					"application/vnd.noblenet-directory": ["nnd"],
					"application/vnd.noblenet-sealer": ["nns"],
					"application/vnd.noblenet-web": ["nnw"],
					"application/vnd.nokia.n-gage.ac+xml": ["*ac"],
					"application/vnd.nokia.n-gage.data": ["ngdat"],
					"application/vnd.nokia.n-gage.symbian.install": ["n-gage"],
					"application/vnd.nokia.radio-preset": ["rpst"],
					"application/vnd.nokia.radio-presets": ["rpss"],
					"application/vnd.novadigm.edm": ["edm"],
					"application/vnd.novadigm.edx": ["edx"],
					"application/vnd.novadigm.ext": ["ext"],
					"application/vnd.oasis.opendocument.chart": ["odc"],
					"application/vnd.oasis.opendocument.chart-template": ["otc"],
					"application/vnd.oasis.opendocument.database": ["odb"],
					"application/vnd.oasis.opendocument.formula": ["odf"],
					"application/vnd.oasis.opendocument.formula-template": ["odft"],
					"application/vnd.oasis.opendocument.graphics": ["odg"],
					"application/vnd.oasis.opendocument.graphics-template": ["otg"],
					"application/vnd.oasis.opendocument.image": ["odi"],
					"application/vnd.oasis.opendocument.image-template": ["oti"],
					"application/vnd.oasis.opendocument.presentation": ["odp"],
					"application/vnd.oasis.opendocument.presentation-template": ["otp"],
					"application/vnd.oasis.opendocument.spreadsheet": ["ods"],
					"application/vnd.oasis.opendocument.spreadsheet-template": ["ots"],
					"application/vnd.oasis.opendocument.text": ["odt"],
					"application/vnd.oasis.opendocument.text-master": ["odm"],
					"application/vnd.oasis.opendocument.text-template": ["ott"],
					"application/vnd.oasis.opendocument.text-web": ["oth"],
					"application/vnd.olpc-sugar": ["xo"],
					"application/vnd.oma.dd2+xml": ["dd2"],
					"application/vnd.openblox.game+xml": ["obgx"],
					"application/vnd.openofficeorg.extension": ["oxt"],
					"application/vnd.openstreetmap.data+xml": ["osm"],
					"application/vnd.openxmlformats-officedocument.presentationml.presentation": [
						"pptx",
					],
					"application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"],
					"application/vnd.openxmlformats-officedocument.presentationml.slideshow": [
						"ppsx",
					],
					"application/vnd.openxmlformats-officedocument.presentationml.template": [
						"potx",
					],
					"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"],
					"application/vnd.openxmlformats-officedocument.spreadsheetml.template": [
						"xltx",
					],
					"application/vnd.openxmlformats-officedocument.wordprocessingml.document": [
						"docx",
					],
					"application/vnd.openxmlformats-officedocument.wordprocessingml.template": [
						"dotx",
					],
					"application/vnd.osgeo.mapguide.package": ["mgp"],
					"application/vnd.osgi.dp": ["dp"],
					"application/vnd.osgi.subsystem": ["esa"],
					"application/vnd.palm": ["pdb", "pqa", "oprc"],
					"application/vnd.pawaafile": ["paw"],
					"application/vnd.pg.format": ["str"],
					"application/vnd.pg.osasli": ["ei6"],
					"application/vnd.picsel": ["efif"],
					"application/vnd.pmi.widget": ["wg"],
					"application/vnd.pocketlearn": ["plf"],
					"application/vnd.powerbuilder6": ["pbd"],
					"application/vnd.previewsystems.box": ["box"],
					"application/vnd.proteus.magazine": ["mgz"],
					"application/vnd.publishare-delta-tree": ["qps"],
					"application/vnd.pvi.ptid1": ["ptid"],
					"application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"],
					"application/vnd.rar": ["rar"],
					"application/vnd.realvnc.bed": ["bed"],
					"application/vnd.recordare.musicxml": ["mxl"],
					"application/vnd.recordare.musicxml+xml": ["musicxml"],
					"application/vnd.rig.cryptonote": ["cryptonote"],
					"application/vnd.rim.cod": ["cod"],
					"application/vnd.rn-realmedia": ["rm"],
					"application/vnd.rn-realmedia-vbr": ["rmvb"],
					"application/vnd.route66.link66+xml": ["link66"],
					"application/vnd.sailingtracker.track": ["st"],
					"application/vnd.seemail": ["see"],
					"application/vnd.sema": ["sema"],
					"application/vnd.semd": ["semd"],
					"application/vnd.semf": ["semf"],
					"application/vnd.shana.informed.formdata": ["ifm"],
					"application/vnd.shana.informed.formtemplate": ["itp"],
					"application/vnd.shana.informed.interchange": ["iif"],
					"application/vnd.shana.informed.package": ["ipk"],
					"application/vnd.simtech-mindmapper": ["twd", "twds"],
					"application/vnd.smaf": ["mmf"],
					"application/vnd.smart.teacher": ["teacher"],
					"application/vnd.software602.filler.form+xml": ["fo"],
					"application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"],
					"application/vnd.spotfire.dxp": ["dxp"],
					"application/vnd.spotfire.sfs": ["sfs"],
					"application/vnd.stardivision.calc": ["sdc"],
					"application/vnd.stardivision.draw": ["sda"],
					"application/vnd.stardivision.impress": ["sdd"],
					"application/vnd.stardivision.math": ["smf"],
					"application/vnd.stardivision.writer": ["sdw", "vor"],
					"application/vnd.stardivision.writer-global": ["sgl"],
					"application/vnd.stepmania.package": ["smzip"],
					"application/vnd.stepmania.stepchart": ["sm"],
					"application/vnd.sun.wadl+xml": ["wadl"],
					"application/vnd.sun.xml.calc": ["sxc"],
					"application/vnd.sun.xml.calc.template": ["stc"],
					"application/vnd.sun.xml.draw": ["sxd"],
					"application/vnd.sun.xml.draw.template": ["std"],
					"application/vnd.sun.xml.impress": ["sxi"],
					"application/vnd.sun.xml.impress.template": ["sti"],
					"application/vnd.sun.xml.math": ["sxm"],
					"application/vnd.sun.xml.writer": ["sxw"],
					"application/vnd.sun.xml.writer.global": ["sxg"],
					"application/vnd.sun.xml.writer.template": ["stw"],
					"application/vnd.sus-calendar": ["sus", "susp"],
					"application/vnd.svd": ["svd"],
					"application/vnd.symbian.install": ["sis", "sisx"],
					"application/vnd.syncml+xml": ["xsm"],
					"application/vnd.syncml.dm+wbxml": ["bdm"],
					"application/vnd.syncml.dm+xml": ["xdm"],
					"application/vnd.syncml.dmddf+xml": ["ddf"],
					"application/vnd.tao.intent-module-archive": ["tao"],
					"application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"],
					"application/vnd.tmobile-livetv": ["tmo"],
					"application/vnd.trid.tpt": ["tpt"],
					"application/vnd.triscape.mxs": ["mxs"],
					"application/vnd.trueapp": ["tra"],
					"application/vnd.ufdl": ["ufd", "ufdl"],
					"application/vnd.uiq.theme": ["utz"],
					"application/vnd.umajin": ["umj"],
					"application/vnd.unity": ["unityweb"],
					"application/vnd.uoml+xml": ["uoml"],
					"application/vnd.vcx": ["vcx"],
					"application/vnd.visio": ["vsd", "vst", "vss", "vsw"],
					"application/vnd.visionary": ["vis"],
					"application/vnd.vsf": ["vsf"],
					"application/vnd.wap.wbxml": ["wbxml"],
					"application/vnd.wap.wmlc": ["wmlc"],
					"application/vnd.wap.wmlscriptc": ["wmlsc"],
					"application/vnd.webturbo": ["wtb"],
					"application/vnd.wolfram.player": ["nbp"],
					"application/vnd.wordperfect": ["wpd"],
					"application/vnd.wqd": ["wqd"],
					"application/vnd.wt.stf": ["stf"],
					"application/vnd.xara": ["xar"],
					"application/vnd.xfdl": ["xfdl"],
					"application/vnd.yamaha.hv-dic": ["hvd"],
					"application/vnd.yamaha.hv-script": ["hvs"],
					"application/vnd.yamaha.hv-voice": ["hvp"],
					"application/vnd.yamaha.openscoreformat": ["osf"],
					"application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"],
					"application/vnd.yamaha.smaf-audio": ["saf"],
					"application/vnd.yamaha.smaf-phrase": ["spf"],
					"application/vnd.yellowriver-custom-menu": ["cmp"],
					"application/vnd.zul": ["zir", "zirz"],
					"application/vnd.zzazz.deck+xml": ["zaz"],
					"application/x-7z-compressed": ["7z"],
					"application/x-abiword": ["abw"],
					"application/x-ace-compressed": ["ace"],
					"application/x-apple-diskimage": ["*dmg"],
					"application/x-arj": ["arj"],
					"application/x-authorware-bin": ["aab", "x32", "u32", "vox"],
					"application/x-authorware-map": ["aam"],
					"application/x-authorware-seg": ["aas"],
					"application/x-bcpio": ["bcpio"],
					"application/x-bdoc": ["*bdoc"],
					"application/x-bittorrent": ["torrent"],
					"application/x-blorb": ["blb", "blorb"],
					"application/x-bzip": ["bz"],
					"application/x-bzip2": ["bz2", "boz"],
					"application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"],
					"application/x-cdlink": ["vcd"],
					"application/x-cfs-compressed": ["cfs"],
					"application/x-chat": ["chat"],
					"application/x-chess-pgn": ["pgn"],
					"application/x-chrome-extension": ["crx"],
					"application/x-cocoa": ["cco"],
					"application/x-conference": ["nsc"],
					"application/x-cpio": ["cpio"],
					"application/x-csh": ["csh"],
					"application/x-debian-package": ["*deb", "udeb"],
					"application/x-dgc-compressed": ["dgc"],
					"application/x-director": [
						"dir",
						"dcr",
						"dxr",
						"cst",
						"cct",
						"cxt",
						"w3d",
						"fgd",
						"swa",
					],
					"application/x-doom": ["wad"],
					"application/x-dtbncx+xml": ["ncx"],
					"application/x-dtbook+xml": ["dtb"],
					"application/x-dtbresource+xml": ["res"],
					"application/x-dvi": ["dvi"],
					"application/x-envoy": ["evy"],
					"application/x-eva": ["eva"],
					"application/x-font-bdf": ["bdf"],
					"application/x-font-ghostscript": ["gsf"],
					"application/x-font-linux-psf": ["psf"],
					"application/x-font-pcf": ["pcf"],
					"application/x-font-snf": ["snf"],
					"application/x-font-type1": ["pfa", "pfb", "pfm", "afm"],
					"application/x-freearc": ["arc"],
					"application/x-futuresplash": ["spl"],
					"application/x-gca-compressed": ["gca"],
					"application/x-glulx": ["ulx"],
					"application/x-gnumeric": ["gnumeric"],
					"application/x-gramps-xml": ["gramps"],
					"application/x-gtar": ["gtar"],
					"application/x-hdf": ["hdf"],
					"application/x-httpd-php": ["php"],
					"application/x-install-instructions": ["install"],
					"application/x-iso9660-image": ["*iso"],
					"application/x-iwork-keynote-sffkey": ["*key"],
					"application/x-iwork-numbers-sffnumbers": ["*numbers"],
					"application/x-iwork-pages-sffpages": ["*pages"],
					"application/x-java-archive-diff": ["jardiff"],
					"application/x-java-jnlp-file": ["jnlp"],
					"application/x-keepass2": ["kdbx"],
					"application/x-latex": ["latex"],
					"application/x-lua-bytecode": ["luac"],
					"application/x-lzh-compressed": ["lzh", "lha"],
					"application/x-makeself": ["run"],
					"application/x-mie": ["mie"],
					"application/x-mobipocket-ebook": ["prc", "mobi"],
					"application/x-ms-application": ["application"],
					"application/x-ms-shortcut": ["lnk"],
					"application/x-ms-wmd": ["wmd"],
					"application/x-ms-wmz": ["wmz"],
					"application/x-ms-xbap": ["xbap"],
					"application/x-msaccess": ["mdb"],
					"application/x-msbinder": ["obd"],
					"application/x-mscardfile": ["crd"],
					"application/x-msclip": ["clp"],
					"application/x-msdos-program": ["*exe"],
					"application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"],
					"application/x-msmediaview": ["mvb", "m13", "m14"],
					"application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"],
					"application/x-msmoney": ["mny"],
					"application/x-mspublisher": ["pub"],
					"application/x-msschedule": ["scd"],
					"application/x-msterminal": ["trm"],
					"application/x-mswrite": ["wri"],
					"application/x-netcdf": ["nc", "cdf"],
					"application/x-ns-proxy-autoconfig": ["pac"],
					"application/x-nzb": ["nzb"],
					"application/x-perl": ["pl", "pm"],
					"application/x-pilot": ["*prc", "*pdb"],
					"application/x-pkcs12": ["p12", "pfx"],
					"application/x-pkcs7-certificates": ["p7b", "spc"],
					"application/x-pkcs7-certreqresp": ["p7r"],
					"application/x-rar-compressed": ["*rar"],
					"application/x-redhat-package-manager": ["rpm"],
					"application/x-research-info-systems": ["ris"],
					"application/x-sea": ["sea"],
					"application/x-sh": ["sh"],
					"application/x-shar": ["shar"],
					"application/x-shockwave-flash": ["swf"],
					"application/x-silverlight-app": ["xap"],
					"application/x-sql": ["sql"],
					"application/x-stuffit": ["sit"],
					"application/x-stuffitx": ["sitx"],
					"application/x-subrip": ["srt"],
					"application/x-sv4cpio": ["sv4cpio"],
					"application/x-sv4crc": ["sv4crc"],
					"application/x-t3vm-image": ["t3"],
					"application/x-tads": ["gam"],
					"application/x-tar": ["tar"],
					"application/x-tcl": ["tcl", "tk"],
					"application/x-tex": ["tex"],
					"application/x-tex-tfm": ["tfm"],
					"application/x-texinfo": ["texinfo", "texi"],
					"application/x-tgif": ["*obj"],
					"application/x-ustar": ["ustar"],
					"application/x-virtualbox-hdd": ["hdd"],
					"application/x-virtualbox-ova": ["ova"],
					"application/x-virtualbox-ovf": ["ovf"],
					"application/x-virtualbox-vbox": ["vbox"],
					"application/x-virtualbox-vbox-extpack": ["vbox-extpack"],
					"application/x-virtualbox-vdi": ["vdi"],
					"application/x-virtualbox-vhd": ["vhd"],
					"application/x-virtualbox-vmdk": ["vmdk"],
					"application/x-wais-source": ["src"],
					"application/x-web-app-manifest+json": ["webapp"],
					"application/x-x509-ca-cert": ["der", "crt", "pem"],
					"application/x-xfig": ["fig"],
					"application/x-xliff+xml": ["*xlf"],
					"application/x-xpinstall": ["xpi"],
					"application/x-xz": ["xz"],
					"application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"],
					"audio/vnd.dece.audio": ["uva", "uvva"],
					"audio/vnd.digital-winds": ["eol"],
					"audio/vnd.dra": ["dra"],
					"audio/vnd.dts": ["dts"],
					"audio/vnd.dts.hd": ["dtshd"],
					"audio/vnd.lucent.voice": ["lvp"],
					"audio/vnd.ms-playready.media.pya": ["pya"],
					"audio/vnd.nuera.ecelp4800": ["ecelp4800"],
					"audio/vnd.nuera.ecelp7470": ["ecelp7470"],
					"audio/vnd.nuera.ecelp9600": ["ecelp9600"],
					"audio/vnd.rip": ["rip"],
					"audio/x-aac": ["aac"],
					"audio/x-aiff": ["aif", "aiff", "aifc"],
					"audio/x-caf": ["caf"],
					"audio/x-flac": ["flac"],
					"audio/x-m4a": ["*m4a"],
					"audio/x-matroska": ["mka"],
					"audio/x-mpegurl": ["m3u"],
					"audio/x-ms-wax": ["wax"],
					"audio/x-ms-wma": ["wma"],
					"audio/x-pn-realaudio": ["ram", "ra"],
					"audio/x-pn-realaudio-plugin": ["rmp"],
					"audio/x-realaudio": ["*ra"],
					"audio/x-wav": ["*wav"],
					"chemical/x-cdx": ["cdx"],
					"chemical/x-cif": ["cif"],
					"chemical/x-cmdf": ["cmdf"],
					"chemical/x-cml": ["cml"],
					"chemical/x-csml": ["csml"],
					"chemical/x-xyz": ["xyz"],
					"image/prs.btif": ["btif"],
					"image/prs.pti": ["pti"],
					"image/vnd.adobe.photoshop": ["psd"],
					"image/vnd.airzip.accelerator.azv": ["azv"],
					"image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"],
					"image/vnd.djvu": ["djvu", "djv"],
					"image/vnd.dvb.subtitle": ["*sub"],
					"image/vnd.dwg": ["dwg"],
					"image/vnd.dxf": ["dxf"],
					"image/vnd.fastbidsheet": ["fbs"],
					"image/vnd.fpx": ["fpx"],
					"image/vnd.fst": ["fst"],
					"image/vnd.fujixerox.edmics-mmr": ["mmr"],
					"image/vnd.fujixerox.edmics-rlc": ["rlc"],
					"image/vnd.microsoft.icon": ["ico"],
					"image/vnd.ms-dds": ["dds"],
					"image/vnd.ms-modi": ["mdi"],
					"image/vnd.ms-photo": ["wdp"],
					"image/vnd.net-fpx": ["npx"],
					"image/vnd.pco.b16": ["b16"],
					"image/vnd.tencent.tap": ["tap"],
					"image/vnd.valve.source.texture": ["vtf"],
					"image/vnd.wap.wbmp": ["wbmp"],
					"image/vnd.xiff": ["xif"],
					"image/vnd.zbrush.pcx": ["pcx"],
					"image/x-3ds": ["3ds"],
					"image/x-cmu-raster": ["ras"],
					"image/x-cmx": ["cmx"],
					"image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"],
					"image/x-icon": ["*ico"],
					"image/x-jng": ["jng"],
					"image/x-mrsid-image": ["sid"],
					"image/x-ms-bmp": ["*bmp"],
					"image/x-pcx": ["*pcx"],
					"image/x-pict": ["pic", "pct"],
					"image/x-portable-anymap": ["pnm"],
					"image/x-portable-bitmap": ["pbm"],
					"image/x-portable-graymap": ["pgm"],
					"image/x-portable-pixmap": ["ppm"],
					"image/x-rgb": ["rgb"],
					"image/x-tga": ["tga"],
					"image/x-xbitmap": ["xbm"],
					"image/x-xpixmap": ["xpm"],
					"image/x-xwindowdump": ["xwd"],
					"message/vnd.wfa.wsc": ["wsc"],
					"model/vnd.collada+xml": ["dae"],
					"model/vnd.dwf": ["dwf"],
					"model/vnd.gdl": ["gdl"],
					"model/vnd.gtw": ["gtw"],
					"model/vnd.mts": ["mts"],
					"model/vnd.opengex": ["ogex"],
					"model/vnd.parasolid.transmit.binary": ["x_b"],
					"model/vnd.parasolid.transmit.text": ["x_t"],
					"model/vnd.sap.vds": ["vds"],
					"model/vnd.usdz+zip": ["usdz"],
					"model/vnd.valve.source.compiled-map": ["bsp"],
					"model/vnd.vtu": ["vtu"],
					"text/prs.lines.tag": ["dsc"],
					"text/vnd.curl": ["curl"],
					"text/vnd.curl.dcurl": ["dcurl"],
					"text/vnd.curl.mcurl": ["mcurl"],
					"text/vnd.curl.scurl": ["scurl"],
					"text/vnd.dvb.subtitle": ["sub"],
					"text/vnd.fly": ["fly"],
					"text/vnd.fmi.flexstor": ["flx"],
					"text/vnd.graphviz": ["gv"],
					"text/vnd.in3d.3dml": ["3dml"],
					"text/vnd.in3d.spot": ["spot"],
					"text/vnd.sun.j2me.app-descriptor": ["jad"],
					"text/vnd.wap.wml": ["wml"],
					"text/vnd.wap.wmlscript": ["wmls"],
					"text/x-asm": ["s", "asm"],
					"text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"],
					"text/x-component": ["htc"],
					"text/x-fortran": ["f", "for", "f77", "f90"],
					"text/x-handlebars-template": ["hbs"],
					"text/x-java-source": ["java"],
					"text/x-lua": ["lua"],
					"text/x-markdown": ["mkd"],
					"text/x-nfo": ["nfo"],
					"text/x-opml": ["opml"],
					"text/x-org": ["*org"],
					"text/x-pascal": ["p", "pas"],
					"text/x-processing": ["pde"],
					"text/x-sass": ["sass"],
					"text/x-scss": ["scss"],
					"text/x-setext": ["etx"],
					"text/x-sfv": ["sfv"],
					"text/x-suse-ymp": ["ymp"],
					"text/x-uuencode": ["uu"],
					"text/x-vcalendar": ["vcs"],
					"text/x-vcard": ["vcf"],
					"video/vnd.dece.hd": ["uvh", "uvvh"],
					"video/vnd.dece.mobile": ["uvm", "uvvm"],
					"video/vnd.dece.pd": ["uvp", "uvvp"],
					"video/vnd.dece.sd": ["uvs", "uvvs"],
					"video/vnd.dece.video": ["uvv", "uvvv"],
					"video/vnd.dvb.file": ["dvb"],
					"video/vnd.fvt": ["fvt"],
					"video/vnd.mpegurl": ["mxu", "m4u"],
					"video/vnd.ms-playready.media.pyv": ["pyv"],
					"video/vnd.uvvu.mp4": ["uvu", "uvvu"],
					"video/vnd.vivo": ["viv"],
					"video/x-f4v": ["f4v"],
					"video/x-fli": ["fli"],
					"video/x-flv": ["flv"],
					"video/x-m4v": ["m4v"],
					"video/x-matroska": ["mkv", "mk3d", "mks"],
					"video/x-mng": ["mng"],
					"video/x-ms-asf": ["asf", "asx"],
					"video/x-ms-vob": ["vob"],
					"video/x-ms-wm": ["wm"],
					"video/x-ms-wmv": ["wmv"],
					"video/x-ms-wmx": ["wmx"],
					"video/x-ms-wvx": ["wvx"],
					"video/x-msvideo": ["avi"],
					"video/x-sgi-movie": ["movie"],
					"video/x-smv": ["smv"],
					"x-conference/x-cooltalk": ["ice"],
				};
			},
		});
		var require_mime = __commonJS2({
			"../../node_modules/.pnpm/mime@3.0.0/node_modules/mime/index.js"(exports3, module22) {
				"use strict";
				var Mime = require_Mime();
				module22.exports = new Mime(require_standard(), require_other());
			},
		});
		var require_workerd_capnp = __commonJS2({
			"src/runtime/config/workerd.capnp.js"(exports3) {
				"use strict";
				Object.defineProperty(exports3, "__esModule", { value: true });
				exports3.Extension =
					exports3.Extension_Module =
					exports3.TlsOptions =
					exports3.TlsOptions_Version =
					exports3.TlsOptions_Keypair =
					exports3.HttpOptions =
					exports3.HttpOptions_Header =
					exports3.HttpOptions_Style =
					exports3.DiskDirectory =
					exports3.Network =
					exports3.ExternalServer =
					exports3.ExternalServer_Which =
					exports3.ExternalServer_Tcp =
					exports3.ExternalServer_Https =
					exports3.Worker =
					exports3.Worker_Which =
					exports3.Worker_DurableObjectStorage =
					exports3.Worker_DurableObjectStorage_Which =
					exports3.Worker_DurableObjectNamespace =
					exports3.Worker_DurableObjectNamespace_Which =
					exports3.Worker_Binding =
					exports3.Worker_Binding_Which =
					exports3.Worker_Binding_MemoryCache =
					exports3.Worker_Binding_Hyperdrive =
					exports3.Worker_Binding_Parameter =
					exports3.Worker_Binding_WrappedBinding =
					exports3.Worker_Binding_MemoryCacheLimits =
					exports3.Worker_Binding_CryptoKey =
					exports3.Worker_Binding_CryptoKey_Which =
					exports3.Worker_Binding_CryptoKey_Algorithm =
					exports3.Worker_Binding_CryptoKey_Algorithm_Which =
					exports3.Worker_Binding_CryptoKey_Usage =
					exports3.Worker_Binding_DurableObjectNamespaceDesignator =
					exports3.Worker_Binding_Type =
					exports3.Worker_Binding_Type_Which =
					exports3.Worker_Module =
					exports3.Worker_Module_Which =
					exports3.ServiceDesignator =
					exports3.Service =
					exports3.Service_Which =
					exports3.Socket =
					exports3.Socket_Which =
					exports3.Socket_Https =
					exports3.Config =
					exports3._capnpFileId =
						void 0;
				var capnp = require_src2();
				var capnp_ts_1 = require_src2();
				exports3._capnpFileId = "e6afd26682091c01";
				var Config3 = class extends capnp_ts_1.Struct {
					adoptServices(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this));
					}
					disownServices() {
						return capnp_ts_1.Struct.disown(this.getServices());
					}
					getServices() {
						return capnp_ts_1.Struct.getList(0, Config3._Services, this);
					}
					hasServices() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this));
					}
					initServices(length) {
						return capnp_ts_1.Struct.initList(0, Config3._Services, length, this);
					}
					setServices(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this));
					}
					adoptSockets(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownSockets() {
						return capnp_ts_1.Struct.disown(this.getSockets());
					}
					getSockets() {
						return capnp_ts_1.Struct.getList(1, Config3._Sockets, this);
					}
					hasSockets() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initSockets(length) {
						return capnp_ts_1.Struct.initList(1, Config3._Sockets, length, this);
					}
					setSockets(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					adoptV8Flags(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this));
					}
					disownV8Flags() {
						return capnp_ts_1.Struct.disown(this.getV8Flags());
					}
					getV8Flags() {
						return capnp_ts_1.Struct.getList(2, capnp.TextList, this);
					}
					hasV8Flags() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this));
					}
					initV8Flags(length) {
						return capnp_ts_1.Struct.initList(2, capnp.TextList, length, this);
					}
					setV8Flags(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this));
					}
					adoptExtensions(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(3, this));
					}
					disownExtensions() {
						return capnp_ts_1.Struct.disown(this.getExtensions());
					}
					getExtensions() {
						return capnp_ts_1.Struct.getList(3, Config3._Extensions, this);
					}
					hasExtensions() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(3, this));
					}
					initExtensions(length) {
						return capnp_ts_1.Struct.initList(3, Config3._Extensions, length, this);
					}
					setExtensions(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(3, this));
					}
					adoptAutogates(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(4, this));
					}
					disownAutogates() {
						return capnp_ts_1.Struct.disown(this.getAutogates());
					}
					getAutogates() {
						return capnp_ts_1.Struct.getList(4, capnp.TextList, this);
					}
					hasAutogates() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(4, this));
					}
					initAutogates(length) {
						return capnp_ts_1.Struct.initList(4, capnp.TextList, length, this);
					}
					setAutogates(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(4, this));
					}
					toString() {
						return "Config_" + super.toString();
					}
				};
				exports3.Config = Config3;
				Config3._capnp = {
					displayName: "Config",
					id: "8794486c76aaa7d6",
					size: new capnp_ts_1.ObjectSize(0, 5),
				};
				var Socket_Https = class extends capnp_ts_1.Struct {
					adoptOptions(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this));
					}
					disownOptions() {
						return capnp_ts_1.Struct.disown(this.getOptions());
					}
					getOptions() {
						return capnp_ts_1.Struct.getStruct(2, HttpOptions, this);
					}
					hasOptions() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this));
					}
					initOptions() {
						return capnp_ts_1.Struct.initStructAt(2, HttpOptions, this);
					}
					setOptions(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this));
					}
					adoptTlsOptions(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(3, this));
					}
					disownTlsOptions() {
						return capnp_ts_1.Struct.disown(this.getTlsOptions());
					}
					getTlsOptions() {
						return capnp_ts_1.Struct.getStruct(3, TlsOptions, this);
					}
					hasTlsOptions() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(3, this));
					}
					initTlsOptions() {
						return capnp_ts_1.Struct.initStructAt(3, TlsOptions, this);
					}
					setTlsOptions(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(3, this));
					}
					toString() {
						return "Socket_Https_" + super.toString();
					}
				};
				exports3.Socket_Https = Socket_Https;
				Socket_Https._capnp = {
					displayName: "https",
					id: "de123876383cbbdc",
					size: new capnp_ts_1.ObjectSize(8, 5),
				};
				var Socket_Which;
				(function (Socket_Which2) {
					Socket_Which2[(Socket_Which2["HTTP"] = 0)] = "HTTP";
					Socket_Which2[(Socket_Which2["HTTPS"] = 1)] = "HTTPS";
				})((Socket_Which = exports3.Socket_Which || (exports3.Socket_Which = {})));
				var Socket2 = class extends capnp_ts_1.Struct {
					getName() {
						return capnp_ts_1.Struct.getText(0, this);
					}
					setName(value) {
						capnp_ts_1.Struct.setText(0, value, this);
					}
					getAddress() {
						return capnp_ts_1.Struct.getText(1, this);
					}
					setAddress(value) {
						capnp_ts_1.Struct.setText(1, value, this);
					}
					adoptHttp(value) {
						capnp_ts_1.Struct.setUint16(0, 0, this);
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this));
					}
					disownHttp() {
						return capnp_ts_1.Struct.disown(this.getHttp());
					}
					getHttp() {
						capnp_ts_1.Struct.testWhich(
							"http",
							capnp_ts_1.Struct.getUint16(0, this),
							0,
							this,
						);
						return capnp_ts_1.Struct.getStruct(2, HttpOptions, this);
					}
					hasHttp() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this));
					}
					initHttp() {
						capnp_ts_1.Struct.setUint16(0, 0, this);
						return capnp_ts_1.Struct.initStructAt(2, HttpOptions, this);
					}
					isHttp() {
						return capnp_ts_1.Struct.getUint16(0, this) === 0;
					}
					setHttp(value) {
						capnp_ts_1.Struct.setUint16(0, 0, this);
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this));
					}
					getHttps() {
						capnp_ts_1.Struct.testWhich(
							"https",
							capnp_ts_1.Struct.getUint16(0, this),
							1,
							this,
						);
						return capnp_ts_1.Struct.getAs(Socket_Https, this);
					}
					initHttps() {
						capnp_ts_1.Struct.setUint16(0, 1, this);
						return capnp_ts_1.Struct.getAs(Socket_Https, this);
					}
					isHttps() {
						return capnp_ts_1.Struct.getUint16(0, this) === 1;
					}
					setHttps() {
						capnp_ts_1.Struct.setUint16(0, 1, this);
					}
					adoptService(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(4, this));
					}
					disownService() {
						return capnp_ts_1.Struct.disown(this.getService());
					}
					getService() {
						return capnp_ts_1.Struct.getStruct(4, ServiceDesignator2, this);
					}
					hasService() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(4, this));
					}
					initService() {
						return capnp_ts_1.Struct.initStructAt(4, ServiceDesignator2, this);
					}
					setService(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(4, this));
					}
					toString() {
						return "Socket_" + super.toString();
					}
					which() {
						return capnp_ts_1.Struct.getUint16(0, this);
					}
				};
				exports3.Socket = Socket2;
				Socket2.HTTP = Socket_Which.HTTP;
				Socket2.HTTPS = Socket_Which.HTTPS;
				Socket2._capnp = {
					displayName: "Socket",
					id: "9a0eba45530ee79f",
					size: new capnp_ts_1.ObjectSize(8, 5),
				};
				var Service_Which;
				(function (Service_Which2) {
					Service_Which2[(Service_Which2["UNSPECIFIED"] = 0)] = "UNSPECIFIED";
					Service_Which2[(Service_Which2["WORKER"] = 1)] = "WORKER";
					Service_Which2[(Service_Which2["NETWORK"] = 2)] = "NETWORK";
					Service_Which2[(Service_Which2["EXTERNAL"] = 3)] = "EXTERNAL";
					Service_Which2[(Service_Which2["DISK"] = 4)] = "DISK";
				})((Service_Which = exports3.Service_Which || (exports3.Service_Which = {})));
				var Service4 = class extends capnp_ts_1.Struct {
					getName() {
						return capnp_ts_1.Struct.getText(0, this);
					}
					setName(value) {
						capnp_ts_1.Struct.setText(0, value, this);
					}
					isUnspecified() {
						return capnp_ts_1.Struct.getUint16(0, this) === 0;
					}
					setUnspecified() {
						capnp_ts_1.Struct.setUint16(0, 0, this);
					}
					adoptWorker(value) {
						capnp_ts_1.Struct.setUint16(0, 1, this);
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownWorker() {
						return capnp_ts_1.Struct.disown(this.getWorker());
					}
					getWorker() {
						capnp_ts_1.Struct.testWhich(
							"worker",
							capnp_ts_1.Struct.getUint16(0, this),
							1,
							this,
						);
						return capnp_ts_1.Struct.getStruct(1, Worker2, this);
					}
					hasWorker() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initWorker() {
						capnp_ts_1.Struct.setUint16(0, 1, this);
						return capnp_ts_1.Struct.initStructAt(1, Worker2, this);
					}
					isWorker() {
						return capnp_ts_1.Struct.getUint16(0, this) === 1;
					}
					setWorker(value) {
						capnp_ts_1.Struct.setUint16(0, 1, this);
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					adoptNetwork(value) {
						capnp_ts_1.Struct.setUint16(0, 2, this);
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownNetwork() {
						return capnp_ts_1.Struct.disown(this.getNetwork());
					}
					getNetwork() {
						capnp_ts_1.Struct.testWhich(
							"network",
							capnp_ts_1.Struct.getUint16(0, this),
							2,
							this,
						);
						return capnp_ts_1.Struct.getStruct(1, Network, this);
					}
					hasNetwork() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initNetwork() {
						capnp_ts_1.Struct.setUint16(0, 2, this);
						return capnp_ts_1.Struct.initStructAt(1, Network, this);
					}
					isNetwork() {
						return capnp_ts_1.Struct.getUint16(0, this) === 2;
					}
					setNetwork(value) {
						capnp_ts_1.Struct.setUint16(0, 2, this);
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					adoptExternal(value) {
						capnp_ts_1.Struct.setUint16(0, 3, this);
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownExternal() {
						return capnp_ts_1.Struct.disown(this.getExternal());
					}
					getExternal() {
						capnp_ts_1.Struct.testWhich(
							"external",
							capnp_ts_1.Struct.getUint16(0, this),
							3,
							this,
						);
						return capnp_ts_1.Struct.getStruct(1, ExternalServer2, this);
					}
					hasExternal() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initExternal() {
						capnp_ts_1.Struct.setUint16(0, 3, this);
						return capnp_ts_1.Struct.initStructAt(1, ExternalServer2, this);
					}
					isExternal() {
						return capnp_ts_1.Struct.getUint16(0, this) === 3;
					}
					setExternal(value) {
						capnp_ts_1.Struct.setUint16(0, 3, this);
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					adoptDisk(value) {
						capnp_ts_1.Struct.setUint16(0, 4, this);
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownDisk() {
						return capnp_ts_1.Struct.disown(this.getDisk());
					}
					getDisk() {
						capnp_ts_1.Struct.testWhich(
							"disk",
							capnp_ts_1.Struct.getUint16(0, this),
							4,
							this,
						);
						return capnp_ts_1.Struct.getStruct(1, DiskDirectory, this);
					}
					hasDisk() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initDisk() {
						capnp_ts_1.Struct.setUint16(0, 4, this);
						return capnp_ts_1.Struct.initStructAt(1, DiskDirectory, this);
					}
					isDisk() {
						return capnp_ts_1.Struct.getUint16(0, this) === 4;
					}
					setDisk(value) {
						capnp_ts_1.Struct.setUint16(0, 4, this);
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					toString() {
						return "Service_" + super.toString();
					}
					which() {
						return capnp_ts_1.Struct.getUint16(0, this);
					}
				};
				exports3.Service = Service4;
				Service4.UNSPECIFIED = Service_Which.UNSPECIFIED;
				Service4.WORKER = Service_Which.WORKER;
				Service4.NETWORK = Service_Which.NETWORK;
				Service4.EXTERNAL = Service_Which.EXTERNAL;
				Service4.DISK = Service_Which.DISK;
				Service4._capnp = {
					displayName: "Service",
					id: "e5c88e8bb7bcb6b9",
					size: new capnp_ts_1.ObjectSize(8, 2),
				};
				var ServiceDesignator2 = class extends capnp_ts_1.Struct {
					getName() {
						return capnp_ts_1.Struct.getText(0, this);
					}
					setName(value) {
						capnp_ts_1.Struct.setText(0, value, this);
					}
					getEntrypoint() {
						return capnp_ts_1.Struct.getText(1, this);
					}
					setEntrypoint(value) {
						capnp_ts_1.Struct.setText(1, value, this);
					}
					toString() {
						return "ServiceDesignator_" + super.toString();
					}
				};
				exports3.ServiceDesignator = ServiceDesignator2;
				ServiceDesignator2._capnp = {
					displayName: "ServiceDesignator",
					id: "ae8ec91cee724450",
					size: new capnp_ts_1.ObjectSize(0, 2),
				};
				var Worker_Module_Which;
				(function (Worker_Module_Which2) {
					Worker_Module_Which2[(Worker_Module_Which2["ES_MODULE"] = 0)] = "ES_MODULE";
					Worker_Module_Which2[(Worker_Module_Which2["COMMON_JS_MODULE"] = 1)] =
						"COMMON_JS_MODULE";
					Worker_Module_Which2[(Worker_Module_Which2["TEXT"] = 2)] = "TEXT";
					Worker_Module_Which2[(Worker_Module_Which2["DATA"] = 3)] = "DATA";
					Worker_Module_Which2[(Worker_Module_Which2["WASM"] = 4)] = "WASM";
					Worker_Module_Which2[(Worker_Module_Which2["JSON"] = 5)] = "JSON";
					Worker_Module_Which2[(Worker_Module_Which2["NODE_JS_COMPAT_MODULE"] = 6)] =
						"NODE_JS_COMPAT_MODULE";
					Worker_Module_Which2[(Worker_Module_Which2["PYTHON_MODULE"] = 7)] =
						"PYTHON_MODULE";
					Worker_Module_Which2[(Worker_Module_Which2["PYTHON_REQUIREMENT"] = 8)] =
						"PYTHON_REQUIREMENT";
				})(
					(Worker_Module_Which =
						exports3.Worker_Module_Which || (exports3.Worker_Module_Which = {})),
				);
				var Worker_Module3 = class extends capnp_ts_1.Struct {
					getName() {
						return capnp_ts_1.Struct.getText(0, this);
					}
					setName(value) {
						capnp_ts_1.Struct.setText(0, value, this);
					}
					getEsModule() {
						capnp_ts_1.Struct.testWhich(
							"esModule",
							capnp_ts_1.Struct.getUint16(0, this),
							0,
							this,
						);
						return capnp_ts_1.Struct.getText(1, this);
					}
					isEsModule() {
						return capnp_ts_1.Struct.getUint16(0, this) === 0;
					}
					setEsModule(value) {
						capnp_ts_1.Struct.setUint16(0, 0, this);
						capnp_ts_1.Struct.setText(1, value, this);
					}
					getCommonJsModule() {
						capnp_ts_1.Struct.testWhich(
							"commonJsModule",
							capnp_ts_1.Struct.getUint16(0, this),
							1,
							this,
						);
						return capnp_ts_1.Struct.getText(1, this);
					}
					isCommonJsModule() {
						return capnp_ts_1.Struct.getUint16(0, this) === 1;
					}
					setCommonJsModule(value) {
						capnp_ts_1.Struct.setUint16(0, 1, this);
						capnp_ts_1.Struct.setText(1, value, this);
					}
					getText() {
						capnp_ts_1.Struct.testWhich(
							"text",
							capnp_ts_1.Struct.getUint16(0, this),
							2,
							this,
						);
						return capnp_ts_1.Struct.getText(1, this);
					}
					isText() {
						return capnp_ts_1.Struct.getUint16(0, this) === 2;
					}
					setText(value) {
						capnp_ts_1.Struct.setUint16(0, 2, this);
						capnp_ts_1.Struct.setText(1, value, this);
					}
					adoptData(value) {
						capnp_ts_1.Struct.setUint16(0, 3, this);
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownData() {
						return capnp_ts_1.Struct.disown(this.getData());
					}
					getData() {
						capnp_ts_1.Struct.testWhich(
							"data",
							capnp_ts_1.Struct.getUint16(0, this),
							3,
							this,
						);
						return capnp_ts_1.Struct.getData(1, this);
					}
					hasData() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initData(length) {
						capnp_ts_1.Struct.setUint16(0, 3, this);
						return capnp_ts_1.Struct.initData(1, length, this);
					}
					isData() {
						return capnp_ts_1.Struct.getUint16(0, this) === 3;
					}
					setData(value) {
						capnp_ts_1.Struct.setUint16(0, 3, this);
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					adoptWasm(value) {
						capnp_ts_1.Struct.setUint16(0, 4, this);
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownWasm() {
						return capnp_ts_1.Struct.disown(this.getWasm());
					}
					getWasm() {
						capnp_ts_1.Struct.testWhich(
							"wasm",
							capnp_ts_1.Struct.getUint16(0, this),
							4,
							this,
						);
						return capnp_ts_1.Struct.getData(1, this);
					}
					hasWasm() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initWasm(length) {
						capnp_ts_1.Struct.setUint16(0, 4, this);
						return capnp_ts_1.Struct.initData(1, length, this);
					}
					isWasm() {
						return capnp_ts_1.Struct.getUint16(0, this) === 4;
					}
					setWasm(value) {
						capnp_ts_1.Struct.setUint16(0, 4, this);
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					getJson() {
						capnp_ts_1.Struct.testWhich(
							"json",
							capnp_ts_1.Struct.getUint16(0, this),
							5,
							this,
						);
						return capnp_ts_1.Struct.getText(1, this);
					}
					isJson() {
						return capnp_ts_1.Struct.getUint16(0, this) === 5;
					}
					setJson(value) {
						capnp_ts_1.Struct.setUint16(0, 5, this);
						capnp_ts_1.Struct.setText(1, value, this);
					}
					getNodeJsCompatModule() {
						capnp_ts_1.Struct.testWhich(
							"nodeJsCompatModule",
							capnp_ts_1.Struct.getUint16(0, this),
							6,
							this,
						);
						return capnp_ts_1.Struct.getText(1, this);
					}
					isNodeJsCompatModule() {
						return capnp_ts_1.Struct.getUint16(0, this) === 6;
					}
					setNodeJsCompatModule(value) {
						capnp_ts_1.Struct.setUint16(0, 6, this);
						capnp_ts_1.Struct.setText(1, value, this);
					}
					getPythonModule() {
						capnp_ts_1.Struct.testWhich(
							"pythonModule",
							capnp_ts_1.Struct.getUint16(0, this),
							7,
							this,
						);
						return capnp_ts_1.Struct.getText(1, this);
					}
					isPythonModule() {
						return capnp_ts_1.Struct.getUint16(0, this) === 7;
					}
					setPythonModule(value) {
						capnp_ts_1.Struct.setUint16(0, 7, this);
						capnp_ts_1.Struct.setText(1, value, this);
					}
					getPythonRequirement() {
						capnp_ts_1.Struct.testWhich(
							"pythonRequirement",
							capnp_ts_1.Struct.getUint16(0, this),
							8,
							this,
						);
						return capnp_ts_1.Struct.getText(1, this);
					}
					isPythonRequirement() {
						return capnp_ts_1.Struct.getUint16(0, this) === 8;
					}
					setPythonRequirement(value) {
						capnp_ts_1.Struct.setUint16(0, 8, this);
						capnp_ts_1.Struct.setText(1, value, this);
					}
					adoptNamedExports(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this));
					}
					disownNamedExports() {
						return capnp_ts_1.Struct.disown(this.getNamedExports());
					}
					getNamedExports() {
						return capnp_ts_1.Struct.getList(2, capnp.TextList, this);
					}
					hasNamedExports() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this));
					}
					initNamedExports(length) {
						return capnp_ts_1.Struct.initList(2, capnp.TextList, length, this);
					}
					setNamedExports(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this));
					}
					toString() {
						return "Worker_Module_" + super.toString();
					}
					which() {
						return capnp_ts_1.Struct.getUint16(0, this);
					}
				};
				exports3.Worker_Module = Worker_Module3;
				Worker_Module3.ES_MODULE = Worker_Module_Which.ES_MODULE;
				Worker_Module3.COMMON_JS_MODULE = Worker_Module_Which.COMMON_JS_MODULE;
				Worker_Module3.TEXT = Worker_Module_Which.TEXT;
				Worker_Module3.DATA = Worker_Module_Which.DATA;
				Worker_Module3.WASM = Worker_Module_Which.WASM;
				Worker_Module3.JSON = Worker_Module_Which.JSON;
				Worker_Module3.NODE_JS_COMPAT_MODULE = Worker_Module_Which.NODE_JS_COMPAT_MODULE;
				Worker_Module3.PYTHON_MODULE = Worker_Module_Which.PYTHON_MODULE;
				Worker_Module3.PYTHON_REQUIREMENT = Worker_Module_Which.PYTHON_REQUIREMENT;
				Worker_Module3._capnp = {
					displayName: "Module",
					id: "d9d87a63770a12f3",
					size: new capnp_ts_1.ObjectSize(8, 3),
				};
				var Worker_Binding_Type_Which;
				(function (Worker_Binding_Type_Which2) {
					Worker_Binding_Type_Which2[(Worker_Binding_Type_Which2["UNSPECIFIED"] = 0)] =
						"UNSPECIFIED";
					Worker_Binding_Type_Which2[(Worker_Binding_Type_Which2["TEXT"] = 1)] = "TEXT";
					Worker_Binding_Type_Which2[(Worker_Binding_Type_Which2["DATA"] = 2)] = "DATA";
					Worker_Binding_Type_Which2[(Worker_Binding_Type_Which2["JSON"] = 3)] = "JSON";
					Worker_Binding_Type_Which2[(Worker_Binding_Type_Which2["WASM"] = 4)] = "WASM";
					Worker_Binding_Type_Which2[(Worker_Binding_Type_Which2["CRYPTO_KEY"] = 5)] =
						"CRYPTO_KEY";
					Worker_Binding_Type_Which2[(Worker_Binding_Type_Which2["SERVICE"] = 6)] =
						"SERVICE";
					Worker_Binding_Type_Which2[
						(Worker_Binding_Type_Which2["DURABLE_OBJECT_NAMESPACE"] = 7)
					] = "DURABLE_OBJECT_NAMESPACE";
					Worker_Binding_Type_Which2[(Worker_Binding_Type_Which2["KV_NAMESPACE"] = 8)] =
						"KV_NAMESPACE";
					Worker_Binding_Type_Which2[(Worker_Binding_Type_Which2["R2BUCKET"] = 9)] =
						"R2BUCKET";
					Worker_Binding_Type_Which2[(Worker_Binding_Type_Which2["R2ADMIN"] = 10)] =
						"R2ADMIN";
					Worker_Binding_Type_Which2[(Worker_Binding_Type_Which2["QUEUE"] = 11)] =
						"QUEUE";
					Worker_Binding_Type_Which2[
						(Worker_Binding_Type_Which2["ANALYTICS_ENGINE"] = 12)
					] = "ANALYTICS_ENGINE";
					Worker_Binding_Type_Which2[(Worker_Binding_Type_Which2["HYPERDRIVE"] = 13)] =
						"HYPERDRIVE";
				})(
					(Worker_Binding_Type_Which =
						exports3.Worker_Binding_Type_Which ||
						(exports3.Worker_Binding_Type_Which = {})),
				);
				var Worker_Binding_Type = class extends capnp_ts_1.Struct {
					isUnspecified() {
						return capnp_ts_1.Struct.getUint16(0, this) === 0;
					}
					setUnspecified() {
						capnp_ts_1.Struct.setUint16(0, 0, this);
					}
					isText() {
						return capnp_ts_1.Struct.getUint16(0, this) === 1;
					}
					setText() {
						capnp_ts_1.Struct.setUint16(0, 1, this);
					}
					isData() {
						return capnp_ts_1.Struct.getUint16(0, this) === 2;
					}
					setData() {
						capnp_ts_1.Struct.setUint16(0, 2, this);
					}
					isJson() {
						return capnp_ts_1.Struct.getUint16(0, this) === 3;
					}
					setJson() {
						capnp_ts_1.Struct.setUint16(0, 3, this);
					}
					isWasm() {
						return capnp_ts_1.Struct.getUint16(0, this) === 4;
					}
					setWasm() {
						capnp_ts_1.Struct.setUint16(0, 4, this);
					}
					adoptCryptoKey(value) {
						capnp_ts_1.Struct.setUint16(0, 5, this);
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this));
					}
					disownCryptoKey() {
						return capnp_ts_1.Struct.disown(this.getCryptoKey());
					}
					getCryptoKey() {
						capnp_ts_1.Struct.testWhich(
							"cryptoKey",
							capnp_ts_1.Struct.getUint16(0, this),
							5,
							this,
						);
						return capnp_ts_1.Struct.getList(0, capnp.Uint16List, this);
					}
					hasCryptoKey() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this));
					}
					initCryptoKey(length) {
						capnp_ts_1.Struct.setUint16(0, 5, this);
						return capnp_ts_1.Struct.initList(0, capnp.Uint16List, length, this);
					}
					isCryptoKey() {
						return capnp_ts_1.Struct.getUint16(0, this) === 5;
					}
					setCryptoKey(value) {
						capnp_ts_1.Struct.setUint16(0, 5, this);
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this));
					}
					isService() {
						return capnp_ts_1.Struct.getUint16(0, this) === 6;
					}
					setService() {
						capnp_ts_1.Struct.setUint16(0, 6, this);
					}
					isDurableObjectNamespace() {
						return capnp_ts_1.Struct.getUint16(0, this) === 7;
					}
					setDurableObjectNamespace() {
						capnp_ts_1.Struct.setUint16(0, 7, this);
					}
					isKvNamespace() {
						return capnp_ts_1.Struct.getUint16(0, this) === 8;
					}
					setKvNamespace() {
						capnp_ts_1.Struct.setUint16(0, 8, this);
					}
					isR2Bucket() {
						return capnp_ts_1.Struct.getUint16(0, this) === 9;
					}
					setR2Bucket() {
						capnp_ts_1.Struct.setUint16(0, 9, this);
					}
					isR2Admin() {
						return capnp_ts_1.Struct.getUint16(0, this) === 10;
					}
					setR2Admin() {
						capnp_ts_1.Struct.setUint16(0, 10, this);
					}
					isQueue() {
						return capnp_ts_1.Struct.getUint16(0, this) === 11;
					}
					setQueue() {
						capnp_ts_1.Struct.setUint16(0, 11, this);
					}
					isAnalyticsEngine() {
						return capnp_ts_1.Struct.getUint16(0, this) === 12;
					}
					setAnalyticsEngine() {
						capnp_ts_1.Struct.setUint16(0, 12, this);
					}
					isHyperdrive() {
						return capnp_ts_1.Struct.getUint16(0, this) === 13;
					}
					setHyperdrive() {
						capnp_ts_1.Struct.setUint16(0, 13, this);
					}
					toString() {
						return "Worker_Binding_Type_" + super.toString();
					}
					which() {
						return capnp_ts_1.Struct.getUint16(0, this);
					}
				};
				exports3.Worker_Binding_Type = Worker_Binding_Type;
				Worker_Binding_Type.UNSPECIFIED = Worker_Binding_Type_Which.UNSPECIFIED;
				Worker_Binding_Type.TEXT = Worker_Binding_Type_Which.TEXT;
				Worker_Binding_Type.DATA = Worker_Binding_Type_Which.DATA;
				Worker_Binding_Type.JSON = Worker_Binding_Type_Which.JSON;
				Worker_Binding_Type.WASM = Worker_Binding_Type_Which.WASM;
				Worker_Binding_Type.CRYPTO_KEY = Worker_Binding_Type_Which.CRYPTO_KEY;
				Worker_Binding_Type.SERVICE = Worker_Binding_Type_Which.SERVICE;
				Worker_Binding_Type.DURABLE_OBJECT_NAMESPACE =
					Worker_Binding_Type_Which.DURABLE_OBJECT_NAMESPACE;
				Worker_Binding_Type.KV_NAMESPACE = Worker_Binding_Type_Which.KV_NAMESPACE;
				Worker_Binding_Type.R2BUCKET = Worker_Binding_Type_Which.R2BUCKET;
				Worker_Binding_Type.R2ADMIN = Worker_Binding_Type_Which.R2ADMIN;
				Worker_Binding_Type.QUEUE = Worker_Binding_Type_Which.QUEUE;
				Worker_Binding_Type.ANALYTICS_ENGINE = Worker_Binding_Type_Which.ANALYTICS_ENGINE;
				Worker_Binding_Type.HYPERDRIVE = Worker_Binding_Type_Which.HYPERDRIVE;
				Worker_Binding_Type._capnp = {
					displayName: "Type",
					id: "8906a1296519bf8a",
					size: new capnp_ts_1.ObjectSize(8, 1),
				};
				var Worker_Binding_DurableObjectNamespaceDesignator2 = class extends capnp_ts_1.Struct {
					getClassName() {
						return capnp_ts_1.Struct.getText(0, this);
					}
					setClassName(value) {
						capnp_ts_1.Struct.setText(0, value, this);
					}
					getServiceName() {
						return capnp_ts_1.Struct.getText(1, this);
					}
					setServiceName(value) {
						capnp_ts_1.Struct.setText(1, value, this);
					}
					toString() {
						return (
							"Worker_Binding_DurableObjectNamespaceDesignator_" + super.toString()
						);
					}
				};
				exports3.Worker_Binding_DurableObjectNamespaceDesignator =
					Worker_Binding_DurableObjectNamespaceDesignator2;
				Worker_Binding_DurableObjectNamespaceDesignator2._capnp = {
					displayName: "DurableObjectNamespaceDesignator",
					id: "804f144ff477aac7",
					size: new capnp_ts_1.ObjectSize(0, 2),
				};
				var Worker_Binding_CryptoKey_Usage2;
				(function (Worker_Binding_CryptoKey_Usage3) {
					Worker_Binding_CryptoKey_Usage3[
						(Worker_Binding_CryptoKey_Usage3["ENCRYPT"] = 0)
					] = "ENCRYPT";
					Worker_Binding_CryptoKey_Usage3[
						(Worker_Binding_CryptoKey_Usage3["DECRYPT"] = 1)
					] = "DECRYPT";
					Worker_Binding_CryptoKey_Usage3[(Worker_Binding_CryptoKey_Usage3["SIGN"] = 2)] =
						"SIGN";
					Worker_Binding_CryptoKey_Usage3[
						(Worker_Binding_CryptoKey_Usage3["VERIFY"] = 3)
					] = "VERIFY";
					Worker_Binding_CryptoKey_Usage3[
						(Worker_Binding_CryptoKey_Usage3["DERIVE_KEY"] = 4)
					] = "DERIVE_KEY";
					Worker_Binding_CryptoKey_Usage3[
						(Worker_Binding_CryptoKey_Usage3["DERIVE_BITS"] = 5)
					] = "DERIVE_BITS";
					Worker_Binding_CryptoKey_Usage3[
						(Worker_Binding_CryptoKey_Usage3["WRAP_KEY"] = 6)
					] = "WRAP_KEY";
					Worker_Binding_CryptoKey_Usage3[
						(Worker_Binding_CryptoKey_Usage3["UNWRAP_KEY"] = 7)
					] = "UNWRAP_KEY";
				})(
					(Worker_Binding_CryptoKey_Usage2 =
						exports3.Worker_Binding_CryptoKey_Usage ||
						(exports3.Worker_Binding_CryptoKey_Usage = {})),
				);
				var Worker_Binding_CryptoKey_Algorithm_Which;
				(function (Worker_Binding_CryptoKey_Algorithm_Which2) {
					Worker_Binding_CryptoKey_Algorithm_Which2[
						(Worker_Binding_CryptoKey_Algorithm_Which2["NAME"] = 0)
					] = "NAME";
					Worker_Binding_CryptoKey_Algorithm_Which2[
						(Worker_Binding_CryptoKey_Algorithm_Which2["JSON"] = 1)
					] = "JSON";
				})(
					(Worker_Binding_CryptoKey_Algorithm_Which =
						exports3.Worker_Binding_CryptoKey_Algorithm_Which ||
						(exports3.Worker_Binding_CryptoKey_Algorithm_Which = {})),
				);
				var Worker_Binding_CryptoKey_Algorithm = class extends capnp_ts_1.Struct {
					getName() {
						capnp_ts_1.Struct.testWhich(
							"name",
							capnp_ts_1.Struct.getUint16(2, this),
							0,
							this,
						);
						return capnp_ts_1.Struct.getText(1, this);
					}
					isName() {
						return capnp_ts_1.Struct.getUint16(2, this) === 0;
					}
					setName(value) {
						capnp_ts_1.Struct.setUint16(2, 0, this);
						capnp_ts_1.Struct.setText(1, value, this);
					}
					getJson() {
						capnp_ts_1.Struct.testWhich(
							"json",
							capnp_ts_1.Struct.getUint16(2, this),
							1,
							this,
						);
						return capnp_ts_1.Struct.getText(1, this);
					}
					isJson() {
						return capnp_ts_1.Struct.getUint16(2, this) === 1;
					}
					setJson(value) {
						capnp_ts_1.Struct.setUint16(2, 1, this);
						capnp_ts_1.Struct.setText(1, value, this);
					}
					toString() {
						return "Worker_Binding_CryptoKey_Algorithm_" + super.toString();
					}
					which() {
						return capnp_ts_1.Struct.getUint16(2, this);
					}
				};
				exports3.Worker_Binding_CryptoKey_Algorithm = Worker_Binding_CryptoKey_Algorithm;
				Worker_Binding_CryptoKey_Algorithm.NAME =
					Worker_Binding_CryptoKey_Algorithm_Which.NAME;
				Worker_Binding_CryptoKey_Algorithm.JSON =
					Worker_Binding_CryptoKey_Algorithm_Which.JSON;
				Worker_Binding_CryptoKey_Algorithm._capnp = {
					displayName: "algorithm",
					id: "a1a040c5e00d7021",
					size: new capnp_ts_1.ObjectSize(8, 3),
				};
				var Worker_Binding_CryptoKey_Which;
				(function (Worker_Binding_CryptoKey_Which2) {
					Worker_Binding_CryptoKey_Which2[(Worker_Binding_CryptoKey_Which2["RAW"] = 0)] =
						"RAW";
					Worker_Binding_CryptoKey_Which2[(Worker_Binding_CryptoKey_Which2["HEX"] = 1)] =
						"HEX";
					Worker_Binding_CryptoKey_Which2[
						(Worker_Binding_CryptoKey_Which2["BASE64"] = 2)
					] = "BASE64";
					Worker_Binding_CryptoKey_Which2[
						(Worker_Binding_CryptoKey_Which2["PKCS8"] = 3)
					] = "PKCS8";
					Worker_Binding_CryptoKey_Which2[(Worker_Binding_CryptoKey_Which2["SPKI"] = 4)] =
						"SPKI";
					Worker_Binding_CryptoKey_Which2[(Worker_Binding_CryptoKey_Which2["JWK"] = 5)] =
						"JWK";
				})(
					(Worker_Binding_CryptoKey_Which =
						exports3.Worker_Binding_CryptoKey_Which ||
						(exports3.Worker_Binding_CryptoKey_Which = {})),
				);
				var Worker_Binding_CryptoKey = class extends capnp_ts_1.Struct {
					adoptRaw(value) {
						capnp_ts_1.Struct.setUint16(0, 0, this);
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this));
					}
					disownRaw() {
						return capnp_ts_1.Struct.disown(this.getRaw());
					}
					getRaw() {
						capnp_ts_1.Struct.testWhich(
							"raw",
							capnp_ts_1.Struct.getUint16(0, this),
							0,
							this,
						);
						return capnp_ts_1.Struct.getData(0, this);
					}
					hasRaw() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this));
					}
					initRaw(length) {
						capnp_ts_1.Struct.setUint16(0, 0, this);
						return capnp_ts_1.Struct.initData(0, length, this);
					}
					isRaw() {
						return capnp_ts_1.Struct.getUint16(0, this) === 0;
					}
					setRaw(value) {
						capnp_ts_1.Struct.setUint16(0, 0, this);
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this));
					}
					getHex() {
						capnp_ts_1.Struct.testWhich(
							"hex",
							capnp_ts_1.Struct.getUint16(0, this),
							1,
							this,
						);
						return capnp_ts_1.Struct.getText(0, this);
					}
					isHex() {
						return capnp_ts_1.Struct.getUint16(0, this) === 1;
					}
					setHex(value) {
						capnp_ts_1.Struct.setUint16(0, 1, this);
						capnp_ts_1.Struct.setText(0, value, this);
					}
					getBase64() {
						capnp_ts_1.Struct.testWhich(
							"base64",
							capnp_ts_1.Struct.getUint16(0, this),
							2,
							this,
						);
						return capnp_ts_1.Struct.getText(0, this);
					}
					isBase64() {
						return capnp_ts_1.Struct.getUint16(0, this) === 2;
					}
					setBase64(value) {
						capnp_ts_1.Struct.setUint16(0, 2, this);
						capnp_ts_1.Struct.setText(0, value, this);
					}
					getPkcs8() {
						capnp_ts_1.Struct.testWhich(
							"pkcs8",
							capnp_ts_1.Struct.getUint16(0, this),
							3,
							this,
						);
						return capnp_ts_1.Struct.getText(0, this);
					}
					isPkcs8() {
						return capnp_ts_1.Struct.getUint16(0, this) === 3;
					}
					setPkcs8(value) {
						capnp_ts_1.Struct.setUint16(0, 3, this);
						capnp_ts_1.Struct.setText(0, value, this);
					}
					getSpki() {
						capnp_ts_1.Struct.testWhich(
							"spki",
							capnp_ts_1.Struct.getUint16(0, this),
							4,
							this,
						);
						return capnp_ts_1.Struct.getText(0, this);
					}
					isSpki() {
						return capnp_ts_1.Struct.getUint16(0, this) === 4;
					}
					setSpki(value) {
						capnp_ts_1.Struct.setUint16(0, 4, this);
						capnp_ts_1.Struct.setText(0, value, this);
					}
					getJwk() {
						capnp_ts_1.Struct.testWhich(
							"jwk",
							capnp_ts_1.Struct.getUint16(0, this),
							5,
							this,
						);
						return capnp_ts_1.Struct.getText(0, this);
					}
					isJwk() {
						return capnp_ts_1.Struct.getUint16(0, this) === 5;
					}
					setJwk(value) {
						capnp_ts_1.Struct.setUint16(0, 5, this);
						capnp_ts_1.Struct.setText(0, value, this);
					}
					getAlgorithm() {
						return capnp_ts_1.Struct.getAs(Worker_Binding_CryptoKey_Algorithm, this);
					}
					initAlgorithm() {
						return capnp_ts_1.Struct.getAs(Worker_Binding_CryptoKey_Algorithm, this);
					}
					getExtractable() {
						return capnp_ts_1.Struct.getBit(
							32,
							this,
							Worker_Binding_CryptoKey._capnp.defaultExtractable,
						);
					}
					setExtractable(value) {
						capnp_ts_1.Struct.setBit(32, value, this);
					}
					adoptUsages(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this));
					}
					disownUsages() {
						return capnp_ts_1.Struct.disown(this.getUsages());
					}
					getUsages() {
						return capnp_ts_1.Struct.getList(2, capnp.Uint16List, this);
					}
					hasUsages() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this));
					}
					initUsages(length) {
						return capnp_ts_1.Struct.initList(2, capnp.Uint16List, length, this);
					}
					setUsages(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this));
					}
					toString() {
						return "Worker_Binding_CryptoKey_" + super.toString();
					}
					which() {
						return capnp_ts_1.Struct.getUint16(0, this);
					}
				};
				exports3.Worker_Binding_CryptoKey = Worker_Binding_CryptoKey;
				Worker_Binding_CryptoKey.RAW = Worker_Binding_CryptoKey_Which.RAW;
				Worker_Binding_CryptoKey.HEX = Worker_Binding_CryptoKey_Which.HEX;
				Worker_Binding_CryptoKey.BASE64 = Worker_Binding_CryptoKey_Which.BASE64;
				Worker_Binding_CryptoKey.PKCS8 = Worker_Binding_CryptoKey_Which.PKCS8;
				Worker_Binding_CryptoKey.SPKI = Worker_Binding_CryptoKey_Which.SPKI;
				Worker_Binding_CryptoKey.JWK = Worker_Binding_CryptoKey_Which.JWK;
				Worker_Binding_CryptoKey.Usage = Worker_Binding_CryptoKey_Usage2;
				Worker_Binding_CryptoKey._capnp = {
					displayName: "CryptoKey",
					id: "b5e1bff0e57d6eb0",
					size: new capnp_ts_1.ObjectSize(8, 3),
					defaultExtractable: capnp.getBitMask(false, 0),
				};
				var Worker_Binding_MemoryCacheLimits = class extends capnp_ts_1.Struct {
					getMaxKeys() {
						return capnp_ts_1.Struct.getUint32(0, this);
					}
					setMaxKeys(value) {
						capnp_ts_1.Struct.setUint32(0, value, this);
					}
					getMaxValueSize() {
						return capnp_ts_1.Struct.getUint32(4, this);
					}
					setMaxValueSize(value) {
						capnp_ts_1.Struct.setUint32(4, value, this);
					}
					getMaxTotalValueSize() {
						return capnp_ts_1.Struct.getUint64(8, this);
					}
					setMaxTotalValueSize(value) {
						capnp_ts_1.Struct.setUint64(8, value, this);
					}
					toString() {
						return "Worker_Binding_MemoryCacheLimits_" + super.toString();
					}
				};
				exports3.Worker_Binding_MemoryCacheLimits = Worker_Binding_MemoryCacheLimits;
				Worker_Binding_MemoryCacheLimits._capnp = {
					displayName: "MemoryCacheLimits",
					id: "8d66725b0867e634",
					size: new capnp_ts_1.ObjectSize(16, 0),
				};
				var Worker_Binding_WrappedBinding = class extends capnp_ts_1.Struct {
					getModuleName() {
						return capnp_ts_1.Struct.getText(0, this);
					}
					setModuleName(value) {
						capnp_ts_1.Struct.setText(0, value, this);
					}
					getEntrypoint() {
						return capnp_ts_1.Struct.getText(
							1,
							this,
							Worker_Binding_WrappedBinding._capnp.defaultEntrypoint,
						);
					}
					setEntrypoint(value) {
						capnp_ts_1.Struct.setText(1, value, this);
					}
					adoptInnerBindings(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this));
					}
					disownInnerBindings() {
						return capnp_ts_1.Struct.disown(this.getInnerBindings());
					}
					getInnerBindings() {
						return capnp_ts_1.Struct.getList(
							2,
							Worker_Binding_WrappedBinding._InnerBindings,
							this,
						);
					}
					hasInnerBindings() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this));
					}
					initInnerBindings(length) {
						return capnp_ts_1.Struct.initList(
							2,
							Worker_Binding_WrappedBinding._InnerBindings,
							length,
							this,
						);
					}
					setInnerBindings(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this));
					}
					toString() {
						return "Worker_Binding_WrappedBinding_" + super.toString();
					}
				};
				exports3.Worker_Binding_WrappedBinding = Worker_Binding_WrappedBinding;
				Worker_Binding_WrappedBinding._capnp = {
					displayName: "WrappedBinding",
					id: "e6f066b75f0ea113",
					size: new capnp_ts_1.ObjectSize(0, 3),
					defaultEntrypoint: "default",
				};
				var Worker_Binding_Parameter = class extends capnp_ts_1.Struct {
					adoptType(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownType() {
						return capnp_ts_1.Struct.disown(this.getType());
					}
					getType() {
						return capnp_ts_1.Struct.getStruct(1, Worker_Binding_Type, this);
					}
					hasType() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initType() {
						return capnp_ts_1.Struct.initStructAt(1, Worker_Binding_Type, this);
					}
					setType(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					getOptional() {
						return capnp_ts_1.Struct.getBit(16, this);
					}
					setOptional(value) {
						capnp_ts_1.Struct.setBit(16, value, this);
					}
					toString() {
						return "Worker_Binding_Parameter_" + super.toString();
					}
				};
				exports3.Worker_Binding_Parameter = Worker_Binding_Parameter;
				Worker_Binding_Parameter._capnp = {
					displayName: "parameter",
					id: "dc57e1258d26d152",
					size: new capnp_ts_1.ObjectSize(8, 6),
				};
				var Worker_Binding_Hyperdrive = class extends capnp_ts_1.Struct {
					adoptDesignator(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownDesignator() {
						return capnp_ts_1.Struct.disown(this.getDesignator());
					}
					getDesignator() {
						return capnp_ts_1.Struct.getStruct(1, ServiceDesignator2, this);
					}
					hasDesignator() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initDesignator() {
						return capnp_ts_1.Struct.initStructAt(1, ServiceDesignator2, this);
					}
					setDesignator(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					getDatabase() {
						return capnp_ts_1.Struct.getText(2, this);
					}
					setDatabase(value) {
						capnp_ts_1.Struct.setText(2, value, this);
					}
					getUser() {
						return capnp_ts_1.Struct.getText(3, this);
					}
					setUser(value) {
						capnp_ts_1.Struct.setText(3, value, this);
					}
					getPassword() {
						return capnp_ts_1.Struct.getText(4, this);
					}
					setPassword(value) {
						capnp_ts_1.Struct.setText(4, value, this);
					}
					getScheme() {
						return capnp_ts_1.Struct.getText(5, this);
					}
					setScheme(value) {
						capnp_ts_1.Struct.setText(5, value, this);
					}
					toString() {
						return "Worker_Binding_Hyperdrive_" + super.toString();
					}
				};
				exports3.Worker_Binding_Hyperdrive = Worker_Binding_Hyperdrive;
				Worker_Binding_Hyperdrive._capnp = {
					displayName: "hyperdrive",
					id: "ad6c391cd55f3134",
					size: new capnp_ts_1.ObjectSize(8, 6),
				};
				var Worker_Binding_MemoryCache = class extends capnp_ts_1.Struct {
					getId() {
						return capnp_ts_1.Struct.getText(1, this);
					}
					setId(value) {
						capnp_ts_1.Struct.setText(1, value, this);
					}
					adoptLimits(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this));
					}
					disownLimits() {
						return capnp_ts_1.Struct.disown(this.getLimits());
					}
					getLimits() {
						return capnp_ts_1.Struct.getStruct(
							2,
							Worker_Binding_MemoryCacheLimits,
							this,
						);
					}
					hasLimits() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this));
					}
					initLimits() {
						return capnp_ts_1.Struct.initStructAt(
							2,
							Worker_Binding_MemoryCacheLimits,
							this,
						);
					}
					setLimits(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this));
					}
					toString() {
						return "Worker_Binding_MemoryCache_" + super.toString();
					}
				};
				exports3.Worker_Binding_MemoryCache = Worker_Binding_MemoryCache;
				Worker_Binding_MemoryCache._capnp = {
					displayName: "memoryCache",
					id: "aed5760c349869da",
					size: new capnp_ts_1.ObjectSize(8, 6),
				};
				var Worker_Binding_Which;
				(function (Worker_Binding_Which2) {
					Worker_Binding_Which2[(Worker_Binding_Which2["UNSPECIFIED"] = 0)] =
						"UNSPECIFIED";
					Worker_Binding_Which2[(Worker_Binding_Which2["PARAMETER"] = 1)] = "PARAMETER";
					Worker_Binding_Which2[(Worker_Binding_Which2["TEXT"] = 2)] = "TEXT";
					Worker_Binding_Which2[(Worker_Binding_Which2["DATA"] = 3)] = "DATA";
					Worker_Binding_Which2[(Worker_Binding_Which2["JSON"] = 4)] = "JSON";
					Worker_Binding_Which2[(Worker_Binding_Which2["WASM_MODULE"] = 5)] =
						"WASM_MODULE";
					Worker_Binding_Which2[(Worker_Binding_Which2["CRYPTO_KEY"] = 6)] = "CRYPTO_KEY";
					Worker_Binding_Which2[(Worker_Binding_Which2["SERVICE"] = 7)] = "SERVICE";
					Worker_Binding_Which2[(Worker_Binding_Which2["DURABLE_OBJECT_NAMESPACE"] = 8)] =
						"DURABLE_OBJECT_NAMESPACE";
					Worker_Binding_Which2[(Worker_Binding_Which2["KV_NAMESPACE"] = 9)] =
						"KV_NAMESPACE";
					Worker_Binding_Which2[(Worker_Binding_Which2["R2BUCKET"] = 10)] = "R2BUCKET";
					Worker_Binding_Which2[(Worker_Binding_Which2["R2ADMIN"] = 11)] = "R2ADMIN";
					Worker_Binding_Which2[(Worker_Binding_Which2["WRAPPED"] = 12)] = "WRAPPED";
					Worker_Binding_Which2[(Worker_Binding_Which2["QUEUE"] = 13)] = "QUEUE";
					Worker_Binding_Which2[(Worker_Binding_Which2["FROM_ENVIRONMENT"] = 14)] =
						"FROM_ENVIRONMENT";
					Worker_Binding_Which2[(Worker_Binding_Which2["ANALYTICS_ENGINE"] = 15)] =
						"ANALYTICS_ENGINE";
					Worker_Binding_Which2[(Worker_Binding_Which2["HYPERDRIVE"] = 16)] =
						"HYPERDRIVE";
					Worker_Binding_Which2[(Worker_Binding_Which2["UNSAFE_EVAL"] = 17)] =
						"UNSAFE_EVAL";
					Worker_Binding_Which2[(Worker_Binding_Which2["MEMORY_CACHE"] = 18)] =
						"MEMORY_CACHE";
				})(
					(Worker_Binding_Which =
						exports3.Worker_Binding_Which || (exports3.Worker_Binding_Which = {})),
				);
				var Worker_Binding4 = class extends capnp_ts_1.Struct {
					getName() {
						return capnp_ts_1.Struct.getText(0, this);
					}
					setName(value) {
						capnp_ts_1.Struct.setText(0, value, this);
					}
					isUnspecified() {
						return capnp_ts_1.Struct.getUint16(0, this) === 0;
					}
					setUnspecified() {
						capnp_ts_1.Struct.setUint16(0, 0, this);
					}
					getParameter() {
						capnp_ts_1.Struct.testWhich(
							"parameter",
							capnp_ts_1.Struct.getUint16(0, this),
							1,
							this,
						);
						return capnp_ts_1.Struct.getAs(Worker_Binding_Parameter, this);
					}
					initParameter() {
						capnp_ts_1.Struct.setUint16(0, 1, this);
						return capnp_ts_1.Struct.getAs(Worker_Binding_Parameter, this);
					}
					isParameter() {
						return capnp_ts_1.Struct.getUint16(0, this) === 1;
					}
					setParameter() {
						capnp_ts_1.Struct.setUint16(0, 1, this);
					}
					getText() {
						capnp_ts_1.Struct.testWhich(
							"text",
							capnp_ts_1.Struct.getUint16(0, this),
							2,
							this,
						);
						return capnp_ts_1.Struct.getText(1, this);
					}
					isText() {
						return capnp_ts_1.Struct.getUint16(0, this) === 2;
					}
					setText(value) {
						capnp_ts_1.Struct.setUint16(0, 2, this);
						capnp_ts_1.Struct.setText(1, value, this);
					}
					adoptData(value) {
						capnp_ts_1.Struct.setUint16(0, 3, this);
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownData() {
						return capnp_ts_1.Struct.disown(this.getData());
					}
					getData() {
						capnp_ts_1.Struct.testWhich(
							"data",
							capnp_ts_1.Struct.getUint16(0, this),
							3,
							this,
						);
						return capnp_ts_1.Struct.getData(1, this);
					}
					hasData() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initData(length) {
						capnp_ts_1.Struct.setUint16(0, 3, this);
						return capnp_ts_1.Struct.initData(1, length, this);
					}
					isData() {
						return capnp_ts_1.Struct.getUint16(0, this) === 3;
					}
					setData(value) {
						capnp_ts_1.Struct.setUint16(0, 3, this);
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					getJson() {
						capnp_ts_1.Struct.testWhich(
							"json",
							capnp_ts_1.Struct.getUint16(0, this),
							4,
							this,
						);
						return capnp_ts_1.Struct.getText(1, this);
					}
					isJson() {
						return capnp_ts_1.Struct.getUint16(0, this) === 4;
					}
					setJson(value) {
						capnp_ts_1.Struct.setUint16(0, 4, this);
						capnp_ts_1.Struct.setText(1, value, this);
					}
					adoptWasmModule(value) {
						capnp_ts_1.Struct.setUint16(0, 5, this);
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownWasmModule() {
						return capnp_ts_1.Struct.disown(this.getWasmModule());
					}
					getWasmModule() {
						capnp_ts_1.Struct.testWhich(
							"wasmModule",
							capnp_ts_1.Struct.getUint16(0, this),
							5,
							this,
						);
						return capnp_ts_1.Struct.getData(1, this);
					}
					hasWasmModule() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initWasmModule(length) {
						capnp_ts_1.Struct.setUint16(0, 5, this);
						return capnp_ts_1.Struct.initData(1, length, this);
					}
					isWasmModule() {
						return capnp_ts_1.Struct.getUint16(0, this) === 5;
					}
					setWasmModule(value) {
						capnp_ts_1.Struct.setUint16(0, 5, this);
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					adoptCryptoKey(value) {
						capnp_ts_1.Struct.setUint16(0, 6, this);
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownCryptoKey() {
						return capnp_ts_1.Struct.disown(this.getCryptoKey());
					}
					getCryptoKey() {
						capnp_ts_1.Struct.testWhich(
							"cryptoKey",
							capnp_ts_1.Struct.getUint16(0, this),
							6,
							this,
						);
						return capnp_ts_1.Struct.getStruct(1, Worker_Binding_CryptoKey, this);
					}
					hasCryptoKey() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initCryptoKey() {
						capnp_ts_1.Struct.setUint16(0, 6, this);
						return capnp_ts_1.Struct.initStructAt(1, Worker_Binding_CryptoKey, this);
					}
					isCryptoKey() {
						return capnp_ts_1.Struct.getUint16(0, this) === 6;
					}
					setCryptoKey(value) {
						capnp_ts_1.Struct.setUint16(0, 6, this);
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					adoptService(value) {
						capnp_ts_1.Struct.setUint16(0, 7, this);
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownService() {
						return capnp_ts_1.Struct.disown(this.getService());
					}
					getService() {
						capnp_ts_1.Struct.testWhich(
							"service",
							capnp_ts_1.Struct.getUint16(0, this),
							7,
							this,
						);
						return capnp_ts_1.Struct.getStruct(1, ServiceDesignator2, this);
					}
					hasService() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initService() {
						capnp_ts_1.Struct.setUint16(0, 7, this);
						return capnp_ts_1.Struct.initStructAt(1, ServiceDesignator2, this);
					}
					isService() {
						return capnp_ts_1.Struct.getUint16(0, this) === 7;
					}
					setService(value) {
						capnp_ts_1.Struct.setUint16(0, 7, this);
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					adoptDurableObjectNamespace(value) {
						capnp_ts_1.Struct.setUint16(0, 8, this);
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownDurableObjectNamespace() {
						return capnp_ts_1.Struct.disown(this.getDurableObjectNamespace());
					}
					getDurableObjectNamespace() {
						capnp_ts_1.Struct.testWhich(
							"durableObjectNamespace",
							capnp_ts_1.Struct.getUint16(0, this),
							8,
							this,
						);
						return capnp_ts_1.Struct.getStruct(
							1,
							Worker_Binding_DurableObjectNamespaceDesignator2,
							this,
						);
					}
					hasDurableObjectNamespace() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initDurableObjectNamespace() {
						capnp_ts_1.Struct.setUint16(0, 8, this);
						return capnp_ts_1.Struct.initStructAt(
							1,
							Worker_Binding_DurableObjectNamespaceDesignator2,
							this,
						);
					}
					isDurableObjectNamespace() {
						return capnp_ts_1.Struct.getUint16(0, this) === 8;
					}
					setDurableObjectNamespace(value) {
						capnp_ts_1.Struct.setUint16(0, 8, this);
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					adoptKvNamespace(value) {
						capnp_ts_1.Struct.setUint16(0, 9, this);
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownKvNamespace() {
						return capnp_ts_1.Struct.disown(this.getKvNamespace());
					}
					getKvNamespace() {
						capnp_ts_1.Struct.testWhich(
							"kvNamespace",
							capnp_ts_1.Struct.getUint16(0, this),
							9,
							this,
						);
						return capnp_ts_1.Struct.getStruct(1, ServiceDesignator2, this);
					}
					hasKvNamespace() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initKvNamespace() {
						capnp_ts_1.Struct.setUint16(0, 9, this);
						return capnp_ts_1.Struct.initStructAt(1, ServiceDesignator2, this);
					}
					isKvNamespace() {
						return capnp_ts_1.Struct.getUint16(0, this) === 9;
					}
					setKvNamespace(value) {
						capnp_ts_1.Struct.setUint16(0, 9, this);
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					adoptR2Bucket(value) {
						capnp_ts_1.Struct.setUint16(0, 10, this);
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownR2Bucket() {
						return capnp_ts_1.Struct.disown(this.getR2Bucket());
					}
					getR2Bucket() {
						capnp_ts_1.Struct.testWhich(
							"r2Bucket",
							capnp_ts_1.Struct.getUint16(0, this),
							10,
							this,
						);
						return capnp_ts_1.Struct.getStruct(1, ServiceDesignator2, this);
					}
					hasR2Bucket() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initR2Bucket() {
						capnp_ts_1.Struct.setUint16(0, 10, this);
						return capnp_ts_1.Struct.initStructAt(1, ServiceDesignator2, this);
					}
					isR2Bucket() {
						return capnp_ts_1.Struct.getUint16(0, this) === 10;
					}
					setR2Bucket(value) {
						capnp_ts_1.Struct.setUint16(0, 10, this);
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					adoptR2Admin(value) {
						capnp_ts_1.Struct.setUint16(0, 11, this);
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownR2Admin() {
						return capnp_ts_1.Struct.disown(this.getR2Admin());
					}
					getR2Admin() {
						capnp_ts_1.Struct.testWhich(
							"r2Admin",
							capnp_ts_1.Struct.getUint16(0, this),
							11,
							this,
						);
						return capnp_ts_1.Struct.getStruct(1, ServiceDesignator2, this);
					}
					hasR2Admin() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initR2Admin() {
						capnp_ts_1.Struct.setUint16(0, 11, this);
						return capnp_ts_1.Struct.initStructAt(1, ServiceDesignator2, this);
					}
					isR2Admin() {
						return capnp_ts_1.Struct.getUint16(0, this) === 11;
					}
					setR2Admin(value) {
						capnp_ts_1.Struct.setUint16(0, 11, this);
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					adoptWrapped(value) {
						capnp_ts_1.Struct.setUint16(0, 12, this);
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownWrapped() {
						return capnp_ts_1.Struct.disown(this.getWrapped());
					}
					getWrapped() {
						capnp_ts_1.Struct.testWhich(
							"wrapped",
							capnp_ts_1.Struct.getUint16(0, this),
							12,
							this,
						);
						return capnp_ts_1.Struct.getStruct(1, Worker_Binding_WrappedBinding, this);
					}
					hasWrapped() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initWrapped() {
						capnp_ts_1.Struct.setUint16(0, 12, this);
						return capnp_ts_1.Struct.initStructAt(
							1,
							Worker_Binding_WrappedBinding,
							this,
						);
					}
					isWrapped() {
						return capnp_ts_1.Struct.getUint16(0, this) === 12;
					}
					setWrapped(value) {
						capnp_ts_1.Struct.setUint16(0, 12, this);
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					adoptQueue(value) {
						capnp_ts_1.Struct.setUint16(0, 13, this);
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownQueue() {
						return capnp_ts_1.Struct.disown(this.getQueue());
					}
					getQueue() {
						capnp_ts_1.Struct.testWhich(
							"queue",
							capnp_ts_1.Struct.getUint16(0, this),
							13,
							this,
						);
						return capnp_ts_1.Struct.getStruct(1, ServiceDesignator2, this);
					}
					hasQueue() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initQueue() {
						capnp_ts_1.Struct.setUint16(0, 13, this);
						return capnp_ts_1.Struct.initStructAt(1, ServiceDesignator2, this);
					}
					isQueue() {
						return capnp_ts_1.Struct.getUint16(0, this) === 13;
					}
					setQueue(value) {
						capnp_ts_1.Struct.setUint16(0, 13, this);
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					getFromEnvironment() {
						capnp_ts_1.Struct.testWhich(
							"fromEnvironment",
							capnp_ts_1.Struct.getUint16(0, this),
							14,
							this,
						);
						return capnp_ts_1.Struct.getText(1, this);
					}
					isFromEnvironment() {
						return capnp_ts_1.Struct.getUint16(0, this) === 14;
					}
					setFromEnvironment(value) {
						capnp_ts_1.Struct.setUint16(0, 14, this);
						capnp_ts_1.Struct.setText(1, value, this);
					}
					adoptAnalyticsEngine(value) {
						capnp_ts_1.Struct.setUint16(0, 15, this);
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownAnalyticsEngine() {
						return capnp_ts_1.Struct.disown(this.getAnalyticsEngine());
					}
					getAnalyticsEngine() {
						capnp_ts_1.Struct.testWhich(
							"analyticsEngine",
							capnp_ts_1.Struct.getUint16(0, this),
							15,
							this,
						);
						return capnp_ts_1.Struct.getStruct(1, ServiceDesignator2, this);
					}
					hasAnalyticsEngine() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initAnalyticsEngine() {
						capnp_ts_1.Struct.setUint16(0, 15, this);
						return capnp_ts_1.Struct.initStructAt(1, ServiceDesignator2, this);
					}
					isAnalyticsEngine() {
						return capnp_ts_1.Struct.getUint16(0, this) === 15;
					}
					setAnalyticsEngine(value) {
						capnp_ts_1.Struct.setUint16(0, 15, this);
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					getHyperdrive() {
						capnp_ts_1.Struct.testWhich(
							"hyperdrive",
							capnp_ts_1.Struct.getUint16(0, this),
							16,
							this,
						);
						return capnp_ts_1.Struct.getAs(Worker_Binding_Hyperdrive, this);
					}
					initHyperdrive() {
						capnp_ts_1.Struct.setUint16(0, 16, this);
						return capnp_ts_1.Struct.getAs(Worker_Binding_Hyperdrive, this);
					}
					isHyperdrive() {
						return capnp_ts_1.Struct.getUint16(0, this) === 16;
					}
					setHyperdrive() {
						capnp_ts_1.Struct.setUint16(0, 16, this);
					}
					isUnsafeEval() {
						return capnp_ts_1.Struct.getUint16(0, this) === 17;
					}
					setUnsafeEval() {
						capnp_ts_1.Struct.setUint16(0, 17, this);
					}
					getMemoryCache() {
						capnp_ts_1.Struct.testWhich(
							"memoryCache",
							capnp_ts_1.Struct.getUint16(0, this),
							18,
							this,
						);
						return capnp_ts_1.Struct.getAs(Worker_Binding_MemoryCache, this);
					}
					initMemoryCache() {
						capnp_ts_1.Struct.setUint16(0, 18, this);
						return capnp_ts_1.Struct.getAs(Worker_Binding_MemoryCache, this);
					}
					isMemoryCache() {
						return capnp_ts_1.Struct.getUint16(0, this) === 18;
					}
					setMemoryCache() {
						capnp_ts_1.Struct.setUint16(0, 18, this);
					}
					toString() {
						return "Worker_Binding_" + super.toString();
					}
					which() {
						return capnp_ts_1.Struct.getUint16(0, this);
					}
				};
				exports3.Worker_Binding = Worker_Binding4;
				Worker_Binding4.UNSPECIFIED = Worker_Binding_Which.UNSPECIFIED;
				Worker_Binding4.PARAMETER = Worker_Binding_Which.PARAMETER;
				Worker_Binding4.TEXT = Worker_Binding_Which.TEXT;
				Worker_Binding4.DATA = Worker_Binding_Which.DATA;
				Worker_Binding4.JSON = Worker_Binding_Which.JSON;
				Worker_Binding4.WASM_MODULE = Worker_Binding_Which.WASM_MODULE;
				Worker_Binding4.CRYPTO_KEY = Worker_Binding_Which.CRYPTO_KEY;
				Worker_Binding4.SERVICE = Worker_Binding_Which.SERVICE;
				Worker_Binding4.DURABLE_OBJECT_NAMESPACE =
					Worker_Binding_Which.DURABLE_OBJECT_NAMESPACE;
				Worker_Binding4.KV_NAMESPACE = Worker_Binding_Which.KV_NAMESPACE;
				Worker_Binding4.R2BUCKET = Worker_Binding_Which.R2BUCKET;
				Worker_Binding4.R2ADMIN = Worker_Binding_Which.R2ADMIN;
				Worker_Binding4.WRAPPED = Worker_Binding_Which.WRAPPED;
				Worker_Binding4.QUEUE = Worker_Binding_Which.QUEUE;
				Worker_Binding4.FROM_ENVIRONMENT = Worker_Binding_Which.FROM_ENVIRONMENT;
				Worker_Binding4.ANALYTICS_ENGINE = Worker_Binding_Which.ANALYTICS_ENGINE;
				Worker_Binding4.HYPERDRIVE = Worker_Binding_Which.HYPERDRIVE;
				Worker_Binding4.UNSAFE_EVAL = Worker_Binding_Which.UNSAFE_EVAL;
				Worker_Binding4.MEMORY_CACHE = Worker_Binding_Which.MEMORY_CACHE;
				Worker_Binding4.Type = Worker_Binding_Type;
				Worker_Binding4.DurableObjectNamespaceDesignator =
					Worker_Binding_DurableObjectNamespaceDesignator2;
				Worker_Binding4.CryptoKey = Worker_Binding_CryptoKey;
				Worker_Binding4.MemoryCacheLimits = Worker_Binding_MemoryCacheLimits;
				Worker_Binding4.WrappedBinding = Worker_Binding_WrappedBinding;
				Worker_Binding4._capnp = {
					displayName: "Binding",
					id: "8e7e492fd7e35f3e",
					size: new capnp_ts_1.ObjectSize(8, 6),
				};
				var Worker_DurableObjectNamespace_Which;
				(function (Worker_DurableObjectNamespace_Which2) {
					Worker_DurableObjectNamespace_Which2[
						(Worker_DurableObjectNamespace_Which2["UNIQUE_KEY"] = 0)
					] = "UNIQUE_KEY";
					Worker_DurableObjectNamespace_Which2[
						(Worker_DurableObjectNamespace_Which2["EPHEMERAL_LOCAL"] = 1)
					] = "EPHEMERAL_LOCAL";
				})(
					(Worker_DurableObjectNamespace_Which =
						exports3.Worker_DurableObjectNamespace_Which ||
						(exports3.Worker_DurableObjectNamespace_Which = {})),
				);
				var Worker_DurableObjectNamespace2 = class extends capnp_ts_1.Struct {
					getClassName() {
						return capnp_ts_1.Struct.getText(0, this);
					}
					setClassName(value) {
						capnp_ts_1.Struct.setText(0, value, this);
					}
					getUniqueKey() {
						capnp_ts_1.Struct.testWhich(
							"uniqueKey",
							capnp_ts_1.Struct.getUint16(0, this),
							0,
							this,
						);
						return capnp_ts_1.Struct.getText(1, this);
					}
					isUniqueKey() {
						return capnp_ts_1.Struct.getUint16(0, this) === 0;
					}
					setUniqueKey(value) {
						capnp_ts_1.Struct.setUint16(0, 0, this);
						capnp_ts_1.Struct.setText(1, value, this);
					}
					isEphemeralLocal() {
						return capnp_ts_1.Struct.getUint16(0, this) === 1;
					}
					setEphemeralLocal() {
						capnp_ts_1.Struct.setUint16(0, 1, this);
					}
					getPreventEviction() {
						return capnp_ts_1.Struct.getBit(16, this);
					}
					setPreventEviction(value) {
						capnp_ts_1.Struct.setBit(16, value, this);
					}
					getEnableSql() {
						return capnp_ts_1.Struct.getBit(17, this);
					}
					setEnableSql(value) {
						capnp_ts_1.Struct.setBit(17, value, this);
					}
					toString() {
						return "Worker_DurableObjectNamespace_" + super.toString();
					}
					which() {
						return capnp_ts_1.Struct.getUint16(0, this);
					}
				};
				exports3.Worker_DurableObjectNamespace = Worker_DurableObjectNamespace2;
				Worker_DurableObjectNamespace2.UNIQUE_KEY =
					Worker_DurableObjectNamespace_Which.UNIQUE_KEY;
				Worker_DurableObjectNamespace2.EPHEMERAL_LOCAL =
					Worker_DurableObjectNamespace_Which.EPHEMERAL_LOCAL;
				Worker_DurableObjectNamespace2._capnp = {
					displayName: "DurableObjectNamespace",
					id: "b429dd547d15747d",
					size: new capnp_ts_1.ObjectSize(8, 2),
				};
				var Worker_DurableObjectStorage_Which;
				(function (Worker_DurableObjectStorage_Which2) {
					Worker_DurableObjectStorage_Which2[
						(Worker_DurableObjectStorage_Which2["NONE"] = 0)
					] = "NONE";
					Worker_DurableObjectStorage_Which2[
						(Worker_DurableObjectStorage_Which2["IN_MEMORY"] = 1)
					] = "IN_MEMORY";
					Worker_DurableObjectStorage_Which2[
						(Worker_DurableObjectStorage_Which2["LOCAL_DISK"] = 2)
					] = "LOCAL_DISK";
				})(
					(Worker_DurableObjectStorage_Which =
						exports3.Worker_DurableObjectStorage_Which ||
						(exports3.Worker_DurableObjectStorage_Which = {})),
				);
				var Worker_DurableObjectStorage = class extends capnp_ts_1.Struct {
					isNone() {
						return capnp_ts_1.Struct.getUint16(2, this) === 0;
					}
					setNone() {
						capnp_ts_1.Struct.setUint16(2, 0, this);
					}
					isInMemory() {
						return capnp_ts_1.Struct.getUint16(2, this) === 1;
					}
					setInMemory() {
						capnp_ts_1.Struct.setUint16(2, 1, this);
					}
					getLocalDisk() {
						capnp_ts_1.Struct.testWhich(
							"localDisk",
							capnp_ts_1.Struct.getUint16(2, this),
							2,
							this,
						);
						return capnp_ts_1.Struct.getText(8, this);
					}
					isLocalDisk() {
						return capnp_ts_1.Struct.getUint16(2, this) === 2;
					}
					setLocalDisk(value) {
						capnp_ts_1.Struct.setUint16(2, 2, this);
						capnp_ts_1.Struct.setText(8, value, this);
					}
					toString() {
						return "Worker_DurableObjectStorage_" + super.toString();
					}
					which() {
						return capnp_ts_1.Struct.getUint16(2, this);
					}
				};
				exports3.Worker_DurableObjectStorage = Worker_DurableObjectStorage;
				Worker_DurableObjectStorage.NONE = Worker_DurableObjectStorage_Which.NONE;
				Worker_DurableObjectStorage.IN_MEMORY = Worker_DurableObjectStorage_Which.IN_MEMORY;
				Worker_DurableObjectStorage.LOCAL_DISK =
					Worker_DurableObjectStorage_Which.LOCAL_DISK;
				Worker_DurableObjectStorage._capnp = {
					displayName: "durableObjectStorage",
					id: "cc72b3faa57827d4",
					size: new capnp_ts_1.ObjectSize(8, 10),
				};
				var Worker_Which;
				(function (Worker_Which2) {
					Worker_Which2[(Worker_Which2["MODULES"] = 0)] = "MODULES";
					Worker_Which2[(Worker_Which2["SERVICE_WORKER_SCRIPT"] = 1)] =
						"SERVICE_WORKER_SCRIPT";
					Worker_Which2[(Worker_Which2["INHERIT"] = 2)] = "INHERIT";
				})((Worker_Which = exports3.Worker_Which || (exports3.Worker_Which = {})));
				var Worker2 = class extends capnp_ts_1.Struct {
					adoptModules(value) {
						capnp_ts_1.Struct.setUint16(0, 0, this);
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this));
					}
					disownModules() {
						return capnp_ts_1.Struct.disown(this.getModules());
					}
					getModules() {
						capnp_ts_1.Struct.testWhich(
							"modules",
							capnp_ts_1.Struct.getUint16(0, this),
							0,
							this,
						);
						return capnp_ts_1.Struct.getList(0, Worker2._Modules, this);
					}
					hasModules() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this));
					}
					initModules(length) {
						capnp_ts_1.Struct.setUint16(0, 0, this);
						return capnp_ts_1.Struct.initList(0, Worker2._Modules, length, this);
					}
					isModules() {
						return capnp_ts_1.Struct.getUint16(0, this) === 0;
					}
					setModules(value) {
						capnp_ts_1.Struct.setUint16(0, 0, this);
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this));
					}
					getServiceWorkerScript() {
						capnp_ts_1.Struct.testWhich(
							"serviceWorkerScript",
							capnp_ts_1.Struct.getUint16(0, this),
							1,
							this,
						);
						return capnp_ts_1.Struct.getText(0, this);
					}
					isServiceWorkerScript() {
						return capnp_ts_1.Struct.getUint16(0, this) === 1;
					}
					setServiceWorkerScript(value) {
						capnp_ts_1.Struct.setUint16(0, 1, this);
						capnp_ts_1.Struct.setText(0, value, this);
					}
					getInherit() {
						capnp_ts_1.Struct.testWhich(
							"inherit",
							capnp_ts_1.Struct.getUint16(0, this),
							2,
							this,
						);
						return capnp_ts_1.Struct.getText(0, this);
					}
					isInherit() {
						return capnp_ts_1.Struct.getUint16(0, this) === 2;
					}
					setInherit(value) {
						capnp_ts_1.Struct.setUint16(0, 2, this);
						capnp_ts_1.Struct.setText(0, value, this);
					}
					getCompatibilityDate() {
						return capnp_ts_1.Struct.getText(1, this);
					}
					setCompatibilityDate(value) {
						capnp_ts_1.Struct.setText(1, value, this);
					}
					adoptCompatibilityFlags(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this));
					}
					disownCompatibilityFlags() {
						return capnp_ts_1.Struct.disown(this.getCompatibilityFlags());
					}
					getCompatibilityFlags() {
						return capnp_ts_1.Struct.getList(2, capnp.TextList, this);
					}
					hasCompatibilityFlags() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this));
					}
					initCompatibilityFlags(length) {
						return capnp_ts_1.Struct.initList(2, capnp.TextList, length, this);
					}
					setCompatibilityFlags(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this));
					}
					adoptBindings(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(3, this));
					}
					disownBindings() {
						return capnp_ts_1.Struct.disown(this.getBindings());
					}
					getBindings() {
						return capnp_ts_1.Struct.getList(3, Worker2._Bindings, this);
					}
					hasBindings() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(3, this));
					}
					initBindings(length) {
						return capnp_ts_1.Struct.initList(3, Worker2._Bindings, length, this);
					}
					setBindings(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(3, this));
					}
					adoptGlobalOutbound(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(4, this));
					}
					disownGlobalOutbound() {
						return capnp_ts_1.Struct.disown(this.getGlobalOutbound());
					}
					getGlobalOutbound() {
						return capnp_ts_1.Struct.getStruct(
							4,
							ServiceDesignator2,
							this,
							Worker2._capnp.defaultGlobalOutbound,
						);
					}
					hasGlobalOutbound() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(4, this));
					}
					initGlobalOutbound() {
						return capnp_ts_1.Struct.initStructAt(4, ServiceDesignator2, this);
					}
					setGlobalOutbound(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(4, this));
					}
					adoptCacheApiOutbound(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(7, this));
					}
					disownCacheApiOutbound() {
						return capnp_ts_1.Struct.disown(this.getCacheApiOutbound());
					}
					getCacheApiOutbound() {
						return capnp_ts_1.Struct.getStruct(7, ServiceDesignator2, this);
					}
					hasCacheApiOutbound() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(7, this));
					}
					initCacheApiOutbound() {
						return capnp_ts_1.Struct.initStructAt(7, ServiceDesignator2, this);
					}
					setCacheApiOutbound(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(7, this));
					}
					adoptDurableObjectNamespaces(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(5, this));
					}
					disownDurableObjectNamespaces() {
						return capnp_ts_1.Struct.disown(this.getDurableObjectNamespaces());
					}
					getDurableObjectNamespaces() {
						return capnp_ts_1.Struct.getList(5, Worker2._DurableObjectNamespaces, this);
					}
					hasDurableObjectNamespaces() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(5, this));
					}
					initDurableObjectNamespaces(length) {
						return capnp_ts_1.Struct.initList(
							5,
							Worker2._DurableObjectNamespaces,
							length,
							this,
						);
					}
					setDurableObjectNamespaces(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(5, this));
					}
					getDurableObjectUniqueKeyModifier() {
						return capnp_ts_1.Struct.getText(6, this);
					}
					setDurableObjectUniqueKeyModifier(value) {
						capnp_ts_1.Struct.setText(6, value, this);
					}
					getDurableObjectStorage() {
						return capnp_ts_1.Struct.getAs(Worker_DurableObjectStorage, this);
					}
					initDurableObjectStorage() {
						return capnp_ts_1.Struct.getAs(Worker_DurableObjectStorage, this);
					}
					getModuleFallback() {
						return capnp_ts_1.Struct.getText(9, this);
					}
					setModuleFallback(value) {
						capnp_ts_1.Struct.setText(9, value, this);
					}
					toString() {
						return "Worker_" + super.toString();
					}
					which() {
						return capnp_ts_1.Struct.getUint16(0, this);
					}
				};
				exports3.Worker = Worker2;
				Worker2.MODULES = Worker_Which.MODULES;
				Worker2.SERVICE_WORKER_SCRIPT = Worker_Which.SERVICE_WORKER_SCRIPT;
				Worker2.INHERIT = Worker_Which.INHERIT;
				Worker2.Module = Worker_Module3;
				Worker2.Binding = Worker_Binding4;
				Worker2.DurableObjectNamespace = Worker_DurableObjectNamespace2;
				Worker2._capnp = {
					displayName: "Worker",
					id: "acfa77e88fd97d1c",
					size: new capnp_ts_1.ObjectSize(8, 10),
					defaultGlobalOutbound: capnp.readRawPointer(
						new Uint8Array([
							16, 5, 64, 2, 17, 5, 74, 0, 0, 255, 105, 110, 116, 101, 114, 110, 101,
							116, 0, 0, 0,
						]).buffer,
					),
				};
				var ExternalServer_Https = class extends capnp_ts_1.Struct {
					adoptOptions(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownOptions() {
						return capnp_ts_1.Struct.disown(this.getOptions());
					}
					getOptions() {
						return capnp_ts_1.Struct.getStruct(1, HttpOptions, this);
					}
					hasOptions() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initOptions() {
						return capnp_ts_1.Struct.initStructAt(1, HttpOptions, this);
					}
					setOptions(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					adoptTlsOptions(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this));
					}
					disownTlsOptions() {
						return capnp_ts_1.Struct.disown(this.getTlsOptions());
					}
					getTlsOptions() {
						return capnp_ts_1.Struct.getStruct(2, TlsOptions, this);
					}
					hasTlsOptions() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this));
					}
					initTlsOptions() {
						return capnp_ts_1.Struct.initStructAt(2, TlsOptions, this);
					}
					setTlsOptions(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this));
					}
					getCertificateHost() {
						return capnp_ts_1.Struct.getText(3, this);
					}
					setCertificateHost(value) {
						capnp_ts_1.Struct.setText(3, value, this);
					}
					toString() {
						return "ExternalServer_Https_" + super.toString();
					}
				};
				exports3.ExternalServer_Https = ExternalServer_Https;
				ExternalServer_Https._capnp = {
					displayName: "https",
					id: "ac37e02afd3dc6db",
					size: new capnp_ts_1.ObjectSize(8, 4),
				};
				var ExternalServer_Tcp = class extends capnp_ts_1.Struct {
					adoptTlsOptions(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownTlsOptions() {
						return capnp_ts_1.Struct.disown(this.getTlsOptions());
					}
					getTlsOptions() {
						return capnp_ts_1.Struct.getStruct(1, TlsOptions, this);
					}
					hasTlsOptions() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initTlsOptions() {
						return capnp_ts_1.Struct.initStructAt(1, TlsOptions, this);
					}
					setTlsOptions(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					getCertificateHost() {
						return capnp_ts_1.Struct.getText(2, this);
					}
					setCertificateHost(value) {
						capnp_ts_1.Struct.setText(2, value, this);
					}
					toString() {
						return "ExternalServer_Tcp_" + super.toString();
					}
				};
				exports3.ExternalServer_Tcp = ExternalServer_Tcp;
				ExternalServer_Tcp._capnp = {
					displayName: "tcp",
					id: "d941637df0fb39f1",
					size: new capnp_ts_1.ObjectSize(8, 4),
				};
				var ExternalServer_Which;
				(function (ExternalServer_Which2) {
					ExternalServer_Which2[(ExternalServer_Which2["HTTP"] = 0)] = "HTTP";
					ExternalServer_Which2[(ExternalServer_Which2["HTTPS"] = 1)] = "HTTPS";
					ExternalServer_Which2[(ExternalServer_Which2["TCP"] = 2)] = "TCP";
				})(
					(ExternalServer_Which =
						exports3.ExternalServer_Which || (exports3.ExternalServer_Which = {})),
				);
				var ExternalServer2 = class extends capnp_ts_1.Struct {
					getAddress() {
						return capnp_ts_1.Struct.getText(0, this);
					}
					setAddress(value) {
						capnp_ts_1.Struct.setText(0, value, this);
					}
					adoptHttp(value) {
						capnp_ts_1.Struct.setUint16(0, 0, this);
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownHttp() {
						return capnp_ts_1.Struct.disown(this.getHttp());
					}
					getHttp() {
						capnp_ts_1.Struct.testWhich(
							"http",
							capnp_ts_1.Struct.getUint16(0, this),
							0,
							this,
						);
						return capnp_ts_1.Struct.getStruct(1, HttpOptions, this);
					}
					hasHttp() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initHttp() {
						capnp_ts_1.Struct.setUint16(0, 0, this);
						return capnp_ts_1.Struct.initStructAt(1, HttpOptions, this);
					}
					isHttp() {
						return capnp_ts_1.Struct.getUint16(0, this) === 0;
					}
					setHttp(value) {
						capnp_ts_1.Struct.setUint16(0, 0, this);
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					getHttps() {
						capnp_ts_1.Struct.testWhich(
							"https",
							capnp_ts_1.Struct.getUint16(0, this),
							1,
							this,
						);
						return capnp_ts_1.Struct.getAs(ExternalServer_Https, this);
					}
					initHttps() {
						capnp_ts_1.Struct.setUint16(0, 1, this);
						return capnp_ts_1.Struct.getAs(ExternalServer_Https, this);
					}
					isHttps() {
						return capnp_ts_1.Struct.getUint16(0, this) === 1;
					}
					setHttps() {
						capnp_ts_1.Struct.setUint16(0, 1, this);
					}
					getTcp() {
						capnp_ts_1.Struct.testWhich(
							"tcp",
							capnp_ts_1.Struct.getUint16(0, this),
							2,
							this,
						);
						return capnp_ts_1.Struct.getAs(ExternalServer_Tcp, this);
					}
					initTcp() {
						capnp_ts_1.Struct.setUint16(0, 2, this);
						return capnp_ts_1.Struct.getAs(ExternalServer_Tcp, this);
					}
					isTcp() {
						return capnp_ts_1.Struct.getUint16(0, this) === 2;
					}
					setTcp() {
						capnp_ts_1.Struct.setUint16(0, 2, this);
					}
					toString() {
						return "ExternalServer_" + super.toString();
					}
					which() {
						return capnp_ts_1.Struct.getUint16(0, this);
					}
				};
				exports3.ExternalServer = ExternalServer2;
				ExternalServer2.HTTP = ExternalServer_Which.HTTP;
				ExternalServer2.HTTPS = ExternalServer_Which.HTTPS;
				ExternalServer2.TCP = ExternalServer_Which.TCP;
				ExternalServer2._capnp = {
					displayName: "ExternalServer",
					id: "ff209f9aa352f5a4",
					size: new capnp_ts_1.ObjectSize(8, 4),
				};
				var Network = class extends capnp_ts_1.Struct {
					adoptAllow(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this));
					}
					disownAllow() {
						return capnp_ts_1.Struct.disown(this.getAllow());
					}
					getAllow() {
						return capnp_ts_1.Struct.getList(
							0,
							capnp.TextList,
							this,
							Network._capnp.defaultAllow,
						);
					}
					hasAllow() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this));
					}
					initAllow(length) {
						return capnp_ts_1.Struct.initList(0, capnp.TextList, length, this);
					}
					setAllow(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this));
					}
					adoptDeny(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownDeny() {
						return capnp_ts_1.Struct.disown(this.getDeny());
					}
					getDeny() {
						return capnp_ts_1.Struct.getList(1, capnp.TextList, this);
					}
					hasDeny() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initDeny(length) {
						return capnp_ts_1.Struct.initList(1, capnp.TextList, length, this);
					}
					setDeny(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					adoptTlsOptions(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this));
					}
					disownTlsOptions() {
						return capnp_ts_1.Struct.disown(this.getTlsOptions());
					}
					getTlsOptions() {
						return capnp_ts_1.Struct.getStruct(2, TlsOptions, this);
					}
					hasTlsOptions() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this));
					}
					initTlsOptions() {
						return capnp_ts_1.Struct.initStructAt(2, TlsOptions, this);
					}
					setTlsOptions(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this));
					}
					toString() {
						return "Network_" + super.toString();
					}
				};
				exports3.Network = Network;
				Network._capnp = {
					displayName: "Network",
					id: "fa42244f950c9b9c",
					size: new capnp_ts_1.ObjectSize(0, 3),
					defaultAllow: capnp.readRawPointer(
						new Uint8Array([
							16, 3, 17, 1, 14, 17, 1, 58, 63, 112, 117, 98, 108, 105, 99,
						]).buffer,
					),
				};
				var DiskDirectory = class extends capnp_ts_1.Struct {
					getPath() {
						return capnp_ts_1.Struct.getText(0, this);
					}
					setPath(value) {
						capnp_ts_1.Struct.setText(0, value, this);
					}
					getWritable() {
						return capnp_ts_1.Struct.getBit(
							0,
							this,
							DiskDirectory._capnp.defaultWritable,
						);
					}
					setWritable(value) {
						capnp_ts_1.Struct.setBit(0, value, this);
					}
					getAllowDotfiles() {
						return capnp_ts_1.Struct.getBit(
							1,
							this,
							DiskDirectory._capnp.defaultAllowDotfiles,
						);
					}
					setAllowDotfiles(value) {
						capnp_ts_1.Struct.setBit(1, value, this);
					}
					toString() {
						return "DiskDirectory_" + super.toString();
					}
				};
				exports3.DiskDirectory = DiskDirectory;
				DiskDirectory._capnp = {
					displayName: "DiskDirectory",
					id: "9048ab22835f51c3",
					size: new capnp_ts_1.ObjectSize(8, 1),
					defaultWritable: capnp.getBitMask(false, 0),
					defaultAllowDotfiles: capnp.getBitMask(false, 1),
				};
				var HttpOptions_Style2;
				(function (HttpOptions_Style3) {
					HttpOptions_Style3[(HttpOptions_Style3["HOST"] = 0)] = "HOST";
					HttpOptions_Style3[(HttpOptions_Style3["PROXY"] = 1)] = "PROXY";
				})(
					(HttpOptions_Style2 =
						exports3.HttpOptions_Style || (exports3.HttpOptions_Style = {})),
				);
				var HttpOptions_Header = class extends capnp_ts_1.Struct {
					getName() {
						return capnp_ts_1.Struct.getText(0, this);
					}
					setName(value) {
						capnp_ts_1.Struct.setText(0, value, this);
					}
					getValue() {
						return capnp_ts_1.Struct.getText(1, this);
					}
					setValue(value) {
						capnp_ts_1.Struct.setText(1, value, this);
					}
					toString() {
						return "HttpOptions_Header_" + super.toString();
					}
				};
				exports3.HttpOptions_Header = HttpOptions_Header;
				HttpOptions_Header._capnp = {
					displayName: "Header",
					id: "dc0394b5a6f3417e",
					size: new capnp_ts_1.ObjectSize(0, 2),
				};
				var HttpOptions = class extends capnp_ts_1.Struct {
					getStyle() {
						return capnp_ts_1.Struct.getUint16(
							0,
							this,
							HttpOptions._capnp.defaultStyle,
						);
					}
					setStyle(value) {
						capnp_ts_1.Struct.setUint16(0, value, this);
					}
					getForwardedProtoHeader() {
						return capnp_ts_1.Struct.getText(0, this);
					}
					setForwardedProtoHeader(value) {
						capnp_ts_1.Struct.setText(0, value, this);
					}
					getCfBlobHeader() {
						return capnp_ts_1.Struct.getText(1, this);
					}
					setCfBlobHeader(value) {
						capnp_ts_1.Struct.setText(1, value, this);
					}
					adoptInjectRequestHeaders(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this));
					}
					disownInjectRequestHeaders() {
						return capnp_ts_1.Struct.disown(this.getInjectRequestHeaders());
					}
					getInjectRequestHeaders() {
						return capnp_ts_1.Struct.getList(
							2,
							HttpOptions._InjectRequestHeaders,
							this,
						);
					}
					hasInjectRequestHeaders() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this));
					}
					initInjectRequestHeaders(length) {
						return capnp_ts_1.Struct.initList(
							2,
							HttpOptions._InjectRequestHeaders,
							length,
							this,
						);
					}
					setInjectRequestHeaders(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this));
					}
					adoptInjectResponseHeaders(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(3, this));
					}
					disownInjectResponseHeaders() {
						return capnp_ts_1.Struct.disown(this.getInjectResponseHeaders());
					}
					getInjectResponseHeaders() {
						return capnp_ts_1.Struct.getList(
							3,
							HttpOptions._InjectResponseHeaders,
							this,
						);
					}
					hasInjectResponseHeaders() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(3, this));
					}
					initInjectResponseHeaders(length) {
						return capnp_ts_1.Struct.initList(
							3,
							HttpOptions._InjectResponseHeaders,
							length,
							this,
						);
					}
					setInjectResponseHeaders(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(3, this));
					}
					getCapnpConnectHost() {
						return capnp_ts_1.Struct.getText(4, this);
					}
					setCapnpConnectHost(value) {
						capnp_ts_1.Struct.setText(4, value, this);
					}
					toString() {
						return "HttpOptions_" + super.toString();
					}
				};
				exports3.HttpOptions = HttpOptions;
				HttpOptions.Style = HttpOptions_Style2;
				HttpOptions.Header = HttpOptions_Header;
				HttpOptions._capnp = {
					displayName: "HttpOptions",
					id: "aa8dc6885da78f19",
					size: new capnp_ts_1.ObjectSize(8, 5),
					defaultStyle: capnp.getUint16Mask(0),
				};
				var TlsOptions_Keypair = class extends capnp_ts_1.Struct {
					getPrivateKey() {
						return capnp_ts_1.Struct.getText(0, this);
					}
					setPrivateKey(value) {
						capnp_ts_1.Struct.setText(0, value, this);
					}
					getCertificateChain() {
						return capnp_ts_1.Struct.getText(1, this);
					}
					setCertificateChain(value) {
						capnp_ts_1.Struct.setText(1, value, this);
					}
					toString() {
						return "TlsOptions_Keypair_" + super.toString();
					}
				};
				exports3.TlsOptions_Keypair = TlsOptions_Keypair;
				TlsOptions_Keypair._capnp = {
					displayName: "Keypair",
					id: "f546bf2d5d8bd13e",
					size: new capnp_ts_1.ObjectSize(0, 2),
				};
				var TlsOptions_Version2;
				(function (TlsOptions_Version3) {
					TlsOptions_Version3[(TlsOptions_Version3["GOOD_DEFAULT"] = 0)] = "GOOD_DEFAULT";
					TlsOptions_Version3[(TlsOptions_Version3["SSL3"] = 1)] = "SSL3";
					TlsOptions_Version3[(TlsOptions_Version3["TLS1DOT0"] = 2)] = "TLS1DOT0";
					TlsOptions_Version3[(TlsOptions_Version3["TLS1DOT1"] = 3)] = "TLS1DOT1";
					TlsOptions_Version3[(TlsOptions_Version3["TLS1DOT2"] = 4)] = "TLS1DOT2";
					TlsOptions_Version3[(TlsOptions_Version3["TLS1DOT3"] = 5)] = "TLS1DOT3";
				})(
					(TlsOptions_Version2 =
						exports3.TlsOptions_Version || (exports3.TlsOptions_Version = {})),
				);
				var TlsOptions = class extends capnp_ts_1.Struct {
					adoptKeypair(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this));
					}
					disownKeypair() {
						return capnp_ts_1.Struct.disown(this.getKeypair());
					}
					getKeypair() {
						return capnp_ts_1.Struct.getStruct(0, TlsOptions_Keypair, this);
					}
					hasKeypair() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this));
					}
					initKeypair() {
						return capnp_ts_1.Struct.initStructAt(0, TlsOptions_Keypair, this);
					}
					setKeypair(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this));
					}
					getRequireClientCerts() {
						return capnp_ts_1.Struct.getBit(
							0,
							this,
							TlsOptions._capnp.defaultRequireClientCerts,
						);
					}
					setRequireClientCerts(value) {
						capnp_ts_1.Struct.setBit(0, value, this);
					}
					getTrustBrowserCas() {
						return capnp_ts_1.Struct.getBit(
							1,
							this,
							TlsOptions._capnp.defaultTrustBrowserCas,
						);
					}
					setTrustBrowserCas(value) {
						capnp_ts_1.Struct.setBit(1, value, this);
					}
					adoptTrustedCertificates(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					disownTrustedCertificates() {
						return capnp_ts_1.Struct.disown(this.getTrustedCertificates());
					}
					getTrustedCertificates() {
						return capnp_ts_1.Struct.getList(1, capnp.TextList, this);
					}
					hasTrustedCertificates() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this));
					}
					initTrustedCertificates(length) {
						return capnp_ts_1.Struct.initList(1, capnp.TextList, length, this);
					}
					setTrustedCertificates(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
					}
					getMinVersion() {
						return capnp_ts_1.Struct.getUint16(
							2,
							this,
							TlsOptions._capnp.defaultMinVersion,
						);
					}
					setMinVersion(value) {
						capnp_ts_1.Struct.setUint16(2, value, this);
					}
					getCipherList() {
						return capnp_ts_1.Struct.getText(2, this);
					}
					setCipherList(value) {
						capnp_ts_1.Struct.setText(2, value, this);
					}
					toString() {
						return "TlsOptions_" + super.toString();
					}
				};
				exports3.TlsOptions = TlsOptions;
				TlsOptions.Keypair = TlsOptions_Keypair;
				TlsOptions.Version = TlsOptions_Version2;
				TlsOptions._capnp = {
					displayName: "TlsOptions",
					id: "aabb3c3778ac4311",
					size: new capnp_ts_1.ObjectSize(8, 3),
					defaultRequireClientCerts: capnp.getBitMask(false, 0),
					defaultTrustBrowserCas: capnp.getBitMask(false, 1),
					defaultMinVersion: capnp.getUint16Mask(0),
				};
				var Extension_Module = class extends capnp_ts_1.Struct {
					getName() {
						return capnp_ts_1.Struct.getText(0, this);
					}
					setName(value) {
						capnp_ts_1.Struct.setText(0, value, this);
					}
					getInternal() {
						return capnp_ts_1.Struct.getBit(
							0,
							this,
							Extension_Module._capnp.defaultInternal,
						);
					}
					setInternal(value) {
						capnp_ts_1.Struct.setBit(0, value, this);
					}
					getEsModule() {
						return capnp_ts_1.Struct.getText(1, this);
					}
					setEsModule(value) {
						capnp_ts_1.Struct.setText(1, value, this);
					}
					toString() {
						return "Extension_Module_" + super.toString();
					}
				};
				exports3.Extension_Module = Extension_Module;
				Extension_Module._capnp = {
					displayName: "Module",
					id: "d5d16e76fdedc37d",
					size: new capnp_ts_1.ObjectSize(8, 2),
					defaultInternal: capnp.getBitMask(false, 0),
				};
				var Extension3 = class extends capnp_ts_1.Struct {
					adoptModules(value) {
						capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this));
					}
					disownModules() {
						return capnp_ts_1.Struct.disown(this.getModules());
					}
					getModules() {
						return capnp_ts_1.Struct.getList(0, Extension3._Modules, this);
					}
					hasModules() {
						return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this));
					}
					initModules(length) {
						return capnp_ts_1.Struct.initList(0, Extension3._Modules, length, this);
					}
					setModules(value) {
						capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this));
					}
					toString() {
						return "Extension_" + super.toString();
					}
				};
				exports3.Extension = Extension3;
				Extension3.Module = Extension_Module;
				Extension3._capnp = {
					displayName: "Extension",
					id: "e390128a861973a6",
					size: new capnp_ts_1.ObjectSize(0, 1),
				};
				Config3._Services = capnp.CompositeList(Service4);
				Config3._Sockets = capnp.CompositeList(Socket2);
				Config3._Extensions = capnp.CompositeList(Extension3);
				Worker_Binding_WrappedBinding._InnerBindings = capnp.CompositeList(Worker_Binding4);
				Worker2._Modules = capnp.CompositeList(Worker_Module3);
				Worker2._Bindings = capnp.CompositeList(Worker_Binding4);
				Worker2._DurableObjectNamespaces = capnp.CompositeList(
					Worker_DurableObjectNamespace2,
				);
				HttpOptions._InjectRequestHeaders = capnp.CompositeList(HttpOptions_Header);
				HttpOptions._InjectResponseHeaders = capnp.CompositeList(HttpOptions_Header);
				Extension3._Modules = capnp.CompositeList(Extension_Module);
			},
		});
		var src_exports = {};
		__export2(src_exports, {
			ASSETS_PLUGIN: () => ASSETS_PLUGIN,
			AssetsOptionsSchema: () => AssetsOptionsSchema,
			CACHE_PLUGIN: () => CACHE_PLUGIN,
			CACHE_PLUGIN_NAME: () => CACHE_PLUGIN_NAME,
			CORE_PLUGIN: () => CORE_PLUGIN,
			CORE_PLUGIN_NAME: () => CORE_PLUGIN_NAME2,
			CacheBindings: () => CacheBindings,
			CacheHeaders: () => CacheHeaders,
			CacheOptionsSchema: () => CacheOptionsSchema,
			CacheSharedOptionsSchema: () => CacheSharedOptionsSchema,
			CloseEvent: () => CloseEvent,
			CoreBindings: () => CoreBindings,
			CoreHeaders: () => CoreHeaders,
			CoreOptionsSchema: () => CoreOptionsSchema,
			CoreSharedOptionsSchema: () => CoreSharedOptionsSchema,
			D1OptionsSchema: () => D1OptionsSchema,
			D1SharedOptionsSchema: () => D1SharedOptionsSchema,
			D1_PLUGIN: () => D1_PLUGIN,
			D1_PLUGIN_NAME: () => D1_PLUGIN_NAME,
			DEFAULT_PERSIST_ROOT: () => DEFAULT_PERSIST_ROOT,
			DURABLE_OBJECTS_PLUGIN: () => DURABLE_OBJECTS_PLUGIN,
			DURABLE_OBJECTS_PLUGIN_NAME: () => DURABLE_OBJECTS_PLUGIN_NAME,
			DURABLE_OBJECTS_STORAGE_SERVICE_NAME: () => DURABLE_OBJECTS_STORAGE_SERVICE_NAME,
			DeferredPromise: () => DeferredPromise,
			DispatchFetchDispatcher: () => DispatchFetchDispatcher,
			DurableObjectsOptionsSchema: () => DurableObjectsOptionsSchema,
			DurableObjectsSharedOptionsSchema: () => DurableObjectsSharedOptionsSchema,
			ENTRY_SOCKET_HTTP_OPTIONS: () => ENTRY_SOCKET_HTTP_OPTIONS,
			ErrorEvent: () => ErrorEvent,
			File: () => import_undici4.File,
			FormData: () => import_undici4.FormData,
			HOST_CAPNP_CONNECT: () => HOST_CAPNP_CONNECT,
			HYPERDRIVE_PLUGIN: () => HYPERDRIVE_PLUGIN,
			HYPERDRIVE_PLUGIN_NAME: () => HYPERDRIVE_PLUGIN_NAME,
			Headers: () => import_undici4.Headers,
			HttpOptions_Style: () => import_workerd_capnp.HttpOptions_Style,
			HyperdriveInputOptionsSchema: () => HyperdriveInputOptionsSchema,
			HyperdriveSchema: () => HyperdriveSchema,
			JsonSchema: () => JsonSchema,
			KVHeaders: () => KVHeaders,
			KVLimits: () => KVLimits,
			KVOptionsSchema: () => KVOptionsSchema,
			KVParams: () => KVParams,
			KVSharedOptionsSchema: () => KVSharedOptionsSchema,
			KV_PLUGIN: () => KV_PLUGIN,
			KV_PLUGIN_NAME: () => KV_PLUGIN_NAME,
			LiteralSchema: () => LiteralSchema,
			Log: () => Log,
			LogLevel: () => LogLevel,
			MessageEvent: () => MessageEvent,
			Miniflare: () => Miniflare22,
			MiniflareCoreError: () => MiniflareCoreError,
			MiniflareError: () => MiniflareError,
			ModuleDefinitionSchema: () => ModuleDefinitionSchema,
			ModuleRuleSchema: () => ModuleRuleSchema,
			ModuleRuleTypeSchema: () => ModuleRuleTypeSchema,
			Mutex: () => Mutex,
			NoOpLog: () => NoOpLog,
			PLUGINS: () => PLUGINS,
			PLUGIN_ENTRIES: () => PLUGIN_ENTRIES,
			PathSchema: () => PathSchema,
			PeriodType: () => PeriodType,
			PersistenceSchema: () => PersistenceSchema,
			ProxyAddresses: () => ProxyAddresses,
			ProxyClient: () => ProxyClient,
			ProxyNodeBinding: () => ProxyNodeBinding,
			ProxyOps: () => ProxyOps,
			QUEUES_PLUGIN: () => QUEUES_PLUGIN,
			QUEUES_PLUGIN_NAME: () => QUEUES_PLUGIN_NAME,
			QueueBindings: () => QueueBindings,
			QueueConsumerOptionsSchema: () => QueueConsumerOptionsSchema,
			QueueConsumerSchema: () => QueueConsumerSchema,
			QueueConsumersSchema: () => QueueConsumersSchema,
			QueueContentTypeSchema: () => QueueContentTypeSchema,
			QueueIncomingMessageSchema: () => QueueIncomingMessageSchema,
			QueueMessageDelaySchema: () => QueueMessageDelaySchema,
			QueueProducerOptionsSchema: () => QueueProducerOptionsSchema,
			QueueProducerSchema: () => QueueProducerSchema,
			QueueProducersSchema: () => QueueProducersSchema,
			QueuesBatchRequestSchema: () => QueuesBatchRequestSchema,
			QueuesError: () => QueuesError,
			QueuesOptionsSchema: () => QueuesOptionsSchema,
			R2OptionsSchema: () => R2OptionsSchema,
			R2SharedOptionsSchema: () => R2SharedOptionsSchema,
			R2_PLUGIN: () => R2_PLUGIN,
			R2_PLUGIN_NAME: () => R2_PLUGIN_NAME,
			RATELIMIT_PLUGIN: () => RATELIMIT_PLUGIN,
			RATELIMIT_PLUGIN_NAME: () => RATELIMIT_PLUGIN_NAME,
			RatelimitConfigSchema: () => RatelimitConfigSchema,
			RatelimitOptionsSchema: () => RatelimitOptionsSchema,
			Request: () => Request,
			Response: () => Response,
			RouterError: () => RouterError,
			Runtime: () => Runtime,
			SERVICE_ENTRY: () => SERVICE_ENTRY,
			SERVICE_LOOPBACK: () => SERVICE_LOOPBACK,
			SITES_NO_CACHE_PREFIX: () => SITES_NO_CACHE_PREFIX,
			SOCKET_ENTRY: () => SOCKET_ENTRY,
			SOCKET_ENTRY_LOCAL: () => SOCKET_ENTRY_LOCAL,
			SharedBindings: () => SharedBindings,
			SharedHeaders: () => SharedHeaders,
			SiteBindings: () => SiteBindings,
			SourceOptionsSchema: () => SourceOptionsSchema,
			TlsOptions_Version: () => import_workerd_capnp.TlsOptions_Version,
			TypedEventTarget: () => TypedEventTarget,
			WORKER_BINDING_SERVICE_LOOPBACK: () => WORKER_BINDING_SERVICE_LOOPBACK,
			WORKFLOWS_PLUGIN: () => WORKFLOWS_PLUGIN,
			WORKFLOWS_PLUGIN_NAME: () => WORKFLOWS_PLUGIN_NAME,
			WORKFLOWS_STORAGE_SERVICE_NAME: () => WORKFLOWS_STORAGE_SERVICE_NAME,
			WaitGroup: () => WaitGroup,
			WebSocket: () => WebSocket,
			WebSocketPair: () => WebSocketPair,
			Worker_Binding_CryptoKey_Usage: () =>
				import_workerd_capnp.Worker_Binding_CryptoKey_Usage,
			WorkflowsOptionsSchema: () => WorkflowsOptionsSchema,
			WorkflowsSharedOptionsSchema: () => WorkflowsSharedOptionsSchema,
			__MiniflareFunctionWrapper: () => __MiniflareFunctionWrapper,
			_enableControlEndpoints: () => _enableControlEndpoints,
			_forceColour: () => _forceColour,
			_initialiseInstanceRegistry: () => _initialiseInstanceRegistry,
			_isCyclic: () => _isCyclic,
			_transformsForContentEncodingAndContentType: () =>
				_transformsForContentEncodingAndContentType,
			base64Decode: () => base64Decode,
			base64Encode: () => base64Encode,
			buildAssetManifest: () => buildAssetManifest,
			compileModuleRules: () => compileModuleRules,
			coupleWebSocket: () => coupleWebSocket,
			createFetchMock: () => createFetchMock,
			createHTTPReducers: () => createHTTPReducers,
			createHTTPRevivers: () => createHTTPRevivers,
			decodeSitesKey: () => decodeSitesKey,
			deserialiseRegExps: () => deserialiseRegExps,
			deserialiseSiteRegExps: () => deserialiseSiteRegExps,
			encodeSitesKey: () => encodeSitesKey,
			fetch: () => fetch3,
			formatZodError: () => formatZodError,
			getAccessibleHosts: () => getAccessibleHosts,
			getAssetsBindingsNames: () => getAssetsBindingsNames,
			getCacheServiceName: () => getCacheServiceName,
			getDirectSocketName: () => getDirectSocketName,
			getEntrySocketHttpOptions: () => getEntrySocketHttpOptions,
			getFreshSourceMapSupport: () => getFreshSourceMapSupport,
			getGlobalServices: () => getGlobalServices,
			getMiniflareObjectBindings: () => getMiniflareObjectBindings,
			getNodeCompat: () => getNodeCompat,
			getPersistPath: () => getPersistPath,
			getRootPath: () => getRootPath,
			globsToRegExps: () => globsToRegExps,
			isFetcherFetch: () => isFetcherFetch,
			isR2ObjectWriteHttpMetadata: () => isR2ObjectWriteHttpMetadata,
			isSitesRequest: () => isSitesRequest,
			kCurrentWorker: () => kCurrentWorker,
			kInspectorSocket: () => kInspectorSocket,
			kUnsafeEphemeralUniqueKey: () => kUnsafeEphemeralUniqueKey,
			kVoid: () => kVoid,
			matchRoutes: () => matchRoutes,
			maybeApply: () => maybeApply,
			maybeParseURL: () => maybeParseURL,
			mergeWorkerOptions: () => mergeWorkerOptions,
			migrateDatabase: () => migrateDatabase,
			namespaceEntries: () => namespaceEntries,
			namespaceKeys: () => namespaceKeys,
			normaliseDurableObject: () => normaliseDurableObject,
			objectEntryWorker: () => objectEntryWorker,
			parseRanges: () => parseRanges,
			parseRoutes: () => parseRoutes,
			parseWithReadableStreams: () => parseWithReadableStreams,
			parseWithRootPath: () => parseWithRootPath,
			prefixError: () => prefixError,
			prefixStream: () => prefixStream,
			readPrefix: () => readPrefix,
			reduceError: () => reduceError,
			sanitisePath: () => sanitisePath,
			serialiseRegExps: () => serialiseRegExps,
			serialiseSiteRegExps: () => serialiseSiteRegExps,
			serializeConfig: () => serializeConfig2,
			stringifyWithStreams: () => stringifyWithStreams,
			stripAnsi: () => stripAnsi,
			structuredSerializableReducers: () => structuredSerializableReducers,
			structuredSerializableRevivers: () => structuredSerializableRevivers,
			supportedCompatibilityDate: () => import_workerd2.compatibilityDate,
			testRegExps: () => testRegExps,
			testSiteRegExps: () => testSiteRegExps,
			viewToBuffer: () => viewToBuffer,
			zAwaitable: () => zAwaitable,
		});
		module2.exports = __toCommonJS2(src_exports);
		var import_assert12 = __toESM2(require("assert"));
		var import_crypto3 = __toESM2(require("crypto"));
		var import_fs22 = __toESM2(require("fs"));
		var import_http6 = __toESM2(require("http"));
		var import_net = __toESM2(require("net"));
		var import_os2 = __toESM2(require("os"));
		var import_path26 = __toESM2(require("path"));
		var import_web5 = require("stream/web");
		var import_util5 = __toESM2(require("util"));
		var import_zlib = __toESM2(require("zlib"));
		var import_exit_hook = __toESM2(require_exit_hook());
		var FORCE_COLOR;
		var NODE_DISABLE_COLORS;
		var NO_COLOR;
		var TERM;
		var isTTY = true;
		if (typeof process !== "undefined") {
			({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
			isTTY = process.stdout && process.stdout.isTTY;
		}
		var $ = {
			enabled:
				!NODE_DISABLE_COLORS &&
				NO_COLOR == null &&
				TERM !== "dumb" &&
				((FORCE_COLOR != null && FORCE_COLOR !== "0") || isTTY),
		};
		function init(x, y) {
			let rgx = new RegExp(`\\x1b\\[${y}m`, "g");
			let open = `\x1B[${x}m`,
				close = `\x1B[${y}m`;
			return function (txt) {
				if (!$.enabled || txt == null) return txt;
				return (
					open +
					(!!~("" + txt).indexOf(close) ? txt.replace(rgx, close + open) : txt) +
					close
				);
			};
		}
		var reset = init(0, 0);
		var bold = init(1, 22);
		var dim = init(2, 22);
		var italic = init(3, 23);
		var underline = init(4, 24);
		var inverse = init(7, 27);
		var hidden = init(8, 28);
		var strikethrough = init(9, 29);
		var black = init(30, 39);
		var red = init(31, 39);
		var green = init(32, 39);
		var yellow = init(33, 39);
		var blue = init(34, 39);
		var magenta = init(35, 39);
		var cyan = init(36, 39);
		var white = init(37, 39);
		var gray = init(90, 39);
		var grey = init(90, 39);
		var bgBlack = init(40, 49);
		var bgRed = init(41, 49);
		var bgGreen = init(42, 49);
		var bgYellow = init(43, 49);
		var bgBlue = init(44, 49);
		var bgMagenta = init(45, 49);
		var bgCyan = init(46, 49);
		var bgWhite = init(47, 49);
		var import_stoppable = __toESM2(require_stoppable());
		var import_undici8 = require_undici();
		var import_fs = __toESM2(require("fs"));
		var import_path = __toESM2(require("path"));
		var import_url = __toESM2(require("url"));
		var contents;
		function index_worker_default() {
			if (contents !== void 0) return contents;
			const filePath = import_path.default.join(
				__dirname,
				"workers",
				"shared/index.worker.js",
			);
			contents =
				import_fs.default.readFileSync(filePath, "utf8") +
				"//# sourceURL=" +
				import_url.default.pathToFileURL(filePath);
			return contents;
		}
		var import_fs2 = __toESM2(require("fs"));
		var import_path2 = __toESM2(require("path"));
		var import_url2 = __toESM2(require("url"));
		var contents2;
		function zod_worker_default() {
			if (contents2 !== void 0) return contents2;
			const filePath = import_path2.default.join(
				__dirname,
				"workers",
				"shared/zod.worker.js",
			);
			contents2 =
				import_fs2.default.readFileSync(filePath, "utf8") +
				"//# sourceURL=" +
				import_url2.default.pathToFileURL(filePath);
			return contents2;
		}
		var import_ws3 = require_ws();
		var import_zod22 = require_lib();
		var import_assert = __toESM2(require("assert"));
		var import_promises = require("fs/promises");
		var import_path3 = __toESM2(require("path"));
		var import_undici = require_undici();
		var defaultCfPath = import_path3.default.resolve("node_modules", ".mf", "cf.json");
		var defaultCfFetchEndpoint = "https://workers.cloudflare.com/cf.json";
		var fallbackCf = {
			asOrganization: "",
			asn: 395747,
			colo: "DFW",
			city: "Austin",
			region: "Texas",
			regionCode: "TX",
			metroCode: "635",
			postalCode: "78701",
			country: "US",
			continent: "NA",
			timezone: "America/Chicago",
			latitude: "30.27130",
			longitude: "-97.74260",
			clientTcpRtt: 0,
			httpProtocol: "HTTP/1.1",
			requestPriority: "weight=192;exclusive=0",
			tlsCipher: "AEAD-AES128-GCM-SHA256",
			tlsVersion: "TLSv1.3",
			tlsClientAuth: {
				certPresented: "0",
				certVerified: "NONE",
				certRevoked: "0",
				certIssuerDN: "",
				certSubjectDN: "",
				certIssuerDNRFC2253: "",
				certSubjectDNRFC2253: "",
				certIssuerDNLegacy: "",
				certSubjectDNLegacy: "",
				certSerial: "",
				certIssuerSerial: "",
				certSKI: "",
				certIssuerSKI: "",
				certFingerprintSHA1: "",
				certFingerprintSHA256: "",
				certNotBefore: "",
				certNotAfter: "",
			},
			edgeRequestKeepAliveStatus: 0,
			hostMetadata: void 0,
			clientTrustScore: 99,
			botManagement: {
				corporateProxy: false,
				verifiedBot: false,
				ja3Hash: "25b4882c2bcb50cd6b469ff28c596742",
				staticResource: false,
				detectionIds: [],
				score: 99,
			},
		};
		var DAY = 864e5;
		var CF_DAYS = 30;
		async function setupCf(log, cf) {
			if (!(cf ?? process.env.NODE_ENV !== "test")) {
				return fallbackCf;
			}
			if (typeof cf === "object") {
				return cf;
			}
			let cfPath = defaultCfPath;
			if (typeof cf === "string") {
				cfPath = cf;
			}
			try {
				const storedCf = JSON.parse(await (0, import_promises.readFile)(cfPath, "utf8"));
				const cfStat = await (0, import_promises.stat)(cfPath);
				(0, import_assert.default)(Date.now() - cfStat.mtimeMs <= CF_DAYS * DAY);
				return storedCf;
			} catch {}
			try {
				const res = await (0, import_undici.fetch)(defaultCfFetchEndpoint);
				const cfText = await res.text();
				const storedCf = JSON.parse(cfText);
				await (0, import_promises.mkdir)(import_path3.default.dirname(cfPath), {
					recursive: true,
				});
				await (0, import_promises.writeFile)(cfPath, cfText, "utf8");
				log.debug("Updated `Request.cf` object cache!");
				return storedCf;
			} catch (e) {
				log.warn(
					"Unable to fetch the `Request.cf` object! Falling back to a default placeholder...\n" +
						dim(e.cause ? e.cause.stack : e.stack),
				);
				return fallbackCf;
			}
		}
		var undici = __toESM2(require_undici());
		var import_ws2 = __toESM2(require_ws());
		var CacheHeaders = {
			NAMESPACE: "cf-cache-namespace",
			STATUS: "cf-cache-status",
		};
		var CacheBindings = {
			MAYBE_JSON_CACHE_WARN_USAGE: "MINIFLARE_CACHE_WARN_USAGE",
		};
		var CoreHeaders = {
			CUSTOM_SERVICE: "MF-Custom-Service",
			ORIGINAL_URL: "MF-Original-URL",
			PROXY_SHARED_SECRET: "MF-Proxy-Shared-Secret",
			DISABLE_PRETTY_ERROR: "MF-Disable-Pretty-Error",
			ERROR_STACK: "MF-Experimental-Error-Stack",
			ROUTE_OVERRIDE: "MF-Route-Override",
			CF_BLOB: "MF-CF-Blob",
			// API Proxy
			OP_SECRET: "MF-Op-Secret",
			OP: "MF-Op",
			OP_TARGET: "MF-Op-Target",
			OP_KEY: "MF-Op-Key",
			OP_SYNC: "MF-Op-Sync",
			OP_STRINGIFIED_SIZE: "MF-Op-Stringified-Size",
			OP_RESULT_TYPE: "MF-Op-Result-Type",
		};
		var CoreBindings = {
			SERVICE_LOOPBACK: "MINIFLARE_LOOPBACK",
			SERVICE_USER_ROUTE_PREFIX: "MINIFLARE_USER_ROUTE_",
			SERVICE_USER_FALLBACK: "MINIFLARE_USER_FALLBACK",
			TEXT_CUSTOM_SERVICE: "MINIFLARE_CUSTOM_SERVICE",
			TEXT_UPSTREAM_URL: "MINIFLARE_UPSTREAM_URL",
			JSON_CF_BLOB: "CF_BLOB",
			JSON_ROUTES: "MINIFLARE_ROUTES",
			JSON_LOG_LEVEL: "MINIFLARE_LOG_LEVEL",
			DATA_LIVE_RELOAD_SCRIPT: "MINIFLARE_LIVE_RELOAD_SCRIPT",
			DURABLE_OBJECT_NAMESPACE_PROXY: "MINIFLARE_PROXY",
			DATA_PROXY_SECRET: "MINIFLARE_PROXY_SECRET",
			DATA_PROXY_SHARED_SECRET: "MINIFLARE_PROXY_SHARED_SECRET",
		};
		var ProxyOps = {
			// Get the target or a property of the target
			GET: "GET",
			// Get the descriptor for a property of the target
			GET_OWN_DESCRIPTOR: "GET_OWN_DESCRIPTOR",
			// Get the target's own property names
			GET_OWN_KEYS: "GET_OWN_KEYS",
			// Call a method on the target
			CALL: "CALL",
			// Remove the strong reference to the target on the "heap", allowing it to be
			// garbage collected
			FREE: "FREE",
		};
		var ProxyAddresses = {
			GLOBAL: 0,
			// globalThis
			ENV: 1,
			// env
			USER_START: 2,
		};
		function isFetcherFetch(targetName, key) {
			return (
				(targetName === "Fetcher" ||
					targetName === "DurableObject" ||
					targetName === "WorkerRpc") &&
				key === "fetch"
			);
		}
		function isR2ObjectWriteHttpMetadata(targetName, key) {
			return (
				(targetName === "HeadResult" || targetName === "GetResult") &&
				key === "writeHttpMetadata"
			);
		}
		var import_node_assert = __toESM2(require("assert"));
		var import_node_buffer = require("buffer");
		var DevalueError = class extends Error {
			/**
			 * @param {string} message
			 * @param {string[]} keys
			 */
			constructor(message, keys) {
				super(message);
				this.name = "DevalueError";
				this.path = keys.join("");
			}
		};
		function is_primitive(thing) {
			return Object(thing) !== thing;
		}
		var object_proto_names = /* @__PURE__ */ Object.getOwnPropertyNames(Object.prototype)
			.sort()
			.join("\0");
		function is_plain_object(thing) {
			const proto = Object.getPrototypeOf(thing);
			return (
				proto === Object.prototype ||
				proto === null ||
				Object.getOwnPropertyNames(proto).sort().join("\0") === object_proto_names
			);
		}
		function get_type(thing) {
			return Object.prototype.toString.call(thing).slice(8, -1);
		}
		function get_escaped_char(char) {
			switch (char) {
				case '"':
					return '\\"';
				case "<":
					return "\\u003C";
				case "\\":
					return "\\\\";
				case "\n":
					return "\\n";
				case "\r":
					return "\\r";
				case "	":
					return "\\t";
				case "\b":
					return "\\b";
				case "\f":
					return "\\f";
				case "\u2028":
					return "\\u2028";
				case "\u2029":
					return "\\u2029";
				default:
					return char < " "
						? `\\u${char.charCodeAt(0).toString(16).padStart(4, "0")}`
						: "";
			}
		}
		function stringify_string(str) {
			let result = "";
			let last_pos = 0;
			const len = str.length;
			for (let i = 0; i < len; i += 1) {
				const char = str[i];
				const replacement = get_escaped_char(char);
				if (replacement) {
					result += str.slice(last_pos, i) + replacement;
					last_pos = i + 1;
				}
			}
			return `"${last_pos === 0 ? str : result + str.slice(last_pos)}"`;
		}
		var UNDEFINED = -1;
		var HOLE = -2;
		var NAN = -3;
		var POSITIVE_INFINITY = -4;
		var NEGATIVE_INFINITY = -5;
		var NEGATIVE_ZERO = -6;
		function parse(serialized, revivers2) {
			return unflatten(JSON.parse(serialized), revivers2);
		}
		function unflatten(parsed, revivers2) {
			if (typeof parsed === "number") return hydrate(parsed, true);
			if (!Array.isArray(parsed) || parsed.length === 0) {
				throw new Error("Invalid input");
			}
			const values =
				/** @type {any[]} */
				parsed;
			const hydrated = Array(values.length);
			function hydrate(index, standalone = false) {
				if (index === UNDEFINED) return void 0;
				if (index === NAN) return NaN;
				if (index === POSITIVE_INFINITY) return Infinity;
				if (index === NEGATIVE_INFINITY) return -Infinity;
				if (index === NEGATIVE_ZERO) return -0;
				if (standalone) throw new Error(`Invalid input`);
				if (index in hydrated) return hydrated[index];
				const value = values[index];
				if (!value || typeof value !== "object") {
					hydrated[index] = value;
				} else if (Array.isArray(value)) {
					if (typeof value[0] === "string") {
						const type = value[0];
						const reviver = revivers2?.[type];
						if (reviver) {
							return (hydrated[index] = reviver(hydrate(value[1])));
						}
						switch (type) {
							case "Date":
								hydrated[index] = new Date(value[1]);
								break;
							case "Set":
								const set = /* @__PURE__ */ new Set();
								hydrated[index] = set;
								for (let i = 1; i < value.length; i += 1) {
									set.add(hydrate(value[i]));
								}
								break;
							case "Map":
								const map = /* @__PURE__ */ new Map();
								hydrated[index] = map;
								for (let i = 1; i < value.length; i += 2) {
									map.set(hydrate(value[i]), hydrate(value[i + 1]));
								}
								break;
							case "RegExp":
								hydrated[index] = new RegExp(value[1], value[2]);
								break;
							case "Object":
								hydrated[index] = Object(value[1]);
								break;
							case "BigInt":
								hydrated[index] = BigInt(value[1]);
								break;
							case "null":
								const obj = /* @__PURE__ */ Object.create(null);
								hydrated[index] = obj;
								for (let i = 1; i < value.length; i += 2) {
									obj[value[i]] = hydrate(value[i + 1]);
								}
								break;
							default:
								throw new Error(`Unknown type ${type}`);
						}
					} else {
						const array = new Array(value.length);
						hydrated[index] = array;
						for (let i = 0; i < value.length; i += 1) {
							const n = value[i];
							if (n === HOLE) continue;
							array[i] = hydrate(n);
						}
					}
				} else {
					const object = {};
					hydrated[index] = object;
					for (const key in value) {
						const n = value[key];
						object[key] = hydrate(n);
					}
				}
				return hydrated[index];
			}
			return hydrate(0);
		}
		function stringify(value, reducers2) {
			const stringified = [];
			const indexes = /* @__PURE__ */ new Map();
			const custom = [];
			for (const key in reducers2) {
				custom.push({ key, fn: reducers2[key] });
			}
			const keys = [];
			let p = 0;
			function flatten(thing) {
				if (typeof thing === "function") {
					throw new DevalueError(`Cannot stringify a function`, keys);
				}
				if (indexes.has(thing)) return indexes.get(thing);
				if (thing === void 0) return UNDEFINED;
				if (Number.isNaN(thing)) return NAN;
				if (thing === Infinity) return POSITIVE_INFINITY;
				if (thing === -Infinity) return NEGATIVE_INFINITY;
				if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO;
				const index2 = p++;
				indexes.set(thing, index2);
				for (const { key, fn } of custom) {
					const value2 = fn(thing);
					if (value2) {
						stringified[index2] = `["${key}",${flatten(value2)}]`;
						return index2;
					}
				}
				let str = "";
				if (is_primitive(thing)) {
					str = stringify_primitive(thing);
				} else {
					const type = get_type(thing);
					switch (type) {
						case "Number":
						case "String":
						case "Boolean":
							str = `["Object",${stringify_primitive(thing)}]`;
							break;
						case "BigInt":
							str = `["BigInt",${thing}]`;
							break;
						case "Date":
							str = `["Date","${thing.toISOString()}"]`;
							break;
						case "RegExp":
							const { source, flags } = thing;
							str = flags
								? `["RegExp",${stringify_string(source)},"${flags}"]`
								: `["RegExp",${stringify_string(source)}]`;
							break;
						case "Array":
							str = "[";
							for (let i = 0; i < thing.length; i += 1) {
								if (i > 0) str += ",";
								if (i in thing) {
									keys.push(`[${i}]`);
									str += flatten(thing[i]);
									keys.pop();
								} else {
									str += HOLE;
								}
							}
							str += "]";
							break;
						case "Set":
							str = '["Set"';
							for (const value2 of thing) {
								str += `,${flatten(value2)}`;
							}
							str += "]";
							break;
						case "Map":
							str = '["Map"';
							for (const [key, value2] of thing) {
								keys.push(
									`.get(${is_primitive(key) ? stringify_primitive(key) : "..."})`,
								);
								str += `,${flatten(key)},${flatten(value2)}`;
							}
							str += "]";
							break;
						default:
							if (!is_plain_object(thing)) {
								throw new DevalueError(
									`Cannot stringify arbitrary non-POJOs`,
									keys,
								);
							}
							if (Object.getOwnPropertySymbols(thing).length > 0) {
								throw new DevalueError(
									`Cannot stringify POJOs with symbolic keys`,
									keys,
								);
							}
							if (Object.getPrototypeOf(thing) === null) {
								str = '["null"';
								for (const key in thing) {
									keys.push(`.${key}`);
									str += `,${stringify_string(key)},${flatten(thing[key])}`;
									keys.pop();
								}
								str += "]";
							} else {
								str = "{";
								let started = false;
								for (const key in thing) {
									if (started) str += ",";
									started = true;
									keys.push(`.${key}`);
									str += `${stringify_string(key)}:${flatten(thing[key])}`;
									keys.pop();
								}
								str += "}";
							}
					}
				}
				stringified[index2] = str;
				return index2;
			}
			const index = flatten(value);
			if (index < 0) return `${index}`;
			return `[${stringified.join(",")}]`;
		}
		function stringify_primitive(thing) {
			const type = typeof thing;
			if (type === "string") return stringify_string(thing);
			if (thing instanceof String) return stringify_string(thing.toString());
			if (thing === void 0) return UNDEFINED.toString();
			if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO.toString();
			if (type === "bigint") return `["BigInt","${thing}"]`;
			return String(thing);
		}
		var ALLOWED_ARRAY_BUFFER_VIEW_CONSTRUCTORS = [
			DataView,
			Int8Array,
			Uint8Array,
			Uint8ClampedArray,
			Int16Array,
			Uint16Array,
			Int32Array,
			Uint32Array,
			Float32Array,
			Float64Array,
			BigInt64Array,
			BigUint64Array,
		];
		var ALLOWED_ERROR_CONSTRUCTORS = [
			EvalError,
			RangeError,
			ReferenceError,
			SyntaxError,
			TypeError,
			URIError,
			Error,
			// `Error` last so more specific error subclasses preferred
		];
		var structuredSerializableReducers = {
			ArrayBuffer(value) {
				if (value instanceof ArrayBuffer) {
					return [import_node_buffer.Buffer.from(value).toString("base64")];
				}
			},
			ArrayBufferView(value) {
				if (ArrayBuffer.isView(value)) {
					return [
						value.constructor.name,
						value.buffer,
						value.byteOffset,
						value.byteLength,
					];
				}
			},
			Error(value) {
				for (const ctor of ALLOWED_ERROR_CONSTRUCTORS) {
					if (value instanceof ctor && value.name === ctor.name) {
						return [value.name, value.message, value.stack, value.cause];
					}
				}
				if (value instanceof Error) {
					return ["Error", value.message, value.stack, value.cause];
				}
			},
		};
		var structuredSerializableRevivers = {
			ArrayBuffer(value) {
				(0, import_node_assert.default)(Array.isArray(value));
				const [encoded] = value;
				(0, import_node_assert.default)(typeof encoded === "string");
				const view = import_node_buffer.Buffer.from(encoded, "base64");
				return view.buffer.slice(view.byteOffset, view.byteOffset + view.byteLength);
			},
			ArrayBufferView(value) {
				(0, import_node_assert.default)(Array.isArray(value));
				const [name, buffer, byteOffset, byteLength] = value;
				(0, import_node_assert.default)(typeof name === "string");
				(0, import_node_assert.default)(buffer instanceof ArrayBuffer);
				(0, import_node_assert.default)(typeof byteOffset === "number");
				(0, import_node_assert.default)(typeof byteLength === "number");
				const ctor = globalThis[name];
				(0, import_node_assert.default)(
					ALLOWED_ARRAY_BUFFER_VIEW_CONSTRUCTORS.includes(ctor),
				);
				let length = byteLength;
				if ("BYTES_PER_ELEMENT" in ctor) length /= ctor.BYTES_PER_ELEMENT;
				return new ctor(buffer, byteOffset, length);
			},
			Error(value) {
				(0, import_node_assert.default)(Array.isArray(value));
				const [name, message, stack, cause] = value;
				(0, import_node_assert.default)(typeof name === "string");
				(0, import_node_assert.default)(typeof message === "string");
				(0, import_node_assert.default)(stack === void 0 || typeof stack === "string");
				const ctor = globalThis[name];
				(0, import_node_assert.default)(ALLOWED_ERROR_CONSTRUCTORS.includes(ctor));
				const error = new ctor(message, { cause });
				error.stack = stack;
				return error;
			},
		};
		function createHTTPReducers(impl) {
			return {
				Headers(val) {
					if (val instanceof impl.Headers) return Object.fromEntries(val);
				},
				Request(val) {
					if (val instanceof impl.Request) {
						return [val.method, val.url, val.headers, val.cf, val.body];
					}
				},
				Response(val) {
					if (val instanceof impl.Response) {
						return [val.status, val.statusText, val.headers, val.cf, val.body];
					}
				},
			};
		}
		function createHTTPRevivers(impl) {
			return {
				Headers(value) {
					(0, import_node_assert.default)(typeof value === "object" && value !== null);
					return new impl.Headers(value);
				},
				Request(value) {
					(0, import_node_assert.default)(Array.isArray(value));
					const [method, url18, headers, cf, body] = value;
					(0, import_node_assert.default)(typeof method === "string");
					(0, import_node_assert.default)(typeof url18 === "string");
					(0, import_node_assert.default)(headers instanceof impl.Headers);
					(0, import_node_assert.default)(body === null || impl.isReadableStream(body));
					return new impl.Request(url18, {
						method,
						headers,
						cf,
						// @ts-expect-error `duplex` is not required by `workerd` yet
						duplex: body === null ? void 0 : "half",
						body,
					});
				},
				Response(value) {
					(0, import_node_assert.default)(Array.isArray(value));
					const [status, statusText, headers, cf, body] = value;
					(0, import_node_assert.default)(typeof status === "number");
					(0, import_node_assert.default)(typeof statusText === "string");
					(0, import_node_assert.default)(headers instanceof impl.Headers);
					(0, import_node_assert.default)(body === null || impl.isReadableStream(body));
					return new impl.Response(body, {
						status,
						statusText,
						headers,
						cf,
					});
				},
			};
		}
		function stringifyWithStreams(impl, value, reducers2, allowUnbufferedStream) {
			let unbufferedStream;
			const bufferPromises = [];
			const streamReducers = {
				ReadableStream(value2) {
					if (impl.isReadableStream(value2)) {
						if (allowUnbufferedStream && unbufferedStream === void 0) {
							unbufferedStream = value2;
						} else {
							bufferPromises.push(impl.bufferReadableStream(value2));
						}
						return true;
					}
				},
				Blob(value2) {
					if (value2 instanceof impl.Blob) {
						bufferPromises.push(value2.arrayBuffer());
						return true;
					}
				},
				...reducers2,
			};
			if (typeof value === "function") {
				value = new __MiniflareFunctionWrapper(value);
			}
			const stringifiedValue = stringify(value, streamReducers);
			if (bufferPromises.length === 0) {
				return { value: stringifiedValue, unbufferedStream };
			}
			return Promise.all(bufferPromises).then((streamBuffers) => {
				streamReducers.ReadableStream = function (value2) {
					if (impl.isReadableStream(value2)) {
						if (value2 === unbufferedStream) {
							return true;
						} else {
							return streamBuffers.shift();
						}
					}
				};
				streamReducers.Blob = function (value2) {
					if (value2 instanceof impl.Blob) {
						const array = [streamBuffers.shift(), value2.type];
						if (value2 instanceof impl.File) {
							array.push(value2.name, value2.lastModified);
						}
						return array;
					}
				};
				const stringifiedValue2 = stringify(value, streamReducers);
				return { value: stringifiedValue2, unbufferedStream };
			});
		}
		var __MiniflareFunctionWrapper = class {
			constructor(fnWithProps) {
				return new Proxy(this, {
					get: (_, key) => {
						if (key === "__miniflareWrappedFunction") return fnWithProps;
						return fnWithProps[key];
					},
				});
			}
		};
		function parseWithReadableStreams(impl, stringified, revivers2) {
			const streamRevivers = {
				ReadableStream(value) {
					if (value === true) {
						(0, import_node_assert.default)(stringified.unbufferedStream !== void 0);
						return stringified.unbufferedStream;
					}
					(0, import_node_assert.default)(value instanceof ArrayBuffer);
					return impl.unbufferReadableStream(value);
				},
				Blob(value) {
					(0, import_node_assert.default)(Array.isArray(value));
					if (value.length === 2) {
						const [buffer, type] = value;
						(0, import_node_assert.default)(buffer instanceof ArrayBuffer);
						(0, import_node_assert.default)(typeof type === "string");
						const opts = {};
						if (type !== "") opts.type = type;
						return new impl.Blob([buffer], opts);
					} else {
						(0, import_node_assert.default)(value.length === 4);
						const [buffer, type, name, lastModified] = value;
						(0, import_node_assert.default)(buffer instanceof ArrayBuffer);
						(0, import_node_assert.default)(typeof type === "string");
						(0, import_node_assert.default)(typeof name === "string");
						(0, import_node_assert.default)(typeof lastModified === "number");
						const opts = { lastModified };
						if (type !== "") opts.type = type;
						return new impl.File([buffer], name, opts);
					}
				},
				...revivers2,
			};
			return parse(stringified.value, streamRevivers);
		}
		function matchRoutes(routes, url18) {
			for (const route of routes) {
				if (route.protocol && route.protocol !== url18.protocol) continue;
				if (route.allowHostnamePrefix) {
					if (!url18.hostname.endsWith(route.hostname)) continue;
				} else {
					if (url18.hostname !== route.hostname) continue;
				}
				const path28 = url18.pathname + url18.search;
				if (route.allowPathSuffix) {
					if (!path28.startsWith(route.path)) continue;
				} else {
					if (path28 !== route.path) continue;
				}
				return route.target;
			}
			return null;
		}
		var SharedHeaders = {
			LOG_LEVEL: "MF-Log-Level",
		};
		var SharedBindings = {
			TEXT_NAMESPACE: "MINIFLARE_NAMESPACE",
			DURABLE_OBJECT_NAMESPACE_OBJECT: "MINIFLARE_OBJECT",
			MAYBE_SERVICE_BLOBS: "MINIFLARE_BLOBS",
			MAYBE_SERVICE_LOOPBACK: "MINIFLARE_LOOPBACK",
			MAYBE_JSON_ENABLE_CONTROL_ENDPOINTS: "MINIFLARE_ENABLE_CONTROL_ENDPOINTS",
			MAYBE_JSON_ENABLE_STICKY_BLOBS: "MINIFLARE_STICKY_BLOBS",
		};
		var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
			LogLevel2[(LogLevel2["NONE"] = 0)] = "NONE";
			LogLevel2[(LogLevel2["ERROR"] = 1)] = "ERROR";
			LogLevel2[(LogLevel2["WARN"] = 2)] = "WARN";
			LogLevel2[(LogLevel2["INFO"] = 3)] = "INFO";
			LogLevel2[(LogLevel2["DEBUG"] = 4)] = "DEBUG";
			LogLevel2[(LogLevel2["VERBOSE"] = 5)] = "VERBOSE";
			return LogLevel2;
		})(LogLevel || {});
		var import_node_buffer2 = require("buffer");
		function viewToBuffer(view) {
			return view.buffer.slice(view.byteOffset, view.byteOffset + view.byteLength);
		}
		function base64Encode(value) {
			return import_node_buffer2.Buffer.from(value, "utf8").toString("base64");
		}
		function base64Decode(encoded) {
			return import_node_buffer2.Buffer.from(encoded, "base64").toString("utf8");
		}
		var dotRegexp = /(^|\/|\\)(\.+)(\/|\\|$)/g;
		var illegalRegexp = /[?<>*"'^/\\:|\x00-\x1f\x80-\x9f]/g;
		var windowsReservedRegexp = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
		var leadingRegexp = /^[ /\\]+/;
		var trailingRegexp = /[ /\\]+$/;
		function dotReplacement(match, g1, g2, g3) {
			return `${g1}${"".padStart(g2.length, "_")}${g3}`;
		}
		function underscoreReplacement(match) {
			return "".padStart(match.length, "_");
		}
		function sanitisePath(unsafe) {
			return unsafe
				.replace(dotRegexp, dotReplacement)
				.replace(dotRegexp, dotReplacement)
				.replace(illegalRegexp, "_")
				.replace(windowsReservedRegexp, "_")
				.replace(leadingRegexp, underscoreReplacement)
				.replace(trailingRegexp, underscoreReplacement)
				.substring(0, 255);
		}
		function testRegExps(matcher, value) {
			for (const exclude of matcher.exclude) if (exclude.test(value)) return false;
			for (const include of matcher.include) if (include.test(value)) return true;
			return false;
		}
		var rangePrefixRegexp = /^ *bytes *=/i;
		var rangeRegexp = /^ *(?<start>\d+)? *- *(?<end>\d+)? *$/;
		function parseRanges(rangeHeader, length) {
			const prefixMatch = rangePrefixRegexp.exec(rangeHeader);
			if (prefixMatch === null) return;
			rangeHeader = rangeHeader.substring(prefixMatch[0].length);
			if (rangeHeader.trimStart() === "") return [];
			const ranges = rangeHeader.split(",");
			const result = [];
			for (const range of ranges) {
				const match = rangeRegexp.exec(range);
				if (match === null) return;
				const { start, end } = match.groups;
				if (start !== void 0 && end !== void 0) {
					const rangeStart = parseInt(start);
					let rangeEnd = parseInt(end);
					if (rangeStart > rangeEnd) return;
					if (rangeStart >= length) return;
					if (rangeEnd >= length) rangeEnd = length - 1;
					result.push({ start: rangeStart, end: rangeEnd });
				} else if (start !== void 0 && end === void 0) {
					const rangeStart = parseInt(start);
					if (rangeStart >= length) return;
					result.push({ start: rangeStart, end: length - 1 });
				} else if (start === void 0 && end !== void 0) {
					const suffix = parseInt(end);
					if (suffix >= length) return [];
					if (suffix === 0) continue;
					result.push({ start: length - suffix, end: length - 1 });
				} else {
					return;
				}
			}
			return result;
		}
		var import_node_assert2 = __toESM2(require("assert"));
		var DeferredPromise = class extends Promise {
			resolve;
			reject;
			constructor(executor = () => {}) {
				let promiseResolve;
				let promiseReject;
				super((resolve, reject) => {
					promiseResolve = resolve;
					promiseReject = reject;
					return executor(resolve, reject);
				});
				this.resolve = promiseResolve;
				this.reject = promiseReject;
			}
		};
		var Mutex = class {
			locked = false;
			resolveQueue = [];
			drainQueue = [];
			lock() {
				if (!this.locked) {
					this.locked = true;
					return;
				}
				return new Promise((resolve) => this.resolveQueue.push(resolve));
			}
			unlock() {
				(0, import_node_assert2.default)(this.locked);
				if (this.resolveQueue.length > 0) {
					this.resolveQueue.shift()?.();
				} else {
					this.locked = false;
					let resolve;
					while ((resolve = this.drainQueue.shift()) !== void 0) resolve();
				}
			}
			get hasWaiting() {
				return this.resolveQueue.length > 0;
			}
			async runWith(closure) {
				const acquireAwaitable = this.lock();
				if (acquireAwaitable instanceof Promise) await acquireAwaitable;
				try {
					const awaitable = closure();
					if (awaitable instanceof Promise) return await awaitable;
					return awaitable;
				} finally {
					this.unlock();
				}
			}
			async drained() {
				if (this.resolveQueue.length === 0 && !this.locked) return;
				return new Promise((resolve) => this.drainQueue.push(resolve));
			}
		};
		var WaitGroup = class {
			counter = 0;
			resolveQueue = [];
			add() {
				this.counter++;
			}
			done() {
				(0, import_node_assert2.default)(this.counter > 0);
				this.counter--;
				if (this.counter === 0) {
					let resolve;
					while ((resolve = this.resolveQueue.shift()) !== void 0) resolve();
				}
			}
			wait() {
				if (this.counter === 0) return Promise.resolve();
				return new Promise((resolve) => this.resolveQueue.push(resolve));
			}
		};
		function reduceError(e) {
			return {
				name: e?.name,
				message: e?.message ?? String(e),
				stack: e?.stack,
				cause: e?.cause === void 0 ? void 0 : reduceError(e.cause),
			};
		}
		function maybeApply(f, maybeValue) {
			return maybeValue === void 0 ? void 0 : f(maybeValue);
		}
		var KVLimits = {
			MIN_CACHE_TTL: 60,
			MAX_LIST_KEYS: 1e3,
			MAX_KEY_SIZE: 512,
			MAX_VALUE_SIZE: 25 * 1024 * 1024,
			MAX_VALUE_SIZE_TEST: 1024,
			MAX_METADATA_SIZE: 1024,
		};
		var KVParams = {
			URL_ENCODED: "urlencoded",
			CACHE_TTL: "cache_ttl",
			EXPIRATION: "expiration",
			EXPIRATION_TTL: "expiration_ttl",
			LIST_LIMIT: "key_count_limit",
			LIST_PREFIX: "prefix",
			LIST_CURSOR: "cursor",
		};
		var KVHeaders = {
			EXPIRATION: "CF-Expiration",
			METADATA: "CF-KV-Metadata",
		};
		var SiteBindings = {
			KV_NAMESPACE_SITE: "__STATIC_CONTENT",
			JSON_SITE_MANIFEST: "__STATIC_CONTENT_MANIFEST",
			JSON_SITE_FILTER: "MINIFLARE_SITE_FILTER",
		};
		var SITES_NO_CACHE_PREFIX = "$__MINIFLARE_SITES__$/";
		function encodeSitesKey(key) {
			return SITES_NO_CACHE_PREFIX + encodeURIComponent(key);
		}
		function decodeSitesKey(key) {
			return key.startsWith(SITES_NO_CACHE_PREFIX)
				? decodeURIComponent(key.substring(SITES_NO_CACHE_PREFIX.length))
				: key;
		}
		function isSitesRequest(request) {
			const url18 = new URL(request.url);
			return url18.pathname.startsWith(`/${SITES_NO_CACHE_PREFIX}`);
		}
		function serialiseRegExp(regExp) {
			const str = regExp.toString();
			return str.substring(str.indexOf("/") + 1, str.lastIndexOf("/"));
		}
		function serialiseRegExps(matcher) {
			return {
				include: matcher.include.map(serialiseRegExp),
				exclude: matcher.exclude.map(serialiseRegExp),
			};
		}
		function deserialiseRegExps(matcher) {
			return {
				include: matcher.include.map((regExp) => new RegExp(regExp)),
				exclude: matcher.exclude.map((regExp) => new RegExp(regExp)),
			};
		}
		function serialiseSiteRegExps(siteRegExps) {
			return {
				include: siteRegExps.include && serialiseRegExps(siteRegExps.include),
				exclude: siteRegExps.exclude && serialiseRegExps(siteRegExps.exclude),
			};
		}
		function deserialiseSiteRegExps(siteRegExps) {
			return {
				include: siteRegExps.include && deserialiseRegExps(siteRegExps.include),
				exclude: siteRegExps.exclude && deserialiseRegExps(siteRegExps.exclude),
			};
		}
		function testSiteRegExps(regExps, key) {
			if (regExps.include !== void 0) return testRegExps(regExps.include, key);
			if (regExps.exclude !== void 0) return !testRegExps(regExps.exclude, key);
			return true;
		}
		function getAssetsBindingsNames(
			assetsKVBindingName = "__STATIC_ASSETS_CONTENT",
			assetsManifestBindingName = "__STATIC_ASSETS_CONTENT_MANIFEST",
		) {
			return {
				ASSETS_KV_NAMESPACE: assetsKVBindingName,
				ASSETS_MANIFEST: assetsManifestBindingName,
			};
		}
		var QueueBindings = {
			SERVICE_WORKER_PREFIX: "MINIFLARE_WORKER_",
			MAYBE_JSON_QUEUE_PRODUCERS: "MINIFLARE_QUEUE_PRODUCERS",
			MAYBE_JSON_QUEUE_CONSUMERS: "MINIFLARE_QUEUE_CONSUMERS",
		};
		var import_node_buffer3 = require("buffer");
		var import_zod = require_lib();
		var import_zod2 = require_lib();
		var HEX_REGEXP = /^[0-9a-f]*$/i;
		var BASE64_REGEXP = /^[0-9a-z+/=]*$/i;
		var HexDataSchema = import_zod.z
			.string()
			.regex(HEX_REGEXP)
			.transform((hex) => import_node_buffer3.Buffer.from(hex, "hex"));
		var Base64DataSchema = import_zod.z
			.string()
			.regex(BASE64_REGEXP)
			.transform((base64) => import_node_buffer3.Buffer.from(base64, "base64"));
		var QueueMessageDelaySchema = import_zod2.z.number().int().min(0).max(43200).optional();
		var QueueProducerOptionsSchema = /* @__PURE__ */ import_zod2.z.object({
			// https://developers.cloudflare.com/queues/platform/configuration/#producer
			queueName: import_zod2.z.string(),
			deliveryDelay: QueueMessageDelaySchema,
		});
		var QueueProducerSchema = /* @__PURE__ */ import_zod2.z.intersection(
			QueueProducerOptionsSchema,
			import_zod2.z.object({ workerName: import_zod2.z.string() }),
		);
		var QueueProducersSchema = /* @__PURE__ */ import_zod2.z.record(QueueProducerSchema);
		var QueueConsumerOptionsSchema = /* @__PURE__ */ import_zod2.z
			.object({
				// https://developers.cloudflare.com/queues/platform/configuration/#consumer
				// https://developers.cloudflare.com/queues/platform/limits/
				maxBatchSize: import_zod2.z.number().min(0).max(100).optional(),
				maxBatchTimeout: import_zod2.z.number().min(0).max(30).optional(),
				// seconds
				maxRetires: import_zod2.z.number().min(0).max(100).optional(),
				// deprecated
				maxRetries: import_zod2.z.number().min(0).max(100).optional(),
				deadLetterQueue: import_zod2.z.ostring(),
				retryDelay: QueueMessageDelaySchema,
			})
			.transform((queue) => {
				if (queue.maxRetires !== void 0) {
					queue.maxRetries = queue.maxRetires;
				}
				return queue;
			});
		var QueueConsumerSchema = /* @__PURE__ */ import_zod2.z.intersection(
			QueueConsumerOptionsSchema,
			import_zod2.z.object({ workerName: import_zod2.z.string() }),
		);
		var QueueConsumersSchema = /* @__PURE__ */ import_zod2.z.record(QueueConsumerSchema);
		var QueueContentTypeSchema = /* @__PURE__ */ import_zod2.z
			.enum(["text", "json", "bytes", "v8"])
			.default("v8");
		var QueueIncomingMessageSchema = /* @__PURE__ */ import_zod2.z.object({
			contentType: QueueContentTypeSchema,
			delaySecs: QueueMessageDelaySchema,
			body: Base64DataSchema,
			// When enqueuing messages on dead-letter queues, we want to reuse the same ID
			// and timestamp
			id: import_zod2.z.ostring(),
			timestamp: import_zod2.z.onumber(),
		});
		var QueuesBatchRequestSchema = /* @__PURE__ */ import_zod2.z.object({
			messages: import_zod2.z.array(QueueIncomingMessageSchema),
		});
		var import_undici2 = require_undici();
		var kCf = Symbol("kCf");
		var Request = class extends import_undici2.Request {
			// We should be able to use a private `#cf` property here instead of a symbol
			// here, but we need to set this on a clone, which would otherwise lead to a
			// "Cannot write private member to an object whose class did not declare it"
			// error.
			[kCf];
			constructor(input, init2) {
				super(input, init2);
				this[kCf] = init2?.cf;
				if (input instanceof Request) this[kCf] ??= input.cf;
			}
			get cf() {
				return this[kCf];
			}
			// JSDoc comment so retained when bundling types with api-extractor
			/** @ts-expect-error `clone` is actually defined as a method internally */
			clone() {
				const request = super.clone();
				Object.setPrototypeOf(request, Request.prototype);
				request[kCf] = this[kCf];
				return request;
			}
		};
		var import_undici3 = require_undici();
		var kWebSocket = Symbol("kWebSocket");
		var Response = class extends import_undici3.Response {
			// We should be able to use a private `#webSocket` property here instead of a
			// symbol here, but `undici` calls `this.status` in its constructor, which
			// causes a "Cannot read private member from an object whose class did not
			// declare it" error.
			[kWebSocket];
			// Override BaseResponse's static methods for building Responses to return
			// our type instead. Ideally, we don't want to use `Object.setPrototypeOf`.
			// Unfortunately, `error()` and `redirect()` set the internal header guard
			// to "immutable".
			static error() {
				const response = import_undici3.Response.error();
				Object.setPrototypeOf(response, Response.prototype);
				return response;
			}
			static redirect(url18, status) {
				const response = import_undici3.Response.redirect(url18, status);
				Object.setPrototypeOf(response, Response.prototype);
				return response;
			}
			static json(data, init2) {
				const body = JSON.stringify(data);
				const response = new Response(body, init2);
				response.headers.set("Content-Type", "application/json");
				return response;
			}
			constructor(body, init2) {
				if (init2?.webSocket) {
					if (init2.status !== 101) {
						throw new RangeError(
							"Responses with a WebSocket must have status code 101.",
						);
					}
					init2 = { ...init2, status: 200 };
				}
				super(body, init2);
				this[kWebSocket] = init2?.webSocket ?? null;
			}
			// JSDoc comment so retained when bundling types with api-extractor
			/** @ts-expect-error `status` is actually defined as a getter internally */
			get status() {
				return this[kWebSocket] ? 101 : super.status;
			}
			get webSocket() {
				return this[kWebSocket];
			}
			// JSDoc comment so retained when bundling types with api-extractor
			/** @ts-expect-error `clone` is actually defined as a method internally */
			clone() {
				if (this[kWebSocket]) {
					throw new TypeError("Cannot clone a response to a WebSocket handshake.");
				}
				const response = super.clone();
				Object.setPrototypeOf(response, Response.prototype);
				return response;
			}
		};
		var import_assert3 = __toESM2(require("assert"));
		var import_events = require("events");
		var import_ws = __toESM2(require_ws());
		var originalEnabled = $.enabled;
		function _forceColour(enabled = originalEnabled) {
			$.enabled = enabled;
		}
		var MiniflareError = class extends Error {
			constructor(code, message, cause) {
				super(message);
				this.code = code;
				this.cause = cause;
				Object.setPrototypeOf(this, new.target.prototype);
				this.name = `${new.target.name} [${code}]`;
			}
		};
		var MiniflareCoreError = class extends MiniflareError {};
		var TypedEventTarget = class extends EventTarget {
			addEventListener(type, listener, options) {
				super.addEventListener(type, listener, options);
			}
			removeEventListener(type, listener, options) {
				super.removeEventListener(type, listener, options);
			}
			dispatchEvent(event) {
				return super.dispatchEvent(event);
			}
		};
		var import_path4 = __toESM2(require("path"));
		var cwd = process.cwd();
		var cwdNodeModules = import_path4.default.join(cwd, "node_modules");
		var LEVEL_PREFIX = {
			[0]:
				/* NONE */
				"",
			[1]:
				/* ERROR */
				"err",
			[2]:
				/* WARN */
				"wrn",
			[3]:
				/* INFO */
				"inf",
			[4]:
				/* DEBUG */
				"dbg",
			[5]:
				/* VERBOSE */
				"vrb",
		};
		var LEVEL_COLOUR = {
			[0]:
				/* NONE */
				reset,
			[1]:
				/* ERROR */
				red,
			[2]:
				/* WARN */
				yellow,
			[3]:
				/* INFO */
				green,
			[4]:
				/* DEBUG */
				grey,
			[5]:
				/* VERBOSE */
				(input) => dim(grey(input)),
		};
		function prefixError(prefix, e) {
			if (e.stack) {
				return new Proxy(e, {
					get(target, propertyKey, receiver) {
						const value = Reflect.get(target, propertyKey, receiver);
						return propertyKey === "stack" ? `${prefix}: ${value}` : value;
					},
				});
			}
			return e;
		}
		function dimInternalStackLine(line) {
			if (
				line.startsWith("    at") &&
				(!line.includes(cwd) || line.includes(cwdNodeModules))
			) {
				return dim(line);
			}
			return line;
		}
		var _prefix;
		var _suffix;
		var _beforeLogHook;
		var _afterLogHook;
		var _Log = class {
			constructor(level = 3, opts = {}) {
				this.level = level;
				__privateAdd(this, _prefix, void 0);
				__privateAdd(this, _suffix, void 0);
				const prefix = opts.prefix ?? "mf";
				const suffix = opts.suffix ?? "";
				__privateSet(this, _prefix, prefix ? prefix + ":" : "");
				__privateSet(this, _suffix, suffix ? ":" + suffix : "");
			}
			log(message) {
				var _a2, _b2;
				(_a2 = __privateGet(_Log, _beforeLogHook)) == null ? void 0 : _a2.call(_Log);
				console.log(message);
				(_b2 = __privateGet(_Log, _afterLogHook)) == null ? void 0 : _b2.call(_Log);
			}
			static unstable_registerBeforeLogHook(callback) {
				__privateSet(this, _beforeLogHook, callback);
			}
			static unstable_registerAfterLogHook(callback) {
				__privateSet(this, _afterLogHook, callback);
			}
			logWithLevel(level, message) {
				if (level <= this.level) {
					const prefix = `[${__privateGet(this, _prefix)}${LEVEL_PREFIX[level]}${__privateGet(this, _suffix)}]`;
					this.log(LEVEL_COLOUR[level](`${prefix} ${message}`));
				}
			}
			error(message) {
				if (this.level < 1) {
				} else if (message.stack) {
					const lines = message.stack.split("\n").map(dimInternalStackLine);
					this.logWithLevel(1, lines.join("\n"));
				} else {
					this.logWithLevel(1, message.toString());
				}
				if (message.cause) {
					this.error(prefixError("Cause", message.cause));
				}
			}
			warn(message) {
				this.logWithLevel(2, message);
			}
			info(message) {
				this.logWithLevel(3, message);
			}
			debug(message) {
				this.logWithLevel(4, message);
			}
			verbose(message) {
				this.logWithLevel(5, message);
			}
		};
		var Log = _Log;
		_prefix = /* @__PURE__ */ new WeakMap();
		_suffix = /* @__PURE__ */ new WeakMap();
		_beforeLogHook = /* @__PURE__ */ new WeakMap();
		_afterLogHook = /* @__PURE__ */ new WeakMap();
		__privateAdd(Log, _beforeLogHook, void 0);
		__privateAdd(Log, _afterLogHook, void 0);
		var NoOpLog = class extends Log {
			constructor() {
				super(
					0,
					/* NONE */
				);
			}
			log() {}
			error(_message) {}
		};
		var ansiRegexpPattern = [
			"[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
			"(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))",
		].join("|");
		var ansiRegexp = new RegExp(ansiRegexpPattern, "g");
		function stripAnsi(value) {
			return value.replace(ansiRegexp, "");
		}
		var import_glob_to_regexp = __toESM2(require_glob_to_regexp());
		function globsToRegExps(globs = []) {
			const include = [];
			const exclude = [];
			const opts = { globstar: true, flags: "g" };
			for (const glob of globs) {
				if (glob.startsWith("!")) {
					exclude.push(
						new RegExp((0, import_glob_to_regexp.default)(glob.slice(1), opts), ""),
					);
				} else {
					include.push(new RegExp((0, import_glob_to_regexp.default)(glob, opts), ""));
				}
			}
			return { include, exclude };
		}
		var import_web = require("stream/web");
		function prefixStream(prefix, stream) {
			const identity = new import_web.TransformStream();
			const writer = identity.writable.getWriter();
			void writer
				.write(prefix)
				.then(() => {
					writer.releaseLock();
					return stream.pipeTo(identity.writable);
				})
				.catch((error) => {
					return writer.abort(error);
				});
			return identity.readable;
		}
		async function readPrefix(stream, prefixLength) {
			const chunks = [];
			let chunksLength = 0;
			for await (const chunk of stream.values({ preventCancel: true })) {
				chunks.push(chunk);
				chunksLength += chunk.byteLength;
				if (chunksLength >= prefixLength) break;
			}
			if (chunksLength < prefixLength) {
				throw new RangeError(
					`Expected ${prefixLength} byte prefix, but received ${chunksLength} byte stream`,
				);
			}
			const atLeastPrefix = Buffer.concat(chunks, chunksLength);
			const prefix = atLeastPrefix.subarray(0, prefixLength);
			let rest = stream;
			if (chunksLength > prefixLength) {
				rest = prefixStream(atLeastPrefix.subarray(prefixLength), stream);
			}
			return [prefix, rest];
		}
		var import_assert2 = __toESM2(require("assert"));
		var import_path5 = __toESM2(require("path"));
		var import_zod3 = require_lib();
		function zAwaitable(type) {
			return type.or(import_zod3.z.promise(type));
		}
		var LiteralSchema = import_zod3.z.union([
			import_zod3.z.string(),
			import_zod3.z.number(),
			import_zod3.z.boolean(),
			import_zod3.z.null(),
		]);
		var JsonSchema = import_zod3.z.lazy(() =>
			import_zod3.z.union([
				LiteralSchema,
				import_zod3.z.array(JsonSchema),
				import_zod3.z.record(JsonSchema),
			]),
		);
		var rootPath;
		function parseWithRootPath(newRootPath, schema, data, params) {
			rootPath = newRootPath;
			try {
				return schema.parse(data, params);
			} finally {
				rootPath = void 0;
			}
		}
		var PathSchema = import_zod3.z.string().transform((p) => {
			(0, import_assert2.default)(
				rootPath !== void 0,
				"Expected `PathSchema` to be parsed within `parseWithRootPath()`",
			);
			return import_path5.default.resolve(rootPath, p);
		});
		function _isCyclic(value, seen = /* @__PURE__ */ new Set()) {
			if (typeof value !== "object" || value === null) return false;
			for (const child of Object.values(value)) {
				if (seen.has(child)) return true;
				seen.add(child);
				if (_isCyclic(child, seen)) return true;
				seen.delete(child);
			}
			return false;
		}
		var MessageEvent = class extends Event {
			data;
			constructor(type, init2) {
				super(type);
				this.data = init2.data;
			}
		};
		var CloseEvent = class extends Event {
			code;
			reason;
			wasClean;
			constructor(type, init2) {
				super(type);
				this.code = init2?.code ?? 1005;
				this.reason = init2?.reason ?? "";
				this.wasClean = init2?.wasClean ?? false;
			}
		};
		var ErrorEvent = class extends Event {
			error;
			constructor(type, init2) {
				super(type);
				this.error = init2?.error ?? null;
			}
		};
		var kPair = Symbol("kPair");
		var kAccepted = Symbol("kAccepted");
		var kCoupled = Symbol("kCoupled");
		var kClosedOutgoing = Symbol("kClosedOutgoing");
		var kClosedIncoming = Symbol("kClosedIncoming");
		var kSend = Symbol("kSend");
		var kClose = Symbol("kClose");
		var kError = Symbol("kError");
		var _dispatchQueue;
		var _a;
		var _b;
		var _c;
		var _d;
		var _e;
		var _queuingDispatchToPair;
		var queuingDispatchToPair_fn;
		var _WebSocket = class extends TypedEventTarget {
			constructor() {
				super(...arguments);
				__privateAdd(this, _queuingDispatchToPair);
				__privateAdd(this, _dispatchQueue, []);
				__publicField(this, _a);
				__publicField(this, _b, false);
				__publicField(this, _c, false);
				__publicField(this, _d, false);
				__publicField(this, _e, false);
			}
			get readyState() {
				if (this[kClosedOutgoing] && this[kClosedIncoming]) {
					return _WebSocket.READY_STATE_CLOSED;
				} else if (this[kClosedOutgoing] || this[kClosedIncoming]) {
					return _WebSocket.READY_STATE_CLOSING;
				}
				return _WebSocket.READY_STATE_OPEN;
			}
			accept() {
				if (this[kCoupled]) {
					throw new TypeError(
						"Can't accept() WebSocket that was already used in a response.",
					);
				}
				if (this[kAccepted]) return;
				this[kAccepted] = true;
				if (__privateGet(this, _dispatchQueue) !== void 0) {
					for (const event of __privateGet(this, _dispatchQueue))
						this.dispatchEvent(event);
					__privateSet(this, _dispatchQueue, void 0);
				}
			}
			send(message) {
				if (!this[kAccepted]) {
					throw new TypeError(
						"You must call accept() on this WebSocket before sending messages.",
					);
				}
				this[kSend](message);
			}
			[((_a = kPair),
			(_b = kAccepted),
			(_c = kCoupled),
			(_d = kClosedOutgoing),
			(_e = kClosedIncoming),
			kSend)](message) {
				if (this[kClosedOutgoing]) {
					throw new TypeError("Can't call WebSocket send() after close().");
				}
				const event = new MessageEvent("message", { data: message });
				void __privateMethod(this, _queuingDispatchToPair, queuingDispatchToPair_fn).call(
					this,
					event,
				);
			}
			close(code, reason) {
				if (code) {
					const validCode =
						code >= 1e3 &&
						code < 5e3 &&
						code !== 1004 &&
						code !== 1005 &&
						code !== 1006 &&
						code !== 1015;
					if (!validCode) throw new TypeError("Invalid WebSocket close code.");
				}
				if (reason !== void 0 && code === void 0) {
					throw new TypeError(
						"If you specify a WebSocket close reason, you must also specify a code.",
					);
				}
				if (!this[kAccepted]) {
					throw new TypeError(
						"You must call accept() on this WebSocket before sending messages.",
					);
				}
				this[kClose](code, reason);
			}
			[kClose](code, reason) {
				if (this[kClosedOutgoing]) throw new TypeError("WebSocket already closed");
				const pair = this[kPair];
				(0, import_assert3.default)(pair !== void 0);
				this[kClosedOutgoing] = true;
				pair[kClosedIncoming] = true;
				const event = new CloseEvent("close", { code, reason });
				void __privateMethod(this, _queuingDispatchToPair, queuingDispatchToPair_fn).call(
					this,
					event,
				);
			}
			[kError](error) {
				const event = new ErrorEvent("error", { error });
				void __privateMethod(this, _queuingDispatchToPair, queuingDispatchToPair_fn).call(
					this,
					event,
				);
			}
		};
		var WebSocket = _WebSocket;
		_dispatchQueue = /* @__PURE__ */ new WeakMap();
		_queuingDispatchToPair = /* @__PURE__ */ new WeakSet();
		queuingDispatchToPair_fn = async function (event) {
			const pair = this[kPair];
			(0, import_assert3.default)(pair !== void 0);
			if (pair[kAccepted]) {
				pair.dispatchEvent(event);
			} else {
				(0, import_assert3.default)(__privateGet(pair, _dispatchQueue) !== void 0);
				__privateGet(pair, _dispatchQueue).push(event);
			}
		};
		__publicField(WebSocket, "READY_STATE_CONNECTING", 0);
		__publicField(WebSocket, "READY_STATE_OPEN", 1);
		__publicField(WebSocket, "READY_STATE_CLOSING", 2);
		__publicField(WebSocket, "READY_STATE_CLOSED", 3);
		var WebSocketPair = function () {
			if (!(this instanceof WebSocketPair)) {
				throw new TypeError(
					"Failed to construct 'WebSocketPair': Please use the 'new' operator, this object constructor cannot be called as a function.",
				);
			}
			this[0] = new WebSocket();
			this[1] = new WebSocket();
			this[0][kPair] = this[1];
			this[1][kPair] = this[0];
		};
		async function coupleWebSocket(ws, pair) {
			if (pair[kCoupled]) {
				throw new TypeError("Can't return WebSocket that was already used in a response.");
			}
			if (pair[kAccepted]) {
				throw new TypeError("Can't return WebSocket in a Response after calling accept().");
			}
			ws.on("message", (message, isBinary) => {
				if (!pair[kClosedOutgoing]) {
					pair[kSend](isBinary ? viewToBuffer(message) : message.toString());
				}
			});
			ws.on("close", (code, reason) => {
				if (!pair[kClosedOutgoing]) {
					pair[kClose](code, reason.toString());
				}
			});
			ws.on("error", (error) => {
				pair[kError](error);
			});
			pair.addEventListener("message", (e) => {
				ws.send(e.data);
			});
			pair.addEventListener("close", (e) => {
				if (e.code === 1005) {
					ws.close();
				} else if (e.code === 1006) {
					ws.terminate();
				} else {
					ws.close(e.code, e.reason);
				}
			});
			if (ws.readyState === import_ws.default.CONNECTING) {
				await (0, import_events.once)(ws, "open");
			} else if (ws.readyState >= import_ws.default.CLOSING) {
				throw new TypeError("Incoming WebSocket connection already closed.");
			}
			pair.accept();
			pair[kCoupled] = true;
		}
		var ignored = ["transfer-encoding", "connection", "keep-alive", "expect"];
		function headersFromIncomingRequest(req) {
			const entries = Object.entries(req.headers).filter((pair) => {
				const [name, value] = pair;
				return !ignored.includes(name) && value !== void 0;
			});
			return new undici.Headers(Object.fromEntries(entries));
		}
		async function fetch3(input, init2) {
			const requestInit = init2;
			const request = new Request(input, requestInit);
			if (request.method === "GET" && request.headers.get("upgrade") === "websocket") {
				const url18 = new URL(request.url);
				if (url18.protocol !== "http:" && url18.protocol !== "https:") {
					throw new TypeError(
						`Fetch API cannot load: ${url18.toString()}.
Make sure you're using http(s):// URLs for WebSocket requests via fetch.`,
					);
				}
				url18.protocol = url18.protocol.replace("http", "ws");
				const headers = {};
				let protocols;
				for (const [key, value] of request.headers.entries()) {
					if (key.toLowerCase() === "sec-websocket-protocol") {
						protocols = value.split(",").map((protocol) => protocol.trim());
					} else {
						headers[key] = value;
					}
				}
				let rejectUnauthorized;
				if (requestInit.dispatcher instanceof DispatchFetchDispatcher) {
					requestInit.dispatcher.addHeaders(headers, url18.pathname + url18.search);
					rejectUnauthorized = { rejectUnauthorized: false };
				}
				const ws = new import_ws2.default(url18, protocols, {
					followRedirects: request.redirect === "follow",
					headers,
					...rejectUnauthorized,
				});
				const responsePromise = new DeferredPromise();
				ws.once("upgrade", (req) => {
					const headers2 = headersFromIncomingRequest(req);
					const [worker, client] = Object.values(new WebSocketPair());
					const couplePromise = coupleWebSocket(ws, client);
					const response2 = new Response(null, {
						status: 101,
						webSocket: worker,
						headers: headers2,
					});
					responsePromise.resolve(couplePromise.then(() => response2));
				});
				ws.once("unexpected-response", (_, req) => {
					const headers2 = headersFromIncomingRequest(req);
					const response2 = new Response(req, {
						status: req.statusCode,
						headers: headers2,
					});
					responsePromise.resolve(response2);
				});
				return responsePromise;
			}
			const response = await undici.fetch(request, {
				dispatcher: requestInit?.dispatcher,
			});
			return new Response(response.body, response);
		}
		function addHeader(headers, key, value) {
			if (Array.isArray(headers)) headers.push(key, value);
			else headers[key] = value;
		}
		var DispatchFetchDispatcher = class extends undici.Dispatcher {
			/**
			 * @param globalDispatcher 		Dispatcher to use for all non-runtime requests
			 * 												 		(rejects unauthorised certificates)
			 * @param runtimeDispatcher 	Dispatcher to use for runtime requests
			 * 														(permits unauthorised certificates)
			 * @param actualRuntimeOrigin	Origin to send all runtime requests to
			 * @param userRuntimeOrigin 	Origin to treat as runtime request
			 * 														(initial URL passed by user to `dispatchFetch()`)
			 * @param cfBlob							`request.cf` blob override for runtime requests
			 */
			constructor(
				globalDispatcher,
				runtimeDispatcher,
				actualRuntimeOrigin,
				userRuntimeOrigin,
				cfBlob,
			) {
				super();
				this.globalDispatcher = globalDispatcher;
				this.runtimeDispatcher = runtimeDispatcher;
				this.actualRuntimeOrigin = actualRuntimeOrigin;
				this.userRuntimeOrigin = userRuntimeOrigin;
				if (cfBlob !== void 0) this.cfBlobJson = JSON.stringify(cfBlob);
			}
			cfBlobJson;
			addHeaders(headers, path28) {
				const originalURL = this.userRuntimeOrigin + path28;
				addHeader(headers, CoreHeaders.ORIGINAL_URL, originalURL);
				addHeader(headers, CoreHeaders.DISABLE_PRETTY_ERROR, "true");
				if (this.cfBlobJson !== void 0) {
					addHeader(headers, CoreHeaders.CF_BLOB, this.cfBlobJson);
				}
			}
			dispatch(options, handler) {
				let origin = String(options.origin);
				if (origin === this.userRuntimeOrigin) origin = this.actualRuntimeOrigin;
				if (origin === this.actualRuntimeOrigin) {
					options.origin = origin;
					let path28 = options.path;
					if (options.query !== void 0) {
						const url18 = new URL(path28, "http://placeholder/");
						for (const [key, value] of Object.entries(options.query)) {
							url18.searchParams.append(key, value);
						}
						path28 = url18.pathname + url18.search;
					}
					options.headers ??= {};
					this.addHeaders(options.headers, path28);
					return this.runtimeDispatcher.dispatch(options, handler);
				} else {
					return this.globalDispatcher.dispatch(options, handler);
				}
			}
			async close(callback) {
				await Promise.all([this.globalDispatcher.close(), this.runtimeDispatcher.close()]);
				callback?.();
			}
			async destroy(errCallback, callback) {
				let err = null;
				if (typeof errCallback === "function") callback = errCallback;
				if (errCallback instanceof Error) err = errCallback;
				await Promise.all([
					this.globalDispatcher.destroy(err),
					this.runtimeDispatcher.destroy(err),
				]);
				callback?.();
			}
			get isMockActive() {
				return this.globalDispatcher.isMockActive ?? false;
			}
		};
		var import_promises2 = __toESM2(require("fs/promises"));
		var KEY = `
-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIC+umAaVUbEfPqGA9M7b5zAP7tN2eLT1bu8U8gpbaKbsoAoGCCqGSM49
AwEHoUQDQgAEtrIEgzogjrUHIvB4qgjg/cT7blhWuLUfSUp6H62NCo21NrVWgPtC
mCWw+vbGTBwIr/9X1S4UL1/f3zDICC7YSA==
-----END EC PRIVATE KEY-----
`;
		var CERT = `
-----BEGIN CERTIFICATE-----
MIICcDCCAhegAwIBAgIUE97EcbEWw3YZMN/ucGBSzJ/5qA4wCgYIKoZIzj0EAwIw
VTELMAkGA1UEBhMCVVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4x
EzARBgNVBAoMCkNsb3VkZmxhcmUxEDAOBgNVBAsMB1dvcmtlcnMwIBcNMjMwNjIy
MTg1ODQ3WhgPMjEyMzA1MjkxODU4NDdaMFUxCzAJBgNVBAYTAlVTMQ4wDAYDVQQI
DAVUZXhhczEPMA0GA1UEBwwGQXVzdGluMRMwEQYDVQQKDApDbG91ZGZsYXJlMRAw
DgYDVQQLDAdXb3JrZXJzMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEtrIEgzog
jrUHIvB4qgjg/cT7blhWuLUfSUp6H62NCo21NrVWgPtCmCWw+vbGTBwIr/9X1S4U
L1/f3zDICC7YSKOBwjCBvzAdBgNVHQ4EFgQUSXahTksi00c6KhUECHIY4FLW7Sow
HwYDVR0jBBgwFoAUSXahTksi00c6KhUECHIY4FLW7SowDwYDVR0TAQH/BAUwAwEB
/zAsBglghkgBhvhCAQ0EHxYdT3BlblNTTCBHZW5lcmF0ZWQgQ2VydGlmaWNhdGUw
CwYDVR0PBAQDAgL0MDEGA1UdJQQqMCgGCCsGAQUFBwMBBggrBgEFBQcDAgYIKwYB
BQUHAwMGCCsGAQUFBwMIMAoGCCqGSM49BAMCA0cAMEQCIE2qnXbKTHQ8wtwI+9XR
h4ivDyz7w7iGxn3+ccmj/CQqAiApdX/Iz/jGRzi04xFlE4GoPVG/zaMi64ckmIpE
ez/dHA==
-----END CERTIFICATE-----
`;
		var ENTRY_SOCKET_HTTP_OPTIONS = {
			// Even though we inject a `cf` object in the entry worker, allow it to
			// be customised via `dispatchFetch`
			cfBlobHeader: CoreHeaders.CF_BLOB,
		};
		async function getEntrySocketHttpOptions(coreOpts) {
			let privateKey = void 0;
			let certificateChain = void 0;
			if (
				(coreOpts.httpsKey || coreOpts.httpsKeyPath) &&
				(coreOpts.httpsCert || coreOpts.httpsCertPath)
			) {
				privateKey = await valueOrFile(coreOpts.httpsKey, coreOpts.httpsKeyPath);
				certificateChain = await valueOrFile(coreOpts.httpsCert, coreOpts.httpsCertPath);
			} else if (coreOpts.https) {
				privateKey = KEY;
				certificateChain = CERT;
			}
			if (privateKey && certificateChain) {
				return {
					https: {
						options: ENTRY_SOCKET_HTTP_OPTIONS,
						tlsOptions: {
							keypair: {
								privateKey,
								certificateChain,
							},
						},
					},
				};
			} else {
				return { http: ENTRY_SOCKET_HTTP_OPTIONS };
			}
		}
		function valueOrFile(value, filePath) {
			return value ?? (filePath && import_promises2.default.readFile(filePath, "utf8"));
		}
		var import_os = require("os");
		function getAccessibleHosts(ipv4Only = false) {
			const hosts = [];
			Object.values((0, import_os.networkInterfaces)()).forEach((net2) => {
				net2?.forEach(({ family, address }) => {
					if (family === "IPv4" || family === 4) {
						hosts.push(address);
					} else if (!ipv4Only) {
						hosts.push(address);
					}
				});
			});
			return hosts;
		}
		var import_undici4 = require_undici();
		var import_node_crypto = __toESM2(require("crypto"));
		var import_promises7 = __toESM2(require("fs/promises"));
		var import_node_path2 = __toESM2(require("path"));
		var HEADER_SIZE = 20;
		var PATH_HASH_SIZE = 16;
		var CONTENT_HASH_SIZE = 16;
		var TAIL_SIZE = 8;
		var PATH_HASH_OFFSET = 0;
		var CONTENT_HASH_OFFSET = PATH_HASH_SIZE;
		var ENTRY_SIZE = PATH_HASH_SIZE + CONTENT_HASH_SIZE + TAIL_SIZE;
		var MAX_ASSET_COUNT = 2e4;
		var MAX_ASSET_SIZE = 25 * 1024 * 1024;
		var import_zod4 = require_lib();
		var RoutingConfigSchema = import_zod4.z.object({
			has_user_worker: import_zod4.z.boolean().optional(),
		});
		var AssetConfigSchema = import_zod4.z.object({
			html_handling: import_zod4.z
				.enum([
					"auto-trailing-slash",
					"force-trailing-slash",
					"drop-trailing-slash",
					"none",
				])
				.optional(),
			not_found_handling: import_zod4.z
				.enum(["single-page-application", "404-page", "none"])
				.optional(),
		});
		var import_node_path = require("path");
		var import_mime = __toESM2(require_mime());
		var normalizeFilePath = (relativeFilepath) => {
			if ((0, import_node_path.isAbsolute)(relativeFilepath)) {
				throw new Error(`Expected relative path`);
			}
			return "/" + relativeFilepath.split(import_node_path.sep).join("/");
		};
		var getContentType = (absFilePath) => {
			let contentType = (0, import_mime.getType)(absFilePath) || "application/octet-stream";
			if (contentType.startsWith("text/") && !contentType.includes("charset")) {
				contentType = `${contentType}; charset=utf-8`;
			}
			return contentType;
		};
		var BYTE_UNITS = ["B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
		var BIBYTE_UNITS = ["B", "kiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"];
		var BIT_UNITS = ["b", "kbit", "Mbit", "Gbit", "Tbit", "Pbit", "Ebit", "Zbit", "Ybit"];
		var BIBIT_UNITS = [
			"b",
			"kibit",
			"Mibit",
			"Gibit",
			"Tibit",
			"Pibit",
			"Eibit",
			"Zibit",
			"Yibit",
		];
		var toLocaleString = (number, locale, options) => {
			let result = number;
			if (typeof locale === "string" || Array.isArray(locale)) {
				result = number.toLocaleString(locale, options);
			} else if (locale === true || options !== void 0) {
				result = number.toLocaleString(void 0, options);
			}
			return result;
		};
		function prettyBytes(number, options) {
			if (!Number.isFinite(number)) {
				throw new TypeError(`Expected a finite number, got ${typeof number}: ${number}`);
			}
			options = {
				bits: false,
				binary: false,
				...options,
			};
			const UNITS = options.bits
				? options.binary
					? BIBIT_UNITS
					: BIT_UNITS
				: options.binary
					? BIBYTE_UNITS
					: BYTE_UNITS;
			if (options.signed && number === 0) {
				return ` 0 ${UNITS[0]}`;
			}
			const isNegative = number < 0;
			const prefix = isNegative ? "-" : options.signed ? "+" : "";
			if (isNegative) {
				number = -number;
			}
			let localeOptions;
			if (options.minimumFractionDigits !== void 0) {
				localeOptions = { minimumFractionDigits: options.minimumFractionDigits };
			}
			if (options.maximumFractionDigits !== void 0) {
				localeOptions = {
					maximumFractionDigits: options.maximumFractionDigits,
					...localeOptions,
				};
			}
			if (number < 1) {
				const numberString2 = toLocaleString(number, options.locale, localeOptions);
				return prefix + numberString2 + " " + UNITS[0];
			}
			const exponent = Math.min(
				Math.floor(
					options.binary ? Math.log(number) / Math.log(1024) : Math.log10(number) / 3,
				),
				UNITS.length - 1,
			);
			number /= (options.binary ? 1024 : 1e3) ** exponent;
			if (!localeOptions) {
				number = number.toPrecision(3);
			}
			const numberString = toLocaleString(Number(number), options.locale, localeOptions);
			const unit = UNITS[exponent];
			return prefix + numberString + " " + unit;
		}
		var import_fs3 = __toESM2(require("fs"));
		var import_path6 = __toESM2(require("path"));
		var import_url3 = __toESM2(require("url"));
		var contents3;
		function assets_worker_default() {
			if (contents3 !== void 0) return contents3;
			const filePath = import_path6.default.join(
				__dirname,
				"workers",
				"assets/assets.worker.js",
			);
			contents3 =
				import_fs3.default.readFileSync(filePath, "utf8") +
				"//# sourceURL=" +
				import_url3.default.pathToFileURL(filePath);
			return contents3;
		}
		var import_fs4 = __toESM2(require("fs"));
		var import_path7 = __toESM2(require("path"));
		var import_url4 = __toESM2(require("url"));
		var contents4;
		function assets_kv_worker_default() {
			if (contents4 !== void 0) return contents4;
			const filePath = import_path7.default.join(
				__dirname,
				"workers",
				"assets/assets-kv.worker.js",
			);
			contents4 =
				import_fs4.default.readFileSync(filePath, "utf8") +
				"//# sourceURL=" +
				import_url4.default.pathToFileURL(filePath);
			return contents4;
		}
		var import_fs5 = __toESM2(require("fs"));
		var import_path8 = __toESM2(require("path"));
		var import_url5 = __toESM2(require("url"));
		var contents5;
		function router_worker_default() {
			if (contents5 !== void 0) return contents5;
			const filePath = import_path8.default.join(
				__dirname,
				"workers",
				"assets/router.worker.js",
			);
			contents5 =
				import_fs5.default.readFileSync(filePath, "utf8") +
				"//# sourceURL=" +
				import_url5.default.pathToFileURL(filePath);
			return contents5;
		}
		var import_assert9 = __toESM2(require("assert"));
		var import_fs14 = require("fs");
		var import_promises6 = __toESM2(require("fs/promises"));
		var import_path17 = __toESM2(require("path"));
		var import_stream2 = require("stream");
		var import_tls = __toESM2(require("tls"));
		var import_util3 = require("util");
		var import_undici7 = require_undici();
		var import_fs6 = __toESM2(require("fs"));
		var import_path9 = __toESM2(require("path"));
		var import_url6 = __toESM2(require("url"));
		var contents6;
		function entry_worker_default() {
			if (contents6 !== void 0) return contents6;
			const filePath = import_path9.default.join(
				__dirname,
				"workers",
				"core/entry.worker.js",
			);
			contents6 =
				import_fs6.default.readFileSync(filePath, "utf8") +
				"//# sourceURL=" +
				import_url6.default.pathToFileURL(filePath);
			return contents6;
		}
		var import_zod12 = require_lib();
		var import_assert4 = __toESM2(require("assert"));
		var import_child_process = __toESM2(require("child_process"));
		var import_events2 = require("events");
		var import_readline = __toESM2(require("readline"));
		var import_stream = require("stream");
		var import_workerd2 = __toESM2(require("workerd"));
		var import_zod5 = require_lib();
		var import_capnp_ts = require_src2();
		var import_workerd_capnp = __toESM2(require_workerd_capnp());
		var kVoid = Symbol("kVoid");
		var import_workerd_capnp2 = __toESM2(require_workerd_capnp());
		function capitalize(str) {
			return str.length > 0 ? str[0].toUpperCase() + str.substring(1) : str;
		}
		function encodeCapnpStruct(obj, struct) {
			const anyStruct = struct;
			for (const [key, value] of Object.entries(obj)) {
				const capitalized = capitalize(key);
				if (value instanceof Uint8Array) {
					const newData = anyStruct[`init${capitalized}`](value.byteLength);
					newData.copyBuffer(value);
				} else if (Array.isArray(value)) {
					const newList = anyStruct[`init${capitalized}`](value.length);
					for (let i = 0; i < value.length; i++) {
						if (typeof value[i] === "object") {
							encodeCapnpStruct(value[i], newList.get(i));
						} else {
							newList.set(i, value[i]);
						}
					}
				} else if (typeof value === "object") {
					const newStruct = anyStruct[`init${capitalized}`]();
					encodeCapnpStruct(value, newStruct);
				} else if (value === kVoid) {
					anyStruct[`set${capitalized}`]();
				} else if (value !== void 0) {
					anyStruct[`set${capitalized}`](value);
				}
			}
		}
		function serializeConfig2(config) {
			const message = new import_capnp_ts.Message();
			const struct = message.initRoot(import_workerd_capnp2.Config);
			encodeCapnpStruct(config, struct);
			return Buffer.from(message.toArrayBuffer());
		}
		var ControlMessageSchema = import_zod5.z.discriminatedUnion("event", [
			import_zod5.z.object({
				event: import_zod5.z.literal("listen"),
				socket: import_zod5.z.string(),
				port: import_zod5.z.number(),
			}),
			import_zod5.z.object({
				event: import_zod5.z.literal("listen-inspector"),
				port: import_zod5.z.number(),
			}),
		]);
		var kInspectorSocket = Symbol("kInspectorSocket");
		async function waitForPorts(stream, options) {
			if (options?.signal?.aborted) return;
			const lines = import_readline.default.createInterface(stream);
			const abortListener = () => lines.close();
			options?.signal?.addEventListener("abort", abortListener, { once: true });
			const requiredSockets = Array.from(options.requiredSockets);
			const socketPorts = /* @__PURE__ */ new Map();
			try {
				for await (const line of lines) {
					const message = ControlMessageSchema.safeParse(JSON.parse(line));
					if (!message.success) continue;
					const data = message.data;
					const socket =
						data.event === "listen-inspector" ? kInspectorSocket : data.socket;
					const index = requiredSockets.indexOf(socket);
					if (index === -1) continue;
					socketPorts.set(socket, data.port);
					requiredSockets.splice(index, 1);
					if (requiredSockets.length === 0) return socketPorts;
				}
			} finally {
				options?.signal?.removeEventListener("abort", abortListener);
			}
		}
		function waitForExit(process2) {
			return new Promise((resolve) => {
				process2.once("exit", () => resolve());
			});
		}
		function pipeOutput(stdout, stderr) {
			import_readline.default.createInterface(stdout).on("line", (data) => console.log(data));
			import_readline.default
				.createInterface(stderr)
				.on("line", (data) => console.error(red(data)));
		}
		function getRuntimeCommand() {
			return process.env.MINIFLARE_WORKERD_PATH ?? import_workerd2.default;
		}
		function getRuntimeArgs(options) {
			const args = [
				"serve",
				// Required to use binary capnp config
				"--binary",
				// Required to use compatibility flags without a default-on date,
				// (e.g. "streams_enable_constructors"), see https://github.com/cloudflare/workerd/pull/21
				"--experimental",
				`--socket-addr=${SOCKET_ENTRY}=${options.entryAddress}`,
				`--external-addr=${SERVICE_LOOPBACK}=${options.loopbackAddress}`,
				// Configure extra pipe for receiving control messages (e.g. when ready)
				"--control-fd=3",
				// Read config from stdin
				"-",
			];
			if (options.inspectorAddress !== void 0) {
				args.push(`--inspector-addr=${options.inspectorAddress}`);
			}
			if (options.verbose) {
				args.push("--verbose");
			}
			return args;
		}
		var Runtime = class {
			#process;
			#processExitPromise;
			async updateConfig(configBuffer, options) {
				await this.dispose();
				const command = getRuntimeCommand();
				const args = getRuntimeArgs(options);
				const FORCE_COLOR2 = $.enabled ? "1" : "0";
				const runtimeProcess = import_child_process.default.spawn(command, args, {
					stdio: ["pipe", "pipe", "pipe", "pipe"],
					env: { ...process.env, FORCE_COLOR: FORCE_COLOR2 },
				});
				this.#process = runtimeProcess;
				this.#processExitPromise = waitForExit(runtimeProcess);
				const handleRuntimeStdio = options.handleRuntimeStdio ?? pipeOutput;
				handleRuntimeStdio(runtimeProcess.stdout, runtimeProcess.stderr);
				const controlPipe = runtimeProcess.stdio[3];
				(0, import_assert4.default)(controlPipe instanceof import_stream.Readable);
				runtimeProcess.stdin.write(configBuffer);
				runtimeProcess.stdin.end();
				await (0, import_events2.once)(runtimeProcess.stdin, "finish");
				return waitForPorts(controlPipe, options);
			}
			dispose() {
				this.#process?.kill("SIGKILL");
				return this.#processExitPromise;
			}
		};
		var ASSETS_PLUGIN_NAME = "assets";
		var ASSETS_SERVICE_NAME = `${ASSETS_PLUGIN_NAME}:assets-service`;
		var ROUTER_SERVICE_NAME = `${ASSETS_PLUGIN_NAME}:router`;
		var ASSETS_KV_SERVICE_NAME = `${ASSETS_PLUGIN_NAME}:kv`;
		var import_promises4 = __toESM2(require("fs/promises"));
		var import_fs7 = __toESM2(require("fs"));
		var import_path10 = __toESM2(require("path"));
		var import_url7 = __toESM2(require("url"));
		var contents7;
		function cache_worker_default() {
			if (contents7 !== void 0) return contents7;
			const filePath = import_path10.default.join(
				__dirname,
				"workers",
				"cache/cache.worker.js",
			);
			contents7 =
				import_fs7.default.readFileSync(filePath, "utf8") +
				"//# sourceURL=" +
				import_url7.default.pathToFileURL(filePath);
			return contents7;
		}
		var import_fs8 = __toESM2(require("fs"));
		var import_path11 = __toESM2(require("path"));
		var import_url8 = __toESM2(require("url"));
		var contents8;
		function cache_entry_worker_default() {
			if (contents8 !== void 0) return contents8;
			const filePath = import_path11.default.join(
				__dirname,
				"workers",
				"cache/cache-entry.worker.js",
			);
			contents8 =
				import_fs8.default.readFileSync(filePath, "utf8") +
				"//# sourceURL=" +
				import_url8.default.pathToFileURL(filePath);
			return contents8;
		}
		var import_fs9 = __toESM2(require("fs"));
		var import_path12 = __toESM2(require("path"));
		var import_url9 = __toESM2(require("url"));
		var contents9;
		function cache_entry_noop_worker_default() {
			if (contents9 !== void 0) return contents9;
			const filePath = import_path12.default.join(
				__dirname,
				"workers",
				"cache/cache-entry-noop.worker.js",
			);
			contents9 =
				import_fs9.default.readFileSync(filePath, "utf8") +
				"//# sourceURL=" +
				import_url9.default.pathToFileURL(filePath);
			return contents9;
		}
		var import_zod7 = require_lib();
		var import_crypto = __toESM2(require("crypto"));
		var import_fs11 = require("fs");
		var import_promises3 = __toESM2(require("fs/promises"));
		var import_path14 = __toESM2(require("path"));
		var import_url12 = require("url");
		var import_zod6 = require_lib();
		var import_fs10 = __toESM2(require("fs"));
		var import_path13 = __toESM2(require("path"));
		var import_url10 = __toESM2(require("url"));
		var contents10;
		function object_entry_worker_default() {
			if (contents10 !== void 0) return contents10;
			const filePath = import_path13.default.join(
				__dirname,
				"workers",
				"shared/object-entry.worker.js",
			);
			contents10 =
				import_fs10.default.readFileSync(filePath, "utf8") +
				"//# sourceURL=" +
				import_url10.default.pathToFileURL(filePath);
			return contents10;
		}
		var SOCKET_ENTRY = "entry";
		var SOCKET_ENTRY_LOCAL = "entry:local";
		var SOCKET_DIRECT_PREFIX = "direct";
		function getDirectSocketName(workerIndex, entrypoint) {
			return `${SOCKET_DIRECT_PREFIX}:${workerIndex}:${entrypoint}`;
		}
		var SERVICE_LOOPBACK = "loopback";
		var HOST_CAPNP_CONNECT = "miniflare-unsafe-internal-capnp-connect";
		var WORKER_BINDING_SERVICE_LOOPBACK = {
			name: CoreBindings.SERVICE_LOOPBACK,
			service: { name: SERVICE_LOOPBACK },
		};
		var WORKER_BINDING_ENABLE_CONTROL_ENDPOINTS = {
			name: SharedBindings.MAYBE_JSON_ENABLE_CONTROL_ENDPOINTS,
			json: "true",
		};
		var WORKER_BINDING_ENABLE_STICKY_BLOBS = {
			name: SharedBindings.MAYBE_JSON_ENABLE_STICKY_BLOBS,
			json: "true",
		};
		var enableControlEndpoints = false;
		function getMiniflareObjectBindings(unsafeStickyBlobs) {
			const result = [];
			if (enableControlEndpoints) {
				result.push(WORKER_BINDING_ENABLE_CONTROL_ENDPOINTS);
			}
			if (unsafeStickyBlobs) {
				result.push(WORKER_BINDING_ENABLE_STICKY_BLOBS);
			}
			return result;
		}
		function _enableControlEndpoints() {
			enableControlEndpoints = true;
		}
		function objectEntryWorker(durableObjectNamespace, namespace) {
			return {
				compatibilityDate: "2023-07-24",
				modules: [
					{ name: "object-entry.worker.js", esModule: object_entry_worker_default() },
				],
				bindings: [
					{ name: SharedBindings.TEXT_NAMESPACE, text: namespace },
					{
						name: SharedBindings.DURABLE_OBJECT_NAMESPACE_OBJECT,
						durableObjectNamespace,
					},
				],
			};
		}
		var kUnsafeEphemeralUniqueKey = Symbol.for("miniflare.kUnsafeEphemeralUniqueKey");
		var import_url11 = require("url");
		var RouterError = class extends MiniflareError {};
		function routeSpecificity(url18) {
			const hostParts = url18.host.split(".");
			let hostScore = hostParts.length;
			if (hostParts[0] === "*") hostScore -= 2;
			const pathParts = url18.pathname.split("/");
			let pathScore = pathParts.length;
			if (pathParts[pathParts.length - 1] === "*") pathScore -= 2;
			return hostScore * 26 + pathScore;
		}
		function parseRoutes(allRoutes) {
			const routes = [];
			for (const [target, targetRoutes] of allRoutes) {
				for (const route of targetRoutes) {
					const hasProtocol = /^[a-z0-9+\-.]+:\/\//i.test(route);
					let urlInput = route;
					if (!hasProtocol) urlInput = `https://${urlInput}`;
					const url18 = new import_url11.URL(urlInput);
					const specificity = routeSpecificity(url18);
					const protocol = hasProtocol ? url18.protocol : void 0;
					const internationalisedAllowHostnamePrefix = url18.hostname.startsWith("xn--*");
					const allowHostnamePrefix =
						url18.hostname.startsWith("*") || internationalisedAllowHostnamePrefix;
					const anyHostname = url18.hostname === "*";
					if (allowHostnamePrefix && !anyHostname) {
						let hostname = url18.hostname;
						if (internationalisedAllowHostnamePrefix) {
							hostname = (0, import_url11.domainToUnicode)(hostname);
						}
						url18.hostname = hostname.substring(1);
					}
					const allowPathSuffix = url18.pathname.endsWith("*");
					if (allowPathSuffix) {
						url18.pathname = url18.pathname.substring(0, url18.pathname.length - 1);
					}
					if (url18.search) {
						throw new RouterError(
							"ERR_QUERY_STRING",
							`Route "${route}" for "${target}" contains a query string. This is not allowed.`,
						);
					}
					if (url18.toString().includes("*") && !anyHostname) {
						throw new RouterError(
							"ERR_INFIX_WILDCARD",
							`Route "${route}" for "${target}" contains an infix wildcard. This is not allowed.`,
						);
					}
					routes.push({
						target,
						route,
						specificity,
						protocol,
						allowHostnamePrefix,
						hostname: anyHostname ? "" : url18.hostname,
						path: url18.pathname,
						allowPathSuffix,
					});
				}
			}
			routes.sort((a, b) => {
				if (a.specificity === b.specificity) {
					return b.route.length - a.route.length;
				} else {
					return b.specificity - a.specificity;
				}
			});
			return routes;
		}
		var DEFAULT_PERSIST_ROOT = ".mf";
		var PersistenceSchema = import_zod6.z
			.union([import_zod6.z.boolean(), import_zod6.z.string().url(), PathSchema])
			.optional();
		var ProxyNodeBinding = class {
			constructor(proxyOverrideHandler) {
				this.proxyOverrideHandler = proxyOverrideHandler;
			}
		};
		function namespaceKeys(namespaces) {
			if (Array.isArray(namespaces)) {
				return namespaces;
			} else if (namespaces !== void 0) {
				return Object.keys(namespaces);
			} else {
				return [];
			}
		}
		function namespaceEntries(namespaces) {
			if (Array.isArray(namespaces)) {
				return namespaces.map((bindingName) => [bindingName, bindingName]);
			} else if (namespaces !== void 0) {
				return Object.entries(namespaces);
			} else {
				return [];
			}
		}
		function maybeParseURL(url18) {
			if (typeof url18 !== "string" || import_path14.default.isAbsolute(url18)) return;
			try {
				return new URL(url18);
			} catch {}
		}
		function getPersistPath(pluginName, tmpPath, persist) {
			const memoryishPath = import_path14.default.join(tmpPath, pluginName);
			if (persist === void 0 || persist === false) {
				return memoryishPath;
			}
			const url18 = maybeParseURL(persist);
			if (url18 !== void 0) {
				if (url18.protocol === "memory:") {
					return memoryishPath;
				} else if (url18.protocol === "file:") {
					return (0, import_url12.fileURLToPath)(url18);
				}
				throw new MiniflareCoreError(
					"ERR_PERSIST_UNSUPPORTED",
					`Unsupported "${url18.protocol}" persistence protocol for storage: ${url18.href}`,
				);
			}
			return persist === true
				? import_path14.default.join(DEFAULT_PERSIST_ROOT, pluginName)
				: persist;
		}
		function durableObjectNamespaceIdFromName(uniqueKey, name) {
			const key = import_crypto.default.createHash("sha256").update(uniqueKey).digest();
			const nameHmac = import_crypto.default
				.createHmac("sha256", key)
				.update(name)
				.digest()
				.subarray(0, 16);
			const hmac = import_crypto.default
				.createHmac("sha256", key)
				.update(nameHmac)
				.digest()
				.subarray(0, 16);
			return Buffer.concat([nameHmac, hmac]).toString("hex");
		}
		async function migrateDatabase(log, uniqueKey, persistPath, namespace) {
			const sanitisedNamespace = sanitisePath(namespace);
			const previousDir = import_path14.default.join(persistPath, sanitisedNamespace);
			const previousPath = import_path14.default.join(previousDir, "db.sqlite");
			const previousWalPath = import_path14.default.join(previousDir, "db.sqlite-wal");
			if (!(0, import_fs11.existsSync)(previousPath)) return;
			const id = durableObjectNamespaceIdFromName(uniqueKey, namespace);
			const newDir = import_path14.default.join(persistPath, uniqueKey);
			const newPath = import_path14.default.join(newDir, `${id}.sqlite`);
			const newWalPath = import_path14.default.join(newDir, `${id}.sqlite-wal`);
			if ((0, import_fs11.existsSync)(newPath)) {
				log.debug(`Not migrating ${previousPath} to ${newPath} as it already exists`);
				return;
			}
			log.debug(`Migrating ${previousPath} to ${newPath}...`);
			await import_promises3.default.mkdir(newDir, { recursive: true });
			try {
				await import_promises3.default.copyFile(previousPath, newPath);
				if ((0, import_fs11.existsSync)(previousWalPath)) {
					await import_promises3.default.copyFile(previousWalPath, newWalPath);
				}
				await import_promises3.default.unlink(previousPath);
				await import_promises3.default.unlink(previousWalPath);
			} catch (e) {
				log.warn(`Error migrating ${previousPath} to ${newPath}: ${e}`);
			}
		}
		var CacheOptionsSchema = import_zod7.z.object({
			cache: import_zod7.z.boolean().optional(),
			cacheWarnUsage: import_zod7.z.boolean().optional(),
		});
		var CacheSharedOptionsSchema = import_zod7.z.object({
			cachePersist: PersistenceSchema,
		});
		var CACHE_PLUGIN_NAME = "cache";
		var CACHE_STORAGE_SERVICE_NAME = `${CACHE_PLUGIN_NAME}:storage`;
		var CACHE_SERVICE_PREFIX = `${CACHE_PLUGIN_NAME}:cache`;
		var CACHE_OBJECT_CLASS_NAME = "CacheObject";
		var CACHE_OBJECT = {
			serviceName: CACHE_SERVICE_PREFIX,
			className: CACHE_OBJECT_CLASS_NAME,
		};
		function getCacheServiceName(workerIndex) {
			return `${CACHE_PLUGIN_NAME}:${workerIndex}`;
		}
		var CACHE_PLUGIN = {
			options: CacheOptionsSchema,
			sharedOptions: CacheSharedOptionsSchema,
			getBindings() {
				return [];
			},
			getNodeBindings() {
				return {};
			},
			async getServices({ sharedOptions, options, workerIndex, tmpPath, unsafeStickyBlobs }) {
				const cache = options.cache ?? true;
				const cacheWarnUsage = options.cacheWarnUsage ?? false;
				let entryWorker;
				if (cache) {
					entryWorker = {
						compatibilityDate: "2023-07-24",
						compatibilityFlags: ["nodejs_compat", "experimental"],
						modules: [
							{
								name: "cache-entry.worker.js",
								esModule: cache_entry_worker_default(),
							},
						],
						bindings: [
							{
								name: SharedBindings.DURABLE_OBJECT_NAMESPACE_OBJECT,
								durableObjectNamespace: CACHE_OBJECT,
							},
							{
								name: CacheBindings.MAYBE_JSON_CACHE_WARN_USAGE,
								json: JSON.stringify(cacheWarnUsage),
							},
						],
					};
				} else {
					entryWorker = {
						compatibilityDate: "2023-07-24",
						compatibilityFlags: ["nodejs_compat", "experimental"],
						modules: [
							{
								name: "cache-entry-noop.worker.js",
								esModule: cache_entry_noop_worker_default(),
							},
						],
					};
				}
				const services = [{ name: getCacheServiceName(workerIndex), worker: entryWorker }];
				if (cache) {
					const uniqueKey = `miniflare-${CACHE_OBJECT_CLASS_NAME}`;
					const persist = sharedOptions.cachePersist;
					const persistPath = getPersistPath(CACHE_PLUGIN_NAME, tmpPath, persist);
					await import_promises4.default.mkdir(persistPath, { recursive: true });
					const storageService = {
						name: CACHE_STORAGE_SERVICE_NAME,
						disk: { path: persistPath, writable: true },
					};
					const objectService = {
						name: CACHE_SERVICE_PREFIX,
						worker: {
							compatibilityDate: "2023-07-24",
							compatibilityFlags: ["nodejs_compat", "experimental"],
							modules: [
								{
									name: "cache.worker.js",
									esModule: cache_worker_default(),
								},
							],
							durableObjectNamespaces: [
								{
									className: CACHE_OBJECT_CLASS_NAME,
									uniqueKey,
								},
							],
							// Store Durable Object SQL databases in persist path
							durableObjectStorage: { localDisk: CACHE_STORAGE_SERVICE_NAME },
							// Bind blob disk directory service to object
							bindings: [
								{
									name: SharedBindings.MAYBE_SERVICE_BLOBS,
									service: { name: CACHE_STORAGE_SERVICE_NAME },
								},
								{
									name: SharedBindings.MAYBE_SERVICE_LOOPBACK,
									service: { name: SERVICE_LOOPBACK },
								},
								...getMiniflareObjectBindings(unsafeStickyBlobs),
							],
						},
					};
					services.push(storageService, objectService);
				}
				return services;
			},
			getPersistPath({ cachePersist }, tmpPath) {
				return getPersistPath(CACHE_PLUGIN_NAME, tmpPath, cachePersist);
			},
		};
		var import_promises5 = __toESM2(require("fs/promises"));
		var import_zod8 = require_lib();
		var DurableObjectsOptionsSchema = import_zod8.z.object({
			durableObjects: import_zod8.z
				.record(
					import_zod8.z.union([
						import_zod8.z.string(),
						import_zod8.z.object({
							className: import_zod8.z.string(),
							scriptName: import_zod8.z.string().optional(),
							useSQLite: import_zod8.z.boolean().optional(),
							// Allow `uniqueKey` to be customised. We use in Wrangler when setting
							// up stub Durable Objects that proxy requests to Durable Objects in
							// another `workerd` process, to ensure the IDs created by the stub
							// object can be used by the real object too.
							unsafeUniqueKey: import_zod8.z
								.union([
									import_zod8.z.string(),
									import_zod8.z.literal(kUnsafeEphemeralUniqueKey),
								])
								.optional(),
							// Prevents the Durable Object being evicted.
							unsafePreventEviction: import_zod8.z.boolean().optional(),
						}),
					]),
				)
				.optional(),
		});
		var DurableObjectsSharedOptionsSchema = import_zod8.z.object({
			durableObjectsPersist: PersistenceSchema,
		});
		function normaliseDurableObject(designator) {
			const isObject = typeof designator === "object";
			const className = isObject ? designator.className : designator;
			const serviceName =
				isObject && designator.scriptName !== void 0
					? getUserServiceName(designator.scriptName)
					: void 0;
			const enableSql = isObject ? designator.useSQLite : void 0;
			const unsafeUniqueKey = isObject ? designator.unsafeUniqueKey : void 0;
			const unsafePreventEviction = isObject ? designator.unsafePreventEviction : void 0;
			return {
				className,
				serviceName,
				enableSql,
				unsafeUniqueKey,
				unsafePreventEviction,
			};
		}
		var DURABLE_OBJECTS_PLUGIN_NAME = "do";
		var DURABLE_OBJECTS_STORAGE_SERVICE_NAME = `${DURABLE_OBJECTS_PLUGIN_NAME}:storage`;
		var DURABLE_OBJECTS_PLUGIN = {
			options: DurableObjectsOptionsSchema,
			sharedOptions: DurableObjectsSharedOptionsSchema,
			getBindings(options) {
				return Object.entries(options.durableObjects ?? {}).map(([name, klass]) => {
					const { className, serviceName } = normaliseDurableObject(klass);
					return {
						name,
						durableObjectNamespace: { className, serviceName },
					};
				});
			},
			getNodeBindings(options) {
				const objects = Object.keys(options.durableObjects ?? {});
				return Object.fromEntries(objects.map((name) => [name, new ProxyNodeBinding()]));
			},
			async getServices({
				sharedOptions,
				tmpPath,
				durableObjectClassNames,
				unsafeEphemeralDurableObjects,
			}) {
				let hasDurableObjects = false;
				for (const classNames of durableObjectClassNames.values()) {
					if (classNames.size > 0) {
						hasDurableObjects = true;
						break;
					}
				}
				if (!hasDurableObjects) return;
				if (unsafeEphemeralDurableObjects) return;
				const storagePath = getPersistPath(
					DURABLE_OBJECTS_PLUGIN_NAME,
					tmpPath,
					sharedOptions.durableObjectsPersist,
				);
				await import_promises5.default.mkdir(storagePath, { recursive: true });
				return [
					{
						// Note this service will be de-duped by name if multiple Workers create
						// it. Each Worker will have the same `sharedOptions` though, so this
						// isn't a problem.
						name: DURABLE_OBJECTS_STORAGE_SERVICE_NAME,
						disk: { path: storagePath, writable: true },
					},
				];
			},
			getPersistPath({ durableObjectsPersist }, tmpPath) {
				return getPersistPath(DURABLE_OBJECTS_PLUGIN_NAME, tmpPath, durableObjectsPersist);
			},
		};
		var CORE_PLUGIN_NAME = "core";
		var SERVICE_ENTRY = `${CORE_PLUGIN_NAME}:entry`;
		var SERVICE_USER_PREFIX = `${CORE_PLUGIN_NAME}:user`;
		var SERVICE_BUILTIN_PREFIX = `${CORE_PLUGIN_NAME}:builtin`;
		var SERVICE_CUSTOM_PREFIX = `${CORE_PLUGIN_NAME}:custom`;
		function getUserServiceName(workerName = "") {
			return `${SERVICE_USER_PREFIX}:${workerName}`;
		}
		var CUSTOM_SERVICE_KNOWN_OUTBOUND = "outbound";
		function getBuiltinServiceName(workerIndex, kind, bindingName) {
			return `${SERVICE_BUILTIN_PREFIX}:${workerIndex}:${kind}${bindingName}`;
		}
		function getCustomServiceName(workerIndex, kind, bindingName) {
			return `${SERVICE_CUSTOM_PREFIX}:${workerIndex}:${kind}${bindingName}`;
		}
		var import_assert5 = __toESM2(require("assert"));
		var import_fs12 = require("fs");
		var import_module = require("module");
		var import_path15 = __toESM2(require("path"));
		var import_url13 = require("url");
		var import_util = require("util");
		var import_acorn = require_acorn();
		var import_acorn_walk = require_walk();
		var import_zod9 = require_lib();
		function getNodeCompat(compatibilityDate = "2000-01-01", compatibilityFlags, opts) {
			const { nodeCompat = false } = opts ?? {};
			const {
				hasNodejsAlsFlag,
				hasNodejsCompatFlag,
				hasNodejsCompatV2Flag,
				hasNoNodejsCompatV2Flag,
				hasExperimentalNodejsCompatV2Flag,
			} = parseNodeCompatibilityFlags(compatibilityFlags);
			const nodeCompatSwitchOverDate = "2024-09-23";
			const legacy = nodeCompat === true;
			let mode = null;
			if (
				hasNodejsCompatV2Flag ||
				(hasNodejsCompatFlag &&
					compatibilityDate >= nodeCompatSwitchOverDate &&
					!hasNoNodejsCompatV2Flag)
			) {
				mode = "v2";
			} else if (hasNodejsCompatFlag) {
				mode = "v1";
			} else if (hasNodejsAlsFlag) {
				mode = "als";
			} else if (legacy) {
				mode = "legacy";
			}
			return {
				mode,
				hasNodejsAlsFlag,
				hasNodejsCompatFlag,
				hasNodejsCompatV2Flag,
				hasNoNodejsCompatV2Flag,
				hasExperimentalNodejsCompatV2Flag,
			};
		}
		function parseNodeCompatibilityFlags(compatibilityFlags) {
			return {
				hasNodejsAlsFlag: compatibilityFlags.includes("nodejs_als"),
				hasNodejsCompatFlag: compatibilityFlags.includes("nodejs_compat"),
				hasNodejsCompatV2Flag: compatibilityFlags.includes("nodejs_compat_v2"),
				hasNoNodejsCompatV2Flag: compatibilityFlags.includes("no_nodejs_compat_v2"),
				hasExperimentalNodejsCompatV2Flag: compatibilityFlags.includes(
					"experimental:nodejs_compat_v2",
				),
			};
		}
		var SUGGEST_BUNDLE =
			"If you're trying to import an npm package, you'll need to bundle your Worker first.";
		var SUGGEST_NODE =
			"If you're trying to import a Node.js built-in module, or an npm package that uses Node.js built-ins, you'll either need to:\n- Bundle your Worker, configuring your bundler to polyfill Node.js built-ins\n- Configure your bundler to load Workers-compatible builds by changing the main fields/conditions\n- Enable the `nodejs_compat` compatibility flag and use the `NodeJsCompatModule` module type\n- Find an alternative package that doesn't require Node.js built-ins";
		var builtinModulesWithPrefix = import_module.builtinModules.concat(
			import_module.builtinModules.map((module22) => `node:${module22}`),
		);
		function buildStringScriptPath(workerIndex) {
			return `script:${workerIndex}`;
		}
		var stringScriptRegexp = /^script:(\d+)$/;
		function maybeGetStringScriptPathIndex(scriptPath) {
			const match = stringScriptRegexp.exec(scriptPath);
			return match === null ? void 0 : parseInt(match[1]);
		}
		var ModuleRuleTypeSchema = import_zod9.z.enum([
			"ESModule",
			"CommonJS",
			"NodeJsCompatModule",
			"Text",
			"Data",
			"CompiledWasm",
			"PythonModule",
			"PythonRequirement",
		]);
		var ModuleRuleSchema = import_zod9.z.object({
			type: ModuleRuleTypeSchema,
			include: import_zod9.z.string().array(),
			fallthrough: import_zod9.z.boolean().optional(),
		});
		var ModuleDefinitionSchema = import_zod9.z.object({
			type: ModuleRuleTypeSchema,
			path: PathSchema,
			contents: import_zod9.z.string().or(import_zod9.z.instanceof(Uint8Array)).optional(),
		});
		var SourceOptionsSchema = import_zod9.z.union([
			import_zod9.z.object({
				// Manually defined modules
				// (used by Wrangler which has its own module collection code)
				modules: import_zod9.z.array(ModuleDefinitionSchema),
				// `modules` "name"s will be their paths relative to this value.
				// This ensures file paths in stack traces are correct.
				modulesRoot: PathSchema.optional(),
			}),
			import_zod9.z.object({
				script: import_zod9.z.string(),
				// Optional script path for resolving modules, and stack traces file names
				scriptPath: PathSchema.optional(),
				// Automatically collect modules by parsing `script` if `true`, or treat as
				// service-worker if `false`
				modules: import_zod9.z.boolean().optional(),
				// How to interpret automatically collected modules
				modulesRules: import_zod9.z.array(ModuleRuleSchema).optional(),
				// `modules` "name"s will be their paths relative to this value.
				// This ensures file paths in stack traces are correct.
				modulesRoot: PathSchema.optional(),
			}),
			import_zod9.z.object({
				scriptPath: PathSchema,
				// Automatically collect modules by parsing `scriptPath` if `true`, or treat
				// as service-worker if `false`
				modules: import_zod9.z.boolean().optional(),
				// How to interpret automatically collected modules
				modulesRules: import_zod9.z.array(ModuleRuleSchema).optional(),
				// `modules` "name"s will be their paths relative to this value.
				// This ensures file paths in stack traces are correct.
				modulesRoot: PathSchema.optional(),
			}),
		]);
		var DEFAULT_MODULE_RULES = [
			{ type: "ESModule", include: ["**/*.mjs"] },
			{ type: "CommonJS", include: ["**/*.js", "**/*.cjs"] },
		];
		function compileModuleRules(rules) {
			const compiledRules = [];
			const finalisedTypes = /* @__PURE__ */ new Set();
			for (const rule of rules) {
				if (finalisedTypes.has(rule.type)) continue;
				compiledRules.push({
					type: rule.type,
					include: globsToRegExps(rule.include),
				});
				if (!rule.fallthrough) finalisedTypes.add(rule.type);
			}
			return compiledRules;
		}
		function moduleName(modulesRoot, modulePath) {
			const name = import_path15.default.relative(modulesRoot, modulePath);
			return import_path15.default.sep === "\\" ? name.replaceAll("\\", "/") : name;
		}
		function withSourceURL(script, scriptPath) {
			if (script.lastIndexOf("//# sourceURL=") !== -1) return script;
			let scriptURL = scriptPath;
			if (maybeGetStringScriptPathIndex(scriptPath) === void 0) {
				scriptURL = (0, import_url13.pathToFileURL)(scriptPath);
			}
			const sourceURL = `
//# sourceURL=${scriptURL}
`;
			return script + sourceURL;
		}
		function getResolveErrorPrefix(referencingPath) {
			const relative = import_path15.default.relative("", referencingPath);
			return `Unable to resolve "${relative}" dependency`;
		}
		var ModuleLocator = class {
			constructor(
				modulesRoot,
				additionalModuleNames,
				rules = [],
				compatibilityDate,
				compatibilityFlags,
			) {
				this.modulesRoot = modulesRoot;
				this.additionalModuleNames = additionalModuleNames;
				rules = rules.concat(DEFAULT_MODULE_RULES);
				this.#compiledRules = compileModuleRules(rules);
				this.#nodejsCompatMode = getNodeCompat(
					compatibilityDate,
					compatibilityFlags ?? [],
				).mode;
			}
			#compiledRules;
			#nodejsCompatMode;
			#visitedPaths = /* @__PURE__ */ new Set();
			modules = [];
			visitEntrypoint(code, modulePath) {
				if (this.#visitedPaths.has(modulePath)) return;
				this.#visitedPaths.add(modulePath);
				this.#visitJavaScriptModule(code, modulePath, "ESModule");
			}
			#visitJavaScriptModule(code, modulePath, type) {
				const name = moduleName(this.modulesRoot, modulePath);
				const module22 = createJavaScriptModule(code, name, modulePath, type);
				this.modules.push(module22);
				const isESM = type === "ESModule";
				let root;
				try {
					root = (0, import_acorn.parse)(code, {
						ecmaVersion: "latest",
						sourceType: isESM ? "module" : "script",
						locations: true,
					});
				} catch (e) {
					let loc = "";
					if (e.loc?.line !== void 0) {
						loc += `:${e.loc.line}`;
						if (e.loc.column !== void 0) loc += `:${e.loc.column}`;
					}
					throw new MiniflareCoreError(
						"ERR_MODULE_PARSE",
						`Unable to parse "${name}": ${e.message ?? e}
    at ${modulePath}${loc}`,
					);
				}
				const visitors = {
					ImportDeclaration: (node) => {
						this.#visitModule(modulePath, name, type, node.source);
					},
					ExportNamedDeclaration: (node) => {
						if (node.source != null) {
							this.#visitModule(modulePath, name, type, node.source);
						}
					},
					ExportAllDeclaration: (node) => {
						this.#visitModule(modulePath, name, type, node.source);
					},
					ImportExpression: (node) => {
						this.#visitModule(modulePath, name, type, node.source);
					},
					CallExpression: isESM
						? void 0
						: (node) => {
								const argument = node.arguments[0];
								if (
									node.callee.type === "Identifier" &&
									node.callee.name === "require" &&
									argument !== void 0
								) {
									this.#visitModule(modulePath, name, type, argument);
								}
							},
				};
				(0, import_acorn_walk.simple)(root, visitors);
			}
			#visitModule(referencingPath, referencingName, referencingType, specExpression) {
				if (specExpression.type !== "Literal" || typeof specExpression.value !== "string") {
					const modules = this.modules.map((mod) => {
						const def = convertWorkerModule(mod);
						return `      { type: "${def.type}", path: "${def.path}" }`;
					});
					const modulesConfig = `  new Miniflare({
    ...,
    modules: [
${modules.join(",\n")},
      ...
    ]
  })`;
					const prefix = getResolveErrorPrefix(referencingPath);
					let message = `${prefix}: dynamic module specifiers are unsupported.
You must manually define your modules when constructing Miniflare:
${dim(modulesConfig)}`;
					if (specExpression.loc != null) {
						const { line, column } = specExpression.loc.start;
						message += `
    at ${referencingPath}:${line}:${column}`;
					}
					throw new MiniflareCoreError("ERR_MODULE_DYNAMIC_SPEC", message);
				}
				const spec = specExpression.value;
				const isNodeJsCompatModule = referencingType === "NodeJsCompatModule";
				if (
					// `cloudflare:` and `workerd:` imports don't need to be included explicitly
					spec.startsWith("cloudflare:") ||
					spec.startsWith("workerd:") || // Node.js compat v1 requires imports to be prefixed with `node:`
					(this.#nodejsCompatMode === "v1" && spec.startsWith("node:")) || // Node.js compat modules and v2 can also handle non-prefixed imports
					((this.#nodejsCompatMode === "v2" || isNodeJsCompatModule) &&
						builtinModulesWithPrefix.includes(spec)) || // Async Local Storage mode (node_als) only deals with `node:async_hooks` imports
					(this.#nodejsCompatMode === "als" && spec === "node:async_hooks") || // Any "additional" external modules can be ignored
					this.additionalModuleNames.includes(spec)
				) {
					return;
				}
				if (maybeGetStringScriptPathIndex(referencingName) !== void 0) {
					const prefix = getResolveErrorPrefix(referencingPath);
					throw new MiniflareCoreError(
						"ERR_MODULE_STRING_SCRIPT",
						`${prefix}: imports are unsupported in string \`script\` without defined \`scriptPath\``,
					);
				}
				const identifier = import_path15.default.resolve(
					import_path15.default.dirname(referencingPath),
					spec,
				);
				const name = moduleName(this.modulesRoot, identifier);
				if (this.#visitedPaths.has(identifier)) return;
				this.#visitedPaths.add(identifier);
				const rule = this.#compiledRules.find((rule2) =>
					testRegExps(rule2.include, identifier),
				);
				if (rule === void 0) {
					const prefix = getResolveErrorPrefix(referencingPath);
					const isBuiltin = builtinModulesWithPrefix.includes(spec);
					const suggestion = isBuiltin ? SUGGEST_NODE : SUGGEST_BUNDLE;
					throw new MiniflareCoreError(
						"ERR_MODULE_RULE",
						`${prefix} "${spec}": no matching module rules.
${suggestion}`,
					);
				}
				const data = (0, import_fs12.readFileSync)(identifier);
				switch (rule.type) {
					case "ESModule":
					case "CommonJS":
					case "NodeJsCompatModule":
						const code = data.toString("utf8");
						this.#visitJavaScriptModule(code, identifier, rule.type);
						break;
					case "Text":
						this.modules.push({ name, text: data.toString("utf8") });
						break;
					case "Data":
						this.modules.push({ name, data });
						break;
					case "CompiledWasm":
						this.modules.push({ name, wasm: data });
						break;
					case "PythonModule":
						this.modules.push({ name, pythonModule: data.toString("utf-8") });
						break;
					case "PythonRequirement":
						this.modules.push({ name, pythonRequirement: data.toString("utf-8") });
						break;
					default:
						const exhaustive = rule.type;
						import_assert5.default.fail(
							`Unreachable: ${exhaustive} modules are unsupported`,
						);
				}
			}
		};
		function createJavaScriptModule(code, name, modulePath, type) {
			code = withSourceURL(code, modulePath);
			if (type === "ESModule") {
				return { name, esModule: code };
			} else if (type === "CommonJS") {
				return { name, commonJsModule: code };
			} else if (type === "NodeJsCompatModule") {
				return { name, nodeJsCompatModule: code };
			}
			const exhaustive = type;
			import_assert5.default.fail(
				`Unreachable: ${exhaustive} JavaScript modules are unsupported`,
			);
		}
		var encoder = new import_util.TextEncoder();
		var decoder = new import_util.TextDecoder();
		function contentsToString(contents18) {
			return typeof contents18 === "string" ? contents18 : decoder.decode(contents18);
		}
		function contentsToArray(contents18) {
			return typeof contents18 === "string" ? encoder.encode(contents18) : contents18;
		}
		function convertModuleDefinition(modulesRoot, def) {
			const name = moduleName(modulesRoot, def.path);
			const contents18 = def.contents ?? (0, import_fs12.readFileSync)(def.path);
			switch (def.type) {
				case "ESModule":
				case "CommonJS":
				case "NodeJsCompatModule":
					return createJavaScriptModule(
						contentsToString(contents18),
						name,
						import_path15.default.resolve(modulesRoot, def.path),
						def.type,
					);
				case "Text":
					return { name, text: contentsToString(contents18) };
				case "Data":
					return { name, data: contentsToArray(contents18) };
				case "CompiledWasm":
					return { name, wasm: contentsToArray(contents18) };
				case "PythonModule":
					return { name, pythonModule: contentsToString(contents18) };
				case "PythonRequirement":
					return { name, pythonRequirement: contentsToString(contents18) };
				default:
					const exhaustive = def.type;
					import_assert5.default.fail(
						`Unreachable: ${exhaustive} modules are unsupported`,
					);
			}
		}
		function convertWorkerModule(mod) {
			const path28 = mod.name;
			(0, import_assert5.default)(path28 !== void 0);
			const m = mod;
			if ("esModule" in m) return { path: path28, type: "ESModule" };
			else if ("commonJsModule" in m) return { path: path28, type: "CommonJS" };
			else if ("nodeJsCompatModule" in m) return { path: path28, type: "NodeJsCompatModule" };
			else if ("text" in m) return { path: path28, type: "Text" };
			else if ("data" in m) return { path: path28, type: "Data" };
			else if ("wasm" in m) return { path: path28, type: "CompiledWasm" };
			else if ("pythonModule" in m) return { path: path28, type: "PythonModule" };
			else if ("pythonRequirement" in m) return { path: path28, type: "PythonRequirement" };
			(0, import_assert5.default)(
				!("json" in m || "fallbackService" in m),
				"Unreachable: json or fallbackService modules aren't generated",
			);
			const exhaustive = m;
			import_assert5.default.fail(
				`Unreachable: [${Object.keys(exhaustive).join(", ")}] modules are unsupported`,
			);
		}
		var import_assert8 = __toESM2(require("assert"));
		var import_crypto2 = __toESM2(require("crypto"));
		var import_web4 = require("stream/web");
		var import_util2 = __toESM2(require("util"));
		var import_undici6 = require_undici();
		var import_assert7 = __toESM2(require("assert"));
		var import_web2 = require("stream/web");
		var import_worker_threads = require("worker_threads");
		var import_fs13 = __toESM2(require("fs"));
		var import_path16 = __toESM2(require("path"));
		var import_url14 = require("url");
		var import_zod10 = require_lib();
		var import_assert6 = __toESM2(require("assert"));
		function parseStack(stack) {
			return stack
				.split("\n")
				.slice(1)
				.map(parseCallSite)
				.filter((site) => site !== void 0);
		}
		function parseCallSite(line) {
			const lineMatch = line.match(/at (?:(.+?)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
			if (!lineMatch) {
				return;
			}
			let object = null;
			let method = null;
			let functionName = null;
			let typeName = null;
			let methodName = null;
			const isNative = lineMatch[5] === "native";
			if (lineMatch[1]) {
				functionName = lineMatch[1];
				let methodStart = functionName.lastIndexOf(".");
				if (functionName[methodStart - 1] == ".") methodStart--;
				if (methodStart > 0) {
					object = functionName.substring(0, methodStart);
					method = functionName.substring(methodStart + 1);
					const objectEnd = object.indexOf(".Module");
					if (objectEnd > 0) {
						functionName = functionName.substring(objectEnd + 1);
						object = object.substring(0, objectEnd);
					}
				}
			}
			if (method) {
				typeName = object;
				methodName = method;
			}
			if (method === "<anonymous>") {
				methodName = null;
				functionName = null;
			}
			return new CallSite({
				typeName,
				functionName,
				methodName,
				fileName: lineMatch[2] || null,
				lineNumber: parseInt(lineMatch[3]) || null,
				columnNumber: parseInt(lineMatch[4]) || null,
				native: isNative,
			});
		}
		var CallSite = class {
			constructor(opts) {
				this.opts = opts;
			}
			getThis() {
				return null;
			}
			getTypeName() {
				return this.opts.typeName;
			}
			// eslint-disable-next-line @typescript-eslint/ban-types
			getFunction() {
				return void 0;
			}
			getFunctionName() {
				return this.opts.functionName;
			}
			getMethodName() {
				return this.opts.methodName;
			}
			getFileName() {
				return this.opts.fileName ?? void 0;
			}
			getScriptNameOrSourceURL() {
				return this.opts.fileName;
			}
			getLineNumber() {
				return this.opts.lineNumber;
			}
			getColumnNumber() {
				return this.opts.columnNumber;
			}
			getEvalOrigin() {
				return void 0;
			}
			isToplevel() {
				return false;
			}
			isEval() {
				return false;
			}
			isNative() {
				return this.opts.native;
			}
			isConstructor() {
				return false;
			}
			isAsync() {
				return false;
			}
			isPromiseAll() {
				return false;
			}
			isPromiseAny() {
				return false;
			}
			getPromiseIndex() {
				return null;
			}
		};
		function getFreshSourceMapSupport() {
			const resolvedSupportPath = require.resolve("@cspotcode/source-map-support");
			const originalSymbolFor = Symbol.for;
			const originalSupport = require.cache[resolvedSupportPath];
			try {
				Symbol.for = (key) => {
					import_assert6.default.strictEqual(key, "source-map-support/sharedData");
					return Symbol(key);
				};
				delete require.cache[resolvedSupportPath];
				return require(resolvedSupportPath);
			} finally {
				Symbol.for = originalSymbolFor;
				require.cache[resolvedSupportPath] = originalSupport;
			}
		}
		var sourceMapInstallBaseOptions = {
			environment: "node",
			// Don't add Node `uncaughtException` handler
			handleUncaughtExceptions: false,
			// Don't hook Node `require` function
			hookRequire: false,
			redirectConflictingLibrary: false,
			// Make sure we're using fresh copies of files (i.e. between `setOptions()`)
			emptyCacheBetweenOperations: true,
			// Always remove existing retrievers when calling `install()`, we should be
			// specifying them each time we want to source map
			overrideRetrieveFile: true,
			overrideRetrieveSourceMap: true,
		};
		var sourceMapper;
		function getSourceMapper() {
			if (sourceMapper !== void 0) return sourceMapper;
			const support = getFreshSourceMapSupport();
			const originalPrepareStackTrace = Error.prepareStackTrace;
			support.install(sourceMapInstallBaseOptions);
			const prepareStackTrace = Error.prepareStackTrace;
			(0, import_assert6.default)(prepareStackTrace !== void 0);
			Error.prepareStackTrace = originalPrepareStackTrace;
			sourceMapper = (retrieveSourceMap, error) => {
				support.install({
					...sourceMapInstallBaseOptions,
					retrieveFile(_file) {
						return "";
					},
					retrieveSourceMap,
				});
				const callSites = parseStack(error.stack ?? "");
				return prepareStackTrace(error, callSites);
			};
			return sourceMapper;
		}
		function maybeGetDiskFile(filePath) {
			try {
				const contents18 = import_fs13.default.readFileSync(filePath, "utf8");
				return { path: filePath, contents: contents18 };
			} catch (e) {
				if (e.code !== "ENOENT") throw e;
			}
		}
		function maybeGetFile(workerSrcOpts, fileSpecifier) {
			const maybeUrl = maybeParseURL(fileSpecifier);
			if (maybeUrl !== void 0 && maybeUrl.protocol === "file:") {
				const filePath = (0, import_url14.fileURLToPath)(maybeUrl);
				for (const srcOpts of workerSrcOpts) {
					if (Array.isArray(srcOpts.modules)) {
						const modulesRoot = srcOpts.modulesRoot ?? "";
						for (const module22 of srcOpts.modules) {
							if (
								module22.contents !== void 0 &&
								import_path16.default.resolve(modulesRoot, module22.path) ===
									filePath
							) {
								const contents18 = contentsToString(module22.contents);
								return { path: filePath, contents: contents18 };
							}
						}
					} else if (
						"script" in srcOpts &&
						"scriptPath" in srcOpts &&
						srcOpts.script !== void 0 &&
						srcOpts.scriptPath !== void 0
					) {
						const modulesRoot = (srcOpts.modules && srcOpts.modulesRoot) || "";
						if (
							import_path16.default.resolve(modulesRoot, srcOpts.scriptPath) ===
							filePath
						) {
							return { path: filePath, contents: srcOpts.script };
						}
					}
				}
				return maybeGetDiskFile(filePath);
			}
			const workerIndex = maybeGetStringScriptPathIndex(fileSpecifier);
			if (workerIndex !== void 0) {
				const srcOpts = workerSrcOpts[workerIndex];
				if ("script" in srcOpts && srcOpts.script !== void 0) {
					return { contents: srcOpts.script };
				}
			}
		}
		function getSourceMappedStack(workerSrcOpts, error) {
			function retrieveSourceMap(fileSpecifier) {
				const sourceFile = maybeGetFile(workerSrcOpts, fileSpecifier);
				if (sourceFile?.path === void 0) return null;
				const sourceMapRegexp = /# sourceMappingURL=(.+)/g;
				const matches = [...sourceFile.contents.matchAll(sourceMapRegexp)];
				if (matches.length === 0) return null;
				const sourceMapMatch = matches[matches.length - 1];
				const root = import_path16.default.dirname(sourceFile.path);
				const sourceMapPath = import_path16.default.resolve(root, sourceMapMatch[1]);
				const sourceMapFile = maybeGetDiskFile(sourceMapPath);
				if (sourceMapFile === void 0) return null;
				return { map: sourceMapFile.contents, url: sourceMapFile.path };
			}
			return getSourceMapper()(retrieveSourceMap, error);
		}
		var JsonErrorSchema = import_zod10.z.lazy(() =>
			import_zod10.z.object({
				message: import_zod10.z.string().optional(),
				name: import_zod10.z.string().optional(),
				stack: import_zod10.z.string().optional(),
				cause: JsonErrorSchema.optional(),
			}),
		);
		var ALLOWED_ERROR_SUBCLASS_CONSTRUCTORS = [
			EvalError,
			RangeError,
			ReferenceError,
			SyntaxError,
			TypeError,
			URIError,
		];
		function reviveError(workerSrcOpts, jsonError) {
			let cause;
			if (jsonError.cause !== void 0) {
				cause = reviveError(workerSrcOpts, jsonError.cause);
			}
			let ctor = Error;
			if (jsonError.name !== void 0 && jsonError.name in globalThis) {
				const maybeCtor = globalThis[jsonError.name];
				if (ALLOWED_ERROR_SUBCLASS_CONSTRUCTORS.includes(maybeCtor)) {
					ctor = maybeCtor;
				}
			}
			const error = new ctor(jsonError.message, { cause });
			if (jsonError.name !== void 0) error.name = jsonError.name;
			error.stack = jsonError.stack;
			error.stack = getSourceMappedStack(workerSrcOpts, error);
			return error;
		}
		async function handlePrettyErrorRequest(log, workerSrcOpts, request) {
			const caught = JsonErrorSchema.parse(await request.json());
			const error = reviveError(workerSrcOpts, caught);
			log.error(error);
			const accept = request.headers.get("Accept")?.toLowerCase() ?? "";
			const userAgent = request.headers.get("User-Agent")?.toLowerCase() ?? "";
			const acceptsPrettyError =
				!userAgent.includes("curl/") &&
				(accept.includes("text/html") ||
					accept.includes("*/*") ||
					accept.includes("text/*"));
			if (!acceptsPrettyError) {
				return new Response(error.stack, { status: 500 });
			}
			const Youch = require_Youch();
			const youch = new Youch(error.cause ?? error, {
				url: request.cf?.prettyErrorOriginalUrl ?? request.url,
				method: request.method,
				headers: Object.fromEntries(request.headers),
			});
			youch.addLink(() => {
				return [
					'<a href="https://developers.cloudflare.com/workers/" target="_blank" style="text-decoration:none">\u{1F4DA} Workers Docs</a>',
					'<a href="https://discord.cloudflare.com" target="_blank" style="text-decoration:none">\u{1F4AC} Workers Discord</a>',
				].join("");
			});
			return new Response(await youch.toHTML(), {
				status: 500,
				headers: { "Content-Type": "text/html;charset=utf-8" },
			});
		}
		var DECODER = new TextDecoder();
		var WORKER_SCRIPT =
			/* javascript */
			`
const { createRequire } = require("module");
const { workerData } = require("worker_threads");

// Not using parentPort here so we can call receiveMessageOnPort() in host
const { notifyHandle, port, filename } = workerData;

// When running Miniflare from Jest, regular 'require("undici")' will fail here
// with "Error: Cannot find module 'undici'". Instead we need to create a
// 'require' using the '__filename' of the host... :(
const actualRequire = createRequire(filename);
const { Pool, fetch } = actualRequire("undici");

let dispatcherUrl;
let dispatcher;

port.addEventListener("message", async (event) => {
  const { id, method, url, headers, body } = event.data;
  if (dispatcherUrl !== url) {
    dispatcherUrl = url;
    dispatcher = new Pool(url, {
      connect: { rejectUnauthorized: false },
    });
  }
  headers["${CoreHeaders.OP_SYNC}"] = "true";
  try {
    // body cannot be a ReadableStream, so no need to specify duplex
    const response = await fetch(url, { method, headers, body, dispatcher });
    const responseBody = response.headers.get("${CoreHeaders.OP_RESULT_TYPE}") === "ReadableStream"
      ? response.body
      : await response.arrayBuffer();
    const transferList = responseBody === null ? undefined : [responseBody];
    port.postMessage(
      {
        id,
        response: {
          status: response.status,
          headers: Object.fromEntries(response.headers),
          body: responseBody,
        }
      },
      transferList
    );
  } catch (error) {
    try {
      port.postMessage({ id, error });
    } catch {
      // If error failed to serialise, post simplified version
      port.postMessage({ id, error: new Error(String(error)) });
    }
  }
  Atomics.store(notifyHandle, /* index */ 0, /* value */ 1);
  Atomics.notify(notifyHandle, /* index */ 0);
});
`;
		var SynchronousFetcher = class {
			#channel;
			#notifyHandle;
			#worker;
			#nextId = 0;
			constructor() {
				this.#channel = new import_worker_threads.MessageChannel();
				this.#notifyHandle = new Int32Array(new SharedArrayBuffer(4));
			}
			#ensureWorker() {
				if (this.#worker !== void 0) return;
				this.#worker = new import_worker_threads.Worker(WORKER_SCRIPT, {
					eval: true,
					workerData: {
						notifyHandle: this.#notifyHandle,
						port: this.#channel.port2,
						filename: __filename,
					},
					transferList: [this.#channel.port2],
				});
			}
			fetch(url18, init2) {
				this.#ensureWorker();
				Atomics.store(
					this.#notifyHandle,
					/* index */
					0,
					/* value */
					0,
				);
				const id = this.#nextId++;
				this.#channel.port1.postMessage({
					id,
					method: init2.method,
					url: url18.toString(),
					headers: init2.headers,
					body: init2.body,
				});
				Atomics.wait(
					this.#notifyHandle,
					/* index */
					0,
					/* value */
					0,
				);
				const message = (0, import_worker_threads.receiveMessageOnPort)(
					this.#channel.port1,
				)?.message;
				(0, import_assert7.default)(message?.id === id);
				if ("response" in message) {
					const { status, headers: rawHeaders, body } = message.response;
					const headers = new import_undici4.Headers(rawHeaders);
					const stack = headers.get(CoreHeaders.ERROR_STACK);
					if (status === 500 && stack !== null && body !== null) {
						(0, import_assert7.default)(!(body instanceof import_web2.ReadableStream));
						const caught = JsonErrorSchema.parse(JSON.parse(DECODER.decode(body)));
						throw reviveError([], caught);
					}
					return { status, headers, body };
				} else {
					throw message.error;
				}
			}
			async dispose() {
				await this.#worker?.terminate();
			}
		};
		var import_buffer = require("buffer");
		var import_consumers = require("stream/consumers");
		var import_web3 = require("stream/web");
		var import_undici5 = require_undici();
		var NODE_PLATFORM_IMPL = {
			// Node's implementation of these classes don't quite match Workers',
			// but they're close enough for us
			Blob: import_buffer.Blob,
			File: import_undici5.File,
			Headers: import_undici5.Headers,
			Request,
			Response,
			isReadableStream(value) {
				return value instanceof import_web3.ReadableStream;
			},
			bufferReadableStream(stream) {
				return (0, import_consumers.arrayBuffer)(stream);
			},
			unbufferReadableStream(buffer) {
				return new import_buffer.Blob([new Uint8Array(buffer)]).stream();
			},
		};
		var kAddress = Symbol("kAddress");
		var kName = Symbol("kName");
		var kIsFunction = Symbol("kIsFunction");
		function isNativeTarget(value) {
			return (
				typeof value === "object" &&
				value !== null &&
				kAddress in value &&
				kIsFunction in value
			);
		}
		var TARGET_GLOBAL = {
			[kAddress]: ProxyAddresses.GLOBAL,
			[kName]: "global",
			[kIsFunction]: false,
		};
		var TARGET_ENV = {
			[kAddress]: ProxyAddresses.ENV,
			[kName]: "env",
			[kIsFunction]: false,
		};
		var reducers = {
			...structuredSerializableReducers,
			...createHTTPReducers(NODE_PLATFORM_IMPL),
			Native(value) {
				if (isNativeTarget(value))
					return [value[kAddress], value[kName], value[kIsFunction]];
			},
		};
		var revivers = {
			...structuredSerializableRevivers,
			...createHTTPRevivers(NODE_PLATFORM_IMPL),
			// `Native` reviver depends on `ProxyStubHandler` methods
		};
		var PROXY_SECRET = import_crypto2.default.randomBytes(16);
		var PROXY_SECRET_HEX = PROXY_SECRET.toString("hex");
		function isClientError(status) {
			return 400 <= status && status < 500;
		}
		var ProxyClient = class {
			#bridge;
			constructor(runtimeEntryURL, dispatchFetch) {
				this.#bridge = new ProxyClientBridge(runtimeEntryURL, dispatchFetch);
			}
			// Lazily initialise proxies as required
			#globalProxy;
			#envProxy;
			get global() {
				return (this.#globalProxy ??= this.#bridge.getProxy(TARGET_GLOBAL));
			}
			get env() {
				return (this.#envProxy ??= this.#bridge.getProxy(TARGET_ENV));
			}
			poisonProxies() {
				this.#bridge.poisonProxies();
				this.#globalProxy = void 0;
				this.#envProxy = void 0;
			}
			setRuntimeEntryURL(runtimeEntryURL) {
				this.#bridge.url = runtimeEntryURL;
			}
			dispose() {
				return this.#bridge.dispose();
			}
		};
		var ProxyClientBridge = class {
			constructor(url18, dispatchFetch) {
				this.url = url18;
				this.dispatchFetch = dispatchFetch;
				this.#finalizationRegistry = new FinalizationRegistry(this.#finalizeProxy);
			}
			// Each proxy stub is initialised with the version stored here. Whenever
			// `poisonProxies()` is called, this version is incremented. Before the
			// proxy makes any request to `workerd`, it checks the version number here
			// matches its own internal version, and throws if not.
			#version = 0;
			// Whenever the `ProxyServer` returns a native target, it adds a strong
			// reference to the "heap" in the singleton object. This prevents the object
			// being garbage collected. To solve this, we register the native target
			// proxies on the client in a `FinalizationRegistry`. When the proxies get
			// garbage collected, we let the `ProxyServer` know it can release the strong
			// "heap" reference, as we'll never be able to access it again. Importantly,
			// we need to unregister all proxies from the registry when we poison them,
			// as the references will be invalid, and a new object with the same address
			// may be added to the "heap".
			#finalizationRegistry;
			// Garbage collection passes will free lots of objects at once. Rather than
			// sending a `DELETE` request for each address, we batch finalisations within
			// 100ms of each other into one request. This ensures we don't create *lots*
			// of TCP connections to `workerd` in `dispatchFetch()` for all the concurrent
			// requests.
			#finalizeBatch = [];
			#finalizeBatchTimeout;
			sync = new SynchronousFetcher();
			get version() {
				return this.#version;
			}
			#finalizeProxy = (held) => {
				this.#finalizeBatch.push(held);
				clearTimeout(this.#finalizeBatchTimeout);
				this.#finalizeBatchTimeout = setTimeout(this.#finalizeProxyBatch, 100);
			};
			#finalizeProxyBatch = async () => {
				const addresses = [];
				for (const held of this.#finalizeBatch.splice(0)) {
					if (held.version === this.#version) addresses.push(held.address);
				}
				if (addresses.length === 0) return;
				try {
					await this.dispatchFetch(this.url, {
						method: "DELETE",
						headers: {
							[CoreHeaders.OP_SECRET]: PROXY_SECRET_HEX,
							[CoreHeaders.OP]: ProxyOps.FREE,
							[CoreHeaders.OP_TARGET]: addresses.join(","),
						},
					});
				} catch {}
			};
			getProxy(target) {
				const handler = new ProxyStubHandler(this, target);
				let proxyTarget;
				if (target[kIsFunction]) {
					proxyTarget = new Function();
				} else {
					proxyTarget = {};
				}
				proxyTarget[import_util2.default.inspect.custom] = handler.inspect;
				const proxy = new Proxy(proxyTarget, handler);
				const held = {
					address: target[kAddress],
					version: this.#version,
				};
				this.#finalizationRegistry.register(proxy, held, this);
				return proxy;
			}
			poisonProxies() {
				this.#version++;
				this.#finalizationRegistry.unregister(this);
			}
			dispose() {
				this.poisonProxies();
				return this.sync.dispose();
			}
		};
		var ProxyStubHandler = class extends Function {
			constructor(bridge, target) {
				super();
				this.bridge = bridge;
				this.target = target;
				this.#version = bridge.version;
				this.#stringifiedTarget = stringify(this.target, reducers);
			}
			#version;
			#stringifiedTarget;
			#knownValues = /* @__PURE__ */ new Map();
			#knownDescriptors = /* @__PURE__ */ new Map();
			#knownOwnKeys;
			revivers = {
				...revivers,
				Native: (value) => {
					(0, import_assert8.default)(Array.isArray(value));
					const [address, name, isFunction] = value;
					(0, import_assert8.default)(typeof address === "number");
					(0, import_assert8.default)(typeof name === "string");
					(0, import_assert8.default)(typeof isFunction === "boolean");
					const target = {
						[kAddress]: address,
						[kName]: name,
						[kIsFunction]: isFunction,
					};
					if (name === "Promise") {
						const resPromise = this.bridge.dispatchFetch(this.bridge.url, {
							method: "POST",
							headers: {
								[CoreHeaders.OP_SECRET]: PROXY_SECRET_HEX,
								[CoreHeaders.OP]: ProxyOps.GET,
								// GET without key just gets target
								[CoreHeaders.OP_TARGET]: stringify(target, reducers),
							},
						});
						return this.#parseAsyncResponse(resPromise);
					} else {
						return this.bridge.getProxy(target);
					}
				},
			};
			get #poisoned() {
				return this.#version !== this.bridge.version;
			}
			#assertSafe() {
				if (this.#poisoned) {
					throw new Error(
						"Attempted to use poisoned stub. Stubs to runtime objects must be re-created after calling `Miniflare#setOptions()` or `Miniflare#dispose()`.",
					);
				}
			}
			inspect = (depth, options) => {
				const details = { name: this.target[kName], poisoned: this.#poisoned };
				return `ProxyStub ${import_util2.default.inspect(details, options)}`;
			};
			#maybeThrow(res, result, caller) {
				if (res.status === 500) {
					if (typeof result === "object" && result !== null) {
						Error.captureStackTrace(result, caller);
					}
					throw result;
				} else {
					(0, import_assert8.default)(res.status === 200);
					return result;
				}
			}
			async #parseAsyncResponse(resPromise) {
				const res = await resPromise;
				(0, import_assert8.default)(!isClientError(res.status));
				const typeHeader = res.headers.get(CoreHeaders.OP_RESULT_TYPE);
				if (typeHeader === "Promise, ReadableStream") return res.body;
				(0, import_assert8.default)(typeHeader === "Promise");
				let stringifiedResult;
				let unbufferedStream;
				const stringifiedSizeHeader = res.headers.get(CoreHeaders.OP_STRINGIFIED_SIZE);
				if (stringifiedSizeHeader === null) {
					stringifiedResult = await res.text();
				} else {
					const stringifiedSize = parseInt(stringifiedSizeHeader);
					(0, import_assert8.default)(!Number.isNaN(stringifiedSize));
					(0, import_assert8.default)(res.body !== null);
					const [buffer, rest] = await readPrefix(res.body, stringifiedSize);
					stringifiedResult = buffer.toString();
					unbufferedStream = rest.pipeThrough(new import_web4.TransformStream());
				}
				const result = parseWithReadableStreams(
					NODE_PLATFORM_IMPL,
					{ value: stringifiedResult, unbufferedStream },
					this.revivers,
				);
				return this.#maybeThrow(res, result, this.#parseAsyncResponse);
			}
			#parseSyncResponse(syncRes, caller) {
				(0, import_assert8.default)(!isClientError(syncRes.status));
				(0, import_assert8.default)(syncRes.body !== null);
				(0, import_assert8.default)(
					syncRes.headers.get(CoreHeaders.OP_STRINGIFIED_SIZE) === null,
				);
				if (syncRes.body instanceof import_web4.ReadableStream) return syncRes.body;
				const stringifiedResult = DECODER.decode(syncRes.body);
				const result = parseWithReadableStreams(
					NODE_PLATFORM_IMPL,
					{ value: stringifiedResult },
					this.revivers,
				);
				return this.#maybeThrow(syncRes, result, caller);
			}
			#thisFnKnownAsync = false;
			apply(_target, ...args) {
				const result = this.#call(
					"__miniflareWrappedFunction",
					this.#thisFnKnownAsync,
					args[1],
					this,
				);
				if (!this.#thisFnKnownAsync && result instanceof Promise) {
					this.#thisFnKnownAsync = true;
				}
				return result;
			}
			get(_target, key, _receiver) {
				this.#assertSafe();
				if (key === kAddress) return this.target[kAddress];
				if (key === kName) return this.target[kName];
				if (key === kIsFunction) return this.target[kIsFunction];
				if (typeof key === "symbol" || key === "then") return void 0;
				const maybeKnown = this.#knownValues.get(key);
				if (maybeKnown !== void 0) return maybeKnown;
				const syncRes = this.bridge.sync.fetch(this.bridge.url, {
					method: "POST",
					headers: {
						[CoreHeaders.OP_SECRET]: PROXY_SECRET_HEX,
						[CoreHeaders.OP]: ProxyOps.GET,
						[CoreHeaders.OP_TARGET]: this.#stringifiedTarget,
						[CoreHeaders.OP_KEY]: key,
					},
				});
				let result;
				if (syncRes.headers.get(CoreHeaders.OP_RESULT_TYPE) === "Function") {
					result = this.#createFunction(key);
				} else {
					result = this.#parseSyncResponse(syncRes, this.get);
				}
				if (
					// Optimisation: if this property is a function, we assume constant
					// prototypes of proxied objects, so it's never going to change
					typeof result === "function" || // Optimisation: if this property is a reference, we assume it's never
					// going to change. This allows us to reuse the known cache of nested
					// objects on multiple access (e.g. reusing `env["...<bucket>"]` proxy if
					// `getR2Bucket(<bucket>)` is called on the same bucket multiple times).
					isNativeTarget(result) || // Once a `ReadableStream` sent across proxy, we won't be able to read it
					// again in the server, so reuse the same stream for future accesses
					// (e.g. accessing `R2ObjectBody#body` multiple times)
					result instanceof import_web4.ReadableStream
				) {
					this.#knownValues.set(key, result);
				}
				return result;
			}
			has(target, key) {
				return this.get(target, key, void 0) !== void 0;
			}
			getOwnPropertyDescriptor(target, key) {
				this.#assertSafe();
				if (typeof key === "symbol") return void 0;
				const maybeKnown = this.#knownDescriptors.get(key);
				if (maybeKnown !== void 0) return maybeKnown;
				const syncRes = this.bridge.sync.fetch(this.bridge.url, {
					method: "POST",
					headers: {
						[CoreHeaders.OP_SECRET]: PROXY_SECRET_HEX,
						[CoreHeaders.OP]: ProxyOps.GET_OWN_DESCRIPTOR,
						[CoreHeaders.OP_KEY]: key,
						[CoreHeaders.OP_TARGET]: this.#stringifiedTarget,
					},
				});
				const result = this.#parseSyncResponse(syncRes, this.getOwnPropertyDescriptor);
				this.#knownDescriptors.set(key, result);
				return result;
			}
			ownKeys(_target) {
				this.#assertSafe();
				if (this.#knownOwnKeys !== void 0) return this.#knownOwnKeys;
				const syncRes = this.bridge.sync.fetch(this.bridge.url, {
					method: "POST",
					headers: {
						[CoreHeaders.OP_SECRET]: PROXY_SECRET_HEX,
						[CoreHeaders.OP]: ProxyOps.GET_OWN_KEYS,
						[CoreHeaders.OP_TARGET]: this.#stringifiedTarget,
					},
				});
				const result = this.#parseSyncResponse(syncRes, this.ownKeys);
				this.#knownOwnKeys = result;
				return result;
			}
			getPrototypeOf(_target) {
				this.#assertSafe();
				return null;
			}
			#createFunction(key) {
				let knownAsync = false;
				const func = {
					[key]: (...args) => {
						const result = this.#call(key, knownAsync, args, func);
						if (!knownAsync && result instanceof Promise) knownAsync = true;
						return result;
					},
				}[key];
				return func;
			}
			#call(key, knownAsync, args, caller) {
				this.#assertSafe();
				const targetName = this.target[kName];
				if (isFetcherFetch(targetName, key)) return this.#fetcherFetchCall(args);
				const stringified = stringifyWithStreams(
					NODE_PLATFORM_IMPL,
					args,
					reducers,
					/* allowUnbufferedStream */
					true,
				);
				if (
					knownAsync || // We assume every call with `ReadableStream`/`Blob` arguments is async.
					// Note that you can't consume `ReadableStream`/`Blob` synchronously: if
					// you tried a similar trick to `SynchronousFetcher`, blocking the main
					// thread with `Atomics.wait()` would prevent chunks being read. This
					// assumption doesn't hold for `Blob`s and `FormData#{append,set}()`, but
					// we should never expose proxies for those APIs to users.
					stringified instanceof Promise || // (instanceof Promise if buffered `ReadableStream`/`Blob`s)
					stringified.unbufferedStream !== void 0
				) {
					return this.#asyncCall(key, stringified);
				} else {
					const result = this.#syncCall(key, stringified.value, caller);
					if (isR2ObjectWriteHttpMetadata(targetName, key)) {
						const arg = args[0];
						(0, import_assert8.default)(arg instanceof import_undici6.Headers);
						(0, import_assert8.default)(result instanceof import_undici6.Headers);
						for (const [key2, value] of result) arg.set(key2, value);
						return;
					}
					return result;
				}
			}
			#syncCall(key, stringifiedValue, caller) {
				const argsSize = Buffer.byteLength(stringifiedValue).toString();
				const syncRes = this.bridge.sync.fetch(this.bridge.url, {
					method: "POST",
					headers: {
						[CoreHeaders.OP_SECRET]: PROXY_SECRET_HEX,
						[CoreHeaders.OP]: ProxyOps.CALL,
						[CoreHeaders.OP_TARGET]: this.#stringifiedTarget,
						[CoreHeaders.OP_KEY]: key,
						[CoreHeaders.OP_STRINGIFIED_SIZE]: argsSize,
						"Content-Length": argsSize,
					},
					body: stringifiedValue,
				});
				return this.#parseSyncResponse(syncRes, caller);
			}
			async #asyncCall(key, stringifiedAwaitable) {
				const stringified = await stringifiedAwaitable;
				let resPromise;
				if (stringified.unbufferedStream === void 0) {
					const argsSize = Buffer.byteLength(stringified.value).toString();
					resPromise = this.bridge.dispatchFetch(this.bridge.url, {
						method: "POST",
						headers: {
							[CoreHeaders.OP_SECRET]: PROXY_SECRET_HEX,
							[CoreHeaders.OP]: ProxyOps.CALL,
							[CoreHeaders.OP_TARGET]: this.#stringifiedTarget,
							[CoreHeaders.OP_KEY]: key,
							[CoreHeaders.OP_STRINGIFIED_SIZE]: argsSize,
							"Content-Length": argsSize,
						},
						body: stringified.value,
					});
				} else {
					const encodedArgs = Buffer.from(stringified.value);
					const argsSize = encodedArgs.byteLength.toString();
					const body = prefixStream(encodedArgs, stringified.unbufferedStream);
					resPromise = this.bridge.dispatchFetch(this.bridge.url, {
						method: "POST",
						headers: {
							[CoreHeaders.OP_SECRET]: PROXY_SECRET_HEX,
							[CoreHeaders.OP]: ProxyOps.CALL,
							[CoreHeaders.OP_TARGET]: this.#stringifiedTarget,
							[CoreHeaders.OP_KEY]: key,
							[CoreHeaders.OP_STRINGIFIED_SIZE]: argsSize,
						},
						duplex: "half",
						body,
					});
				}
				return this.#parseAsyncResponse(resPromise);
			}
			#fetcherFetchCall(args) {
				const request = new Request(...args);
				request.headers.set(CoreHeaders.OP_SECRET, PROXY_SECRET_HEX);
				request.headers.set(CoreHeaders.OP, ProxyOps.CALL);
				request.headers.set(CoreHeaders.OP_TARGET, this.#stringifiedTarget);
				request.headers.set(CoreHeaders.OP_KEY, "fetch");
				return this.bridge.dispatchFetch(request);
			}
		};
		var import_zod11 = require_lib();
		var kCurrentWorker = Symbol.for("miniflare.kCurrentWorker");
		var HttpOptionsHeaderSchema = import_zod11.z.object({
			name: import_zod11.z.string(),
			// name should be required
			value: import_zod11.z.ostring(),
			// If omitted, the header will be removed
		});
		var HttpOptionsSchema = import_zod11.z
			.object({
				style: import_zod11.z.nativeEnum(import_workerd_capnp.HttpOptions_Style).optional(),
				forwardedProtoHeader: import_zod11.z.ostring(),
				cfBlobHeader: import_zod11.z.ostring(),
				injectRequestHeaders: HttpOptionsHeaderSchema.array().optional(),
				injectResponseHeaders: HttpOptionsHeaderSchema.array().optional(),
			})
			.transform((options) => ({
				...options,
				capnpConnectHost: HOST_CAPNP_CONNECT,
			}));
		var TlsOptionsKeypairSchema = import_zod11.z.object({
			privateKey: import_zod11.z.ostring(),
			certificateChain: import_zod11.z.ostring(),
		});
		var TlsOptionsSchema = import_zod11.z.object({
			keypair: TlsOptionsKeypairSchema.optional(),
			requireClientCerts: import_zod11.z.oboolean(),
			trustBrowserCas: import_zod11.z.oboolean(),
			trustedCertificates: import_zod11.z.string().array().optional(),
			minVersion: import_zod11.z
				.nativeEnum(import_workerd_capnp.TlsOptions_Version)
				.optional(),
			cipherList: import_zod11.z.ostring(),
		});
		var NetworkSchema = import_zod11.z.object({
			allow: import_zod11.z.string().array().optional(),
			deny: import_zod11.z.string().array().optional(),
			tlsOptions: TlsOptionsSchema.optional(),
		});
		var ExternalServerSchema = import_zod11.z.intersection(
			import_zod11.z.object({ address: import_zod11.z.string() }),
			// address should be required
			import_zod11.z.union([
				import_zod11.z.object({ http: import_zod11.z.optional(HttpOptionsSchema) }),
				import_zod11.z.object({
					https: import_zod11.z.optional(
						import_zod11.z.object({
							options: HttpOptionsSchema.optional(),
							tlsOptions: TlsOptionsSchema.optional(),
							certificateHost: import_zod11.z.ostring(),
						}),
					),
				}),
			]),
		);
		var DiskDirectorySchema = import_zod11.z.object({
			path: import_zod11.z.string(),
			// path should be required
			writable: import_zod11.z.oboolean(),
		});
		var ServiceFetchSchema = import_zod11.z.custom((v) => typeof v === "function");
		var ServiceDesignatorSchema = import_zod11.z.union([
			import_zod11.z.string(),
			import_zod11.z.literal(kCurrentWorker),
			import_zod11.z.object({
				name: import_zod11.z.union([
					import_zod11.z.string(),
					import_zod11.z.literal(kCurrentWorker),
				]),
				entrypoint: import_zod11.z.ostring(),
			}),
			import_zod11.z.object({ network: NetworkSchema }),
			import_zod11.z.object({ external: ExternalServerSchema }),
			import_zod11.z.object({ disk: DiskDirectorySchema }),
			ServiceFetchSchema,
		]);
		var trustedCertificates =
			process.platform === "win32" ? Array.from(import_tls.default.rootCertificates) : [];
		if (process.env.NODE_EXTRA_CA_CERTS !== void 0) {
			try {
				const extra = (0, import_fs14.readFileSync)(
					process.env.NODE_EXTRA_CA_CERTS,
					"utf8",
				);
				const pemBegin = "-----BEGIN";
				for (const cert of extra.split(pemBegin)) {
					if (cert.trim() !== "") trustedCertificates.push(pemBegin + cert);
				}
			} catch {}
		}
		var encoder2 = new import_util3.TextEncoder();
		var numericCompare = new Intl.Collator(void 0, { numeric: true }).compare;
		function createFetchMock() {
			return new import_undici7.MockAgent();
		}
		var WrappedBindingSchema = import_zod12.z.object({
			scriptName: import_zod12.z.string(),
			entrypoint: import_zod12.z.string().optional(),
			bindings: import_zod12.z.record(JsonSchema).optional(),
		});
		var UnusableStringSchema = import_zod12.z.string().transform(() => void 0);
		var UnsafeDirectSocketSchema = import_zod12.z.object({
			host: import_zod12.z.ostring(),
			port: import_zod12.z.onumber(),
			entrypoint: import_zod12.z.ostring(),
			proxy: import_zod12.z.oboolean(),
		});
		var CoreOptionsSchemaInput = import_zod12.z.intersection(
			SourceOptionsSchema,
			import_zod12.z.object({
				name: import_zod12.z.string().optional(),
				rootPath: UnusableStringSchema.optional(),
				compatibilityDate: import_zod12.z.string().optional(),
				compatibilityFlags: import_zod12.z.string().array().optional(),
				routes: import_zod12.z.string().array().optional(),
				bindings: import_zod12.z.record(JsonSchema).optional(),
				wasmBindings: import_zod12.z
					.record(
						import_zod12.z.union([PathSchema, import_zod12.z.instanceof(Uint8Array)]),
					)
					.optional(),
				textBlobBindings: import_zod12.z.record(PathSchema).optional(),
				dataBlobBindings: import_zod12.z
					.record(
						import_zod12.z.union([PathSchema, import_zod12.z.instanceof(Uint8Array)]),
					)
					.optional(),
				serviceBindings: import_zod12.z.record(ServiceDesignatorSchema).optional(),
				wrappedBindings: import_zod12.z
					.record(import_zod12.z.union([import_zod12.z.string(), WrappedBindingSchema]))
					.optional(),
				outboundService: ServiceDesignatorSchema.optional(),
				fetchMock: import_zod12.z.instanceof(import_undici7.MockAgent).optional(),
				// TODO(soon): remove this in favour of per-object `unsafeUniqueKey: kEphemeralUniqueKey`
				unsafeEphemeralDurableObjects: import_zod12.z.boolean().optional(),
				unsafeDirectSockets: UnsafeDirectSocketSchema.array().optional(),
				unsafeEvalBinding: import_zod12.z.string().optional(),
				unsafeUseModuleFallbackService: import_zod12.z.boolean().optional(),
				/** Used to set the vitest pool worker SELF binding to point to the router worker if there are assets.
         (If there are assets but we're not using vitest, the miniflare entry worker can point directly to RW.)
         */
				hasAssetsAndIsVitest: import_zod12.z.boolean().optional(),
			}),
		);
		var CoreOptionsSchema = CoreOptionsSchemaInput.transform((value) => {
			const fetchMock = value.fetchMock;
			if (fetchMock !== void 0) {
				if (value.outboundService !== void 0) {
					throw new MiniflareCoreError(
						"ERR_MULTIPLE_OUTBOUNDS",
						"Only one of `outboundService` or `fetchMock` may be specified per worker",
					);
				}
				value.outboundService = (req) => fetch3(req, { dispatcher: fetchMock });
			}
			return value;
		});
		var CoreSharedOptionsSchema = import_zod12.z.object({
			rootPath: UnusableStringSchema.optional(),
			host: import_zod12.z.string().optional(),
			port: import_zod12.z.number().optional(),
			https: import_zod12.z.boolean().optional(),
			httpsKey: import_zod12.z.string().optional(),
			httpsKeyPath: import_zod12.z.string().optional(),
			httpsCert: import_zod12.z.string().optional(),
			httpsCertPath: import_zod12.z.string().optional(),
			inspectorPort: import_zod12.z.number().optional(),
			verbose: import_zod12.z.boolean().optional(),
			log: import_zod12.z.instanceof(Log).optional(),
			handleRuntimeStdio: import_zod12.z
				.function(
					import_zod12.z.tuple([
						import_zod12.z.instanceof(import_stream2.Readable),
						import_zod12.z.instanceof(import_stream2.Readable),
					]),
				)
				.optional(),
			upstream: import_zod12.z.string().optional(),
			// TODO: add back validation of cf object
			cf: import_zod12.z
				.union([
					import_zod12.z.boolean(),
					import_zod12.z.string(),
					import_zod12.z.record(import_zod12.z.any()),
				])
				.optional(),
			liveReload: import_zod12.z.boolean().optional(),
			// This is a shared secret between a proxy server and miniflare that can be
			// passed in a header to prove that the request came from the proxy and not
			// some malicious attacker.
			unsafeProxySharedSecret: import_zod12.z.string().optional(),
			unsafeModuleFallbackService: ServiceFetchSchema.optional(),
			// Keep blobs when deleting/overwriting keys, required for stacked storage
			unsafeStickyBlobs: import_zod12.z.boolean().optional(),
		});
		var CORE_PLUGIN_NAME2 = "core";
		var LIVE_RELOAD_SCRIPT_TEMPLATE = (port) => `<script defer type="application/javascript">
(function () {
  // Miniflare Live Reload
  var url = new URL("/cdn-cgi/mf/reload", location.origin);
  url.protocol = url.protocol.replace("http", "ws");
  url.port = ${port};
  function reload() { location.reload(); }
  function connect(reconnected) {
    var ws = new WebSocket(url);
    if (reconnected) ws.onopen = reload;
    ws.onclose = function(e) {
      e.code === 1012 ? reload() : e.code === 1000 || e.code === 1001 || setTimeout(connect, 1000, true);
    }
  }
  connect();
})();
</script>`;
		var SCRIPT_CUSTOM_SERVICE = `addEventListener("fetch", (event) => {
  const request = new Request(event.request);
  request.headers.set("${CoreHeaders.CUSTOM_SERVICE}", ${CoreBindings.TEXT_CUSTOM_SERVICE});
  request.headers.set("${CoreHeaders.ORIGINAL_URL}", request.url);
  event.respondWith(${CoreBindings.SERVICE_LOOPBACK}.fetch(request));
})`;
		function getCustomServiceDesignator(
			refererName,
			workerIndex,
			kind,
			name,
			service,
			hasAssetsAndIsVitest = false,
		) {
			let serviceName;
			let entrypoint;
			if (typeof service === "function") {
				serviceName = getCustomServiceName(workerIndex, kind, name);
			} else if (typeof service === "object") {
				if ("name" in service) {
					if (service.name === kCurrentWorker) {
						serviceName = getUserServiceName(refererName);
					} else {
						serviceName = getUserServiceName(service.name);
					}
					entrypoint = service.entrypoint;
				} else {
					serviceName = getBuiltinServiceName(workerIndex, kind, name);
				}
			} else if (service === kCurrentWorker) {
				serviceName = hasAssetsAndIsVitest
					? ROUTER_SERVICE_NAME
					: getUserServiceName(refererName);
			} else {
				serviceName = getUserServiceName(service);
			}
			return { name: serviceName, entrypoint };
		}
		function maybeGetCustomServiceService(workerIndex, kind, name, service) {
			if (typeof service === "function") {
				return {
					name: getCustomServiceName(workerIndex, kind, name),
					worker: {
						serviceWorkerScript: SCRIPT_CUSTOM_SERVICE,
						compatibilityDate: "2022-09-01",
						bindings: [
							{
								name: CoreBindings.TEXT_CUSTOM_SERVICE,
								text: `${workerIndex}/${kind}${name}`,
							},
							WORKER_BINDING_SERVICE_LOOPBACK,
						],
					},
				};
			} else if (typeof service === "object" && !("name" in service)) {
				return {
					name: getBuiltinServiceName(workerIndex, kind, name),
					...service,
				};
			}
		}
		var FALLBACK_COMPATIBILITY_DATE = "2000-01-01";
		function getCurrentCompatibilityDate() {
			const now = /* @__PURE__ */ new Date().toISOString();
			return now.substring(0, now.indexOf("T"));
		}
		function validateCompatibilityDate(log, compatibilityDate) {
			if (numericCompare(compatibilityDate, getCurrentCompatibilityDate()) > 0) {
				throw new MiniflareCoreError(
					"ERR_FUTURE_COMPATIBILITY_DATE",
					`Compatibility date "${compatibilityDate}" is in the future and unsupported`,
				);
			} else if (numericCompare(compatibilityDate, import_workerd2.compatibilityDate) > 0) {
				log.warn(
					[
						"The latest compatibility date supported by the installed Cloudflare Workers Runtime is ",
						bold(`"${import_workerd2.compatibilityDate}"`),
						",\nbut you've requested ",
						bold(`"${compatibilityDate}"`),
						". Falling back to ",
						bold(`"${import_workerd2.compatibilityDate}"`),
						"...",
					].join(""),
				);
				return import_workerd2.compatibilityDate;
			}
			return compatibilityDate;
		}
		function buildJsonBindings(bindings) {
			return Object.entries(bindings).map(([name, value]) => ({
				name,
				json: JSON.stringify(value),
			}));
		}
		var WRAPPED_MODULE_PREFIX = "miniflare-internal:wrapped:";
		function workerNameToWrappedModule(workerName) {
			return WRAPPED_MODULE_PREFIX + workerName;
		}
		function maybeWrappedModuleToWorkerName(name) {
			if (name.startsWith(WRAPPED_MODULE_PREFIX)) {
				return name.substring(WRAPPED_MODULE_PREFIX.length);
			}
		}
		var CORE_PLUGIN = {
			options: CoreOptionsSchema,
			sharedOptions: CoreSharedOptionsSchema,
			getBindings(options, workerIndex) {
				const bindings = [];
				if (options.bindings !== void 0) {
					bindings.push(...buildJsonBindings(options.bindings));
				}
				if (options.wasmBindings !== void 0) {
					bindings.push(
						...Object.entries(options.wasmBindings).map(([name, value]) =>
							typeof value === "string"
								? import_promises6.default
										.readFile(value)
										.then((wasmModule) => ({ name, wasmModule }))
								: { name, wasmModule: value },
						),
					);
				}
				if (options.textBlobBindings !== void 0) {
					bindings.push(
						...Object.entries(options.textBlobBindings).map(([name, path28]) =>
							import_promises6.default
								.readFile(path28, "utf8")
								.then((text) => ({ name, text })),
						),
					);
				}
				if (options.dataBlobBindings !== void 0) {
					bindings.push(
						...Object.entries(options.dataBlobBindings).map(([name, value]) =>
							typeof value === "string"
								? import_promises6.default
										.readFile(value)
										.then((data) => ({ name, data }))
								: { name, data: value },
						),
					);
				}
				if (options.serviceBindings !== void 0) {
					bindings.push(
						...Object.entries(options.serviceBindings).map(([name, service]) => {
							return {
								name,
								service: getCustomServiceDesignator(
									/* referrer */
									options.name,
									workerIndex,
									"#",
									name,
									service,
									options.hasAssetsAndIsVitest,
								),
							};
						}),
					);
				}
				if (options.wrappedBindings !== void 0) {
					bindings.push(
						...Object.entries(options.wrappedBindings).map(([name, designator]) => {
							const isObject = typeof designator === "object";
							const scriptName = isObject ? designator.scriptName : designator;
							const entrypoint = isObject ? designator.entrypoint : void 0;
							const bindings2 = isObject ? designator.bindings : void 0;
							const moduleName2 = workerNameToWrappedModule(scriptName);
							const innerBindings =
								bindings2 === void 0 ? [] : buildJsonBindings(bindings2);
							return {
								name,
								wrapped: { moduleName: moduleName2, entrypoint, innerBindings },
							};
						}),
					);
				}
				if (options.unsafeEvalBinding !== void 0) {
					bindings.push({
						name: options.unsafeEvalBinding,
						unsafeEval: kVoid,
					});
				}
				return Promise.all(bindings);
			},
			async getNodeBindings(options) {
				const bindingEntries2 = [];
				if (options.bindings !== void 0) {
					bindingEntries2.push(
						...Object.entries(options.bindings).map(([name, value]) => [
							name,
							JSON.parse(JSON.stringify(value)),
						]),
					);
				}
				if (options.wasmBindings !== void 0) {
					bindingEntries2.push(
						...Object.entries(options.wasmBindings).map(([name, value]) =>
							typeof value === "string"
								? import_promises6.default
										.readFile(value)
										.then((buffer) => [name, new WebAssembly.Module(buffer)])
								: [name, new WebAssembly.Module(value)],
						),
					);
				}
				if (options.textBlobBindings !== void 0) {
					bindingEntries2.push(
						...Object.entries(options.textBlobBindings).map(([name, path28]) =>
							import_promises6.default
								.readFile(path28, "utf8")
								.then((text) => [name, text]),
						),
					);
				}
				if (options.dataBlobBindings !== void 0) {
					bindingEntries2.push(
						...Object.entries(options.dataBlobBindings).map(([name, value]) =>
							typeof value === "string"
								? import_promises6.default
										.readFile(value)
										.then((buffer) => [name, viewToBuffer(buffer)])
								: [name, viewToBuffer(value)],
						),
					);
				}
				if (options.serviceBindings !== void 0) {
					bindingEntries2.push(
						...Object.keys(options.serviceBindings).map((name) => [
							name,
							new ProxyNodeBinding(),
						]),
					);
				}
				if (options.wrappedBindings !== void 0) {
					bindingEntries2.push(
						...Object.keys(options.wrappedBindings).map((name) => [
							name,
							new ProxyNodeBinding(),
						]),
					);
				}
				return Object.fromEntries(await Promise.all(bindingEntries2));
			},
			async getServices({
				log,
				options,
				sharedOptions,
				workerBindings,
				workerIndex,
				wrappedBindingNames,
				durableObjectClassNames,
				additionalModules,
				loopbackPort,
			}) {
				const additionalModuleNames = additionalModules.map(({ name: name2 }) => name2);
				const workerScript = getWorkerScript(options, workerIndex, additionalModuleNames);
				if ("modules" in workerScript) {
					const subDirs = new Set(
						workerScript.modules.map(({ name: name2 }) =>
							import_path17.default.posix.dirname(name2),
						),
					);
					subDirs.delete(".");
					for (const module22 of additionalModules) {
						workerScript.modules.push(module22);
						for (const subDir of subDirs) {
							const relativePath = import_path17.default.posix.relative(
								subDir,
								module22.name,
							);
							const relativePathString = JSON.stringify(relativePath);
							workerScript.modules.push({
								name: import_path17.default.posix.join(subDir, module22.name),
								// TODO(someday): if we ever have additional modules without
								//  default exports, this may be a problem. For now, our only
								//  additional module is `__STATIC_CONTENT_MANIFEST` so it's fine.
								//  If needed, we could look for instances of `export default` or
								//  `as default` in the module's code as a heuristic.
								esModule: `export * from ${relativePathString}; export { default } from ${relativePathString};`,
							});
						}
					}
				}
				const name = options.name ?? "";
				const serviceName = getUserServiceName(options.name);
				const classNames = durableObjectClassNames.get(serviceName);
				const classNamesEntries = Array.from(classNames ?? []);
				const compatibilityDate = validateCompatibilityDate(
					log,
					options.compatibilityDate ?? FALLBACK_COMPATIBILITY_DATE,
				);
				const isWrappedBinding = wrappedBindingNames.has(name);
				const services = [];
				const extensions = [];
				if (isWrappedBinding) {
					let invalidWrapped2 = function (reason) {
						const message = `Cannot use ${stringName} for wrapped binding because ${reason}`;
						throw new MiniflareCoreError("ERR_INVALID_WRAPPED", message);
					};
					var invalidWrapped = invalidWrapped2;
					const stringName = JSON.stringify(name);
					if (workerIndex === 0) {
						invalidWrapped2(
							`it's the entrypoint.
Ensure ${stringName} isn't the first entry in the \`workers\` array.`,
						);
					}
					if (!("modules" in workerScript)) {
						invalidWrapped2(
							`it's a service worker.
Ensure ${stringName} sets \`modules\` to \`true\` or an array of modules`,
						);
					}
					if (workerScript.modules.length !== 1) {
						invalidWrapped2(
							`it isn't a single module.
Ensure ${stringName} doesn't include unbundled \`import\`s.`,
						);
					}
					const firstModule = workerScript.modules[0];
					if (!("esModule" in firstModule)) {
						invalidWrapped2("it isn't a single ES module");
					}
					if (options.compatibilityDate !== void 0) {
						invalidWrapped2(
							"it defines a compatibility date.\nWrapped bindings use the compatibility date of the worker with the binding.",
						);
					}
					if (options.compatibilityFlags?.length) {
						invalidWrapped2(
							"it defines compatibility flags.\nWrapped bindings use the compatibility flags of the worker with the binding.",
						);
					}
					if (options.outboundService !== void 0) {
						invalidWrapped2(
							"it defines an outbound service.\nWrapped bindings use the outbound service of the worker with the binding.",
						);
					}
					extensions.push({
						modules: [
							{
								name: workerNameToWrappedModule(name),
								esModule: firstModule.esModule,
								internal: true,
							},
						],
					});
				} else {
					services.push({
						name: serviceName,
						worker: {
							...workerScript,
							compatibilityDate,
							compatibilityFlags: options.compatibilityFlags,
							bindings: workerBindings,
							durableObjectNamespaces: classNamesEntries.map(
								([
									className,
									{ enableSql, unsafeUniqueKey, unsafePreventEviction },
								]) => {
									if (unsafeUniqueKey === kUnsafeEphemeralUniqueKey) {
										return {
											className,
											enableSql,
											ephemeralLocal: kVoid,
											preventEviction: unsafePreventEviction,
										};
									} else {
										return {
											className,
											enableSql,
											// This `uniqueKey` will (among other things) be used as part of the
											// path when persisting to the file-system. `-` is invalid in
											// JavaScript class names, but safe on filesystems (incl. Windows).
											uniqueKey:
												unsafeUniqueKey ??
												`${options.name ?? ""}-${className}`,
											preventEviction: unsafePreventEviction,
										};
									}
								},
							),
							durableObjectStorage:
								classNamesEntries.length === 0
									? void 0
									: options.unsafeEphemeralDurableObjects
										? { inMemory: kVoid }
										: { localDisk: DURABLE_OBJECTS_STORAGE_SERVICE_NAME },
							globalOutbound:
								options.outboundService === void 0
									? void 0
									: getCustomServiceDesignator(
											/* referrer */
											options.name,
											workerIndex,
											"$",
											CUSTOM_SERVICE_KNOWN_OUTBOUND,
											options.outboundService,
											options.hasAssetsAndIsVitest,
										),
							cacheApiOutbound: { name: getCacheServiceName(workerIndex) },
							moduleFallback:
								options.unsafeUseModuleFallbackService &&
								sharedOptions.unsafeModuleFallbackService !== void 0
									? `localhost:${loopbackPort}`
									: void 0,
						},
					});
				}
				if (options.serviceBindings !== void 0) {
					for (const [name2, service] of Object.entries(options.serviceBindings)) {
						const maybeService = maybeGetCustomServiceService(
							workerIndex,
							"#",
							name2,
							service,
						);
						if (maybeService !== void 0) services.push(maybeService);
					}
				}
				if (options.outboundService !== void 0) {
					const maybeService = maybeGetCustomServiceService(
						workerIndex,
						"$",
						CUSTOM_SERVICE_KNOWN_OUTBOUND,
						options.outboundService,
					);
					if (maybeService !== void 0) services.push(maybeService);
				}
				return { services, extensions };
			},
		};
		function getGlobalServices({
			sharedOptions,
			allWorkerRoutes,
			fallbackWorkerName,
			loopbackPort,
			log,
			proxyBindings,
		}) {
			const workerNames = [...allWorkerRoutes.keys()];
			const routes = parseRoutes(allWorkerRoutes);
			const serviceEntryBindings = [
				WORKER_BINDING_SERVICE_LOOPBACK,
				// For converting stack-traces to pretty-error pages
				{ name: CoreBindings.JSON_ROUTES, json: JSON.stringify(routes) },
				{ name: CoreBindings.JSON_CF_BLOB, json: JSON.stringify(sharedOptions.cf) },
				{ name: CoreBindings.JSON_LOG_LEVEL, json: JSON.stringify(log.level) },
				{
					name: CoreBindings.SERVICE_USER_FALLBACK,
					service: { name: fallbackWorkerName },
				},
				...workerNames.map((name) => ({
					name: CoreBindings.SERVICE_USER_ROUTE_PREFIX + name,
					service: { name: getUserServiceName(name) },
				})),
				{
					name: CoreBindings.DURABLE_OBJECT_NAMESPACE_PROXY,
					durableObjectNamespace: { className: "ProxyServer" },
				},
				{
					name: CoreBindings.DATA_PROXY_SECRET,
					data: PROXY_SECRET,
				},
				// Add `proxyBindings` here, they'll be added to the `ProxyServer` `env`
				...proxyBindings,
			];
			if (sharedOptions.upstream !== void 0) {
				serviceEntryBindings.push({
					name: CoreBindings.TEXT_UPSTREAM_URL,
					text: sharedOptions.upstream,
				});
			}
			if (sharedOptions.unsafeProxySharedSecret !== void 0) {
				serviceEntryBindings.push({
					name: CoreBindings.DATA_PROXY_SHARED_SECRET,
					data: encoder2.encode(sharedOptions.unsafeProxySharedSecret),
				});
			}
			if (sharedOptions.liveReload) {
				const liveReloadScript = LIVE_RELOAD_SCRIPT_TEMPLATE(loopbackPort);
				serviceEntryBindings.push({
					name: CoreBindings.DATA_LIVE_RELOAD_SCRIPT,
					data: encoder2.encode(liveReloadScript),
				});
			}
			return [
				{
					name: SERVICE_LOOPBACK,
					external: { http: { cfBlobHeader: CoreHeaders.CF_BLOB } },
				},
				{
					name: SERVICE_ENTRY,
					worker: {
						modules: [{ name: "entry.worker.js", esModule: entry_worker_default() }],
						compatibilityDate: "2023-04-04",
						compatibilityFlags: [
							"nodejs_compat",
							"service_binding_extra_handlers",
							"brotli_content_encoding",
							"rpc",
						],
						bindings: serviceEntryBindings,
						durableObjectNamespaces: [
							{
								className: "ProxyServer",
								uniqueKey: `${SERVICE_ENTRY}-ProxyServer`,
								// `ProxyServer` relies on a singleton object containing of "heap"
								// mapping addresses to native references. If the singleton object
								// were evicted, addresses would be invalidated. Therefore, we
								// prevent eviction to ensure heap addresses stay valid for the
								// lifetime of the `workerd` process
								preventEviction: true,
							},
						],
						// `ProxyServer` doesn't make use of Durable Object storage
						durableObjectStorage: { inMemory: kVoid },
						// Always use the entrypoints cache implementation for proxying. This
						// means if the entrypoint disables caching, proxied cache operations
						// will be no-ops. Note we always require at least one worker to be set.
						cacheApiOutbound: { name: "cache:0" },
					},
				},
				{
					name: "internet",
					network: {
						// Allow access to private/public addresses:
						// https://github.com/cloudflare/miniflare/issues/412
						allow: ["public", "private", "240.0.0.0/4"],
						deny: [],
						tlsOptions: {
							trustBrowserCas: true,
							trustedCertificates,
						},
					},
				},
			];
		}
		function getWorkerScript(options, workerIndex, additionalModuleNames) {
			const modulesRoot = import_path17.default.resolve(
				("modulesRoot" in options ? options.modulesRoot : void 0) ?? "",
			);
			if (Array.isArray(options.modules)) {
				return {
					modules: options.modules.map((module22) =>
						convertModuleDefinition(modulesRoot, module22),
					),
				};
			}
			let code;
			if ("script" in options && options.script !== void 0) {
				code = options.script;
			} else if ("scriptPath" in options && options.scriptPath !== void 0) {
				code = (0, import_fs14.readFileSync)(options.scriptPath, "utf8");
			} else {
				import_assert9.default.fail("Unreachable: Workers must have code");
			}
			const scriptPath = options.scriptPath ?? buildStringScriptPath(workerIndex);
			if (options.modules) {
				const locator = new ModuleLocator(
					modulesRoot,
					additionalModuleNames,
					options.modulesRules,
					options.compatibilityDate,
					options.compatibilityFlags,
				);
				locator.visitEntrypoint(code, scriptPath);
				return { modules: locator.modules };
			} else {
				code = withSourceURL(code, scriptPath);
				return { serviceWorkerScript: code };
			}
		}
		var import_zod13 = require_lib();
		var AssetsOptionsSchema = import_zod13.z.object({
			assets: import_zod13.z
				.object({
					// User worker name or vitest runner - this is only ever set inside miniflare
					// The assets plugin needs access to the worker name to create the router worker - user worker binding
					workerName: import_zod13.z.string().optional(),
					directory: PathSchema,
					binding: import_zod13.z.string().optional(),
					routingConfig: RoutingConfigSchema.optional(),
					assetConfig: AssetConfigSchema.optional(),
				})
				.optional(),
		});
		var ASSETS_PLUGIN = {
			options: AssetsOptionsSchema,
			async getBindings(options) {
				if (!options.assets?.binding) {
					return [];
				}
				return [
					{
						// binding between User Worker and Asset Worker
						name: options.assets.binding,
						service: { name: ASSETS_SERVICE_NAME },
					},
				];
			},
			async getNodeBindings(options) {
				if (!options.assets?.binding) {
					return {};
				}
				return {
					[options.assets.binding]: new ProxyNodeBinding(),
				};
			},
			async getServices({ options }) {
				if (!options.assets) {
					return [];
				}
				const storageServiceName = `${ASSETS_PLUGIN_NAME}:storage`;
				const storageService = {
					name: storageServiceName,
					disk: { path: options.assets.directory, writable: true },
				};
				const { encodedAssetManifest, assetsReverseMap } = await buildAssetManifest(
					options.assets.directory,
				);
				const namespaceService = {
					name: ASSETS_KV_SERVICE_NAME,
					worker: {
						compatibilityDate: "2023-07-24",
						compatibilityFlags: ["nodejs_compat"],
						modules: [
							{
								name: "assets-kv-worker.mjs",
								esModule: assets_kv_worker_default(),
							},
						],
						bindings: [
							{
								name: SharedBindings.MAYBE_SERVICE_BLOBS,
								service: { name: storageServiceName },
							},
							{
								name: "ASSETS_REVERSE_MAP",
								json: JSON.stringify(assetsReverseMap),
							},
						],
					},
				};
				const assetService = {
					name: ASSETS_SERVICE_NAME,
					worker: {
						compatibilityDate: "2024-08-01",
						modules: [
							{
								name: "asset-worker.mjs",
								esModule: assets_worker_default(),
							},
						],
						bindings: [
							{
								name: "ASSETS_KV_NAMESPACE",
								kvNamespace: { name: ASSETS_KV_SERVICE_NAME },
							},
							{
								name: "ASSETS_MANIFEST",
								data: encodedAssetManifest,
							},
							{
								name: "CONFIG",
								json: JSON.stringify(options.assets.assetConfig ?? {}),
							},
						],
					},
				};
				const routerService = {
					name: ROUTER_SERVICE_NAME,
					worker: {
						compatibilityDate: "2024-08-01",
						modules: [
							{
								name: "router-worker.mjs",
								esModule: router_worker_default(),
							},
						],
						bindings: [
							{
								name: "ASSET_WORKER",
								service: { name: ASSETS_SERVICE_NAME },
							},
							{
								name: "USER_WORKER",
								service: { name: getUserServiceName(options.assets.workerName) },
							},
							{
								name: "CONFIG",
								json: JSON.stringify(options.assets.routingConfig),
							},
						],
					},
				};
				return [storageService, namespaceService, assetService, routerService];
			},
		};
		var buildAssetManifest = async (dir) => {
			const { manifest, assetsReverseMap } = await walk(dir);
			const sortedAssetManifest = sortManifest(manifest);
			const encodedAssetManifest = encodeManifest(sortedAssetManifest);
			return { encodedAssetManifest, assetsReverseMap };
		};
		var walk = async (dir) => {
			const files = await import_promises7.default.readdir(dir, { recursive: true });
			const manifest = [];
			const assetsReverseMap = {};
			let counter = 0;
			await Promise.all(
				files.map(async (file) => {
					const filepath = import_node_path2.default.join(dir, file);
					const relativeFilepath = import_node_path2.default.relative(dir, filepath);
					const filestat = await import_promises7.default.stat(filepath);
					if (filestat.isSymbolicLink() || filestat.isDirectory()) {
						return;
					} else {
						if (filestat.size > MAX_ASSET_SIZE) {
							throw new Error(
								`Asset too large.
Cloudflare Workers supports assets with sizes of up to ${prettyBytes(MAX_ASSET_SIZE, {
									binary: true,
								})}. We found a file ${filepath} with a size of ${prettyBytes(
									filestat.size,
									{
										binary: true,
									},
								)}.
Ensure all assets in your assets directory "${dir}" conform with the Workers maximum size requirement.`,
							);
						}
						const [pathHash, contentHash] = await Promise.all([
							hashPath(normalizeFilePath(relativeFilepath)),
							// used absolute filepath here so that changes to the enclosing asset folder will be registered
							hashPath(filepath + filestat.mtimeMs.toString()),
						]);
						manifest.push({
							pathHash,
							contentHash,
						});
						assetsReverseMap[bytesToHex(contentHash)] = {
							filePath: relativeFilepath,
							contentType: getContentType(filepath),
						};
						counter++;
					}
				}),
			);
			if (counter > MAX_ASSET_COUNT) {
				throw new Error(
					`Maximum number of assets exceeded.
Cloudflare Workers supports up to ${MAX_ASSET_COUNT.toLocaleString()} assets in a version. We found ${counter.toLocaleString()} files in the specified assets directory "${dir}".
Ensure your assets directory contains a maximum of ${MAX_ASSET_COUNT.toLocaleString()} files, and that you have specified your assets directory correctly.`,
				);
			}
			return { manifest, assetsReverseMap };
		};
		var sortManifest = (manifest) => {
			return manifest.sort(comparisonFn);
		};
		var comparisonFn = (a, b) => {
			if (a.pathHash.length < b.pathHash.length) {
				return -1;
			}
			if (a.pathHash.length > b.pathHash.length) {
				return 1;
			}
			for (const [i, v] of a.pathHash.entries()) {
				if (v < b.pathHash[i]) {
					return -1;
				}
				if (v > b.pathHash[i]) {
					return 1;
				}
			}
			return 1;
		};
		var encodeManifest = (manifest) => {
			const assetManifestBytes = new Uint8Array(HEADER_SIZE + manifest.length * ENTRY_SIZE);
			for (const [i, entry] of manifest.entries()) {
				const entryOffset = HEADER_SIZE + i * ENTRY_SIZE;
				assetManifestBytes.set(entry.pathHash, entryOffset + PATH_HASH_OFFSET);
				assetManifestBytes.set(entry.contentHash, entryOffset + CONTENT_HASH_OFFSET);
			}
			return assetManifestBytes;
		};
		var bytesToHex = (buffer) => {
			return [...new Uint8Array(buffer)].map((b) => b.toString(16).padStart(2, "0")).join("");
		};
		var hashPath = async (path28) => {
			const encoder3 = new TextEncoder();
			const data = encoder3.encode(path28);
			const hashBuffer = await import_node_crypto.default.subtle.digest(
				"SHA-256",
				data.buffer,
			);
			return new Uint8Array(hashBuffer, 0, PATH_HASH_SIZE);
		};
		var import_promises8 = __toESM2(require("fs/promises"));
		var import_fs15 = __toESM2(require("fs"));
		var import_path18 = __toESM2(require("path"));
		var import_url15 = __toESM2(require("url"));
		var contents11;
		function database_worker_default() {
			if (contents11 !== void 0) return contents11;
			const filePath = import_path18.default.join(
				__dirname,
				"workers",
				"d1/database.worker.js",
			);
			contents11 =
				import_fs15.default.readFileSync(filePath, "utf8") +
				"//# sourceURL=" +
				import_url15.default.pathToFileURL(filePath);
			return contents11;
		}
		var import_zod14 = require_lib();
		var D1OptionsSchema = import_zod14.z.object({
			d1Databases: import_zod14.z
				.union([
					import_zod14.z.record(import_zod14.z.string()),
					import_zod14.z.string().array(),
				])
				.optional(),
		});
		var D1SharedOptionsSchema = import_zod14.z.object({
			d1Persist: PersistenceSchema,
		});
		var D1_PLUGIN_NAME = "d1";
		var D1_STORAGE_SERVICE_NAME = `${D1_PLUGIN_NAME}:storage`;
		var D1_DATABASE_SERVICE_PREFIX = `${D1_PLUGIN_NAME}:db`;
		var D1_DATABASE_OBJECT_CLASS_NAME = "D1DatabaseObject";
		var D1_DATABASE_OBJECT = {
			serviceName: D1_DATABASE_SERVICE_PREFIX,
			className: D1_DATABASE_OBJECT_CLASS_NAME,
		};
		var D1_PLUGIN = {
			options: D1OptionsSchema,
			sharedOptions: D1SharedOptionsSchema,
			getBindings(options) {
				const databases = namespaceEntries(options.d1Databases);
				return databases.map(([name, id]) => {
					const binding = name.startsWith("__D1_BETA__")
						? // Used before Wrangler 3.3
							{
								service: { name: `${D1_DATABASE_SERVICE_PREFIX}:${id}` },
							}
						: // Used after Wrangler 3.3
							{
								wrapped: {
									moduleName: "cloudflare-internal:d1-api",
									innerBindings: [
										{
											name: "fetcher",
											service: {
												name: `${D1_DATABASE_SERVICE_PREFIX}:${id}`,
											},
										},
									],
								},
							};
					return { name, ...binding };
				});
			},
			getNodeBindings(options) {
				const databases = namespaceKeys(options.d1Databases);
				return Object.fromEntries(databases.map((name) => [name, new ProxyNodeBinding()]));
			},
			async getServices({ options, sharedOptions, tmpPath, log, unsafeStickyBlobs }) {
				const persist = sharedOptions.d1Persist;
				const databases = namespaceEntries(options.d1Databases);
				const services = databases.map(([_, id]) => ({
					name: `${D1_DATABASE_SERVICE_PREFIX}:${id}`,
					worker: objectEntryWorker(D1_DATABASE_OBJECT, id),
				}));
				if (databases.length > 0) {
					const uniqueKey = `miniflare-${D1_DATABASE_OBJECT_CLASS_NAME}`;
					const persistPath = getPersistPath(D1_PLUGIN_NAME, tmpPath, persist);
					await import_promises8.default.mkdir(persistPath, { recursive: true });
					const storageService = {
						name: D1_STORAGE_SERVICE_NAME,
						disk: { path: persistPath, writable: true },
					};
					const objectService = {
						name: D1_DATABASE_SERVICE_PREFIX,
						worker: {
							compatibilityDate: "2023-07-24",
							compatibilityFlags: ["nodejs_compat", "experimental"],
							modules: [
								{
									name: "database.worker.js",
									esModule: database_worker_default(),
								},
							],
							durableObjectNamespaces: [
								{
									className: D1_DATABASE_OBJECT_CLASS_NAME,
									uniqueKey,
								},
							],
							// Store Durable Object SQL databases in persist path
							durableObjectStorage: { localDisk: D1_STORAGE_SERVICE_NAME },
							// Bind blob disk directory service to object
							bindings: [
								{
									name: SharedBindings.MAYBE_SERVICE_BLOBS,
									service: { name: D1_STORAGE_SERVICE_NAME },
								},
								{
									name: SharedBindings.MAYBE_SERVICE_LOOPBACK,
									service: { name: SERVICE_LOOPBACK },
								},
								...getMiniflareObjectBindings(unsafeStickyBlobs),
							],
						},
					};
					services.push(storageService, objectService);
					for (const database of databases) {
						await migrateDatabase(log, uniqueKey, persistPath, database[1]);
					}
				}
				return services;
			},
			getPersistPath({ d1Persist }, tmpPath) {
				return getPersistPath(D1_PLUGIN_NAME, tmpPath, d1Persist);
			},
		};
		var import_node_assert3 = __toESM2(require("assert"));
		var import_zod15 = require_lib();
		var HYPERDRIVE_PLUGIN_NAME = "hyperdrive";
		function hasPostgresProtocol(url18) {
			return url18.protocol === "postgresql:" || url18.protocol === "postgres:";
		}
		function getPort(url18) {
			if (url18.port !== "") return url18.port;
			if (hasPostgresProtocol(url18)) return "5432";
			import_node_assert3.default.fail(`Expected known protocol, got ${url18.protocol}`);
		}
		var HyperdriveSchema = import_zod15.z
			.union([import_zod15.z.string().url(), import_zod15.z.instanceof(URL)])
			.transform((url18, ctx) => {
				if (typeof url18 === "string") url18 = new URL(url18);
				if (url18.protocol === "") {
					ctx.addIssue({
						code: import_zod15.z.ZodIssueCode.custom,
						message: "You must specify the database protocol - e.g. 'postgresql'.",
					});
				} else if (!hasPostgresProtocol(url18)) {
					ctx.addIssue({
						code: import_zod15.z.ZodIssueCode.custom,
						message:
							"Only PostgreSQL or PostgreSQL compatible databases are currently supported.",
					});
				}
				if (url18.host === "") {
					ctx.addIssue({
						code: import_zod15.z.ZodIssueCode.custom,
						message:
							"You must provide a hostname or IP address in your connection string - e.g. 'user:password@database-hostname.example.com:5432/databasename",
					});
				}
				if (url18.pathname === "") {
					ctx.addIssue({
						code: import_zod15.z.ZodIssueCode.custom,
						message:
							"You must provide a database name as the path component - e.g. /postgres",
					});
				}
				if (url18.username === "") {
					ctx.addIssue({
						code: import_zod15.z.ZodIssueCode.custom,
						message:
							"You must provide a username - e.g. 'user:password@database.example.com:port/databasename'",
					});
				}
				if (url18.password === "") {
					ctx.addIssue({
						code: import_zod15.z.ZodIssueCode.custom,
						message:
							"You must provide a password - e.g. 'user:password@database.example.com:port/databasename' ",
					});
				}
				return url18;
			});
		var HyperdriveInputOptionsSchema = import_zod15.z.object({
			hyperdrives: import_zod15.z
				.record(import_zod15.z.string(), HyperdriveSchema)
				.optional(),
		});
		var HYPERDRIVE_PLUGIN = {
			options: HyperdriveInputOptionsSchema,
			getBindings(options) {
				return Object.entries(options.hyperdrives ?? {}).map(([name, url18]) => {
					const database = url18.pathname.replace("/", "");
					const scheme = url18.protocol.replace(":", "");
					return {
						name,
						hyperdrive: {
							designator: {
								name: `${HYPERDRIVE_PLUGIN_NAME}:${name}`,
							},
							database: decodeURIComponent(database),
							user: decodeURIComponent(url18.username),
							password: decodeURIComponent(url18.password),
							scheme,
						},
					};
				});
			},
			getNodeBindings(options) {
				return Object.fromEntries(
					Object.entries(options.hyperdrives ?? {}).map(([name, url18]) => {
						const connectionOverrides = {
							connectionString: `${url18}`,
							port: Number.parseInt(url18.port),
							host: url18.hostname,
						};
						const proxyNodeBinding = new ProxyNodeBinding({
							get(target, prop) {
								return prop in connectionOverrides
									? connectionOverrides[prop]
									: target[prop];
							},
						});
						return [name, proxyNodeBinding];
					}),
				);
			},
			async getServices({ options }) {
				return Object.entries(options.hyperdrives ?? {}).map(([name, url18]) => ({
					name: `${HYPERDRIVE_PLUGIN_NAME}:${name}`,
					external: {
						address: `${url18.hostname}:${getPort(url18)}`,
						tcp: {},
					},
				}));
			},
		};
		var import_promises10 = __toESM2(require("fs/promises"));
		var import_fs16 = __toESM2(require("fs"));
		var import_path19 = __toESM2(require("path"));
		var import_url16 = __toESM2(require("url"));
		var contents12;
		function namespace_worker_default() {
			if (contents12 !== void 0) return contents12;
			const filePath = import_path19.default.join(
				__dirname,
				"workers",
				"kv/namespace.worker.js",
			);
			contents12 =
				import_fs16.default.readFileSync(filePath, "utf8") +
				"//# sourceURL=" +
				import_url16.default.pathToFileURL(filePath);
			return contents12;
		}
		var import_zod16 = require_lib();
		var KV_PLUGIN_NAME = "kv";
		var import_assert10 = __toESM2(require("assert"));
		var import_promises9 = __toESM2(require("fs/promises"));
		var import_path21 = __toESM2(require("path"));
		var import_fs17 = __toESM2(require("fs"));
		var import_path20 = __toESM2(require("path"));
		var import_url17 = __toESM2(require("url"));
		var contents13;
		function sites_worker_default() {
			if (contents13 !== void 0) return contents13;
			const filePath = import_path20.default.join(__dirname, "workers", "kv/sites.worker.js");
			contents13 =
				import_fs17.default.readFileSync(filePath, "utf8") +
				"//# sourceURL=" +
				import_url17.default.pathToFileURL(filePath);
			return contents13;
		}
		async function* listKeysInDirectoryInner(rootPath2, currentPath) {
			const fileEntries = await import_promises9.default.readdir(currentPath, {
				withFileTypes: true,
			});
			for (const fileEntry of fileEntries) {
				const filePath = import_path21.default.posix.join(currentPath, fileEntry.name);
				if (fileEntry.isDirectory()) {
					yield* listKeysInDirectoryInner(rootPath2, filePath);
				} else {
					yield filePath.substring(rootPath2.length + 1);
				}
			}
		}
		function listKeysInDirectory(rootPath2) {
			rootPath2 = import_path21.default.resolve(rootPath2);
			return listKeysInDirectoryInner(rootPath2, rootPath2);
		}
		var sitesRegExpsCache = /* @__PURE__ */ new WeakMap();
		var SERVICE_NAMESPACE_SITE = `${KV_PLUGIN_NAME}:site`;
		async function buildStaticContentManifest(sitePath, siteRegExps) {
			const staticContentManifest = {};
			for await (const key of listKeysInDirectory(sitePath)) {
				if (testSiteRegExps(siteRegExps, key)) {
					staticContentManifest[key] = encodeSitesKey(key);
				}
			}
			return staticContentManifest;
		}
		async function getSitesBindings(options) {
			const siteRegExps = {
				include: options.siteInclude && globsToRegExps(options.siteInclude),
				exclude: options.siteExclude && globsToRegExps(options.siteExclude),
			};
			sitesRegExpsCache.set(options, siteRegExps);
			const __STATIC_CONTENT_MANIFEST = await buildStaticContentManifest(
				options.sitePath,
				siteRegExps,
			);
			return [
				{
					name: SiteBindings.KV_NAMESPACE_SITE,
					kvNamespace: { name: SERVICE_NAMESPACE_SITE },
				},
				{
					name: SiteBindings.JSON_SITE_MANIFEST,
					json: JSON.stringify(__STATIC_CONTENT_MANIFEST),
				},
			];
		}
		async function getSitesNodeBindings(options) {
			const siteRegExps = sitesRegExpsCache.get(options);
			(0, import_assert10.default)(siteRegExps !== void 0);
			const __STATIC_CONTENT_MANIFEST = await buildStaticContentManifest(
				options.sitePath,
				siteRegExps,
			);
			return {
				[SiteBindings.KV_NAMESPACE_SITE]: new ProxyNodeBinding(),
				[SiteBindings.JSON_SITE_MANIFEST]: __STATIC_CONTENT_MANIFEST,
			};
		}
		function getSitesServices(options) {
			const siteRegExps = sitesRegExpsCache.get(options);
			(0, import_assert10.default)(siteRegExps !== void 0);
			const serialisedSiteRegExps = serialiseSiteRegExps(siteRegExps);
			const persist = import_path21.default.resolve(options.sitePath);
			const storageServiceName = `${SERVICE_NAMESPACE_SITE}:storage`;
			const storageService = {
				name: storageServiceName,
				disk: { path: persist, writable: true },
			};
			const namespaceService = {
				name: SERVICE_NAMESPACE_SITE,
				worker: {
					compatibilityDate: "2023-07-24",
					compatibilityFlags: ["nodejs_compat"],
					modules: [
						{
							name: "site.worker.js",
							esModule: sites_worker_default(),
						},
					],
					bindings: [
						{
							name: SharedBindings.MAYBE_SERVICE_BLOBS,
							service: { name: storageServiceName },
						},
						{
							name: SiteBindings.JSON_SITE_FILTER,
							json: JSON.stringify(serialisedSiteRegExps),
						},
					],
				},
			};
			return [storageService, namespaceService];
		}
		var KVOptionsSchema = import_zod16.z.object({
			kvNamespaces: import_zod16.z
				.union([
					import_zod16.z.record(import_zod16.z.string()),
					import_zod16.z.string().array(),
				])
				.optional(),
			// Workers Sites
			sitePath: PathSchema.optional(),
			siteInclude: import_zod16.z.string().array().optional(),
			siteExclude: import_zod16.z.string().array().optional(),
		});
		var KVSharedOptionsSchema = import_zod16.z.object({
			kvPersist: PersistenceSchema,
		});
		var SERVICE_NAMESPACE_PREFIX = `${KV_PLUGIN_NAME}:ns`;
		var KV_STORAGE_SERVICE_NAME = `${KV_PLUGIN_NAME}:storage`;
		var KV_NAMESPACE_OBJECT_CLASS_NAME = "KVNamespaceObject";
		var KV_NAMESPACE_OBJECT = {
			serviceName: SERVICE_NAMESPACE_PREFIX,
			className: KV_NAMESPACE_OBJECT_CLASS_NAME,
		};
		function isWorkersSitesEnabled(options) {
			return options.sitePath !== void 0;
		}
		var KV_PLUGIN = {
			options: KVOptionsSchema,
			sharedOptions: KVSharedOptionsSchema,
			async getBindings(options) {
				const namespaces = namespaceEntries(options.kvNamespaces);
				const bindings = namespaces.map(([name, id]) => ({
					name,
					kvNamespace: { name: `${SERVICE_NAMESPACE_PREFIX}:${id}` },
				}));
				if (isWorkersSitesEnabled(options)) {
					bindings.push(...(await getSitesBindings(options)));
				}
				return bindings;
			},
			async getNodeBindings(options) {
				const namespaces = namespaceKeys(options.kvNamespaces);
				const bindings = Object.fromEntries(
					namespaces.map((name) => [name, new ProxyNodeBinding()]),
				);
				if (isWorkersSitesEnabled(options)) {
					Object.assign(bindings, await getSitesNodeBindings(options));
				}
				return bindings;
			},
			async getServices({ options, sharedOptions, tmpPath, log, unsafeStickyBlobs }) {
				const persist = sharedOptions.kvPersist;
				const namespaces = namespaceEntries(options.kvNamespaces);
				const services = namespaces.map(([_, id]) => ({
					name: `${SERVICE_NAMESPACE_PREFIX}:${id}`,
					worker: objectEntryWorker(KV_NAMESPACE_OBJECT, id),
				}));
				if (services.length > 0) {
					const uniqueKey = `miniflare-${KV_NAMESPACE_OBJECT_CLASS_NAME}`;
					const persistPath = getPersistPath(KV_PLUGIN_NAME, tmpPath, persist);
					await import_promises10.default.mkdir(persistPath, { recursive: true });
					const storageService = {
						name: KV_STORAGE_SERVICE_NAME,
						disk: { path: persistPath, writable: true },
					};
					const objectService = {
						name: SERVICE_NAMESPACE_PREFIX,
						worker: {
							compatibilityDate: "2023-07-24",
							compatibilityFlags: ["nodejs_compat", "experimental"],
							modules: [
								{
									name: "namespace.worker.js",
									esModule: namespace_worker_default(),
								},
							],
							durableObjectNamespaces: [
								{ className: KV_NAMESPACE_OBJECT_CLASS_NAME, uniqueKey },
							],
							// Store Durable Object SQL databases in persist path
							durableObjectStorage: { localDisk: KV_STORAGE_SERVICE_NAME },
							// Bind blob disk directory service to object
							bindings: [
								{
									name: SharedBindings.MAYBE_SERVICE_BLOBS,
									service: { name: KV_STORAGE_SERVICE_NAME },
								},
								{
									name: SharedBindings.MAYBE_SERVICE_LOOPBACK,
									service: { name: SERVICE_LOOPBACK },
								},
								...getMiniflareObjectBindings(unsafeStickyBlobs),
							],
						},
					};
					services.push(storageService, objectService);
					for (const namespace of namespaces) {
						await migrateDatabase(log, uniqueKey, persistPath, namespace[1]);
					}
				}
				if (isWorkersSitesEnabled(options)) {
					services.push(...getSitesServices(options));
				}
				return services;
			},
			getPersistPath({ kvPersist }, tmpPath) {
				return getPersistPath(KV_PLUGIN_NAME, tmpPath, kvPersist);
			},
		};
		var import_fs18 = __toESM2(require("fs"));
		var import_path22 = __toESM2(require("path"));
		var import_url18 = __toESM2(require("url"));
		var contents14;
		function broker_worker_default() {
			if (contents14 !== void 0) return contents14;
			const filePath = import_path22.default.join(
				__dirname,
				"workers",
				"queues/broker.worker.js",
			);
			contents14 =
				import_fs18.default.readFileSync(filePath, "utf8") +
				"//# sourceURL=" +
				import_url18.default.pathToFileURL(filePath);
			return contents14;
		}
		var import_zod17 = require_lib();
		var QueuesError = class extends MiniflareError {};
		var QueuesOptionsSchema = import_zod17.z.object({
			queueProducers: import_zod17.z
				.union([
					import_zod17.z.record(QueueProducerOptionsSchema),
					import_zod17.z.string().array(),
					import_zod17.z.record(import_zod17.z.string()),
				])
				.optional(),
			queueConsumers: import_zod17.z
				.union([
					import_zod17.z.record(QueueConsumerOptionsSchema),
					import_zod17.z.string().array(),
				])
				.optional(),
		});
		var QUEUES_PLUGIN_NAME = "queues";
		var SERVICE_QUEUE_PREFIX = `${QUEUES_PLUGIN_NAME}:queue`;
		var QUEUE_BROKER_OBJECT_CLASS_NAME = "QueueBrokerObject";
		var QUEUE_BROKER_OBJECT = {
			serviceName: SERVICE_QUEUE_PREFIX,
			className: QUEUE_BROKER_OBJECT_CLASS_NAME,
		};
		var QUEUES_PLUGIN = {
			options: QueuesOptionsSchema,
			getBindings(options) {
				const queues = bindingEntries(options.queueProducers);
				return queues.map(([name, id]) => ({
					name,
					queue: { name: `${SERVICE_QUEUE_PREFIX}:${id}` },
				}));
			},
			getNodeBindings(options) {
				const queues = bindingKeys(options.queueProducers);
				return Object.fromEntries(queues.map((name) => [name, new ProxyNodeBinding()]));
			},
			async getServices({
				options,
				workerNames,
				queueProducers: allQueueProducers,
				queueConsumers: allQueueConsumers,
				unsafeStickyBlobs,
			}) {
				const queues = bindingEntries(options.queueProducers);
				if (queues.length === 0) return [];
				const services = queues.map(([_, id]) => ({
					name: `${SERVICE_QUEUE_PREFIX}:${id}`,
					worker: objectEntryWorker(QUEUE_BROKER_OBJECT, id),
				}));
				const uniqueKey = `miniflare-${QUEUE_BROKER_OBJECT_CLASS_NAME}`;
				const objectService = {
					name: SERVICE_QUEUE_PREFIX,
					worker: {
						compatibilityDate: "2023-07-24",
						compatibilityFlags: [
							"nodejs_compat",
							"experimental",
							"service_binding_extra_handlers",
						],
						modules: [{ name: "broker.worker.js", esModule: broker_worker_default() }],
						durableObjectNamespaces: [
							{
								className: QUEUE_BROKER_OBJECT_CLASS_NAME,
								uniqueKey,
								preventEviction: true,
							},
						],
						// Miniflare's Queue broker is in-memory only at the moment
						durableObjectStorage: { inMemory: kVoid },
						bindings: [
							{
								name: SharedBindings.MAYBE_SERVICE_LOOPBACK,
								service: { name: SERVICE_LOOPBACK },
							},
							...getMiniflareObjectBindings(unsafeStickyBlobs),
							{
								name: SharedBindings.DURABLE_OBJECT_NAMESPACE_OBJECT,
								durableObjectNamespace: {
									className: QUEUE_BROKER_OBJECT_CLASS_NAME,
								},
							},
							{
								name: QueueBindings.MAYBE_JSON_QUEUE_PRODUCERS,
								json: JSON.stringify(Object.fromEntries(allQueueProducers)),
							},
							{
								name: QueueBindings.MAYBE_JSON_QUEUE_CONSUMERS,
								json: JSON.stringify(Object.fromEntries(allQueueConsumers)),
							},
							...workerNames.map((name) => ({
								name: QueueBindings.SERVICE_WORKER_PREFIX + name,
								service: { name: getUserServiceName(name) },
							})),
						],
					},
				};
				services.push(objectService);
				return services;
			},
		};
		function bindingEntries(namespaces) {
			if (Array.isArray(namespaces)) {
				return namespaces.map((bindingName) => [bindingName, bindingName]);
			} else if (namespaces !== void 0) {
				return Object.entries(namespaces).map(([name, opts]) => [
					name,
					typeof opts === "string" ? opts : opts.queueName,
				]);
			} else {
				return [];
			}
		}
		function bindingKeys(namespaces) {
			if (Array.isArray(namespaces)) {
				return namespaces;
			} else if (namespaces !== void 0) {
				return Object.keys(namespaces);
			} else {
				return [];
			}
		}
		var import_promises11 = __toESM2(require("fs/promises"));
		var import_fs19 = __toESM2(require("fs"));
		var import_path23 = __toESM2(require("path"));
		var import_url19 = __toESM2(require("url"));
		var contents15;
		function bucket_worker_default() {
			if (contents15 !== void 0) return contents15;
			const filePath = import_path23.default.join(
				__dirname,
				"workers",
				"r2/bucket.worker.js",
			);
			contents15 =
				import_fs19.default.readFileSync(filePath, "utf8") +
				"//# sourceURL=" +
				import_url19.default.pathToFileURL(filePath);
			return contents15;
		}
		var import_zod18 = require_lib();
		var R2OptionsSchema = import_zod18.z.object({
			r2Buckets: import_zod18.z
				.union([
					import_zod18.z.record(import_zod18.z.string()),
					import_zod18.z.string().array(),
				])
				.optional(),
		});
		var R2SharedOptionsSchema = import_zod18.z.object({
			r2Persist: PersistenceSchema,
		});
		var R2_PLUGIN_NAME = "r2";
		var R2_STORAGE_SERVICE_NAME = `${R2_PLUGIN_NAME}:storage`;
		var R2_BUCKET_SERVICE_PREFIX = `${R2_PLUGIN_NAME}:bucket`;
		var R2_BUCKET_OBJECT_CLASS_NAME = "R2BucketObject";
		var R2_BUCKET_OBJECT = {
			serviceName: R2_BUCKET_SERVICE_PREFIX,
			className: R2_BUCKET_OBJECT_CLASS_NAME,
		};
		var R2_PLUGIN = {
			options: R2OptionsSchema,
			sharedOptions: R2SharedOptionsSchema,
			getBindings(options) {
				const buckets = namespaceEntries(options.r2Buckets);
				return buckets.map(([name, id]) => ({
					name,
					r2Bucket: { name: `${R2_BUCKET_SERVICE_PREFIX}:${id}` },
				}));
			},
			getNodeBindings(options) {
				const buckets = namespaceKeys(options.r2Buckets);
				return Object.fromEntries(buckets.map((name) => [name, new ProxyNodeBinding()]));
			},
			async getServices({ options, sharedOptions, tmpPath, log, unsafeStickyBlobs }) {
				const persist = sharedOptions.r2Persist;
				const buckets = namespaceEntries(options.r2Buckets);
				const services = buckets.map(([_, id]) => ({
					name: `${R2_BUCKET_SERVICE_PREFIX}:${id}`,
					worker: objectEntryWorker(R2_BUCKET_OBJECT, id),
				}));
				if (buckets.length > 0) {
					const uniqueKey = `miniflare-${R2_BUCKET_OBJECT_CLASS_NAME}`;
					const persistPath = getPersistPath(R2_PLUGIN_NAME, tmpPath, persist);
					await import_promises11.default.mkdir(persistPath, { recursive: true });
					const storageService = {
						name: R2_STORAGE_SERVICE_NAME,
						disk: { path: persistPath, writable: true },
					};
					const objectService = {
						name: R2_BUCKET_SERVICE_PREFIX,
						worker: {
							compatibilityDate: "2023-07-24",
							compatibilityFlags: ["nodejs_compat", "experimental"],
							modules: [
								{
									name: "bucket.worker.js",
									esModule: bucket_worker_default(),
								},
							],
							durableObjectNamespaces: [
								{
									className: R2_BUCKET_OBJECT_CLASS_NAME,
									uniqueKey,
								},
							],
							// Store Durable Object SQL databases in persist path
							durableObjectStorage: { localDisk: R2_STORAGE_SERVICE_NAME },
							// Bind blob disk directory service to object
							bindings: [
								{
									name: SharedBindings.MAYBE_SERVICE_BLOBS,
									service: { name: R2_STORAGE_SERVICE_NAME },
								},
								{
									name: SharedBindings.MAYBE_SERVICE_LOOPBACK,
									service: { name: SERVICE_LOOPBACK },
								},
								...getMiniflareObjectBindings(unsafeStickyBlobs),
							],
						},
					};
					services.push(storageService, objectService);
					for (const bucket of buckets) {
						await migrateDatabase(log, uniqueKey, persistPath, bucket[1]);
					}
				}
				return services;
			},
			getPersistPath({ r2Persist }, tmpPath) {
				return getPersistPath(R2_PLUGIN_NAME, tmpPath, r2Persist);
			},
		};
		var import_fs20 = __toESM2(require("fs"));
		var import_path24 = __toESM2(require("path"));
		var import_url20 = __toESM2(require("url"));
		var contents16;
		function ratelimit_worker_default() {
			if (contents16 !== void 0) return contents16;
			const filePath = import_path24.default.join(
				__dirname,
				"workers",
				"ratelimit/ratelimit.worker.js",
			);
			contents16 =
				import_fs20.default.readFileSync(filePath, "utf8") +
				"//# sourceURL=" +
				import_url20.default.pathToFileURL(filePath);
			return contents16;
		}
		var import_zod19 = require_lib();
		var PeriodType = /* @__PURE__ */ ((PeriodType2) => {
			PeriodType2[(PeriodType2["TENSECONDS"] = 10)] = "TENSECONDS";
			PeriodType2[(PeriodType2["MINUTE"] = 60)] = "MINUTE";
			return PeriodType2;
		})(PeriodType || {});
		var RatelimitConfigSchema = import_zod19.z.object({
			simple: import_zod19.z.object({
				limit: import_zod19.z.number().gt(0),
				// may relax this to be any number in the future
				period: import_zod19.z.nativeEnum(PeriodType).optional(),
			}),
		});
		var RatelimitOptionsSchema = import_zod19.z.object({
			ratelimits: import_zod19.z.record(RatelimitConfigSchema).optional(),
		});
		var RATELIMIT_PLUGIN_NAME = "ratelimit";
		var SERVICE_RATELIMIT_PREFIX = `${RATELIMIT_PLUGIN_NAME}`;
		var SERVICE_RATELIMIT_MODULE = `cloudflare-internal:${SERVICE_RATELIMIT_PREFIX}:module`;
		function buildJsonBindings2(bindings) {
			return Object.entries(bindings).map(([name, value]) => ({
				name,
				json: JSON.stringify(value),
			}));
		}
		var RATELIMIT_PLUGIN = {
			options: RatelimitOptionsSchema,
			getBindings(options) {
				if (!options.ratelimits) {
					return [];
				}
				const bindings = Object.entries(options.ratelimits).map(([name, config]) => ({
					name,
					wrapped: {
						moduleName: SERVICE_RATELIMIT_MODULE,
						innerBindings: buildJsonBindings2({
							namespaceId: name,
							limit: config.simple.limit,
							period: config.simple.period,
						}),
					},
				}));
				return bindings;
			},
			getNodeBindings(options) {
				if (!options.ratelimits) {
					return {};
				}
				return Object.fromEntries(
					Object.keys(options.ratelimits).map((name) => [name, new ProxyNodeBinding()]),
				);
			},
			async getServices({ options }) {
				if (!options.ratelimits) {
					return [];
				}
				return {
					services: [],
					extensions: [
						{
							modules: [
								{
									name: SERVICE_RATELIMIT_MODULE,
									esModule: ratelimit_worker_default(),
									internal: true,
								},
							],
						},
					],
				};
			},
		};
		var import_promises12 = __toESM2(require("fs/promises"));
		var import_fs21 = __toESM2(require("fs"));
		var import_path25 = __toESM2(require("path"));
		var import_url21 = __toESM2(require("url"));
		var contents17;
		function binding_worker_default() {
			if (contents17 !== void 0) return contents17;
			const filePath = import_path25.default.join(
				__dirname,
				"workers",
				"workflows/binding.worker.js",
			);
			contents17 =
				import_fs21.default.readFileSync(filePath, "utf8") +
				"//# sourceURL=" +
				import_url21.default.pathToFileURL(filePath);
			return contents17;
		}
		var import_zod20 = require_lib();
		var WorkflowsOptionsSchema = import_zod20.z.object({
			workflows: import_zod20.z
				.record(
					import_zod20.z.object({
						name: import_zod20.z.string(),
						className: import_zod20.z.string(),
						scriptName: import_zod20.z.string().optional(),
					}),
				)
				.optional(),
		});
		var WorkflowsSharedOptionsSchema = import_zod20.z.object({
			workflowsPersist: PersistenceSchema,
		});
		var WORKFLOWS_PLUGIN_NAME = "workflows";
		var WORKFLOWS_STORAGE_SERVICE_NAME = `${WORKFLOWS_PLUGIN_NAME}:storage`;
		var WORKFLOWS_PLUGIN = {
			options: WorkflowsOptionsSchema,
			sharedOptions: WorkflowsSharedOptionsSchema,
			async getBindings(options) {
				return Object.entries(options.workflows ?? {}).map(([bindingName, workflow]) => ({
					name: bindingName,
					service: {
						name: `${WORKFLOWS_PLUGIN_NAME}:${workflow.name}`,
						entrypoint: "WorkflowBinding",
					},
				}));
			},
			async getNodeBindings(options) {
				return Object.fromEntries(
					Object.keys(options.workflows ?? {}).map((bindingName) => [
						bindingName,
						new ProxyNodeBinding(),
					]),
				);
			},
			async getServices({ options, sharedOptions, tmpPath }) {
				const persistPath = getPersistPath(
					WORKFLOWS_PLUGIN_NAME,
					tmpPath,
					sharedOptions.workflowsPersist,
				);
				await import_promises12.default.mkdir(persistPath, { recursive: true });
				const storageService = {
					name: WORKFLOWS_STORAGE_SERVICE_NAME,
					disk: { path: persistPath, writable: true },
				};
				const services = Object.entries(options.workflows ?? {}).map(
					([_bindingName, workflow]) => {
						const uniqueKey = `miniflare-workflows`;
						const workflowsBinding = {
							name: `${WORKFLOWS_PLUGIN_NAME}:${workflow.name}`,
							worker: {
								compatibilityDate: "2024-10-22",
								modules: [
									{
										name: "workflows.mjs",
										esModule: binding_worker_default(),
									},
								],
								durableObjectNamespaces: [
									{
										className: "Engine",
										enableSql: true,
										uniqueKey,
										preventEviction: true,
									},
								],
								// this might conflict between workflows
								durableObjectStorage: { localDisk: WORKFLOWS_STORAGE_SERVICE_NAME },
								bindings: [
									{
										name: "ENGINE",
										durableObjectNamespace: { className: "Engine" },
									},
									{
										name: "USER_WORKFLOW",
										service: {
											name: getUserServiceName(workflow.scriptName),
											entrypoint: workflow.className,
										},
									},
								],
							},
						};
						return workflowsBinding;
					},
				);
				if (services.length === 0) {
					return [];
				}
				return [storageService, ...services];
			},
			getPersistPath({ workflowsPersist }, tmpPath) {
				return getPersistPath(WORKFLOWS_PLUGIN_NAME, tmpPath, workflowsPersist);
			},
		};
		var PLUGINS = {
			[CORE_PLUGIN_NAME2]: CORE_PLUGIN,
			[CACHE_PLUGIN_NAME]: CACHE_PLUGIN,
			[D1_PLUGIN_NAME]: D1_PLUGIN,
			[DURABLE_OBJECTS_PLUGIN_NAME]: DURABLE_OBJECTS_PLUGIN,
			[KV_PLUGIN_NAME]: KV_PLUGIN,
			[QUEUES_PLUGIN_NAME]: QUEUES_PLUGIN,
			[R2_PLUGIN_NAME]: R2_PLUGIN,
			[HYPERDRIVE_PLUGIN_NAME]: HYPERDRIVE_PLUGIN,
			[RATELIMIT_PLUGIN_NAME]: RATELIMIT_PLUGIN,
			[ASSETS_PLUGIN_NAME]: ASSETS_PLUGIN,
			[WORKFLOWS_PLUGIN_NAME]: WORKFLOWS_PLUGIN,
		};
		var PLUGIN_ENTRIES = Object.entries(PLUGINS);
		var compressedByCloudflareFL = /* @__PURE__ */ new Set([
			// list copied from https://developers.cloudflare.com/speed/optimization/content/brotli/content-compression/#:~:text=If%20supported%20by%20visitors%E2%80%99%20web%20browsers%2C%20Cloudflare%20will%20return%20Gzip%20or%20Brotli%2Dencoded%20responses%20for%20the%20following%20content%20types%3A
			"text/html",
			"text/richtext",
			"text/plain",
			"text/css",
			"text/x-script",
			"text/x-component",
			"text/x-java-source",
			"text/x-markdown",
			"application/javascript",
			"application/x-javascript",
			"text/javascript",
			"text/js",
			"image/x-icon",
			"image/vnd.microsoft.icon",
			"application/x-perl",
			"application/x-httpd-cgi",
			"text/xml",
			"application/xml",
			"application/rss+xml",
			"application/vnd.api+json",
			"application/x-protobuf",
			"application/json",
			"multipart/bag",
			"multipart/mixed",
			"application/xhtml+xml",
			"font/ttf",
			"font/otf",
			"font/x-woff",
			"image/svg+xml",
			"application/vnd.ms-fontobject",
			"application/ttf",
			"application/x-ttf",
			"application/otf",
			"application/x-otf",
			"application/truetype",
			"application/opentype",
			"application/x-opentype",
			"application/font-woff",
			"application/eot",
			"application/font",
			"application/font-sfnt",
			"application/wasm",
			"application/javascript-binast",
			"application/manifest+json",
			"application/ld+json",
			"application/graphql+json",
			"application/geo+json",
		]);
		function isCompressedByCloudflareFL(contentTypeHeader) {
			if (!contentTypeHeader) return true;
			const [contentType] = contentTypeHeader.split(";");
			return compressedByCloudflareFL.has(contentType);
		}
		var import_assert11 = __toESM2(require("assert"));
		var import_util4 = __toESM2(require("util"));
		var kMessages = Symbol("kMessages");
		var kActual = Symbol("kActual");
		var kGroupId = Symbol("kGroupId");
		var groupColours = [
			yellow,
			/* (green) */
			cyan,
			blue,
			magenta,
			green,
		];
		var GroupCountsMap = Map;
		function isAnnotation(value) {
			return (
				typeof value === "object" &&
				value !== null &&
				kMessages in value &&
				kActual in value
			);
		}
		function isRecord(value) {
			return typeof value === "object" && value !== null;
		}
		function arrayShallowEqual(a, b) {
			if (a.length !== b.length) return false;
			for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
			return true;
		}
		function issueEqual(a, b) {
			return a.message === b.message && arrayShallowEqual(a.path, b.path);
		}
		function hasMultipleDistinctMessages(issues, atDepth) {
			let firstIssue;
			for (const issue of issues) {
				if (issue.path.length < atDepth) continue;
				if (firstIssue === void 0) firstIssue = issue;
				else if (!issueEqual(firstIssue, issue)) return true;
			}
			return false;
		}
		function annotate(groupCounts, annotated, input, issue, path28, groupId) {
			if (path28.length === 0) {
				if (issue.code === "invalid_union") {
					const unionIssues = issue.unionErrors.flatMap(({ issues }) => issues);
					let newGroupId;
					const multipleDistinct = hasMultipleDistinctMessages(
						unionIssues,
						// For this check, we only include messages that are deeper than our
						// current level, so we don't include messages we'd ignore if we grouped
						issue.path.length + 1,
					);
					if (isRecord(input) && multipleDistinct) {
						newGroupId = groupCounts.size;
						groupCounts.set(newGroupId, 0);
					}
					for (const unionIssue of unionIssues) {
						const unionPath = unionIssue.path.slice(issue.path.length);
						if (multipleDistinct && unionPath.length === 0) continue;
						annotated = annotate(
							groupCounts,
							annotated,
							input,
							unionIssue,
							unionPath,
							newGroupId,
						);
					}
					return annotated;
				}
				const message = issue.message;
				if (annotated !== void 0) {
					if (isAnnotation(annotated) && !annotated[kMessages].includes(message)) {
						annotated[kMessages].push(message);
					}
					return annotated;
				}
				if (groupId !== void 0) {
					const current = groupCounts.get(groupId);
					(0, import_assert11.default)(current !== void 0);
					groupCounts.set(groupId, current + 1);
				}
				return {
					[kMessages]: [message],
					[kActual]: input,
					[kGroupId]: groupId,
				};
			}
			const [head, ...tail] = path28;
			(0, import_assert11.default)(
				isRecord(input),
				"Expected object/array input for nested issue",
			);
			if (annotated === void 0) {
				if (Array.isArray(input)) {
					annotated = new Array(input.length);
				} else {
					const entries = Object.keys(input).map((key) => [key, void 0]);
					annotated = Object.fromEntries(entries);
				}
			}
			(0, import_assert11.default)(
				isRecord(annotated),
				"Expected object/array for nested issue",
			);
			annotated[head] = annotate(
				groupCounts,
				annotated[head],
				input[head],
				issue,
				tail,
				groupId,
			);
			return annotated;
		}
		function print(inspectOptions, groupCounts, annotated, indent = "", extras) {
			const prefix = extras?.prefix ?? "";
			const suffix = extras?.suffix ?? "";
			if (isAnnotation(annotated)) {
				const prefixIndent = indent + " ".repeat(prefix.length);
				const actual = import_util4.default.inspect(annotated[kActual], inspectOptions);
				const actualIndented = actual
					.split("\n")
					.map((line, i) => (i > 0 ? prefixIndent + line : line))
					.join("\n");
				let messageColour = red;
				let messagePrefix = prefixIndent + "^";
				let groupOr = "";
				if (annotated[kGroupId] !== void 0) {
					messageColour = groupColours[annotated[kGroupId] % groupColours.length];
					messagePrefix += annotated[kGroupId] + 1;
					const remaining = groupCounts.get(annotated[kGroupId]);
					(0, import_assert11.default)(remaining !== void 0);
					if (remaining > 1) groupOr = " *or*";
					groupCounts.set(annotated[kGroupId], remaining - 1);
				}
				messagePrefix += " ";
				const messageIndent = " ".repeat(messagePrefix.length);
				const messageIndented = annotated[kMessages]
					.flatMap((m) => m.split("\n"))
					.map((line, i) => (i > 0 ? messageIndent + line : line))
					.join("\n");
				const error = messageColour(`${messagePrefix}${messageIndented}${groupOr}`);
				return `${indent}${dim(prefix)}${actualIndented}${dim(suffix)}
${error}`;
			} else if (Array.isArray(annotated)) {
				let result = `${indent}${dim(`${prefix}[`)}
`;
				const arrayIndent = indent + "  ";
				for (let i = 0; i < annotated.length; i++) {
					const value = annotated[i];
					if (value === void 0 && (i === 0 || annotated[i - 1] !== void 0)) {
						result += `${arrayIndent}${dim("...,")}
`;
					}
					if (value !== void 0) {
						result += print(inspectOptions, groupCounts, value, arrayIndent, {
							prefix: `/* [${i}] */ `,
							suffix: ",",
						});
						result += "\n";
					}
				}
				result += `${indent}${dim(`]${suffix}`)}`;
				return result;
			} else if (isRecord(annotated)) {
				let result = `${indent}${dim(`${prefix}{`)}
`;
				const objectIndent = indent + "  ";
				const entries = Object.entries(annotated);
				for (let i = 0; i < entries.length; i++) {
					const [key, value] = entries[i];
					if (value === void 0 && (i === 0 || entries[i - 1][1] !== void 0)) {
						result += `${objectIndent}${dim("...,")}
`;
					}
					if (value !== void 0) {
						result += print(inspectOptions, groupCounts, value, objectIndent, {
							prefix: `${key}: `,
							suffix: ",",
						});
						result += "\n";
					}
				}
				result += `${indent}${dim(`}${suffix}`)}`;
				return result;
			}
			return "";
		}
		function formatZodError(error, input) {
			const sortedIssues = Array.from(error.issues).sort((a, b) => {
				if (a.code !== b.code) {
					if (a.code === "invalid_union") return -1;
					if (b.code === "invalid_union") return 1;
				}
				return 0;
			});
			let annotated;
			const groupCounts = new GroupCountsMap();
			for (const issue of sortedIssues) {
				annotated = annotate(groupCounts, annotated, input, issue, issue.path);
			}
			const inspectOptions = {
				depth: 0,
				colors: $.enabled,
			};
			return print(inspectOptions, groupCounts, annotated);
		}
		var objectProtoNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
		function isPlainObject(value) {
			const proto = Object.getPrototypeOf(value);
			return (
				proto === Object.prototype ||
				proto === null ||
				Object.getOwnPropertyNames(proto).sort().join("\0") === objectProtoNames
			);
		}
		function convertWorkerOptionsArrayToObject(key, array) {
			const _ = array;
			if (key === "queueConsumers") {
				const object = Object.fromEntries(array.map((item) => [item, {}]));
				return object;
			} else {
				const object = Object.fromEntries(array.map((item) => [item, item]));
				return object;
			}
		}
		function mergeWorkerOptions(a, b) {
			const aRecord = a;
			for (const [key, bValue] of Object.entries(b)) {
				const aValue = aRecord[key];
				if (aValue === void 0) {
					aRecord[key] = bValue;
					continue;
				}
				const aIsArray = Array.isArray(aValue);
				const bIsArray = Array.isArray(bValue);
				const aIsObject = isPlainObject(aValue);
				const bIsObject = isPlainObject(bValue);
				if (aIsArray && bIsArray) {
					aRecord[key] = Array.from(new Set(aValue.concat(bValue)));
				} else if (aIsArray && bIsObject) {
					const aNewValue = convertWorkerOptionsArrayToObject(
						// Must be an array/record key if `aValue` & `bValue` are array/record
						key,
						aValue,
					);
					Object.assign(aNewValue, bValue);
					aRecord[key] = aNewValue;
				} else if (aIsObject && bIsArray) {
					const bNewValue = convertWorkerOptionsArrayToObject(
						// Must be an array/record key if `aValue` & `bValue` are array/record
						key,
						bValue,
					);
					Object.assign(aValue, bNewValue);
				} else if (aIsObject && bIsObject) {
					Object.assign(aValue, bValue);
				} else {
					aRecord[key] = bValue;
				}
			}
			return a;
		}
		var DEFAULT_HOST = "127.0.0.1";
		function getURLSafeHost(host) {
			return import_net.default.isIPv6(host) ? `[${host}]` : host;
		}
		function maybeGetLocallyAccessibleHost(h) {
			if (h === "localhost") return "localhost";
			if (h === "127.0.0.1" || h === "*" || h === "0.0.0.0" || h === "::") {
				return "127.0.0.1";
			}
			if (h === "::1") return "[::1]";
		}
		function getServerPort(server) {
			const address = server.address();
			(0, import_assert12.default)(address !== null && typeof address === "object");
			return address.port;
		}
		function hasMultipleWorkers(opts) {
			return (
				typeof opts === "object" &&
				opts !== null &&
				"workers" in opts &&
				Array.isArray(opts.workers)
			);
		}
		function getRootPath(opts) {
			if (
				typeof opts === "object" &&
				opts !== null &&
				"rootPath" in opts &&
				typeof opts.rootPath === "string"
			) {
				return opts.rootPath;
			} else {
				return "";
			}
		}
		function validateOptions(opts) {
			const sharedOpts = opts;
			const multipleWorkers = hasMultipleWorkers(opts);
			const workerOpts = multipleWorkers ? opts.workers : [opts];
			if (workerOpts.length === 0) {
				throw new MiniflareCoreError("ERR_NO_WORKERS", "No workers defined");
			}
			const pluginSharedOpts = {};
			const pluginWorkerOpts = Array.from(Array(workerOpts.length)).map(() => ({}));
			const sharedRootPath = multipleWorkers ? getRootPath(sharedOpts) : "";
			const workerRootPaths = workerOpts.map((opts2) =>
				import_path26.default.resolve(sharedRootPath, getRootPath(opts2)),
			);
			try {
				for (const [key, plugin] of PLUGIN_ENTRIES) {
					pluginSharedOpts[key] =
						plugin.sharedOptions === void 0
							? void 0
							: parseWithRootPath(sharedRootPath, plugin.sharedOptions, sharedOpts);
					for (let i = 0; i < workerOpts.length; i++) {
						const optionsPath = multipleWorkers ? ["workers", i] : void 0;
						pluginWorkerOpts[i][key] = parseWithRootPath(
							workerRootPaths[i],
							plugin.options,
							workerOpts[i],
							{ path: optionsPath },
						);
					}
				}
			} catch (e) {
				if (e instanceof import_zod22.z.ZodError) {
					let formatted;
					try {
						formatted = formatZodError(e, opts);
					} catch (formatError) {
						const title = "[Miniflare] Validation Error Format Failure";
						const message = [
							"### Input",
							"```",
							import_util5.default.inspect(opts, { depth: null }),
							"```",
							"",
							"### Validation Error",
							"```",
							e.stack,
							"```",
							"",
							"### Format Error",
							"```",
							typeof formatError === "object" &&
							formatError !== null &&
							"stack" in formatError &&
							typeof formatError.stack === "string"
								? formatError.stack
								: String(formatError),
							"```",
						].join("\n");
						const githubIssueUrl = new URL(
							"https://github.com/cloudflare/miniflare/issues/new",
						);
						githubIssueUrl.searchParams.set("title", title);
						githubIssueUrl.searchParams.set("body", message);
						formatted = [
							"Unable to format validation error.",
							"Please open the following URL in your browser to create a GitHub issue:",
							githubIssueUrl,
							"",
							message,
							"",
						].join("\n");
					}
					const error = new MiniflareCoreError(
						"ERR_VALIDATION",
						`Unexpected options passed to \`new Miniflare()\` constructor:
${formatted}`,
					);
					Object.defineProperty(error, "cause", { get: () => e });
					throw error;
				}
				throw e;
			}
			const names = /* @__PURE__ */ new Set();
			for (const opts2 of pluginWorkerOpts) {
				const name = opts2.core.name ?? "";
				if (names.has(name)) {
					throw new MiniflareCoreError(
						"ERR_DUPLICATE_NAME",
						name === ""
							? "Multiple workers defined without a `name`"
							: `Multiple workers defined with the same \`name\`: "${name}"`,
					);
				}
				names.add(name);
			}
			return [pluginSharedOpts, pluginWorkerOpts];
		}
		function getDurableObjectClassNames(allWorkerOpts) {
			const serviceClassNames = /* @__PURE__ */ new Map();
			for (const workerOpts of allWorkerOpts) {
				const workerServiceName = getUserServiceName(workerOpts.core.name);
				for (const designator of Object.values(workerOpts.do.durableObjects ?? {})) {
					const {
						className,
						// Fallback to current worker service if name not defined
						serviceName = workerServiceName,
						enableSql,
						unsafeUniqueKey,
						unsafePreventEviction,
					} = normaliseDurableObject(designator);
					let classNames = serviceClassNames.get(serviceName);
					if (classNames === void 0) {
						classNames = /* @__PURE__ */ new Map();
						serviceClassNames.set(serviceName, classNames);
					}
					if (classNames.has(className)) {
						const existingInfo = classNames.get(className);
						if (existingInfo?.enableSql !== enableSql) {
							throw new MiniflareCoreError(
								"ERR_DIFFERENT_STORAGE_BACKEND",
								`Different storage backends defined for Durable Object "${className}" in "${serviceName}": ${JSON.stringify(
									enableSql,
								)} and ${JSON.stringify(existingInfo?.enableSql)}`,
							);
						}
						if (existingInfo?.unsafeUniqueKey !== unsafeUniqueKey) {
							throw new MiniflareCoreError(
								"ERR_DIFFERENT_UNIQUE_KEYS",
								`Multiple unsafe unique keys defined for Durable Object "${className}" in "${serviceName}": ${JSON.stringify(
									unsafeUniqueKey,
								)} and ${JSON.stringify(existingInfo?.unsafeUniqueKey)}`,
							);
						}
						if (existingInfo?.unsafePreventEviction !== unsafePreventEviction) {
							throw new MiniflareCoreError(
								"ERR_DIFFERENT_PREVENT_EVICTION",
								`Multiple unsafe prevent eviction values defined for Durable Object "${className}" in "${serviceName}": ${JSON.stringify(
									unsafePreventEviction,
								)} and ${JSON.stringify(existingInfo?.unsafePreventEviction)}`,
							);
						}
					} else {
						classNames.set(className, {
							enableSql,
							unsafeUniqueKey,
							unsafePreventEviction,
						});
					}
				}
			}
			return serviceClassNames;
		}
		function invalidWrappedAsBound(name, bindingType) {
			const stringName = JSON.stringify(name);
			throw new MiniflareCoreError(
				"ERR_INVALID_WRAPPED",
				`Cannot use ${stringName} for wrapped binding because it is bound to with ${bindingType} bindings.
Ensure other workers don't define ${bindingType} bindings to ${stringName}.`,
			);
		}
		function getWrappedBindingNames(allWorkerOpts, durableObjectClassNames) {
			const wrappedBindingWorkerNames = /* @__PURE__ */ new Set();
			for (const workerOpts of allWorkerOpts) {
				for (const designator of Object.values(workerOpts.core.wrappedBindings ?? {})) {
					const scriptName =
						typeof designator === "object" ? designator.scriptName : designator;
					if (durableObjectClassNames.has(getUserServiceName(scriptName))) {
						invalidWrappedAsBound(scriptName, "Durable Object");
					}
					wrappedBindingWorkerNames.add(scriptName);
				}
			}
			for (const workerOpts of allWorkerOpts) {
				for (const designator of Object.values(workerOpts.core.serviceBindings ?? {})) {
					if (typeof designator !== "string") continue;
					if (wrappedBindingWorkerNames.has(designator)) {
						invalidWrappedAsBound(designator, "service");
					}
				}
			}
			return wrappedBindingWorkerNames;
		}
		function getQueueProducers(allWorkerOpts) {
			const queueProducers = /* @__PURE__ */ new Map();
			for (const workerOpts of allWorkerOpts) {
				const workerName = workerOpts.core.name ?? "";
				let workerProducers = workerOpts.queues.queueProducers;
				if (workerProducers !== void 0) {
					if (Array.isArray(workerProducers)) {
						workerProducers = Object.fromEntries(
							workerProducers.map((bindingName) => [
								bindingName,
								{ queueName: bindingName },
							]),
						);
					}
					const producersIterable = Object.entries(workerProducers);
					for (const [bindingName, opts] of producersIterable) {
						if (typeof opts === "string") {
							queueProducers.set(bindingName, { workerName, queueName: opts });
						} else {
							queueProducers.set(bindingName, { workerName, ...opts });
						}
					}
				}
			}
			return queueProducers;
		}
		function getQueueConsumers(allWorkerOpts) {
			const queueConsumers = /* @__PURE__ */ new Map();
			for (const workerOpts of allWorkerOpts) {
				const workerName = workerOpts.core.name ?? "";
				let workerConsumers = workerOpts.queues.queueConsumers;
				if (workerConsumers !== void 0) {
					if (Array.isArray(workerConsumers)) {
						workerConsumers = Object.fromEntries(
							workerConsumers.map((queueName) => [queueName, {}]),
						);
					}
					for (const [queueName, opts] of Object.entries(workerConsumers)) {
						const existingConsumer = queueConsumers.get(queueName);
						if (existingConsumer !== void 0) {
							throw new QueuesError(
								"ERR_MULTIPLE_CONSUMERS",
								`Multiple consumers defined for queue "${queueName}": "${existingConsumer.workerName}" and "${workerName}"`,
							);
						}
						queueConsumers.set(queueName, { workerName, ...opts });
					}
				}
			}
			for (const [queueName, consumer] of queueConsumers) {
				if (consumer.deadLetterQueue === queueName) {
					throw new QueuesError(
						"ERR_DEAD_LETTER_QUEUE_CYCLE",
						`Dead letter queue for queue "${queueName}" cannot be itself`,
					);
				}
			}
			return queueConsumers;
		}
		function getWorkerRoutes(allWorkerOpts, wrappedBindingNames) {
			const allRoutes = /* @__PURE__ */ new Map();
			for (const workerOpts of allWorkerOpts) {
				const name = workerOpts.core.name ?? "";
				if (wrappedBindingNames.has(name)) continue;
				(0, import_assert12.default)(!allRoutes.has(name));
				allRoutes.set(name, workerOpts.core.routes ?? []);
			}
			return allRoutes;
		}
		function getProxyBindingName(plugin, worker, binding) {
			return [CoreBindings.DURABLE_OBJECT_NAMESPACE_PROXY, plugin, worker, binding].join(":");
		}
		function isNativeTargetBinding(binding) {
			return !(
				"json" in binding ||
				"wasmModule" in binding ||
				"text" in binding ||
				"data" in binding
			);
		}
		function buildProxyBinding(plugin, worker, binding) {
			(0, import_assert12.default)(binding.name !== void 0);
			const name = getProxyBindingName(plugin, worker, binding.name);
			const proxyBinding = { ...binding, name };
			if (
				"durableObjectNamespace" in proxyBinding &&
				proxyBinding.durableObjectNamespace !== void 0
			) {
				proxyBinding.durableObjectNamespace.serviceName ??= getUserServiceName(worker);
			}
			return proxyBinding;
		}
		function getInternalDurableObjectProxyBindings(plugin, service) {
			if (!("worker" in service)) return;
			(0, import_assert12.default)(service.worker !== void 0);
			const serviceName = service.name;
			(0, import_assert12.default)(serviceName !== void 0);
			return service.worker.durableObjectNamespaces?.map(({ className }) => {
				(0, import_assert12.default)(className !== void 0);
				return {
					name: getProxyBindingName(`${plugin}-internal`, serviceName, className),
					durableObjectNamespace: { serviceName, className },
				};
			});
		}
		var restrictedUndiciHeaders = [
			// From Miniflare 2:
			// https://github.com/cloudflare/miniflare/blob/9c135599dc21fe69080ada17fce6153692793bf1/packages/core/src/standards/http.ts#L129-L132
			"transfer-encoding",
			"connection",
			"keep-alive",
			"expect",
		];
		var restrictedWebSocketUpgradeHeaders = ["upgrade", "connection", "sec-websocket-accept"];
		function _transformsForContentEncodingAndContentType(encoding, type) {
			const encoders = [];
			if (!encoding) return encoders;
			if (!isCompressedByCloudflareFL(type)) return encoders;
			const codings = encoding
				.toLowerCase()
				.split(",")
				.map((x) => x.trim());
			for (const coding of codings) {
				if (/(x-)?gzip/.test(coding)) {
					encoders.push(import_zlib.default.createGzip());
				} else if (/(x-)?deflate/.test(coding)) {
					encoders.push(import_zlib.default.createDeflate());
				} else if (coding === "br") {
					encoders.push(import_zlib.default.createBrotliCompress());
				} else {
					encoders.length = 0;
					break;
				}
			}
			return encoders;
		}
		async function writeResponse(response, res) {
			const headers = {};
			for (const entry of response.headers) {
				const key = entry[0].toLowerCase();
				const value = entry[1];
				if (key === "set-cookie") {
					headers[key] = response.headers.getSetCookie();
				} else {
					headers[key] = value;
				}
			}
			const encoding = headers["content-encoding"]?.toString();
			const type = headers["content-type"]?.toString();
			const encoders = _transformsForContentEncodingAndContentType(encoding, type);
			if (encoders.length > 0) {
				delete headers["content-length"];
			}
			res.writeHead(response.status, response.statusText, headers);
			let initialStream = res;
			for (let i = encoders.length - 1; i >= 0; i--) {
				encoders[i].pipe(initialStream);
				initialStream = encoders[i];
			}
			if (response.body) {
				for await (const chunk of response.body) {
					if (chunk) initialStream.write(chunk);
				}
			}
			initialStream.end();
		}
		function safeReadableStreamFrom(iterable) {
			let iterator;
			return new import_web5.ReadableStream({
				async start() {
					iterator = iterable[Symbol.asyncIterator]();
				},
				// @ts-expect-error `pull` may return anything
				async pull(controller) {
					try {
						const { done, value } = await iterator.next();
						if (done) {
							queueMicrotask(() => controller.close());
						} else {
							const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
							controller.enqueue(new Uint8Array(buf));
						}
					} catch {
						queueMicrotask(() => controller.close());
					}
					return controller.desiredSize > 0;
				},
				async cancel() {
					await iterator.return?.();
				},
			});
		}
		var maybeInstanceRegistry;
		function _initialiseInstanceRegistry() {
			return (maybeInstanceRegistry = /* @__PURE__ */ new Map());
		}
		var Miniflare22 = class {
			#previousSharedOpts;
			#previousWorkerOpts;
			#sharedOpts;
			#workerOpts;
			#log;
			#runtime;
			#removeExitHook;
			#runtimeEntryURL;
			#socketPorts;
			#runtimeDispatcher;
			#proxyClient;
			#cfObject = {};
			// Path to temporary directory for use as scratch space/"in-memory" Durable
			// Object storage. Note this may not exist, it's up to the consumers to
			// create this if needed. Deleted on `dispose()`.
			#tmpPath;
			// Mutual exclusion lock for runtime operations (i.e. initialisation and
			// updating config). This essentially puts initialisation and future updates
			// in a queue, ensuring they're performed in calling order.
			#runtimeMutex;
			// Store `#init()` `Promise`, so we can propagate initialisation errors in
			// `ready`. We would have no way of catching these otherwise.
			#initPromise;
			// Aborted when dispose() is called
			#disposeController;
			#loopbackServer;
			#loopbackHost;
			#liveReloadServer;
			#webSocketServer;
			#webSocketExtraHeaders;
			constructor(opts) {
				const [sharedOpts, workerOpts] = validateOptions(opts);
				this.#sharedOpts = sharedOpts;
				this.#workerOpts = workerOpts;
				if (maybeInstanceRegistry !== void 0) {
					const object = { name: "Miniflare", stack: "" };
					Error.captureStackTrace(object, Miniflare22);
					maybeInstanceRegistry.set(this, object.stack);
				}
				this.#log = this.#sharedOpts.core.log ?? new NoOpLog();
				this.#liveReloadServer = new import_ws3.WebSocketServer({ noServer: true });
				this.#webSocketServer = new import_ws3.WebSocketServer({
					noServer: true,
					// Disable automatic handling of `Sec-WebSocket-Protocol` header,
					// Cloudflare Workers require users to include this header themselves in
					// `Response`s: https://github.com/cloudflare/miniflare/issues/179
					handleProtocols: () => false,
				});
				this.#webSocketExtraHeaders = /* @__PURE__ */ new WeakMap();
				this.#webSocketServer.on("headers", (headers, req) => {
					const extra = this.#webSocketExtraHeaders.get(req);
					this.#webSocketExtraHeaders.delete(req);
					if (extra) {
						for (const [key, value] of extra) {
							if (!restrictedWebSocketUpgradeHeaders.includes(key.toLowerCase())) {
								headers.push(`${key}: ${value}`);
							}
						}
					}
				});
				this.#tmpPath = import_path26.default.join(
					import_os2.default.tmpdir(),
					`miniflare-${import_crypto3.default.randomBytes(16).toString("hex")}`,
				);
				this.#runtime = new Runtime();
				this.#removeExitHook = (0, import_exit_hook.default)(() => {
					void this.#runtime?.dispose();
					try {
						import_fs22.default.rmSync(this.#tmpPath, { force: true, recursive: true });
					} catch (e) {
						this.#log.debug(`Unable to remove temporary directory: ${String(e)}`);
					}
				});
				this.#disposeController = new AbortController();
				this.#runtimeMutex = new Mutex();
				this.#initPromise = this.#runtimeMutex
					.runWith(() => this.#assembleAndUpdateConfig())
					.catch((e) => {
						maybeInstanceRegistry?.delete(this);
						throw e;
					});
			}
			#handleReload() {
				for (const ws of this.#liveReloadServer.clients) {
					ws.close(1012, "Service Restart");
				}
				for (const ws of this.#webSocketServer.clients) {
					ws.close(1012, "Service Restart");
				}
			}
			async #handleLoopbackCustomService(request, customService) {
				const slashIndex = customService.indexOf("/");
				const workerIndex = parseInt(customService.substring(0, slashIndex));
				const serviceKind = customService[slashIndex + 1];
				const serviceName = customService.substring(slashIndex + 2);
				let service;
				if (serviceKind === "#") {
					service = this.#workerOpts[workerIndex]?.core.serviceBindings?.[serviceName];
				} else if (serviceName === CUSTOM_SERVICE_KNOWN_OUTBOUND) {
					service = this.#workerOpts[workerIndex]?.core.outboundService;
				}
				(0, import_assert12.default)(typeof service === "function");
				try {
					let response = await service(request, this);
					if (!(response instanceof Response)) {
						response = new Response(response.body, response);
					}
					return import_zod22.z.instanceof(Response).parse(response);
				} catch (e) {
					return new Response(e?.stack ?? e, { status: 500 });
				}
			}
			get #workerSrcOpts() {
				return this.#workerOpts.map(({ core }) => core);
			}
			#handleLoopback = async (req, res) => {
				const headers = new import_undici4.Headers();
				for (const [name, values] of Object.entries(req.headers)) {
					if (restrictedUndiciHeaders.includes(name)) continue;
					if (Array.isArray(values)) {
						for (const value of values) headers.append(name, value);
					} else if (values !== void 0) {
						headers.append(name, values);
					}
				}
				const cfBlob = headers.get(CoreHeaders.CF_BLOB);
				headers.delete(CoreHeaders.CF_BLOB);
				(0, import_assert12.default)(!Array.isArray(cfBlob));
				const cf = cfBlob ? JSON.parse(cfBlob) : void 0;
				const originalUrl = headers.get(CoreHeaders.ORIGINAL_URL);
				const url18 = new URL(originalUrl ?? req.url ?? "", "http://localhost");
				headers.delete(CoreHeaders.ORIGINAL_URL);
				const noBody = req.method === "GET" || req.method === "HEAD";
				const body = noBody ? void 0 : safeReadableStreamFrom(req);
				const request = new Request(url18, {
					method: req.method,
					headers,
					body,
					duplex: "half",
					cf,
				});
				let response;
				try {
					const customService = request.headers.get(CoreHeaders.CUSTOM_SERVICE);
					if (customService !== null) {
						request.headers.delete(CoreHeaders.CUSTOM_SERVICE);
						response = await this.#handleLoopbackCustomService(request, customService);
					} else if (
						this.#sharedOpts.core.unsafeModuleFallbackService !== void 0 &&
						request.headers.has("X-Resolve-Method") &&
						originalUrl === null
					) {
						response = await this.#sharedOpts.core.unsafeModuleFallbackService(
							request,
							this,
						);
					} else if (url18.pathname === "/core/error") {
						response = await handlePrettyErrorRequest(
							this.#log,
							this.#workerSrcOpts,
							request,
						);
					} else if (url18.pathname === "/core/log") {
						const level = parseInt(request.headers.get(SharedHeaders.LOG_LEVEL));
						(0, import_assert12.default)(
							0 <= level && level <= 5,
							`Expected ${SharedHeaders.LOG_LEVEL} header to be log level, got ${level}`,
						);
						const logLevel = level;
						let message = await request.text();
						if (!$.enabled) message = stripAnsi(message);
						this.#log.logWithLevel(logLevel, message);
						response = new Response(null, { status: 204 });
					}
				} catch (e) {
					this.#log.error(e);
					res?.writeHead(500);
					res?.end(e?.stack ?? String(e));
					return;
				}
				if (res !== void 0) {
					if (response === void 0) {
						res.writeHead(404);
						res.end();
					} else {
						await writeResponse(response, res);
					}
				}
				return response;
			};
			#handleLoopbackUpgrade = async (req, socket, head) => {
				const { pathname } = new URL(req.url ?? "", "http://localhost");
				if (pathname === "/cdn-cgi/mf/reload") {
					this.#liveReloadServer.handleUpgrade(req, socket, head, (ws) => {
						this.#liveReloadServer.emit("connection", ws, req);
					});
					return;
				}
				const response = await this.#handleLoopback(req);
				const webSocket = response?.webSocket;
				if (response?.status === 101 && webSocket) {
					this.#webSocketExtraHeaders.set(req, response.headers);
					this.#webSocketServer.handleUpgrade(req, socket, head, (ws) => {
						void coupleWebSocket(ws, webSocket);
						this.#webSocketServer.emit("connection", ws, req);
					});
					return;
				}
				const res = new import_http6.default.ServerResponse(req);
				(0, import_assert12.default)(socket instanceof import_net.default.Socket);
				res.assignSocket(socket);
				if (!response || response.ok) {
					res.writeHead(500);
					res.end();
					this.#log.error(
						new TypeError(
							"Web Socket request did not return status 101 Switching Protocols response with Web Socket",
						),
					);
					return;
				}
				await writeResponse(response, res);
			};
			async getLoopbackPort() {
				const loopbackHost = this.#sharedOpts.core.host ?? DEFAULT_HOST;
				if (this.#loopbackServer !== void 0) {
					if (this.#loopbackHost === loopbackHost) {
						return getServerPort(this.#loopbackServer);
					}
					await this.#stopLoopbackServer();
				}
				this.#loopbackServer = await this.#startLoopbackServer(loopbackHost);
				this.#loopbackHost = loopbackHost;
				return getServerPort(this.#loopbackServer);
			}
			#startLoopbackServer(hostname) {
				if (hostname === "*") hostname = "::";
				return new Promise((resolve) => {
					const server = (0, import_stoppable.default)(
						import_http6.default.createServer(this.#handleLoopback),
						/* grace */
						0,
					);
					server.on("upgrade", this.#handleLoopbackUpgrade);
					server.listen(0, hostname, () => resolve(server));
				});
			}
			#stopLoopbackServer() {
				return new Promise((resolve, reject) => {
					(0, import_assert12.default)(this.#loopbackServer !== void 0);
					this.#loopbackServer.stop((err) => (err ? reject(err) : resolve()));
				});
			}
			#getSocketAddress(id, previousRequestedPort, host = DEFAULT_HOST, requestedPort) {
				if (requestedPort === 0 && previousRequestedPort === 0) {
					requestedPort = this.#socketPorts?.get(id);
				}
				return `${getURLSafeHost(host)}:${requestedPort ?? 0}`;
			}
			async assembleConfig(loopbackPort) {
				const allPreviousWorkerOpts = this.#previousWorkerOpts;
				const allWorkerOpts = this.#workerOpts;
				const sharedOpts = this.#sharedOpts;
				sharedOpts.core.cf = await setupCf(this.#log, sharedOpts.core.cf);
				this.#cfObject = sharedOpts.core.cf;
				const durableObjectClassNames = getDurableObjectClassNames(allWorkerOpts);
				const wrappedBindingNames = getWrappedBindingNames(
					allWorkerOpts,
					durableObjectClassNames,
				);
				const queueProducers = getQueueProducers(allWorkerOpts);
				const queueConsumers = getQueueConsumers(allWorkerOpts);
				const allWorkerRoutes = getWorkerRoutes(allWorkerOpts, wrappedBindingNames);
				const workerNames = [...allWorkerRoutes.keys()];
				const services = /* @__PURE__ */ new Map();
				const extensions = [
					{
						modules: [
							{ name: "miniflare:shared", esModule: index_worker_default() },
							{ name: "miniflare:zod", esModule: zod_worker_default() },
						],
					},
				];
				const sockets = [
					{
						name: SOCKET_ENTRY,
						service: { name: SERVICE_ENTRY },
						...(await getEntrySocketHttpOptions(sharedOpts.core)),
					},
				];
				const configuredHost = sharedOpts.core.host ?? DEFAULT_HOST;
				if (maybeGetLocallyAccessibleHost(configuredHost) === void 0) {
					sockets.push({
						name: SOCKET_ENTRY_LOCAL,
						service: { name: SERVICE_ENTRY },
						http: ENTRY_SOCKET_HTTP_OPTIONS,
						address: "127.0.0.1:0",
					});
				}
				const proxyBindings = [];
				const allWorkerBindings = /* @__PURE__ */ new Map();
				const wrappedBindingsToPopulate = [];
				if (this.#workerOpts[0].assets.assets) {
					this.#workerOpts[0].assets.assets.workerName = this.#workerOpts[0].core.name;
				}
				for (let i = 0; i < allWorkerOpts.length; i++) {
					const previousWorkerOpts = allPreviousWorkerOpts?.[i];
					const workerOpts = allWorkerOpts[i];
					const workerName = workerOpts.core.name ?? "";
					const isModulesWorker = Boolean(workerOpts.core.modules);
					if (workerOpts.workflows.workflows) {
						for (const workflow of Object.values(workerOpts.workflows.workflows)) {
							workflow.scriptName ??= workerOpts.core.name;
						}
					}
					const workerBindings = [];
					allWorkerBindings.set(workerName, workerBindings);
					const additionalModules = [];
					for (const [key, plugin] of PLUGIN_ENTRIES) {
						const pluginBindings = await plugin.getBindings(workerOpts[key], i);
						if (pluginBindings !== void 0) {
							for (const binding of pluginBindings) {
								if (
									key === "kv" &&
									binding.name === SiteBindings.JSON_SITE_MANIFEST &&
									isModulesWorker
								) {
									(0, import_assert12.default)(
										"json" in binding && binding.json !== void 0,
									);
									additionalModules.push({
										name: SiteBindings.JSON_SITE_MANIFEST,
										text: binding.json,
									});
								} else {
									workerBindings.push(binding);
								}
								if (isNativeTargetBinding(binding)) {
									proxyBindings.push(buildProxyBinding(key, workerName, binding));
								}
								if (
									"wrapped" in binding &&
									binding.wrapped?.moduleName !== void 0 &&
									binding.wrapped.innerBindings !== void 0
								) {
									const workerName2 = maybeWrappedModuleToWorkerName(
										binding.wrapped.moduleName,
									);
									if (workerName2 !== void 0) {
										wrappedBindingsToPopulate.push({
											workerName: workerName2,
											innerBindings: binding.wrapped.innerBindings,
										});
									}
								}
							}
						}
					}
					const unsafeStickyBlobs = sharedOpts.core.unsafeStickyBlobs ?? false;
					const unsafeEphemeralDurableObjects =
						workerOpts.core.unsafeEphemeralDurableObjects ?? false;
					const pluginServicesOptionsBase = {
						log: this.#log,
						workerBindings,
						workerIndex: i,
						additionalModules,
						tmpPath: this.#tmpPath,
						workerNames,
						loopbackPort,
						unsafeStickyBlobs,
						wrappedBindingNames,
						durableObjectClassNames,
						unsafeEphemeralDurableObjects,
						queueProducers,
						queueConsumers,
					};
					for (const [key, plugin] of PLUGIN_ENTRIES) {
						const pluginServicesExtensions = await plugin.getServices({
							...pluginServicesOptionsBase,
							// @ts-expect-error `CoreOptionsSchema` has required options which are
							//  missing in other plugins' options.
							options: workerOpts[key],
							// @ts-expect-error `QueuesPlugin` doesn't define shared options
							sharedOptions: sharedOpts[key],
						});
						if (pluginServicesExtensions !== void 0) {
							let pluginServices;
							if (Array.isArray(pluginServicesExtensions)) {
								pluginServices = pluginServicesExtensions;
							} else {
								pluginServices = pluginServicesExtensions.services;
								extensions.push(...pluginServicesExtensions.extensions);
							}
							for (const service of pluginServices) {
								if (service.name !== void 0 && !services.has(service.name)) {
									services.set(service.name, service);
									if (key !== DURABLE_OBJECTS_PLUGIN_NAME) {
										const maybeBindings = getInternalDurableObjectProxyBindings(
											key,
											service,
										);
										if (maybeBindings !== void 0) {
											proxyBindings.push(...maybeBindings);
										}
									}
								}
							}
						}
					}
					const previousDirectSockets =
						previousWorkerOpts?.core.unsafeDirectSockets ?? [];
					const directSockets = workerOpts.core.unsafeDirectSockets ?? [];
					for (let j = 0; j < directSockets.length; j++) {
						const previousDirectSocket = previousDirectSockets[j];
						const directSocket = directSockets[j];
						const entrypoint = directSocket.entrypoint ?? "default";
						const name = getDirectSocketName(i, entrypoint);
						const address = this.#getSocketAddress(
							name,
							previousDirectSocket?.port,
							directSocket.host,
							directSocket.port,
						);
						sockets.push({
							name,
							address,
							service: {
								name: getUserServiceName(workerName),
								entrypoint: entrypoint === "default" ? void 0 : entrypoint,
							},
							http: {
								style: directSocket.proxy
									? import_workerd_capnp.HttpOptions_Style.PROXY
									: void 0,
								cfBlobHeader: CoreHeaders.CF_BLOB,
								capnpConnectHost: HOST_CAPNP_CONNECT,
							},
						});
					}
				}
				const globalServices = getGlobalServices({
					sharedOptions: sharedOpts.core,
					allWorkerRoutes,
					// if Workers + Assets project but NOT Vitest, point to router Worker instead
					// if Vitest with assets, the self binding on the test runner will point to RW
					fallbackWorkerName:
						this.#workerOpts[0].assets.assets &&
						!this.#workerOpts[0].core.name?.startsWith("vitest-pool-workers-runner-")
							? ROUTER_SERVICE_NAME
							: getUserServiceName(this.#workerOpts[0].core.name),
					loopbackPort,
					log: this.#log,
					proxyBindings,
				});
				for (const service of globalServices) {
					(0, import_assert12.default)(
						service.name !== void 0 && !services.has(service.name),
					);
					services.set(service.name, service);
				}
				for (const toPopulate of wrappedBindingsToPopulate) {
					const bindings = allWorkerBindings.get(toPopulate.workerName);
					if (bindings === void 0) continue;
					const existingBindingNames = new Set(
						toPopulate.innerBindings.map(({ name }) => name),
					);
					toPopulate.innerBindings.push(
						...bindings.filter(({ name }) => !existingBindingNames.has(name)),
					);
				}
				const servicesArray = Array.from(services.values());
				if (wrappedBindingsToPopulate.length > 0 && _isCyclic(servicesArray)) {
					throw new MiniflareCoreError(
						"ERR_CYCLIC",
						"Generated workerd config contains cycles. Ensure wrapped bindings don't have bindings to themselves.",
					);
				}
				return { services: servicesArray, sockets, extensions };
			}
			async #assembleAndUpdateConfig() {
				const initial = !this.#runtimeEntryURL;
				(0, import_assert12.default)(this.#runtime !== void 0);
				const loopbackPort = await this.getLoopbackPort();
				const config = await this.assembleConfig(loopbackPort);
				const configBuffer = serializeConfig2(config);
				(0, import_assert12.default)(config.sockets !== void 0);
				const requiredSockets = config.sockets.map(({ name }) => {
					(0, import_assert12.default)(name !== void 0);
					return name;
				});
				if (this.#sharedOpts.core.inspectorPort !== void 0) {
					requiredSockets.push(kInspectorSocket);
				}
				const configuredHost = this.#sharedOpts.core.host ?? DEFAULT_HOST;
				const entryAddress = this.#getSocketAddress(
					SOCKET_ENTRY,
					this.#previousSharedOpts?.core.port,
					configuredHost,
					this.#sharedOpts.core.port,
				);
				let inspectorAddress;
				if (this.#sharedOpts.core.inspectorPort !== void 0) {
					inspectorAddress = this.#getSocketAddress(
						kInspectorSocket,
						this.#previousSharedOpts?.core.inspectorPort,
						"localhost",
						this.#sharedOpts.core.inspectorPort,
					);
				}
				const loopbackAddress = `${maybeGetLocallyAccessibleHost(configuredHost) ?? getURLSafeHost(configuredHost)}:${loopbackPort}`;
				const runtimeOpts = {
					signal: this.#disposeController.signal,
					entryAddress,
					loopbackAddress,
					requiredSockets,
					inspectorAddress,
					verbose: this.#sharedOpts.core.verbose,
					handleRuntimeStdio: this.#sharedOpts.core.handleRuntimeStdio,
				};
				const maybeSocketPorts = await this.#runtime.updateConfig(
					configBuffer,
					runtimeOpts,
				);
				if (this.#disposeController.signal.aborted) return;
				if (maybeSocketPorts === void 0) {
					throw new MiniflareCoreError(
						"ERR_RUNTIME_FAILURE",
						"The Workers runtime failed to start. There is likely additional logging output above.",
					);
				}
				this.#socketPorts = maybeSocketPorts;
				const entrySocket = config.sockets?.[0];
				const secure = entrySocket !== void 0 && "https" in entrySocket;
				const previousEntryURL = this.#runtimeEntryURL;
				const entryPort = maybeSocketPorts.get(SOCKET_ENTRY);
				(0, import_assert12.default)(entryPort !== void 0);
				const maybeAccessibleHost = maybeGetLocallyAccessibleHost(configuredHost);
				if (maybeAccessibleHost === void 0) {
					const localEntryPort = maybeSocketPorts.get(SOCKET_ENTRY_LOCAL);
					(0, import_assert12.default)(
						localEntryPort !== void 0,
						"Expected local entry socket port",
					);
					this.#runtimeEntryURL = new URL(`http://127.0.0.1:${localEntryPort}`);
				} else {
					this.#runtimeEntryURL = new URL(
						`${secure ? "https" : "http"}://${maybeAccessibleHost}:${entryPort}`,
					);
				}
				if (previousEntryURL?.toString() !== this.#runtimeEntryURL.toString()) {
					this.#runtimeDispatcher = new import_undici8.Pool(this.#runtimeEntryURL, {
						connect: { rejectUnauthorized: false },
					});
				}
				if (this.#proxyClient === void 0) {
					this.#proxyClient = new ProxyClient(this.#runtimeEntryURL, this.dispatchFetch);
				} else {
					this.#proxyClient.setRuntimeEntryURL(this.#runtimeEntryURL);
				}
				if (!this.#runtimeMutex.hasWaiting) {
					const ready = initial ? "Ready" : "Updated and ready";
					const urlSafeHost = getURLSafeHost(configuredHost);
					this.#log.info(
						`${ready} on ${secure ? "https" : "http"}://${urlSafeHost}:${entryPort}`,
					);
					if (initial) {
						const hosts = [];
						if (configuredHost === "::" || configuredHost === "*") {
							hosts.push("localhost");
							hosts.push("[::1]");
						}
						if (
							configuredHost === "::" ||
							configuredHost === "*" ||
							configuredHost === "0.0.0.0"
						) {
							hosts.push(...getAccessibleHosts(true));
						}
						for (const h of hosts) {
							this.#log.info(`- ${secure ? "https" : "http"}://${h}:${entryPort}`);
						}
					}
					this.#handleReload();
				}
			}
			async #waitForReady(disposing = false) {
				await this.#initPromise;
				await this.#runtimeMutex.drained();
				if (disposing) return new URL("http://[100::]/");
				this.#checkDisposed();
				(0, import_assert12.default)(this.#runtimeEntryURL !== void 0);
				return new URL(this.#runtimeEntryURL.toString());
			}
			get ready() {
				return this.#waitForReady();
			}
			async getCf() {
				this.#checkDisposed();
				await this.ready;
				return JSON.parse(JSON.stringify(this.#cfObject));
			}
			async getInspectorURL() {
				this.#checkDisposed();
				await this.ready;
				(0, import_assert12.default)(this.#socketPorts !== void 0);
				const maybePort = this.#socketPorts.get(kInspectorSocket);
				if (maybePort === void 0) {
					throw new TypeError(
						"Inspector not enabled in Miniflare instance. Set the `inspectorPort` option to enable it.",
					);
				}
				return new URL(`ws://127.0.0.1:${maybePort}`);
			}
			async unsafeGetDirectURL(workerName, entrypoint = "default") {
				this.#checkDisposed();
				await this.ready;
				const workerIndex = this.#findAndAssertWorkerIndex(workerName);
				const workerOpts = this.#workerOpts[workerIndex];
				const socketName = getDirectSocketName(workerIndex, entrypoint);
				(0, import_assert12.default)(this.#socketPorts !== void 0);
				const maybePort = this.#socketPorts.get(socketName);
				if (maybePort === void 0) {
					const friendlyWorkerName =
						workerName === void 0 ? "entrypoint" : JSON.stringify(workerName);
					const friendlyEntrypointName =
						entrypoint === "default" ? entrypoint : JSON.stringify(entrypoint);
					throw new TypeError(
						`Direct access disabled in ${friendlyWorkerName} worker for ${friendlyEntrypointName} entrypoint`,
					);
				}
				const directSocket = workerOpts.core.unsafeDirectSockets?.find(
					(socket) => (socket.entrypoint ?? "default") === entrypoint,
				);
				(0, import_assert12.default)(directSocket !== void 0);
				const host = directSocket.host ?? DEFAULT_HOST;
				const accessibleHost = maybeGetLocallyAccessibleHost(host) ?? getURLSafeHost(host);
				return new URL(`http://${accessibleHost}:${maybePort}`);
			}
			#checkDisposed() {
				if (this.#disposeController.signal.aborted) {
					throw new MiniflareCoreError("ERR_DISPOSED", "Cannot use disposed instance");
				}
			}
			async #setOptions(opts) {
				const [sharedOpts, workerOpts] = validateOptions(opts);
				this.#previousSharedOpts = this.#sharedOpts;
				this.#previousWorkerOpts = this.#workerOpts;
				this.#sharedOpts = sharedOpts;
				this.#workerOpts = workerOpts;
				this.#log = this.#sharedOpts.core.log ?? this.#log;
				await this.#assembleAndUpdateConfig();
			}
			setOptions(opts) {
				this.#checkDisposed();
				this.#proxyClient?.poisonProxies();
				return this.#runtimeMutex.runWith(() => this.#setOptions(opts));
			}
			dispatchFetch = async (input, init2) => {
				this.#checkDisposed();
				await this.ready;
				(0, import_assert12.default)(this.#runtimeEntryURL !== void 0);
				(0, import_assert12.default)(this.#runtimeDispatcher !== void 0);
				const forward = new Request(input, init2);
				const url18 = new URL(forward.url);
				const actualRuntimeOrigin = this.#runtimeEntryURL.origin;
				const userRuntimeOrigin = url18.origin;
				url18.protocol = this.#runtimeEntryURL.protocol;
				url18.host = this.#runtimeEntryURL.host;
				if (forward.body !== null && forward.headers.get("Content-Length") === "0") {
					forward.headers.delete("Content-Length");
				}
				const cfBlob = forward.cf ? { ...fallbackCf, ...forward.cf } : void 0;
				const dispatcher = new DispatchFetchDispatcher(
					(0, import_undici8.getGlobalDispatcher)(),
					this.#runtimeDispatcher,
					actualRuntimeOrigin,
					userRuntimeOrigin,
					cfBlob,
				);
				const forwardInit = forward;
				forwardInit.dispatcher = dispatcher;
				const response = await fetch3(url18, forwardInit);
				const stack = response.headers.get(CoreHeaders.ERROR_STACK);
				if (response.status === 500 && stack !== null) {
					const caught = JsonErrorSchema.parse(await response.json());
					throw reviveError(this.#workerSrcOpts, caught);
				}
				const contentEncoding = response.headers.get("Content-Encoding");
				if (contentEncoding) response.headers.set("MF-Content-Encoding", contentEncoding);
				response.headers.delete("Content-Encoding");
				if (
					process.env.MINIFLARE_ASSERT_BODIES_CONSUMED === "true" &&
					response.body !== null
				) {
					const originalLimit = Error.stackTraceLimit;
					Error.stackTraceLimit = Infinity;
					const error = new Error(
						"`body` returned from `Miniflare#dispatchFetch()` not consumed immediately",
					);
					Error.stackTraceLimit = originalLimit;
					setImmediate(() => {
						if (!response.bodyUsed) throw error;
					});
				}
				return response;
			};
			/** @internal */
			async _getProxyClient() {
				this.#checkDisposed();
				await this.ready;
				(0, import_assert12.default)(this.#proxyClient !== void 0);
				return this.#proxyClient;
			}
			#findAndAssertWorkerIndex(workerName) {
				if (workerName === void 0) {
					return 0;
				} else {
					const index = this.#workerOpts.findIndex(
						({ core }) => (core.name ?? "") === workerName,
					);
					if (index === -1) {
						throw new TypeError(`${JSON.stringify(workerName)} worker not found`);
					}
					return index;
				}
			}
			async getBindings(workerName) {
				const bindings = {};
				const proxyClient = await this._getProxyClient();
				const workerIndex = this.#findAndAssertWorkerIndex(workerName);
				const workerOpts = this.#workerOpts[workerIndex];
				workerName = workerOpts.core.name ?? "";
				for (const [key, plugin] of PLUGIN_ENTRIES) {
					const pluginBindings = await plugin.getNodeBindings(workerOpts[key]);
					for (const [name, binding] of Object.entries(pluginBindings)) {
						if (binding instanceof ProxyNodeBinding) {
							const proxyBindingName = getProxyBindingName(key, workerName, name);
							let proxy = proxyClient.env[proxyBindingName];
							(0, import_assert12.default)(
								proxy !== void 0,
								`Expected ${proxyBindingName} to be bound`,
							);
							if (binding.proxyOverrideHandler) {
								proxy = new Proxy(proxy, binding.proxyOverrideHandler);
							}
							bindings[name] = proxy;
						} else {
							bindings[name] = binding;
						}
					}
				}
				return bindings;
			}
			async getWorker(workerName) {
				const proxyClient = await this._getProxyClient();
				const workerIndex = this.#findAndAssertWorkerIndex(workerName);
				const workerOpts = this.#workerOpts[workerIndex];
				workerName = workerOpts.core.name ?? "";
				const bindingName = CoreBindings.SERVICE_USER_ROUTE_PREFIX + workerName;
				const fetcher = proxyClient.env[bindingName];
				if (fetcher === void 0) {
					const stringName = JSON.stringify(workerName);
					throw new TypeError(
						`${stringName} is being used as a wrapped binding, and cannot be accessed as a worker`,
					);
				}
				return fetcher;
			}
			async #getProxy(pluginName, bindingName, workerName) {
				const proxyClient = await this._getProxyClient();
				const proxyBindingName = getProxyBindingName(
					pluginName,
					// Default to entrypoint worker if none specified
					workerName ?? this.#workerOpts[0].core.name ?? "",
					bindingName,
				);
				const proxy = proxyClient.env[proxyBindingName];
				if (proxy === void 0) {
					const friendlyWorkerName =
						workerName === void 0 ? "entrypoint" : JSON.stringify(workerName);
					throw new TypeError(
						`${JSON.stringify(bindingName)} unbound in ${friendlyWorkerName} worker`,
					);
				}
				return proxy;
			}
			// TODO(someday): would be nice to define these in plugins
			async getCaches() {
				const proxyClient = await this._getProxyClient();
				return proxyClient.global.caches;
			}
			getD1Database(bindingName, workerName) {
				return this.#getProxy(D1_PLUGIN_NAME, bindingName, workerName);
			}
			getDurableObjectNamespace(bindingName, workerName) {
				return this.#getProxy(DURABLE_OBJECTS_PLUGIN_NAME, bindingName, workerName);
			}
			getKVNamespace(bindingName, workerName) {
				return this.#getProxy(KV_PLUGIN_NAME, bindingName, workerName);
			}
			getQueueProducer(bindingName, workerName) {
				return this.#getProxy(QUEUES_PLUGIN_NAME, bindingName, workerName);
			}
			getR2Bucket(bindingName, workerName) {
				return this.#getProxy(R2_PLUGIN_NAME, bindingName, workerName);
			}
			/** @internal */
			_getInternalDurableObjectNamespace(pluginName, serviceName, className) {
				return this.#getProxy(`${pluginName}-internal`, className, serviceName);
			}
			unsafeGetPersistPaths() {
				const result = /* @__PURE__ */ new Map();
				for (const [key, plugin] of PLUGIN_ENTRIES) {
					const sharedOpts = this.#sharedOpts[key];
					const maybePath = plugin.getPersistPath?.(sharedOpts, this.#tmpPath);
					if (maybePath !== void 0) result.set(key, maybePath);
				}
				return result;
			}
			async dispose() {
				this.#disposeController.abort();
				this.#proxyClient?.poisonProxies();
				try {
					await this.#waitForReady(
						/* disposing */
						true,
					);
				} finally {
					this.#removeExitHook?.();
					await this.#proxyClient?.dispose();
					await this.#runtime?.dispose();
					await this.#stopLoopbackServer();
					await import_fs22.default.promises.rm(this.#tmpPath, {
						force: true,
						recursive: true,
					});
					maybeInstanceRegistry?.delete(this);
				}
			}
		};
	},
});

// src/index.ts
var import_yargs = __toESM(require("yargs"));
var import_helpers = require("yargs/helpers");

// package.json
var package_default = {
	name: "selflare",
	version: "1.1.3",
	description: "Compile Cloudflare Workers to Cap'n Proto and deliver them as Docker images.",
	keywords: ["cloudflare", "worker", "capnp", "capnproto", "docker", "image"],
	author: "JacobLinCool <jacoblincool@gmail.com> (https://github.com/JacobLinCool)",
	license: "MIT",
	bin: {
		selflare: "dist/index.js",
	},
	files: ["dist"],
	scripts: {
		prepare: "husky",
		"patch:mf": "tsx scripts/patch-miniflare.ts",
		build: "pnpm run patch:mf && tsup",
		changeset: "changeset",
		format: "prettier --write . --ignore-path .gitignore",
		test: "vitest --dir test",
	},
	dependencies: {
		"@iarna/toml": "^2.2.5",
		dedent: "^1.5.1",
		workerd: "^1.20241112.0",
		wrangler: "^3.80.0",
		yargs: "^17.7.2",
	},
	devDependencies: {
		"@changesets/changelog-github": "^0.5.0",
		"@changesets/cli": "^2.27.1",
		"@types/iarna__toml": "^2.0.5",
		"@types/node": "^20.11.24",
		"@types/yargs": "^17.0.32",
		husky: "^9.0.11",
		"lint-staged": "^15.2.2",
		miniflare: "^3.20241106.0",
		prettier: "^3.2.5",
		"prettier-plugin-organize-imports": "^3.2.4",
		tsup: "^8.0.2",
		tsx: "^4.7.1",
		typescript: "^5.3.3",
		vitest: "^1.3.1",
	},
	"lint-staged": {
		"*.{ts,js,json,yaml,yml}": ["prettier --write"],
	},
	packageManager: "pnpm@8.15.4",
	repository: {
		type: "git",
		url: "git+https://github.com/JacobLinCool/selflare.git",
	},
	homepage: "https://github.com/JacobLinCool/selflare",
	bugs: {
		url: "https://github.com/JacobLinCool/selflare/issues",
	},
};

// src/commands/compile.ts
var import_toml = __toESM(require("@iarna/toml"));
var import_miniflare = __toESM(require_src3());
var import_node_child_process = require("child_process");
var import_node_fs = __toESM(require("fs"));
var import_node_util = require("util");
var import_wrangler = require("wrangler");
async function compile(argv) {
	const { main, workerOptions } = (0, import_wrangler.unstable_getMiniflareWorkerOptions)(
		"wrangler.toml",
	);
	if (!main) {
		throw new Error("No main in wrangler.toml");
	}
	if (argv.debug) {
		console.log(
			(0, import_node_util.inspect)(workerOptions, {
				compact: true,
				depth: 10,
				breakLength: 80,
			}),
		);
	}
	if (!argv.script) {
		console.log("Building script with wrangler ...");
		(0, import_node_child_process.execSync)(
			"npx wrangler deploy --dry-run --outdir .wrangler/dist",
		);
		argv.script = ".wrangler/dist/index.js";
	}
	console.log("Using script from", argv.script);
	const toml = import_toml.default.parse(
		import_node_fs.default.readFileSync("wrangler.toml", "utf-8"),
	);
	if (argv.debug) {
		console.log(
			(0, import_node_util.inspect)(toml, { compact: true, depth: 10, breakLength: 80 }),
		);
	}
	console.log("Options: ", workerOptions);
	const mf = new import_miniflare.Miniflare({
		...workerOptions,
		modules: true,
		scriptPath: argv.script,
		unsafeEphemeralDurableObjects: true,
		modulesRules: toml.rules?.map((r) => ({
			type: r.type,
			fallthrough: r.fallthrough,
			include: r.globs,
		})),
	});
	await mf.ready;
	console.log("unsafeGetPersistPaths: ", mf.unsafeGetPersistPaths());
	const port = await mf.getLoopbackPort();
	const config = await mf.assembleConfig(port);
	if (argv.debug) {
		console.log(
			(0, import_node_util.inspect)(config, { compact: true, depth: 10, breakLength: 80 }),
		);
	}
	for (const service of config.services) {
		const matched = argv.dir.filter((d) => d.split("=")[0] === service.name);
		const dir = matched[matched.length - 1];
		if (dir) {
			const [name, path] = dir.split("=");
			service.disk.path = path;
			console.log(`Mapping ${name} to ${path}`);
		}
	}
	const loopback = config.services.find((s) => s.name === "loopback");
	if (loopback) {
		loopback.external.address = `localhost:8080`;
	}
	const entry = config.services.findIndex((s) => s.name === "core:entry");
	if (entry !== -1) {
		config.services.splice(entry, 1);
	}
	config.sockets[0].address = "*:8080";
	config.sockets[0].service.name = "core:user:";
	const core = config.services.find((s) => s.name === "core:user:");
	for (const binding of core.worker.bindings) {
		if (typeof binding.json === "string") {
			delete binding.json;
			binding.fromEnvironment = binding.name;
		}
	}
	if (argv.debug) {
		console.log(
			(0, import_node_util.inspect)(config, { compact: true, depth: 10, breakLength: 80 }),
		);
	}
	const buffer = (0, import_miniflare.serializeConfig)(config);
	import_node_fs.default.writeFileSync(argv.out, buffer);
	console.log("Wrote capnp file to", argv.out);
	await mf.dispose();
}

// src/commands/docker.ts
var import_dedent = __toESM(require("dedent"));
var import_node_fs2 = __toESM(require("fs"));
function docker(argv) {
	if (import_node_fs2.default.existsSync("Dockerfile")) {
		console.log("Dockerfile already exists, skipping");
	} else {
		import_node_fs2.default.writeFileSync(
			"Dockerfile",
			import_dedent.default`
            FROM jacoblincool/workerd:latest

            COPY ${argv.capnp} ./worker.capnp

            CMD ["serve", "--experimental", "--binary", "worker.capnp"]
        `,
		);
		console.log("Wrote Dockerfile");
	}
	if (import_node_fs2.default.existsSync("docker-compose.yml")) {
		console.log("docker-compose.yml already exists, skipping");
	} else {
		import_node_fs2.default.writeFileSync(
			"docker-compose.yml",
			import_dedent.default`
            version: "3.8"

            services:
                worker:
                    build: .
                    image: worker
                    volumes:
                        - ./.storage/cache:/worker/cache
                        - ./.storage/kv:/worker/kv
                        - ./.storage/d1:/worker/d1
                        - ./.storage/r2:/worker/r2
                    ports:
                        - "8080:8080"
        `,
		);
		console.log("Wrote docker-compose.yml");
	}
}

// src/constants.ts
var DEFAULT_CAPNP_PATH = "./worker.capnp";
var DEFAULT_DIR_MAPPING = [
	"cache:storage=./cache",
	"kv:storage=./kv",
	"d1:storage=./d1",
	"r2:storage=./r2",
];

// src/index.ts
(0, import_yargs.default)((0, import_helpers.hideBin)(process.argv))
	.scriptName(package_default.name)
	.version(package_default.version)
	.command(
		"compile",
		"Compile the worker script into a capnp file",
		(yargs2) => {
			return yargs2
				.option("script", {
					alias: "s",
					type: "string",
					description: "the bundled script to use",
				})
				.option("out", {
					alias: "o",
					type: "string",
					description: "the output path of capnp file",
					default: DEFAULT_CAPNP_PATH,
				})
				.option("dir", {
					alias: "d",
					type: "string",
					description: "the directory mapping in the format of NAME=PATH",
					array: true,
					default: DEFAULT_DIR_MAPPING,
				})
				.option("debug", {
					alias: "D",
					type: "boolean",
					description: "enable debug mode",
					default: false,
				});
		},
		compile,
	)
	.command(
		"docker",
		"Generate Dockerfile and docker-compose.yml",
		(yargs2) => {
			return yargs2.option("capnp", {
				type: "string",
				description: "the path of capnp file",
				default: DEFAULT_CAPNP_PATH,
			});
		},
		docker,
	)
	.demandCommand()
	.alias("h", "help")
	.alias("v", "version")
	.parse();
/*! Bundled license information:

undici/lib/fetch/body.js:
  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

undici/lib/websocket/frame.js:
  (*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> *)

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

mustache/mustache.js:
  (*!
   * mustache.js - Logic-less {{mustache}} templates with JavaScript
   * http://github.com/janl/mustache.js
   *)

miniflare/dist/src/index.js:
  (*! Path sanitisation regexps adapted from node-sanitize-filename:
   * https://github.com/parshap/node-sanitize-filename/blob/209c39b914c8eb48ee27bcbde64b2c7822fdf3de/index.js#L4-L37
   *
   * Licensed under the ISC license:
   *
   * Copyright Parsha Pourkhomami <parshap@gmail.com>
   *
   * Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the
   * above copyright notice and this permission notice appear in all copies.
   *
   * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
   * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
   * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *)
  (*!
   * MIT License
   *
   * Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *)
  (*!
   * Copyright (c) 2011 Felix Geisendrfer (felix@debuggable.com)
   *
   *  Permission is hereby granted, free of charge, to any person obtaining a copy
   *  of this software and associated documentation files (the "Software"), to deal
   *  in the Software without restriction, including without limitation the rights
   *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   *  copies of the Software, and to permit persons to whom the Software is
   *  furnished to do so, subject to the following conditions:
   *
   *  The above copyright notice and this permission notice shall be included in
   *  all copies or substantial portions of the Software.
   *
   *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   *  THE SOFTWARE.
   *)
*/
